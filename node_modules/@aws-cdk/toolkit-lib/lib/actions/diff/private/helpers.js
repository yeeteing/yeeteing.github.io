"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareDiff = prepareDiff;
exports.appendObject = appendObject;
const fs = require("fs-extra");
const uuid = require("uuid");
const __1 = require("..");
const cfnApi = require("../../../api/deployments/cfn-api");
const resource_import_1 = require("../../../api/resource-import");
const toolkit_error_1 = require("../../../toolkit/toolkit-error");
const util_1 = require("../../../util");
function prepareDiff(ioHelper, stacks, deployments, sdkProvider, options) {
    switch (options.method?.method ?? __1.DiffMethod.ChangeSet().method) {
        case 'local-file':
            return localFileDiff(stacks, options);
        case 'template-only':
            return cfnDiff(ioHelper, stacks, deployments, options, sdkProvider, false);
        case 'change-set':
            return cfnDiff(ioHelper, stacks, deployments, options, sdkProvider, true);
        default:
            throw new toolkit_error_1.ToolkitError((0, util_1.formatErrorMessage)(`Unknown diff method ${options.method}`));
    }
}
async function localFileDiff(stacks, options) {
    const methodOptions = (options.method?.options ?? {});
    // Compare single stack against fixed template
    if (stacks.stackCount !== 1) {
        throw new toolkit_error_1.ToolkitError('Can only select one stack when comparing to fixed template. Use --exclusively to avoid selecting multiple stacks.');
    }
    if (!(await fs.pathExists(methodOptions.path))) {
        throw new toolkit_error_1.ToolkitError(`There is no file at ${methodOptions.path}`);
    }
    const file = fs.readFileSync(methodOptions.path).toString();
    const template = (0, util_1.deserializeStructure)(file);
    return [{
            oldTemplate: template,
            newTemplate: stacks.firstStack,
        }];
}
async function cfnDiff(ioHelper, stacks, deployments, options, sdkProvider, includeChangeSet) {
    const templateInfos = [];
    const methodOptions = (options.method?.options ?? {});
    // Compare N stacks against deployed templates
    for (const stack of stacks.stackArtifacts) {
        const templateWithNestedStacks = await deployments.readCurrentTemplateWithNestedStacks(stack, methodOptions.compareAgainstProcessedTemplate);
        const currentTemplate = templateWithNestedStacks.deployedRootTemplate;
        const nestedStacks = templateWithNestedStacks.nestedStacks;
        const migrator = new resource_import_1.ResourceMigrator({ deployments, ioHelper });
        const resourcesToImport = await migrator.tryGetResources(await deployments.resolveEnvironment(stack));
        if (resourcesToImport) {
            (0, resource_import_1.removeNonImportResources)(stack);
        }
        const changeSet = includeChangeSet ? await changeSetDiff(ioHelper, deployments, stack, sdkProvider, resourcesToImport, methodOptions.parameters, methodOptions.fallbackToTemplate, methodOptions.importExistingResources) : undefined;
        templateInfos.push({
            oldTemplate: currentTemplate,
            newTemplate: stack,
            isImport: !!resourcesToImport,
            nestedStacks,
            changeSet,
        });
    }
    return templateInfos;
}
async function changeSetDiff(ioHelper, deployments, stack, sdkProvider, resourcesToImport, parameters = {}, fallBackToTemplate = true, importExistingResources = false) {
    let stackExists = false;
    try {
        stackExists = await deployments.stackExists({
            stack,
            deployName: stack.stackName,
            tryLookupRole: true,
        });
    }
    catch (e) {
        if (!fallBackToTemplate) {
            throw new toolkit_error_1.ToolkitError(`describeStacks call failed with ${e} for ${stack.stackName}, set fallBackToTemplate to true or use DiffMethod.templateOnly to base the diff on template differences.`);
        }
        await ioHelper.defaults.debug(`Checking if the stack ${stack.stackName} exists before creating the changeset has failed, will base the diff on template differences.\n`);
        await ioHelper.defaults.debug((0, util_1.formatErrorMessage)(e));
        stackExists = false;
    }
    if (stackExists) {
        return cfnApi.createDiffChangeSet(ioHelper, {
            stack,
            uuid: uuid.v4(),
            deployments,
            willExecute: false,
            sdkProvider,
            parameters: parameters,
            resourcesToImport,
            failOnError: !fallBackToTemplate,
            importExistingResources,
        });
    }
    else {
        if (!fallBackToTemplate) {
            throw new toolkit_error_1.ToolkitError(`the stack '${stack.stackName}' has not been deployed to CloudFormation, set fallBackToTemplate to true or use DiffMethod.templateOnly to base the diff on template differences.`);
        }
        await ioHelper.defaults.debug(`the stack '${stack.stackName}' has not been deployed to CloudFormation, skipping changeset creation.`);
        return;
    }
}
/**
 * Appends all properties from obj2 to obj1.
 * obj2 values take priority in the case of collisions.
 *
 * @param obj1 - The object to modify
 * @param obj2 - The object to consume
 *
 * @returns obj1 with all properties from obj2
 */
function appendObject(obj1, obj2) {
    // Directly modify obj1 by adding all properties from obj2
    for (const key in obj2) {
        obj1[key] = obj2[key];
    }
    // Return the modified obj1
    return obj1;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhlbHBlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFnQkEsa0NBaUJDO0FBb0lELG9DQVdDO0FBL0tELCtCQUErQjtBQUMvQiw2QkFBNkI7QUFFN0IsMEJBQWdDO0FBSWhDLDJEQUEyRDtBQUkzRCxrRUFBMEY7QUFDMUYsa0VBQThEO0FBQzlELHdDQUF5RTtBQUV6RSxTQUFnQixXQUFXLENBQ3pCLFFBQWtCLEVBQ2xCLE1BQXVCLEVBQ3ZCLFdBQXdCLEVBQ3hCLFdBQXdCLEVBQ3hCLE9BQW9CO0lBRXBCLFFBQVEsT0FBTyxDQUFDLE1BQU0sRUFBRSxNQUFNLElBQUksY0FBVSxDQUFDLFNBQVMsRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ2hFLEtBQUssWUFBWTtZQUNmLE9BQU8sYUFBYSxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQztRQUN4QyxLQUFLLGVBQWU7WUFDbEIsT0FBTyxPQUFPLENBQUMsUUFBUSxFQUFFLE1BQU0sRUFBRSxXQUFXLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUM3RSxLQUFLLFlBQVk7WUFDZixPQUFPLE9BQU8sQ0FBQyxRQUFRLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxPQUFPLEVBQUUsV0FBVyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzVFO1lBQ0UsTUFBTSxJQUFJLDRCQUFZLENBQUMsSUFBQSx5QkFBa0IsRUFBQyx1QkFBdUIsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN4RixDQUFDO0FBQ0gsQ0FBQztBQUVELEtBQUssVUFBVSxhQUFhLENBQUMsTUFBdUIsRUFBRSxPQUFvQjtJQUN4RSxNQUFNLGFBQWEsR0FBRyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsT0FBTyxJQUFJLEVBQUUsQ0FBeUIsQ0FBQztJQUU5RSw4Q0FBOEM7SUFDOUMsSUFBSSxNQUFNLENBQUMsVUFB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QUEyQjtJQUUzQiwwREFBMEQ7SUFDMUQsS0FBSyxNQUFNLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3hCLENBQUM7SUFFRCwyQkFBMkI7SUFDM0IsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgdXVpZCBmcm9tICd1dWlkJztcbmltcG9ydCB0eXBlIHsgQ2hhbmdlU2V0RGlmZk9wdGlvbnMsIERpZmZPcHRpb25zLCBMb2NhbEZpbGVEaWZmT3B0aW9ucyB9IGZyb20gJy4uJztcbmltcG9ydCB7IERpZmZNZXRob2QgfSBmcm9tICcuLic7XG5pbXBvcnQgdHlwZSB7IFNka1Byb3ZpZGVyIH0gZnJvbSAnLi4vLi4vLi4vYXBpL2F3cy1hdXRoL3ByaXZhdGUnO1xuaW1wb3J0IHR5cGUgeyBTdGFja0NvbGxlY3Rpb24gfSBmcm9tICcuLi8uLi8uLi9hcGkvY2xvdWQtYXNzZW1ibHkvc3RhY2stY29sbGVjdGlvbic7XG5pbXBvcnQgdHlwZSB7IERlcGxveW1lbnRzIH0gZnJvbSAnLi4vLi4vLi4vYXBpL2RlcGxveW1lbnRzJztcbmltcG9ydCAqIGFzIGNmbkFwaSBmcm9tICcuLi8uLi8uLi9hcGkvZGVwbG95bWVudHMvY2ZuLWFwaSc7XG5pbXBvcnQgdHlwZSB7IFRlbXBsYXRlSW5mbyB9IGZyb20gJy4uLy4uLy4uL2FwaS9kaWZmJztcbmltcG9ydCB0eXBlIHsgSW9IZWxwZXIgfSBmcm9tICcuLi8uLi8uLi9hcGkvaW8vcHJpdmF0ZSc7XG5pbXBvcnQgdHlwZSB7IFJlc291cmNlc1RvSW1wb3J0IH0gZnJvbSAnLi4vLi4vLi4vYXBpL3Jlc291cmNlLWltcG9ydCc7XG5pbXBvcnQgeyByZW1vdmVOb25JbXBvcnRSZXNvdXJjZXMsIFJlc291cmNlTWlncmF0b3IgfSBmcm9tICcuLi8uLi8uLi9hcGkvcmVzb3VyY2UtaW1wb3J0JztcbmltcG9ydCB7IFRvb2xraXRFcnJvciB9IGZyb20gJy4uLy4uLy4uL3Rvb2xraXQvdG9vbGtpdC1lcnJvcic7XG5pbXBvcnQgeyBkZXNlcmlhbGl6ZVN0cnVjdHVyZSwgZm9ybWF0RXJyb3JNZXNzYWdlIH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlRGlmZihcbiAgaW9IZWxwZXI6IElvSGVscGVyLFxuICBzdGFja3M6IFN0YWNrQ29sbGVjdGlvbixcbiAgZGVwbG95bWVudHM6IERlcGxveW1lbnRzLFxuICBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXIsXG4gIG9wdGlvbnM6IERpZmZPcHRpb25zLFxuKTogUHJvbWlzZTxUZW1wbGF0ZUluZm9bXT4ge1xuICBzd2l0Y2ggKG9wdGlvbnMubWV0aG9kPy5tZXRob2QgPz8gRGlmZk1ldGhvZC5DaGFuZ2VTZXQoKS5tZXRob2QpIHtcbiAgICBjYXNlICdsb2NhbC1maWxlJzpcbiAgICAgIHJldHVybiBsb2NhbEZpbGVEaWZmKHN0YWNrcywgb3B0aW9ucyk7XG4gICAgY2FzZSAndGVtcGxhdGUtb25seSc6XG4gICAgICByZXR1cm4gY2ZuRGlmZihpb0hlbHBlciwgc3RhY2tzLCBkZXBsb3ltZW50cywgb3B0aW9ucywgc2RrUHJvdmlkZXIsIGZhbHNlKTtcbiAgICBjYXNlICdjaGFuZ2Utc2V0JzpcbiAgICAgIHJldHVybiBjZm5EaWZmKGlvSGVscGVyLCBzdGFja3MsIGRlcGxveW1lbnRzLCBvcHRpb25zLCBzZGtQcm92aWRlciwgdHJ1ZSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoZm9ybWF0RXJyb3JNZXNzYWdlKGBVbmtub3duIGRpZmYgbWV0aG9kICR7b3B0aW9ucy5tZXRob2R9YCkpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGxvY2FsRmlsZURpZmYoc3RhY2tzOiBTdGFja0NvbGxlY3Rpb24sIG9wdGlvbnM6IERpZmZPcHRpb25zKTogUHJvbWlzZTxUZW1wbGF0ZUluZm9bXT4ge1xuICBjb25zdCBtZXRob2RPcHRpb25zID0gKG9wdGlvbnMubWV0aG9kPy5vcHRpb25zID8/IHt9KSBhcyBMb2NhbEZpbGVEaWZmT3B0aW9ucztcblxuICAvLyBDb21wYXJlIHNpbmdsZSBzdGFjayBhZ2FpbnN0IGZpeGVkIHRlbXBsYXRlXG4gIGlmIChzdGFja3Muc3RhY2tDb3VudCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoXG4gICAgICAnQ2FuIG9ubHkgc2VsZWN0IG9uZSBzdGFjayB3aGVuIGNvbXBhcmluZyB0byBmaXhlZCB0ZW1wbGF0ZS4gVXNlIC0tZXhjbHVzaXZlbHkgdG8gYXZvaWQgc2VsZWN0aW5nIG11bHRpcGxlIHN0YWNrcy4nLFxuICAgICk7XG4gIH1cblxuICBpZiAoIShhd2FpdCBmcy5wYXRoRXhpc3RzKG1ldGhvZE9wdGlvbnMucGF0aCkpKSB7XG4gICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgVGhlcmUgaXMgbm8gZmlsZSBhdCAke21ldGhvZE9wdGlvbnMucGF0aH1gKTtcbiAgfVxuXG4gIGNvbnN0IGZpbGUgPSBmcy5yZWFkRmlsZVN5bmMobWV0aG9kT3B0aW9ucy5wYXRoKS50b1N0cmluZygpO1xuICBjb25zdCB0ZW1wbGF0ZSA9IGRlc2VyaWFsaXplU3RydWN0dXJlKGZpbGUpO1xuXG4gIHJldHVybiBbe1xuICAgIG9sZFRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICBuZXdUZW1wbGF0ZTogc3RhY2tzLmZpcnN0U3RhY2ssXG4gIH1dO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjZm5EaWZmKFxuICBpb0hlbHBlcjogSW9IZWxwZXIsXG4gIHN0YWNrczogU3RhY2tDb2xsZWN0aW9uLFxuICBkZXBsb3ltZW50czogRGVwbG95bWVudHMsXG4gIG9wdGlvbnM6IERpZmZPcHRpb25zLFxuICBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXIsXG4gIGluY2x1ZGVDaGFuZ2VTZXQ6IGJvb2xlYW4sXG4pOiBQcm9taXNlPFRlbXBsYXRlSW5mb1tdPiB7XG4gIGNvbnN0IHRlbXBsYXRlSW5mb3MgPSBbXTtcbiAgY29uc3QgbWV0aG9kT3B0aW9ucyA9IChvcHRpb25zLm1ldGhvZD8ub3B0aW9ucyA/PyB7fSkgYXMgQ2hhbmdlU2V0RGlmZk9wdGlvbnM7XG5cbiAgLy8gQ29tcGFyZSBOIHN0YWNrcyBhZ2FpbnN0IGRlcGxveWVkIHRlbXBsYXRlc1xuICBmb3IgKGNvbnN0IHN0YWNrIG9mIHN0YWNrcy5zdGFja0FydGlmYWN0cykge1xuICAgIGNvbnN0IHRlbXBsYXRlV2l0aE5lc3RlZFN0YWNrcyA9IGF3YWl0IGRlcGxveW1lbnRzLnJlYWRDdXJyZW50VGVtcGxhdGVXaXRoTmVzdGVkU3RhY2tzKFxuICAgICAgc3RhY2ssXG4gICAgICBtZXRob2RPcHRpb25zLmNvbXBhcmVBZ2FpbnN0UHJvY2Vzc2VkVGVtcGxhdGUsXG4gICAgKTtcbiAgICBjb25zdCBjdXJyZW50VGVtcGxhdGUgPSB0ZW1wbGF0ZVdpdGhOZXN0ZWRTdGFja3MuZGVwbG95ZWRSb290VGVtcGxhdGU7XG4gICAgY29uc3QgbmVzdGVkU3RhY2tzID0gdGVtcGxhdGVXaXRoTmVzdGVkU3RhY2tzLm5lc3RlZFN0YWNrcztcblxuICAgIGNvbnN0IG1pZ3JhdG9yID0gbmV3IFJlc291cmNlTWlncmF0b3IoeyBkZXBsb3ltZW50cywgaW9IZWxwZXIgfSk7XG4gICAgY29uc3QgcmVzb3VyY2VzVG9JbXBvcnQgPSBhd2FpdCBtaWdyYXRvci50cnlHZXRSZXNvdXJjZXMoYXdhaXQgZGVwbG95bWVudHMucmVzb2x2ZUVudmlyb25tZW50KHN0YWNrKSk7XG4gICAgaWYgKHJlc291cmNlc1RvSW1wb3J0KSB7XG4gICAgICByZW1vdmVOb25JbXBvcnRSZXNvdXJjZXMoc3RhY2spO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYW5nZVNldCA9IGluY2x1ZGVDaGFuZ2VTZXQgPyBhd2FpdCBjaGFuZ2VTZXREaWZmKFxuICAgICAgaW9IZWxwZXIsXG4gICAgICBkZXBsb3ltZW50cyxcbiAgICAgIHN0YWNrLFxuICAgICAgc2RrUHJvdmlkZXIsXG4gICAgICByZXNvdXJjZXNUb0ltcG9ydCxcbiAgICAgIG1ldGhvZE9wdGlvbnMucGFyYW1ldGVycyxcbiAgICAgIG1ldGhvZE9wdGlvbnMuZmFsbGJhY2tUb1RlbXBsYXRlLFxuICAgICAgbWV0aG9kT3B0aW9ucy5pbXBvcnRFeGlzdGluZ1Jlc291cmNlcyxcbiAgICApIDogdW5kZWZpbmVkO1xuXG4gICAgdGVtcGxhdGVJbmZvcy5wdXNoKHtcbiAgICAgIG9sZFRlbXBsYXRlOiBjdXJyZW50VGVtcGxhdGUsXG4gICAgICBuZXdUZW1wbGF0ZTogc3RhY2ssXG4gICAgICBpc0ltcG9ydDogISFyZXNvdXJjZXNUb0ltcG9ydCxcbiAgICAgIG5lc3RlZFN0YWNrcyxcbiAgICAgIGNoYW5nZVNldCxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0ZW1wbGF0ZUluZm9zO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjaGFuZ2VTZXREaWZmKFxuICBpb0hlbHBlcjogSW9IZWxwZXIsXG4gIGRlcGxveW1lbnRzOiBEZXBsb3ltZW50cyxcbiAgc3RhY2s6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCxcbiAgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyLFxuICByZXNvdXJjZXNUb0ltcG9ydD86IFJlc291cmNlc1RvSW1wb3J0LFxuICBwYXJhbWV0ZXJzOiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQgfSA9IHt9LFxuICBmYWxsQmFja1RvVGVtcGxhdGU6IGJvb2xlYW4gPSB0cnVlLFxuICBpbXBvcnRFeGlzdGluZ1Jlc291cmNlczogYm9vbGVhbiA9IGZhbHNlLFxuKTogUHJvbWlzZTxhbnkgfCB1bmRlZmluZWQ+IHtcbiAgbGV0IHN0YWNrRXhpc3RzID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgc3RhY2tFeGlzdHMgPSBhd2FpdCBkZXBsb3ltZW50cy5zdGFja0V4aXN0cyh7XG4gICAgICBzdGFjayxcbiAgICAgIGRlcGxveU5hbWU6IHN0YWNrLnN0YWNrTmFtZSxcbiAgICAgIHRyeUxvb2t1cFJvbGU6IHRydWUsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgIGlmICghZmFsbEJhY2tUb1RlbXBsYXRlKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBkZXNjcmliZVN0YWNrcyBjYWxsIGZhaWxlZCB3aXRoICR7ZX0gZm9yICR7c3RhY2suc3RhY2tOYW1lfSwgc2V0IGZhbGxCYWNrVG9UZW1wbGF0ZSB0byB0cnVlIG9yIHVzZSBEaWZmTWV0aG9kLnRlbXBsYXRlT25seSB0byBiYXNlIHRoZSBkaWZmIG9uIHRlbXBsYXRlIGRpZmZlcmVuY2VzLmApO1xuICAgIH1cblxuICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLmRlYnVnKGBDaGVja2luZyBpZiB0aGUgc3RhY2sgJHtzdGFjay5zdGFja05hbWV9IGV4aXN0cyBiZWZvcmUgY3JlYXRpbmcgdGhlIGNoYW5nZXNldCBoYXMgZmFpbGVkLCB3aWxsIGJhc2UgdGhlIGRpZmYgb24gdGVtcGxhdGUgZGlmZmVyZW5jZXMuXFxuYCk7XG4gICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMuZGVidWcoZm9ybWF0RXJyb3JNZXNzYWdlKGUpKTtcbiAgICBzdGFja0V4aXN0cyA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHN0YWNrRXhpc3RzKSB7XG4gICAgcmV0dXJuIGNmbkFwaS5jcmVhdGVEaWZmQ2hhbmdlU2V0KGlvSGVscGVyLCB7XG4gICAgICBzdGFjayxcbiAgICAgIHV1aWQ6IHV1aWQudjQoKSxcbiAgICAgIGRlcGxveW1lbnRzLFxuICAgICAgd2lsbEV4ZWN1dGU6IGZhbHNlLFxuICAgICAgc2RrUHJvdmlkZXIsXG4gICAgICBwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzLFxuICAgICAgcmVzb3VyY2VzVG9JbXBvcnQsXG4gICAgICBmYWlsT25FcnJvcjogIWZhbGxCYWNrVG9UZW1wbGF0ZSxcbiAgICAgIGltcG9ydEV4aXN0aW5nUmVzb3VyY2VzLFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmICghZmFsbEJhY2tUb1RlbXBsYXRlKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGB0aGUgc3RhY2sgJyR7c3RhY2suc3RhY2tOYW1lfScgaGFzIG5vdCBiZWVuIGRlcGxveWVkIHRvIENsb3VkRm9ybWF0aW9uLCBzZXQgZmFsbEJhY2tUb1RlbXBsYXRlIHRvIHRydWUgb3IgdXNlIERpZmZNZXRob2QudGVtcGxhdGVPbmx5IHRvIGJhc2UgdGhlIGRpZmYgb24gdGVtcGxhdGUgZGlmZmVyZW5jZXMuYCk7XG4gICAgfVxuXG4gICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMuZGVidWcoYHRoZSBzdGFjayAnJHtzdGFjay5zdGFja05hbWV9JyBoYXMgbm90IGJlZW4gZGVwbG95ZWQgdG8gQ2xvdWRGb3JtYXRpb24sIHNraXBwaW5nIGNoYW5nZXNldCBjcmVhdGlvbi5gKTtcbiAgICByZXR1cm47XG4gIH1cbn1cblxuLyoqXG4gKiBBcHBlbmRzIGFsbCBwcm9wZXJ0aWVzIGZyb20gb2JqMiB0byBvYmoxLlxuICogb2JqMiB2YWx1ZXMgdGFrZSBwcmlvcml0eSBpbiB0aGUgY2FzZSBvZiBjb2xsaXNpb25zLlxuICpcbiAqIEBwYXJhbSBvYmoxIC0gVGhlIG9iamVjdCB0byBtb2RpZnlcbiAqIEBwYXJhbSBvYmoyIC0gVGhlIG9iamVjdCB0byBjb25zdW1lXG4gKlxuICogQHJldHVybnMgb2JqMSB3aXRoIGFsbCBwcm9wZXJ0aWVzIGZyb20gb2JqMlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kT2JqZWN0PFQ+KFxuICBvYmoxOiB7IFtuYW1lOiBzdHJpbmddOiBUIH0sXG4gIG9iajI6IHsgW25hbWU6IHN0cmluZ106IFQgfSxcbik6IHsgW25hbWU6IHN0cmluZ106IFQgfSB7XG4gIC8vIERpcmVjdGx5IG1vZGlmeSBvYmoxIGJ5IGFkZGluZyBhbGwgcHJvcGVydGllcyBmcm9tIG9iajJcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqMikge1xuICAgIG9iajFba2V5XSA9IG9iajJba2V5XTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqMVxuICByZXR1cm4gb2JqMTtcbn1cbiJdfQ==