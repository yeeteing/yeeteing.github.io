import debounce from 'debounce-promise';
import { subscribe as _subscribe } from '@parcel/watcher';
import parseGitIgnore from 'parse-gitignore';
import path from 'path';
import fs from 'fs';
import _open from 'open';
// EventEmitter is a class name and expected to have PascalCase
// eslint-disable-next-line @typescript-eslint/naming-convention
import EventEmitter from 'events';
import { GetParameterCommand, ParameterNotFound, SSMServiceException, } from '@aws-sdk/client-ssm';
import { AmplifyPrompter, LogLevel, format, } from '@aws-amplify/cli-core';
import { createFilesChangesTracker, } from './files_changes_tracker.js';
import { AmplifyError, AmplifyUserError, BackendIdentifierConversions, setSpanAttributes, translateErrorToTelemetryErrorDetails, } from '@aws-amplify/platform-core';
import { EOL } from 'os';
import { trace as openTelemetryTrace } from '@opentelemetry/api';
/**
 * CDK stores bootstrap version in parameter store. Example parameter name looks like /cdk-bootstrap/<qualifier>/version.
 * The default value for qualifier is hnb659fds, i.e. default parameter path is /cdk-bootstrap/hnb659fds/version.
 * The default qualifier is hardcoded value without any significance.
 * Ability to provide custom qualifier is intended for name isolation between automated tests of the CDK itself.
 * In order to use custom qualifier all stack synthesizers must be programmatically configured to use it.
 * That makes bootstraps with custom qualifier incompatible with Amplify Backend and we treat that setup as
 * not bootstrapped.
 * See: https://docs.aws.amazon.com/cdk/v2/guide/bootstrapping.html
 */
export const CDK_DEFAULT_BOOTSTRAP_VERSION_PARAMETER_NAME = 
// suppress spell checker, it is triggered by qualifier value.
// eslint-disable-next-line spellcheck/spell-checker
'/cdk-bootstrap/hnb659fds/version';
export const CDK_MIN_BOOTSTRAP_VERSION = 6;
/**
 * Constructs Amplify Console bootstrap URL for a given region
 * @param region AWS region
 * @returns Amplify Console bootstrap URL
 */
export const getBootstrapUrl = (region) => `https://${region}.console.aws.amazon.com/amplify/create/bootstrap?region=${region}`;
/**
 * Runs a file watcher and deploys
 */
export class FileWatchingSandbox extends EventEmitter {
    backendIdSandboxResolver;
    executor;
    ssmClient;
    functionsLogStreamer;
    printer;
    open;
    subscribe;
    watcherSubscription;
    outputFilesExcludedFromWatch = ['.amplify'];
    filesChangesTracker;
    /**
     * Creates a watcher process for this instance
     */
    constructor(backendIdSandboxResolver, executor, ssmClient, functionsLogStreamer, printer, open = _open, subscribe = _subscribe) {
        process.once('SIGINT', () => void this.stop());
        process.once('SIGTERM', () => void this.stop());
        super();
        this.backendIdSandboxResolver = backendIdSandboxResolver;
        this.executor = executor;
        this.ssmClient = ssmClient;
        this.functionsLogStreamer = functionsLogStreamer;
        this.printer = printer;
        this.open = open;
        this.subscribe = subscribe;
        this.interceptStderr();
    }
    /**
     * @inheritdoc
     */
    emit(eventName, ...args) {
        return super.emit(eventName, ...args);
    }
    /**
     * @inheritdoc
     */
    on(eventName, listener) {
        return super.on(eventName, listener);
    }
    /**
     * @inheritdoc
     */
    start = async (options) => {
        const watchDir = options.dir ?? './amplify';
        const watchForChanges = options.watchForChanges ?? true;
        if (!fs.existsSync(watchDir)) {
            throw new AmplifyUserError('PathNotFoundError', {
                message: `${watchDir} does not exist.`,
                resolution: 'Make sure you are running this command from your project root directory.',
            });
        }
        this.filesChangesTracker = await createFilesChangesTracker(watchDir);
        const bootstrapped = await this.isBootstrapped();
        // get region from an available sdk client;
        const region = await this.ssmClient.config.region();
        if (!bootstrapped) {
            this.printer.log(`The region ${format.highlight(region)} has not been bootstrapped. Sign in to the AWS console as a Root user or Admin to complete the bootstrap process, then restart the sandbox.${EOL}If this is not the region you are expecting to bootstrap, check for any AWS environment variables that may be set in your shell or use ${format.command('--profile <profile-name>')} to specify a profile with the correct region.`);
            const bootstrapUrl = getBootstrapUrl(region);
            try {
                await this.open(bootstrapUrl);
            }
            catch (e) {
                // If opening the link fails for any reason we fall back to
                // printing the url in the console.
                // This might happen:
                // - in headless environments
                // - if user does not have any app to open URL
                // - if browser crashes
                let logEntry = 'Unable to open bootstrap url';
                if (e instanceof Error) {
                    logEntry = `${logEntry}, ${e.message}`;
                }
                this.printer.log(logEntry, LogLevel.DEBUG);
                this.printer.log(`Open ${bootstrapUrl} in the browser.`);
            }
            return;
        }
        const ignoredPaths = this.getGitIgnoredPaths();
        this.outputFilesExcludedFromWatch =
            this.outputFilesExcludedFromWatch.concat(...ignoredPaths);
        this.printer.clearConsole();
        await this.printSandboxNameInfo(options.identifier);
        // Since 'cdk deploy' is a relatively slow operation for a 'watch' process,
        // introduce a concurrency latch that tracks the state.
        // This way, if file change events arrive when a 'cdk deploy' is still executing,
        // we will batch them, and trigger another 'cdk deploy' after the current one finishes,
        // making sure 'cdk deploy's  always execute one at a time.
        // Here's a diagram showing the state transitions:
        // --------    file changed     --------------    file changed     --------------  file changed
        // |      | ------------------> |            | ------------------> |            | --------------|
        // | open |                     | deploying  |                     |   queued   |               |
        // |      | <------------------ |            | <------------------ |            | <-------------|
        // --------  'cdk deploy' done  --------------  'cdk deploy' done  --------------
        let latch = 'open';
        const deployAndWatch = debounce(async () => {
            latch = 'deploying';
            // Stop streaming the logs so that deployment logs don't get mixed up
            this.functionsLogStreamer.stopStreamingLogs();
            await this.deploy(options);
            // If latch is still 'deploying' after the 'await', that's fine,
            // but if it's 'queued', that means we need to deploy again
            while (latch === 'queued') {
                // TypeScript doesn't realize latch can change between 'awaits' ¯\_(ツ)_/¯,
                // and thinks the above 'while' condition is always 'false' without the cast
                latch = 'deploying';
                this.printer.clearConsole();
                await this.printSandboxNameInfo(options.identifier);
                this.printer.log("[Sandbox] Detected file changes while previous deployment was in progress. Invoking 'sandbox' again");
                await this.deploy(options);
            }
            latch = 'open';
            // Idle state, let customers know and start streaming function logs
            this.emitWatching();
            await this.functionsLogStreamer.startStreamingLogs(await this.backendIdSandboxResolver(options.identifier), options.functionStreamingOptions);
        });
        if (watchForChanges) {
            this.watcherSubscription = await this.subscribe(watchDir, async (_, events) => {
                // Log and track file changes.
                await Promise.all(events.map(async ({ type: eventName, path: filePath }) => {
                    this.filesChangesTracker.trackFileChange(filePath);
                    if (latch === 'open') {
                        this.printer.clearConsole();
                        await this.printSandboxNameInfo();
                    }
                    this.printer.log(`[Sandbox] Triggered due to a file ${eventName} event: ${path.relative(process.cwd(), filePath)}`);
                }));
                if (latch === 'open') {
                    await deployAndWatch();
                }
                else {
                    // this means latch is either 'deploying' or 'queued'
                    latch = 'queued';
                    this.printer.log('[Sandbox] Previous deployment is still in progress. ' +
                        'Will queue for another deployment after this one finishes');
                }
            }, {
                ignore: this.outputFilesExcludedFromWatch.concat(...(options.exclude ?? [])),
            });
            // Start the first full deployment without waiting for a file change
            await deployAndWatch();
        }
        else {
            await this.deploy(options);
        }
    };
    /**
     * @inheritdoc
     */
    stop = async () => {
        this.printer.log(`[Sandbox] Shutting down`, LogLevel.DEBUG);
        this.functionsLogStreamer?.stopStreamingLogs();
        // can be undefined if command exits before subscription
        await this.watcherSubscription?.unsubscribe();
    };
    /**
     * @inheritdoc
     */
    delete = async (options) => {
        this.printer.log('[Sandbox] Deleting all the resources in the sandbox environment...');
        await this.executor.destroy(await this.backendIdSandboxResolver(options.identifier));
        this.emit('successfulDeletion');
        this.printer.log('[Sandbox] Finished deleting.');
    };
    shouldValidateAppSources = () => {
        const snapshot = this.filesChangesTracker.getAndResetSnapshot();
        // if zero files changed this indicates initial deployment
        const shouldValidateOnColdStart = snapshot.hadTypeScriptFilesAtStart &&
            !snapshot.didAnyFileChangeSinceStart;
        return (shouldValidateOnColdStart ||
            snapshot.didAnyTypeScriptFileChangeSinceLastSnapshot);
    };
    deploy = async (options) => {
        const tracer = openTelemetryTrace.getTracer('amplify-backend');
        await tracer.startActiveSpan('sandbox', async (span) => {
            const startTime = Date.now();
            try {
                const deployResult = await this.executor.deploy(await this.backendIdSandboxResolver(options.identifier), 
                // It's important to pass this as callback so that debounce does
                // not reset tracker prematurely
                this.shouldValidateAppSources);
                const data = {
                    latency: {
                        total: deployResult.deploymentTimes.totalTime
                            ? deployResult.deploymentTimes.totalTime * 1000
                            : 0,
                        synthesis: deployResult.deploymentTimes.synthesisTime
                            ? deployResult.deploymentTimes.synthesisTime * 1000
                            : 0,
                    },
                    event: {
                        state: 'SUCCEEDED',
                        command: {
                            path: ['SandboxDeployment'],
                            parameters: [],
                        },
                    },
                };
                setSpanAttributes(span, data);
                span.end();
                this.printer.log('[Sandbox] Deployment successful', LogLevel.DEBUG);
                this.emit('successfulDeployment', deployResult);
            }
            catch (error) {
                const amplifyError = AmplifyError.isAmplifyError(error)
                    ? error
                    : AmplifyError.fromError(error);
                const data = {
                    latency: {
                        total: Date.now() - startTime,
                    },
                    event: {
                        state: 'FAILED',
                        command: {
                            path: ['SandboxDeployment'],
                            parameters: [],
                        },
                    },
                    error: translateErrorToTelemetryErrorDetails(amplifyError),
                };
                setSpanAttributes(span, data);
                span.end();
                // Print a meaningful message
                this.printer.log(format.error(amplifyError), LogLevel.ERROR);
                // Print stack traces
                let errorToDisplayStackTrace = amplifyError;
                while (errorToDisplayStackTrace) {
                    if (errorToDisplayStackTrace.stack) {
                        this.printer.log(`Stack Trace for ${errorToDisplayStackTrace.name}`, LogLevel.DEBUG);
                        this.printer.log(format.dim(errorToDisplayStackTrace.stack), LogLevel.DEBUG);
                    }
                    errorToDisplayStackTrace =
                        errorToDisplayStackTrace.cause instanceof Error
                            ? errorToDisplayStackTrace.cause
                            : undefined;
                }
                this.emit('failedDeployment', error);
                // If the error is because of a non-allowed destructive change such as
                // https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cognito-userpool.html#cfn-cognito-userpool-aliasattributes
                // offer to recreate the sandbox or revert the change
                if (AmplifyError.isAmplifyError(error) &&
                    error.name === 'CFNUpdateNotSupportedError') {
                    await this.handleUnsupportedDestructiveChanges(options);
                }
                // else do not propagate and let the sandbox continue to run
            }
        });
    };
    reset = async (options) => {
        await this.delete({ identifier: options.identifier });
        await this.start(options);
    };
    /**
     * Just a shorthand console log to indicate whenever watcher is going idle
     */
    emitWatching = () => {
        this.printer.log(`[Sandbox] Watching for file changes...`);
    };
    /**
     * Reads and parses .gitignore file and returns the list of paths
     */
    getGitIgnoredPaths = () => {
        const gitIgnoreFilePath = path.join(process.cwd(), '.gitignore');
        if (fs.existsSync(gitIgnoreFilePath)) {
            return parseGitIgnore
                .parse(gitIgnoreFilePath)
                .patterns.map((pattern) => pattern.startsWith('/') ? pattern.substring(1) : pattern)
                .filter((pattern) => {
                if (pattern.startsWith('!')) {
                    this.printer.log(`[Sandbox] Pattern ${pattern} found in .gitignore. "${pattern.substring(1)}" will not be watched if other patterns in .gitignore are excluding it.`);
                    return false;
                }
                return true;
            });
        }
        return [];
    };
    /**
     * Checks if a given region has been bootstrapped with >= min version using CDK bootstrap version parameter
     * stored in parameter store.
     * @returns A Boolean that represents if region has been bootstrapped.
     */
    isBootstrapped = async () => {
        try {
            const { Parameter: parameter } = await this.ssmClient.send(new GetParameterCommand({
                Name: CDK_DEFAULT_BOOTSTRAP_VERSION_PARAMETER_NAME,
            }));
            const bootstrapVersion = parameter?.Value;
            if (!bootstrapVersion ||
                Number(bootstrapVersion) < CDK_MIN_BOOTSTRAP_VERSION) {
                return false;
            }
            return true;
        }
        catch (e) {
            if (e instanceof ParameterNotFound) {
                return false;
            }
            if (e instanceof SSMServiceException &&
                [
                    'UnrecognizedClientException',
                    'AccessDeniedException',
                    'NotAuthorized',
                    'ExpiredTokenException',
                    'ExpiredToken',
                    'InvalidSignatureException',
                ].includes(e.name)) {
                throw new AmplifyUserError('SSMCredentialsError', {
                    message: `${e.name}: ${e.message}`,
                    resolution: 'Make sure your AWS credentials are set up correctly and have permissions to call SSM:GetParameter',
                }, e);
            }
            // If we are unable to retrieve bootstrap version parameter due to other reasons, we fail fast.
            throw e;
        }
    };
    handleUnsupportedDestructiveChanges = async (options) => {
        this.printer.print(format.error('[Sandbox] We cannot deploy your new changes. You can either revert them or recreate your sandbox with the new changes (deleting all user data)'));
        // offer to recreate the sandbox with new properties
        const answer = await AmplifyPrompter.yesOrNo({
            message: 'Would you like to recreate your sandbox (deleting all user data)?',
            defaultValue: false,
        });
        if (answer) {
            await this.stop();
            await this.reset(options);
        }
        // else let the sandbox continue so customers can revert their changes
    };
    printSandboxNameInfo = async (sandboxIdentifier) => {
        const sandboxBackendId = await this.backendIdSandboxResolver(sandboxIdentifier);
        const stackName = BackendIdentifierConversions.toStackName(sandboxBackendId);
        const region = await this.ssmClient.config.region();
        this.printer.print(format.indent(format.highlight(format.bold('\nAmplify Sandbox\n'))));
        this.printer.print(format.indent(`${format.bold('Identifier:')} \t${sandboxBackendId.name}`));
        this.printer.print(format.indent(`${format.bold('Stack:')} \t${stackName}`));
        this.printer.print(format.indent(`${format.bold('Region:')} \t${region}`));
        if (!sandboxIdentifier) {
            this.printer.print(`${format.indent(format.dim('\nTo specify a different sandbox identifier, use '))}${format.bold('--identifier')}`);
        }
        this.printer.printNewLine();
    };
    /**
     * Hack to suppress certain stderr messages until aws-cdk constructs
     * can use the toolkit's IoHost to deliver messages.
     * See tracking items https://github.com/aws/aws-cdk-cli/issues/158
     *
     * Rest of the stderr messages are rerouted to our printer so that they
     * don't get intermingled with spinners.
     */
    interceptStderr = () => {
        process.stderr.write = (chunk) => {
            if (typeof chunk !== 'string' ||
                !['Bundling asset'].some((prohibitedStrings) => chunk.includes(prohibitedStrings))) {
                this.printer.log(typeof chunk === 'string' ? chunk : chunk.toLocaleString());
            }
            return true;
        };
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZV93YXRjaGluZ19zYW5kYm94LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2ZpbGVfd2F0Y2hpbmdfc2FuZGJveC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLFFBQVEsTUFBTSxrQkFBa0IsQ0FBQztBQUN4QyxPQUFPLEVBQUUsU0FBUyxJQUFJLFVBQVUsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBUzFELE9BQU8sY0FBYyxNQUFNLGlCQUFpQixDQUFDO0FBQzdDLE9BQU8sSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUN4QixPQUFPLEVBQUUsTUFBTSxJQUFJLENBQUM7QUFDcEIsT0FBTyxLQUFLLE1BQU0sTUFBTSxDQUFDO0FBQ3pCLCtEQUErRDtBQUMvRCxnRUFBZ0U7QUFDaEUsT0FBTyxZQUFZLE1BQU0sUUFBUSxDQUFDO0FBQ2xDLE9BQU8sRUFDTCxtQkFBbUIsRUFDbkIsaUJBQWlCLEVBRWpCLG1CQUFtQixHQUNwQixNQUFNLHFCQUFxQixDQUFDO0FBQzdCLE9BQU8sRUFDTCxlQUFlLEVBQ2YsUUFBUSxFQUVSLE1BQU0sR0FDUCxNQUFNLHVCQUF1QixDQUFDO0FBQy9CLE9BQU8sRUFFTCx5QkFBeUIsR0FDMUIsTUFBTSw0QkFBNEIsQ0FBQztBQUNwQyxPQUFPLEVBQ0wsWUFBWSxFQUNaLGdCQUFnQixFQUNoQiw0QkFBNEIsRUFFNUIsaUJBQWlCLEVBQ2pCLHFDQUFxQyxHQUN0QyxNQUFNLDRCQUE0QixDQUFDO0FBRXBDLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxJQUFJLENBQUM7QUFDekIsT0FBTyxFQUFRLEtBQUssSUFBSSxrQkFBa0IsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBR3ZFOzs7Ozs7Ozs7R0FTRztBQUNILE1BQU0sQ0FBQyxNQUFNLDRDQUE0QztBQUN2RCw4REFBOEQ7QUFDOUQsb0RBQW9EO0FBQ3BELGtDQUFrQyxDQUFDO0FBQ3JDLE1BQU0sQ0FBQyxNQUFNLHlCQUF5QixHQUFHLENBQUMs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OUIsQ0FBQyxDQUFDO0lBRUY7Ozs7Ozs7T0FPRztJQUNLLGVBQWUsR0FBRyxHQUFHLEVBQUU7UUFDN0IsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUMvQixJQUNFLE9BQU8sS0FBSyxLQUFLLFFBQVE7Z0JBQ3pCLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLGlCQUFpQixFQUFFLEVBQUUsQ0FDN0MsS0FBSyxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUNsQyxFQUNELENBQUM7Z0JBQ0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQ2QsT0FBTyxLQUFLLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FDM0QsQ0FBQztZQUNKLENBQUM7WUFDRCxPQUFPLElBQUksQ0FBQztRQUNkLENBQUMsQ0FBQztJQUNKLENBQUMsQ0FBQztDQUNIIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlYm91bmNlIGZyb20gJ2RlYm91bmNlLXByb21pc2UnO1xuaW1wb3J0IHsgc3Vic2NyaWJlIGFzIF9zdWJzY3JpYmUgfSBmcm9tICdAcGFyY2VsL3dhdGNoZXInO1xuaW1wb3J0IHsgQW1wbGlmeVNhbmRib3hFeGVjdXRvciB9IGZyb20gJy4vc2FuZGJveF9leGVjdXRvci5qcyc7XG5pbXBvcnQge1xuICBCYWNrZW5kSWRTYW5kYm94UmVzb2x2ZXIsXG4gIFNhbmRib3gsXG4gIFNhbmRib3hEZWxldGVPcHRpb25zLFxuICBTYW5kYm94RXZlbnRzLFxuICBTYW5kYm94T3B0aW9ucyxcbn0gZnJvbSAnLi9zYW5kYm94LmpzJztcbmltcG9ydCBwYXJzZUdpdElnbm9yZSBmcm9tICdwYXJzZS1naXRpZ25vcmUnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IF9vcGVuIGZyb20gJ29wZW4nO1xuLy8gRXZlbnRFbWl0dGVyIGlzIGEgY2xhc3MgbmFtZSBhbmQgZXhwZWN0ZWQgdG8gaGF2ZSBQYXNjYWxDYXNlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQge1xuICBHZXRQYXJhbWV0ZXJDb21tYW5kLFxuICBQYXJhbWV0ZXJOb3RGb3VuZCxcbiAgU1NNQ2xpZW50LFxuICBTU01TZXJ2aWNlRXhjZXB0aW9uLFxufSBmcm9tICdAYXdzLXNkay9jbGllbnQtc3NtJztcbmltcG9ydCB7XG4gIEFtcGxpZnlQcm9tcHRlcixcbiAgTG9nTGV2ZWwsXG4gIFByaW50ZXIsXG4gIGZvcm1hdCxcbn0gZnJvbSAnQGF3cy1hbXBsaWZ5L2NsaS1jb3JlJztcbmltcG9ydCB7XG4gIEZpbGVzQ2hhbmdlc1RyYWNrZXIsXG4gIGNyZWF0ZUZpbGVzQ2hhbmdlc1RyYWNrZXIsXG59IGZyb20gJy4vZmlsZXNfY2hhbmdlc190cmFja2VyLmpzJztcbmltcG9ydCB7XG4gIEFtcGxpZnlFcnJvcixcbiAgQW1wbGlmeVVzZXJFcnJvcixcbiAgQmFja2VuZElkZW50aWZpZXJDb252ZXJzaW9ucyxcbiAgVGVsZW1ldHJ5UGF5bG9hZCxcbiAgc2V0U3BhbkF0dHJpYnV0ZXMsXG4gIHRyYW5zbGF0ZUVycm9yVG9UZWxlbWV0cnlFcnJvckRldGFpbHMsXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbGF0Zm9ybS1jb3JlJztcbmltcG9ydCB7IExhbWJkYUZ1bmN0aW9uTG9nU3RyZWFtZXIgfSBmcm9tICcuL2xhbWJkYV9mdW5jdGlvbl9sb2dfc3RyZWFtZXIuanMnO1xuaW1wb3J0IHsgRU9MIH0gZnJvbSAnb3MnO1xuaW1wb3J0IHsgU3BhbiwgdHJhY2UgYXMgb3BlblRlbGVtZXRyeVRyYWNlIH0gZnJvbSAnQG9wZW50ZWxlbWV0cnkvYXBpJztcbmltcG9ydCB7IERlZXBQYXJ0aWFsIH0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsdWdpbi10eXBlcyc7XG5cbi8qKlxuICogQ0RLIHN0b3JlcyBib290c3RyYXAgdmVyc2lvbiBpbiBwYXJhbWV0ZXIgc3RvcmUuIEV4YW1wbGUgcGFyYW1ldGVyIG5hbWUgbG9va3MgbGlrZSAvY2RrLWJvb3RzdHJhcC88cXVhbGlmaWVyPi92ZXJzaW9uLlxuICogVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHF1YWxpZmllciBpcyBobmI2NTlmZHMsIGkuZS4gZGVmYXVsdCBwYXJhbWV0ZXIgcGF0aCBpcyAvY2RrLWJvb3RzdHJhcC9obmI2NTlmZHMvdmVyc2lvbi5cbiAqIFRoZSBkZWZhdWx0IHF1YWxpZmllciBpcyBoYXJkY29kZWQgdmFsdWUgd2l0aG91dCBhbnkgc2lnbmlmaWNhbmNlLlxuICogQWJpbGl0eSB0byBwcm92aWRlIGN1c3RvbSBxdWFsaWZpZXIgaXMgaW50ZW5kZWQgZm9yIG5hbWUgaXNvbGF0aW9uIGJldHdlZW4gYXV0b21hdGVkIHRlc3RzIG9mIHRoZSBDREsgaXRzZWxmLlxuICogSW4gb3JkZXIgdG8gdXNlIGN1c3RvbSBxdWFsaWZpZXIgYWxsIHN0YWNrIHN5bnRoZXNpemVycyBtdXN0IGJlIHByb2dyYW1tYXRpY2FsbHkgY29uZmlndXJlZCB0byB1c2UgaXQuXG4gKiBUaGF0IG1ha2VzIGJvb3RzdHJhcHMgd2l0aCBjdXN0b20gcXVhbGlmaWVyIGluY29tcGF0aWJsZSB3aXRoIEFtcGxpZnkgQmFja2VuZCBhbmQgd2UgdHJlYXQgdGhhdCBzZXR1cCBhc1xuICogbm90IGJvb3RzdHJhcHBlZC5cbiAqIFNlZTogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2Nkay92Mi9ndWlkZS9ib290c3RyYXBwaW5nLmh0bWxcbiAqL1xuZXhwb3J0IGNvbnN0IENES19ERUZBVUxUX0JPT1RTVFJBUF9WRVJTSU9OX1BBUkFNRVRFUl9OQU1FID1cbiAgLy8gc3VwcHJlc3Mgc3BlbGwgY2hlY2tlciwgaXQgaXMgdHJpZ2dlcmVkIGJ5IHF1YWxpZmllciB2YWx1ZS5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNwZWxsY2hlY2svc3BlbGwtY2hlY2tlclxuICAnL2Nkay1ib290c3RyYXAvaG5iNjU5ZmRzL3ZlcnNpb24nO1xuZXhwb3J0IGNvbnN0IENES19NSU5fQk9PVFNUUkFQX1ZFUlNJT04gPSA2O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgQW1wbGlmeSBDb25zb2xlIGJvb3RzdHJhcCBVUkwgZm9yIGEgZ2l2ZW4gcmVnaW9uXG4gKiBAcGFyYW0gcmVnaW9uIEFXUyByZWdpb25cbiAqIEByZXR1cm5zIEFtcGxpZnkgQ29uc29sZSBib290c3RyYXAgVVJMXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRCb290c3RyYXBVcmwgPSAocmVnaW9uOiBzdHJpbmcpID0+XG4gIGBodHRwczovLyR7cmVnaW9ufS5jb25zb2xlLmF3cy5hbWF6b24uY29tL2FtcGxpZnkvY3JlYXRlL2Jvb3RzdHJhcD9yZWdpb249JHtyZWdpb259YDtcblxuLyoqXG4gKiBSdW5zIGEgZmlsZSB3YXRjaGVyIGFuZCBkZXBsb3lzXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWxlV2F0Y2hpbmdTYW5kYm94IGV4dGVuZHMgRXZlbnRFbWl0dGVyIGltcGxlbWVudHMgU2FuZGJveCB7XG4gIHByaXZhdGUgd2F0Y2hlclN1YnNjcmlwdGlvbjogQXdhaXRlZDxSZXR1cm5UeXBlPHR5cGVvZiBfc3Vic2NyaWJlPj47XG4gIHByaXZhdGUgb3V0cHV0RmlsZXNFeGNsdWRlZEZyb21XYXRjaCA9IFsnLmFtcGxpZnknXTtcbiAgcHJpdmF0ZSBmaWxlc0NoYW5nZXNUcmFja2VyOiBGaWxlc0NoYW5nZXNUcmFja2VyO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgd2F0Y2hlciBwcm9jZXNzIGZvciB0aGlzIGluc3RhbmNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGJhY2tlbmRJZFNhbmRib3hSZXNvbHZlcjogQmFja2VuZElkU2FuZGJveFJlc29sdmVyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZXhlY3V0b3I6IEFtcGxpZnlTYW5kYm94RXhlY3V0b3IsXG4gICAgcHJpdmF0ZSByZWFkb25seSBzc21DbGllbnQ6IFNTTUNsaWVudCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZ1bmN0aW9uc0xvZ1N0cmVhbWVyOiBMYW1iZGFGdW5jdGlvbkxvZ1N0cmVhbWVyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcHJpbnRlcjogUHJpbnRlcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IG9wZW4gPSBfb3BlbixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN1YnNjcmliZSA9IF9zdWJzY3JpYmUsXG4gICkge1xuICAgIHByb2Nlc3Mub25jZSgnU0lHSU5UJywgKCkgPT4gdm9pZCB0aGlzLnN0b3AoKSk7XG4gICAgcHJvY2Vzcy5vbmNlKCdTSUdURVJNJywgKCkgPT4gdm9pZCB0aGlzLnN0b3AoKSk7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmludGVyY2VwdFN0ZGVycigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jXG4gICAqL1xuICBvdmVycmlkZSBlbWl0KGV2ZW50TmFtZTogU2FuZGJveEV2ZW50cywgLi4uYXJnczogdW5rbm93bltdKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHN1cGVyLmVtaXQoZXZlbnROYW1lLCAuLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvY1xuICAgKi9cbiAgb3ZlcnJpZGUgb24oXG4gICAgZXZlbnROYW1lOiBTYW5kYm94RXZlbnRzLFxuICAgIGxpc3RlbmVyOiAoLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkLFxuICApOiB0aGlzIHtcbiAgICByZXR1cm4gc3VwZXIub24oZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIHN0YXJ0ID0gYXN5bmMgKG9wdGlvbnM6IFNhbmRib3hPcHRpb25zKSA9PiB7XG4gICAgY29uc3Qgd2F0Y2hEaXIgPSBvcHRpb25zLmRpciA/PyAnLi9hbXBsaWZ5JztcbiAgICBjb25zdCB3YXRjaEZvckNoYW5nZXMgPSBvcHRpb25zLndhdGNoRm9yQ2hhbmdlcyA/PyB0cnVlO1xuXG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKHdhdGNoRGlyKSkge1xuICAgICAgdGhyb3cgbmV3IEFtcGxpZnlVc2VyRXJyb3IoJ1BhdGhOb3RGb3VuZEVycm9yJywge1xuICAgICAgICBtZXNzYWdlOiBgJHt3YXRjaERpcn0gZG9lcyBub3QgZXhpc3QuYCxcbiAgICAgICAgcmVzb2x1dGlvbjpcbiAgICAgICAgICAnTWFrZSBzdXJlIHlvdSBhcmUgcnVubmluZyB0aGlzIGNvbW1hbmQgZnJvbSB5b3VyIHByb2plY3Qgcm9vdCBkaXJlY3RvcnkuJyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuZmlsZXNDaGFuZ2VzVHJhY2tlciA9IGF3YWl0IGNyZWF0ZUZpbGVzQ2hhbmdlc1RyYWNrZXIod2F0Y2hEaXIpO1xuICAgIGNvbnN0IGJvb3RzdHJhcHBlZCA9IGF3YWl0IHRoaXMuaXNCb290c3RyYXBwZWQoKTtcbiAgICAvLyBnZXQgcmVnaW9uIGZyb20gYW4gYXZhaWxhYmxlIHNkayBjbGllbnQ7XG4gICAgY29uc3QgcmVnaW9uID0gYXdhaXQgdGhpcy5zc21DbGllbnQuY29uZmlnLnJlZ2lvbigpO1xuICAgIGlmICghYm9vdHN0cmFwcGVkKSB7XG4gICAgICB0aGlzLnByaW50ZXIubG9nKFxuICAgICAgICBgVGhlIHJlZ2lvbiAke2Zvcm1hdC5oaWdobGlnaHQoXG4gICAgICAgICAgcmVnaW9uLFxuICAgICAgICApfSBoYXMgbm90IGJlZW4gYm9vdHN0cmFwcGVkLiBTaWduIGluIHRvIHRoZSBBV1MgY29uc29sZSBhcyBhIFJvb3QgdXNlciBvciBBZG1pbiB0byBjb21wbGV0ZSB0aGUgYm9vdHN0cmFwIHByb2Nlc3MsIHRoZW4gcmVzdGFydCB0aGUgc2FuZGJveC4ke0VPTH1JZiB0aGlzIGlzIG5vdCB0aGUgcmVnaW9uIHlvdSBhcmUgZXhwZWN0aW5nIHRvIGJvb3RzdHJhcCwgY2hlY2sgZm9yIGFueSBBV1MgZW52aXJvbm1lbnQgdmFyaWFibGVzIHRoYXQgbWF5IGJlIHNldCBpbiB5b3VyIHNoZWxsIG9yIHVzZSAke2Zvcm1hdC5jb21tYW5kKFxuICAgICAgICAgICctLXByb2ZpbGUgPHByb2ZpbGUtbmFtZT4nLFxuICAgICAgICApfSB0byBzcGVjaWZ5IGEgcHJvZmlsZSB3aXRoIHRoZSBjb3JyZWN0IHJlZ2lvbi5gLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGJvb3RzdHJhcFVybCA9IGdldEJvb3RzdHJhcFVybChyZWdpb24pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5vcGVuKGJvb3RzdHJhcFVybCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIElmIG9wZW5pbmcgdGhlIGxpbmsgZmFpbHMgZm9yIGFueSByZWFzb24gd2UgZmFsbCBiYWNrIHRvXG4gICAgICAgIC8vIHByaW50aW5nIHRoZSB1cmwgaW4gdGhlIGNvbnNvbGUuXG4gICAgICAgIC8vIFRoaXMgbWlnaHQgaGFwcGVuOlxuICAgICAgICAvLyAtIGluIGhlYWRsZXNzIGVudmlyb25tZW50c1xuICAgICAgICAvLyAtIGlmIHVzZXIgZG9lcyBub3QgaGF2ZSBhbnkgYXBwIHRvIG9wZW4gVVJMXG4gICAgICAgIC8vIC0gaWYgYnJvd3NlciBjcmFzaGVzXG4gICAgICAgIGxldCBsb2dFbnRyeSA9ICdVbmFibGUgdG8gb3BlbiBib290c3RyYXAgdXJsJztcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGxvZ0VudHJ5ID0gYCR7bG9nRW50cnl9LCAke2UubWVzc2FnZX1gO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJpbnRlci5sb2cobG9nRW50cnksIExvZ0xldmVsLkRFQlVHKTtcbiAgICAgICAgdGhpcy5wcmludGVyLmxvZyhgT3BlbiAke2Jvb3RzdHJhcFVybH0gaW4gdGhlIGJyb3dzZXIuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaWdub3JlZFBhdGhzID0gdGhpcy5nZXRHaXRJZ25vcmVkUGF0aHMoKTtcbiAgICB0aGlzLm91dHB1dEZpbGVzRXhjbHVkZWRGcm9tV2F0Y2ggPVxuICAgICAgdGhpcy5vdXRwdXRGaWxlc0V4Y2x1ZGVkRnJvbVdhdGNoLmNvbmNhdCguLi5pZ25vcmVkUGF0aHMpO1xuXG4gICAgdGhpcy5wcmludGVyLmNsZWFyQ29uc29sZSgpO1xuICAgIGF3YWl0IHRoaXMucHJpbnRTYW5kYm94TmFtZUluZm8ob3B0aW9ucy5pZGVudGlmaWVyKTtcblxuICAgIC8vIFNpbmNlICdjZGsgZGVwbG95JyBpcyBhIHJlbGF0aXZlbHkgc2xvdyBvcGVyYXRpb24gZm9yIGEgJ3dhdGNoJyBwcm9jZXNzLFxuICAgIC8vIGludHJvZHVjZSBhIGNvbmN1cnJlbmN5IGxhdGNoIHRoYXQgdHJhY2tzIHRoZSBzdGF0ZS5cbiAgICAvLyBUaGlzIHdheSwgaWYgZmlsZSBjaGFuZ2UgZXZlbnRzIGFycml2ZSB3aGVuIGEgJ2NkayBkZXBsb3knIGlzIHN0aWxsIGV4ZWN1dGluZyxcbiAgICAvLyB3ZSB3aWxsIGJhdGNoIHRoZW0sIGFuZCB0cmlnZ2VyIGFub3RoZXIgJ2NkayBkZXBsb3knIGFmdGVyIHRoZSBjdXJyZW50IG9uZSBmaW5pc2hlcyxcbiAgICAvLyBtYWtpbmcgc3VyZSAnY2RrIGRlcGxveSdzICBhbHdheXMgZXhlY3V0ZSBvbmUgYXQgYSB0aW1lLlxuICAgIC8vIEhlcmUncyBhIGRpYWdyYW0gc2hvd2luZyB0aGUgc3RhdGUgdHJhbnNpdGlvbnM6XG5cbiAgICAvLyAtLS0tLS0tLSAgICBmaWxlIGNoYW5nZWQgICAgIC0tLS0tLS0tLS0tLS0tICAgIGZpbGUgY2hhbmdlZCAgICAgLS0tLS0tLS0tLS0tLS0gIGZpbGUgY2hhbmdlZFxuICAgIC8vIHwgICAgICB8IC0tLS0tLS0tLS0tLS0tLS0tLT4gfCAgICAgICAgICAgIHwgLS0tLS0tLS0tLS0tLS0tLS0tPiB8ICAgICAgICAgICAgfCAtLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8IG9wZW4gfCAgICAgICAgICAgICAgICAgICAgIHwgZGVwbG95aW5nICB8ICAgICAgICAgICAgICAgICAgICAgfCAgIHF1ZXVlZCAgIHwgICAgICAgICAgICAgICB8XG4gICAgLy8gfCAgICAgIHwgPC0tLS0tLS0tLS0tLS0tLS0tLSB8ICAgICAgICAgICAgfCA8LS0tLS0tLS0tLS0tLS0tLS0tIHwgICAgICAgICAgICB8IDwtLS0tLS0tLS0tLS0tfFxuICAgIC8vIC0tLS0tLS0tICAnY2RrIGRlcGxveScgZG9uZSAgLS0tLS0tLS0tLS0tLS0gICdjZGsgZGVwbG95JyBkb25lICAtLS0tLS0tLS0tLS0tLVxuXG4gICAgbGV0IGxhdGNoOiAnb3BlbicgfCAnZGVwbG95aW5nJyB8ICdxdWV1ZWQnID0gJ29wZW4nO1xuXG4gICAgY29uc3QgZGVwbG95QW5kV2F0Y2ggPSBkZWJvdW5jZShhc3luYyAoKSA9PiB7XG4gICAgICBsYXRjaCA9ICdkZXBsb3lpbmcnO1xuXG4gICAgICAvLyBTdG9wIHN0cmVhbWluZyB0aGUgbG9ncyBzbyB0aGF0IGRlcGxveW1lbnQgbG9ncyBkb24ndCBnZXQgbWl4ZWQgdXBcbiAgICAgIHRoaXMuZnVuY3Rpb25zTG9nU3RyZWFtZXIuc3RvcFN0cmVhbWluZ0xvZ3MoKTtcblxuICAgICAgYXdhaXQgdGhpcy5kZXBsb3kob3B0aW9ucyk7XG5cbiAgICAgIC8vIElmIGxhdGNoIGlzIHN0aWxsICdkZXBsb3lpbmcnIGFmdGVyIHRoZSAnYXdhaXQnLCB0aGF0J3MgZmluZSxcbiAgICAgIC8vIGJ1dCBpZiBpdCdzICdxdWV1ZWQnLCB0aGF0IG1lYW5zIHdlIG5lZWQgdG8gZGVwbG95IGFnYWluXG4gICAgICB3aGlsZSAoKGxhdGNoIGFzICdkZXBsb3lpbmcnIHwgJ3F1ZXVlZCcpID09PSAncXVldWVkJykge1xuICAgICAgICAvLyBUeXBlU2NyaXB0IGRvZXNuJ3QgcmVhbGl6ZSBsYXRjaCBjYW4gY2hhbmdlIGJldHdlZW4gJ2F3YWl0cycgwq9cXF8o44OEKV8vwq8sXG4gICAgICAgIC8vIGFuZCB0aGlua3MgdGhlIGFib3ZlICd3aGlsZScgY29uZGl0aW9uIGlzIGFsd2F5cyAnZmFsc2UnIHdpdGhvdXQgdGhlIGNhc3RcbiAgICAgICAgbGF0Y2ggPSAnZGVwbG95aW5nJztcbiAgICAgICAgdGhpcy5wcmludGVyLmNsZWFyQ29uc29sZSgpO1xuICAgICAgICBhd2FpdCB0aGlzLnByaW50U2FuZGJveE5hbWVJbmZvKG9wdGlvbnMuaWRlbnRpZmllcik7XG4gICAgICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICAgICAgXCJbU2FuZGJveF0gRGV0ZWN0ZWQgZmlsZSBjaGFuZ2VzIHdoaWxlIHByZXZpb3VzIGRlcGxveW1lbnQgd2FzIGluIHByb2dyZXNzLiBJbnZva2luZyAnc2FuZGJveCcgYWdhaW5cIixcbiAgICAgICAgKTtcbiAgICAgICAgYXdhaXQgdGhpcy5kZXBsb3kob3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBsYXRjaCA9ICdvcGVuJztcblxuICAgICAgLy8gSWRsZSBzdGF0ZSwgbGV0IGN1c3RvbWVycyBrbm93IGFuZCBzdGFydCBzdHJlYW1pbmcgZnVuY3Rpb24gbG9nc1xuICAgICAgdGhpcy5lbWl0V2F0Y2hpbmcoKTtcbiAgICAgIGF3YWl0IHRoaXMuZnVuY3Rpb25zTG9nU3RyZWFtZXIuc3RhcnRTdHJlYW1pbmdMb2dzKFxuICAgICAgICBhd2FpdCB0aGlzLmJhY2tlbmRJZFNhbmRib3hSZXNvbHZlcihvcHRpb25zLmlkZW50aWZpZXIpLFxuICAgICAgICBvcHRpb25zLmZ1bmN0aW9uU3RyZWFtaW5nT3B0aW9ucyxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpZiAod2F0Y2hGb3JDaGFuZ2VzKSB7XG4gICAgICB0aGlzLndhdGNoZXJTdWJzY3JpcHRpb24gPSBhd2FpdCB0aGlzLnN1YnNjcmliZShcbiAgICAgICAgd2F0Y2hEaXIsXG4gICAgICAgIGFzeW5jIChfLCBldmVudHMpID0+IHtcbiAgICAgICAgICAvLyBMb2cgYW5kIHRyYWNrIGZpbGUgY2hhbmdlcy5cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIGV2ZW50cy5tYXAoYXN5bmMgKHsgdHlwZTogZXZlbnROYW1lLCBwYXRoOiBmaWxlUGF0aCB9KSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuZmlsZXNDaGFuZ2VzVHJhY2tlci50cmFja0ZpbGVDaGFuZ2UoZmlsZVBhdGgpO1xuICAgICAgICAgICAgICBpZiAobGF0Y2ggPT09ICdvcGVuJykge1xuICAgICAgICAgICAgICAgIHRoaXMucHJpbnRlci5jbGVhckNvbnNvbGUoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnByaW50U2FuZGJveE5hbWVJbmZvKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgICAgICAgICAgICBgW1NhbmRib3hdIFRyaWdnZXJlZCBkdWUgdG8gYSBmaWxlICR7ZXZlbnROYW1lfSBldmVudDogJHtwYXRoLnJlbGF0aXZlKFxuICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5jd2QoKSxcbiAgICAgICAgICAgICAgICAgIGZpbGVQYXRoLFxuICAgICAgICAgICAgICAgICl9YCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGxhdGNoID09PSAnb3BlbicpIHtcbiAgICAgICAgICAgIGF3YWl0IGRlcGxveUFuZFdhdGNoKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgbGF0Y2ggaXMgZWl0aGVyICdkZXBsb3lpbmcnIG9yICdxdWV1ZWQnXG4gICAgICAgICAgICBsYXRjaCA9ICdxdWV1ZWQnO1xuICAgICAgICAgICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgICAgICAgICAgJ1tTYW5kYm94XSBQcmV2aW91cyBkZXBsb3ltZW50IGlzIHN0aWxsIGluIHByb2dyZXNzLiAnICtcbiAgICAgICAgICAgICAgICAnV2lsbCBxdWV1ZSBmb3IgYW5vdGhlciBkZXBsb3ltZW50IGFmdGVyIHRoaXMgb25lIGZpbmlzaGVzJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWdub3JlOiB0aGlzLm91dHB1dEZpbGVzRXhjbHVkZWRGcm9tV2F0Y2guY29uY2F0KFxuICAgICAgICAgICAgLi4uKG9wdGlvbnMuZXhjbHVkZSA/PyBbXSksXG4gICAgICAgICAgKSxcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgICAvLyBTdGFydCB0aGUgZmlyc3QgZnVsbCBkZXBsb3ltZW50IHdpdGhvdXQgd2FpdGluZyBmb3IgYSBmaWxlIGNoYW5nZVxuICAgICAgYXdhaXQgZGVwbG95QW5kV2F0Y2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgdGhpcy5kZXBsb3kob3B0aW9ucyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvY1xuICAgKi9cbiAgc3RvcCA9IGFzeW5jICgpID0+IHtcbiAgICB0aGlzLnByaW50ZXIubG9nKGBbU2FuZGJveF0gU2h1dHRpbmcgZG93bmAsIExvZ0xldmVsLkRFQlVHKTtcbiAgICB0aGlzLmZ1bmN0aW9uc0xvZ1N0cmVhbWVyPy5zdG9wU3RyZWFtaW5nTG9ncygpO1xuICAgIC8vIGNhbiBiZSB1bmRlZmluZWQgaWYgY29tbWFuZCBleGl0cyBiZWZvcmUgc3Vic2NyaXB0aW9uXG4gICAgYXdhaXQgdGhpcy53YXRjaGVyU3Vic2NyaXB0aW9uPy51bnN1YnNjcmliZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvY1xuICAgKi9cbiAgZGVsZXRlID0gYXN5bmMgKG9wdGlvbnM6IFNhbmRib3hEZWxldGVPcHRpb25zKSA9PiB7XG4gICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgICdbU2FuZGJveF0gRGVsZXRpbmcgYWxsIHRoZSByZXNvdXJjZXMgaW4gdGhlIHNhbmRib3ggZW52aXJvbm1lbnQuLi4nLFxuICAgICk7XG4gICAgYXdhaXQgdGhpcy5leGVjdXRvci5kZXN0cm95KFxuICAgICAgYXdhaXQgdGhpcy5iYWNrZW5kSWRTYW5kYm94UmVzb2x2ZXIob3B0aW9ucy5pZGVudGlmaWVyKSxcbiAgICApO1xuICAgIHRoaXMuZW1pdCgnc3VjY2Vzc2Z1bERlbGV0aW9uJyk7XG4gICAgdGhpcy5wcmludGVyLmxvZygnW1NhbmRib3hdIEZpbmlzaGVkIGRlbGV0aW5nLicpO1xuICB9O1xuXG4gIHByaXZhdGUgc2hvdWxkVmFsaWRhdGVBcHBTb3VyY2VzID0gKCk6IGJvb2xlYW4gPT4ge1xuICAgIGNvbnN0IHNuYXBzaG90ID0gdGhpcy5maWxlc0NoYW5nZXNUcmFja2VyLmdldEFuZFJlc2V0U25hcHNob3QoKTtcbiAgICAvLyBpZiB6ZXJvIGZpbGVzIGNoYW5nZWQgdGhpcyBpbmRpY2F0ZXMgaW5pdGlhbCBkZXBsb3ltZW50XG4gICAgY29uc3Qgc2hvdWxkVmFsaWRhdGVPbkNvbGRTdGFydCA9XG4gICAgICBzbmFwc2hvdC5oYWRUeXBlU2NyaXB0RmlsZXNBdFN0YXJ0ICYmXG4gICAgICAhc25hcHNob3QuZGlkQW55RmlsZUNoYW5nZVNpbmNlU3RhcnQ7XG4gICAgcmV0dXJuIChcbiAgICAgIHNob3VsZFZhbGlkYXRlT25Db2xkU3RhcnQgfHxcbiAgICAgIHNuYXBzaG90LmRpZEFueVR5cGVTY3JpcHRGaWxlQ2hhbmdlU2luY2VMYXN0U25hcHNob3RcbiAgICApO1xuICB9O1xuXG4gIHByaXZhdGUgZGVwbG95ID0gYXN5bmMgKG9wdGlvbnM6IFNhbmRib3hPcHRpb25zKSA9PiB7XG4gICAgY29uc3QgdHJhY2VyID0gb3BlblRlbGVtZXRyeVRyYWNlLmdldFRyYWNlcignYW1wbGlmeS1iYWNrZW5kJyk7XG4gICAgYXdhaXQgdHJhY2VyLnN0YXJ0QWN0aXZlU3Bhbignc2FuZGJveCcsIGFzeW5jIChzcGFuOiBTcGFuKSA9PiB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGVwbG95UmVzdWx0ID0gYXdhaXQgdGhpcy5leGVjdXRvci5kZXBsb3koXG4gICAgICAgICAgYXdhaXQgdGhpcy5iYWNrZW5kSWRTYW5kYm94UmVzb2x2ZXIob3B0aW9ucy5pZGVudGlmaWVyKSxcbiAgICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0byBwYXNzIHRoaXMgYXMgY2FsbGJhY2sgc28gdGhhdCBkZWJvdW5jZSBkb2VzXG4gICAgICAgICAgLy8gbm90IHJlc2V0IHRyYWNrZXIgcHJlbWF0dXJlbHlcbiAgICAgICAgICB0aGlzLnNob3VsZFZhbGlkYXRlQXBwU291cmNlcyxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgZGF0YTogRGVlcFBhcnRpYWw8VGVsZW1ldHJ5UGF5bG9hZD4gPSB7XG4gICAgICAgICAgbGF0ZW5jeToge1xuICAgICAgICAgICAgdG90YWw6IGRlcGxveVJlc3VsdC5kZXBsb3ltZW50VGltZXMudG90YWxUaW1lXG4gICAgICAgICAgICAgID8gZGVwbG95UmVzdWx0LmRlcGxveW1lbnRUaW1lcy50b3RhbFRpbWUgKiAxMDAwXG4gICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIHN5bnRoZXNpczogZGVwbG95UmVzdWx0LmRlcGxveW1lbnRUaW1lcy5zeW50aGVzaXNUaW1lXG4gICAgICAgICAgICAgID8gZGVwbG95UmVzdWx0LmRlcGxveW1lbnRUaW1lcy5zeW50aGVzaXNUaW1lICogMTAwMFxuICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgc3RhdGU6ICdTVUNDRUVERUQnLFxuICAgICAgICAgICAgY29tbWFuZDoge1xuICAgICAgICAgICAgICBwYXRoOiBbJ1NhbmRib3hEZXBsb3ltZW50J10sXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBzZXRTcGFuQXR0cmlidXRlcyhzcGFuLCBkYXRhKTtcbiAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgICAgdGhpcy5wcmludGVyLmxvZygnW1NhbmRib3hdIERlcGxveW1lbnQgc3VjY2Vzc2Z1bCcsIExvZ0xldmVsLkRFQlVHKTtcbiAgICAgICAgdGhpcy5lbWl0KCdzdWNjZXNzZnVsRGVwbG95bWVudCcsIGRlcGxveVJlc3VsdCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBhbXBsaWZ5RXJyb3IgPSBBbXBsaWZ5RXJyb3IuaXNBbXBsaWZ5RXJyb3IoZXJyb3IpXG4gICAgICAgICAgPyBlcnJvclxuICAgICAgICAgIDogQW1wbGlmeUVycm9yLmZyb21FcnJvcihlcnJvcik7XG4gICAgICAgIGNvbnN0IGRhdGE6IERlZXBQYXJ0aWFsPFRlbGVtZXRyeVBheWxvYWQ+ID0ge1xuICAgICAgICAgIGxhdGVuY3k6IHtcbiAgICAgICAgICAgIHRvdGFsOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICAgIHN0YXRlOiAnRkFJTEVEJyxcbiAgICAgICAgICAgIGNvbW1hbmQ6IHtcbiAgICAgICAgICAgICAgcGF0aDogWydTYW5kYm94RGVwbG95bWVudCddLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvcjogdHJhbnNsYXRlRXJyb3JUb1RlbGVtZXRyeUVycm9yRGV0YWlscyhhbXBsaWZ5RXJyb3IpLFxuICAgICAgICB9O1xuICAgICAgICBzZXRTcGFuQXR0cmlidXRlcyhzcGFuLCBkYXRhKTtcbiAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgICAgLy8gUHJpbnQgYSBtZWFuaW5nZnVsIG1lc3NhZ2VcbiAgICAgICAgdGhpcy5wcmludGVyLmxvZyhmb3JtYXQuZXJyb3IoYW1wbGlmeUVycm9yKSwgTG9nTGV2ZWwuRVJST1IpO1xuXG4gICAgICAgIC8vIFByaW50IHN0YWNrIHRyYWNlc1xuICAgICAgICBsZXQgZXJyb3JUb0Rpc3BsYXlTdGFja1RyYWNlOiBFcnJvciB8IHVuZGVmaW5lZCA9IGFtcGxpZnlFcnJvcjtcbiAgICAgICAgd2hpbGUgKGVycm9yVG9EaXNwbGF5U3RhY2tUcmFjZSkge1xuICAgICAgICAgIGlmIChlcnJvclRvRGlzcGxheVN0YWNrVHJhY2Uuc3RhY2spIHtcbiAgICAgICAgICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICAgICAgICAgIGBTdGFjayBUcmFjZSBmb3IgJHtlcnJvclRvRGlzcGxheVN0YWNrVHJhY2UubmFtZX1gLFxuICAgICAgICAgICAgICBMb2dMZXZlbC5ERUJVRyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLnByaW50ZXIubG9nKFxuICAgICAgICAgICAgICBmb3JtYXQuZGltKGVycm9yVG9EaXNwbGF5U3RhY2tUcmFjZS5zdGFjayksXG4gICAgICAgICAgICAgIExvZ0xldmVsLkRFQlVHLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3JUb0Rpc3BsYXlTdGFja1RyYWNlID1cbiAgICAgICAgICAgIGVycm9yVG9EaXNwbGF5U3RhY2tUcmFjZS5jYXVzZSBpbnN0YW5jZW9mIEVycm9yXG4gICAgICAgICAgICAgID8gZXJyb3JUb0Rpc3BsYXlTdGFja1RyYWNlLmNhdXNlXG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdmYWlsZWREZXBsb3ltZW50JywgZXJyb3IpO1xuXG4gICAgICAgIC8vIElmIHRoZSBlcnJvciBpcyBiZWNhdXNlIG9mIGEgbm9uLWFsbG93ZWQgZGVzdHJ1Y3RpdmUgY2hhbmdlIHN1Y2ggYXNcbiAgICAgICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0Nsb3VkRm9ybWF0aW9uL2xhdGVzdC9Vc2VyR3VpZGUvYXdzLXJlc291cmNlLWNvZ25pdG8tdXNlcnBvb2wuaHRtbCNjZm4tY29nbml0by11c2VycG9vbC1hbGlhc2F0dHJpYnV0ZXNcbiAgICAgICAgLy8gb2ZmZXIgdG8gcmVjcmVhdGUgdGhlIHNhbmRib3ggb3IgcmV2ZXJ0IHRoZSBjaGFuZ2VcbiAgICAgICAgaWYgKFxuICAgICAgICAgIEFtcGxpZnlFcnJvci5pc0FtcGxpZnlFcnJvcihlcnJvcikgJiZcbiAgICAgICAgICBlcnJvci5uYW1lID09PSAnQ0ZOVXBkYXRlTm90U3VwcG9ydGVkRXJyb3InXG4gICAgICAgICkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlVW5zdXBwb3J0ZWREZXN0cnVjdGl2ZUNoYW5nZXMob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxzZSBkbyBub3QgcHJvcGFnYXRlIGFuZCBsZXQgdGhlIHNhbmRib3ggY29udGludWUgdG8gcnVuXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcHJpdmF0ZSByZXNldCA9IGFzeW5jIChvcHRpb25zOiBTYW5kYm94T3B0aW9ucykgPT4ge1xuICAgIGF3YWl0IHRoaXMuZGVsZXRlKHsgaWRlbnRpZmllcjogb3B0aW9ucy5pZGVudGlmaWVyIH0pO1xuICAgIGF3YWl0IHRoaXMuc3RhcnQob3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEp1c3QgYSBzaG9ydGhhbmQgY29uc29sZSBsb2cgdG8gaW5kaWNhdGUgd2hlbmV2ZXIgd2F0Y2hlciBpcyBnb2luZyBpZGxlXG4gICAqL1xuICBwcml2YXRlIGVtaXRXYXRjaGluZyA9ICgpID0+IHtcbiAgICB0aGlzLnByaW50ZXIubG9nKGBbU2FuZGJveF0gV2F0Y2hpbmcgZm9yIGZpbGUgY2hhbmdlcy4uLmApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWFkcyBhbmQgcGFyc2VzIC5naXRpZ25vcmUgZmlsZSBhbmQgcmV0dXJucyB0aGUgbGlzdCBvZiBwYXRoc1xuICAgKi9cbiAgcHJpdmF0ZSBnZXRHaXRJZ25vcmVkUGF0aHMgPSAoKSA9PiB7XG4gICAgY29uc3QgZ2l0SWdub3JlRmlsZVBhdGggPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJy5naXRpZ25vcmUnKTtcbiAgICBpZiAoZnMuZXhpc3RzU3luYyhnaXRJZ25vcmVGaWxlUGF0aCkpIHtcbiAgICAgIHJldHVybiBwYXJzZUdpdElnbm9yZVxuICAgICAgICAucGFyc2UoZ2l0SWdub3JlRmlsZVBhdGgpXG4gICAgICAgIC5wYXR0ZXJucy5tYXAoKHBhdHRlcm46IHN0cmluZykgPT5cbiAgICAgICAgICBwYXR0ZXJuLnN0YXJ0c1dpdGgoJy8nKSA/IHBhdHRlcm4uc3Vic3RyaW5nKDEpIDogcGF0dGVybixcbiAgICAgICAgKVxuICAgICAgICAuZmlsdGVyKChwYXR0ZXJuOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBpZiAocGF0dGVybi5zdGFydHNXaXRoKCchJykpIHtcbiAgICAgICAgICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICAgICAgICAgIGBbU2FuZGJveF0gUGF0dGVybiAke3BhdHRlcm59IGZvdW5kIGluIC5naXRpZ25vcmUuIFwiJHtwYXR0ZXJuLnN1YnN0cmluZyhcbiAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICApfVwiIHdpbGwgbm90IGJlIHdhdGNoZWQgaWYgb3RoZXIgcGF0dGVybnMgaW4gLmdpdGlnbm9yZSBhcmUgZXhjbHVkaW5nIGl0LmAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gcmVnaW9uIGhhcyBiZWVuIGJvb3RzdHJhcHBlZCB3aXRoID49IG1pbiB2ZXJzaW9uIHVzaW5nIENESyBib290c3RyYXAgdmVyc2lvbiBwYXJhbWV0ZXJcbiAgICogc3RvcmVkIGluIHBhcmFtZXRlciBzdG9yZS5cbiAgICogQHJldHVybnMgQSBCb29sZWFuIHRoYXQgcmVwcmVzZW50cyBpZiByZWdpb24gaGFzIGJlZW4gYm9vdHN0cmFwcGVkLlxuICAgKi9cbiAgcHJpdmF0ZSBpc0Jvb3RzdHJhcHBlZCA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBQYXJhbWV0ZXI6IHBhcmFtZXRlciB9ID0gYXdhaXQgdGhpcy5zc21DbGllbnQuc2VuZChcbiAgICAgICAgbmV3IEdldFBhcmFtZXRlckNvbW1hbmQoe1xuICAgICAgICAgIE5hbWU6IENES19ERUZBVUxUX0JPT1RTVFJBUF9WRVJTSU9OX1BBUkFNRVRFUl9OQU1FLFxuICAgICAgICB9KSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGJvb3RzdHJhcFZlcnNpb24gPSBwYXJhbWV0ZXI/LlZhbHVlO1xuICAgICAgaWYgKFxuICAgICAgICAhYm9vdHN0cmFwVmVyc2lvbiB8fFxuICAgICAgICBOdW1iZXIoYm9vdHN0cmFwVmVyc2lvbikgPCBDREtfTUlOX0JPT1RTVFJBUF9WRVJTSU9OXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBQYXJhbWV0ZXJOb3RGb3VuZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIGUgaW5zdGFuY2VvZiBTU01TZXJ2aWNlRXhjZXB0aW9uICYmXG4gICAgICAgIFtcbiAgICAgICAgICAnVW5yZWNvZ25pemVkQ2xpZW50RXhjZXB0aW9uJyxcbiAgICAgICAgICAnQWNjZXNzRGVuaWVkRXhjZXB0aW9uJyxcbiAgICAgICAgICAnTm90QXV0aG9yaXplZCcsXG4gICAgICAgICAgJ0V4cGlyZWRUb2tlbkV4Y2VwdGlvbicsXG4gICAgICAgICAgJ0V4cGlyZWRUb2tlbicsXG4gICAgICAgICAgJ0ludmFsaWRTaWduYXR1cmVFeGNlcHRpb24nLFxuICAgICAgICBdLmluY2x1ZGVzKGUubmFtZSlcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgQW1wbGlmeVVzZXJFcnJvcihcbiAgICAgICAgICAnU1NNQ3JlZGVudGlhbHNFcnJvcicsXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWVzc2FnZTogYCR7ZS5uYW1lfTogJHtlLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgIHJlc29sdXRpb246XG4gICAgICAgICAgICAgICdNYWtlIHN1cmUgeW91ciBBV1MgY3JlZGVudGlhbHMgYXJlIHNldCB1cCBjb3JyZWN0bHkgYW5kIGhhdmUgcGVybWlzc2lvbnMgdG8gY2FsbCBTU006R2V0UGFyYW1ldGVyJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGUsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIGFyZSB1bmFibGUgdG8gcmV0cmlldmUgYm9vdHN0cmFwIHZlcnNpb24gcGFyYW1ldGVyIGR1ZSB0byBvdGhlciByZWFzb25zLCB3ZSBmYWlsIGZhc3QuXG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZVVuc3VwcG9ydGVkRGVzdHJ1Y3RpdmVDaGFuZ2VzID0gYXN5bmMgKFxuICAgIG9wdGlvbnM6IFNhbmRib3hPcHRpb25zLFxuICApID0+IHtcbiAgICB0aGlzLnByaW50ZXIucHJpbnQoXG4gICAgICBmb3JtYXQuZXJyb3IoXG4gICAgICAgICdbU2FuZGJveF0gV2UgY2Fubm90IGRlcGxveSB5b3VyIG5ldyBjaGFuZ2VzLiBZb3UgY2FuIGVpdGhlciByZXZlcnQgdGhlbSBvciByZWNyZWF0ZSB5b3VyIHNhbmRib3ggd2l0aCB0aGUgbmV3IGNoYW5nZXMgKGRlbGV0aW5nIGFsbCB1c2VyIGRhdGEpJyxcbiAgICAgICksXG4gICAgKTtcbiAgICAvLyBvZmZlciB0byByZWNyZWF0ZSB0aGUgc2FuZGJveCB3aXRoIG5ldyBwcm9wZXJ0aWVzXG4gICAgY29uc3QgYW5zd2VyID0gYXdhaXQgQW1wbGlmeVByb21wdGVyLnllc09yTm8oe1xuICAgICAgbWVzc2FnZTpcbiAgICAgICAgJ1dvdWxkIHlvdSBsaWtlIHRvIHJlY3JlYXRlIHlvdXIgc2FuZGJveCAoZGVsZXRpbmcgYWxsIHVzZXIgZGF0YSk/JyxcbiAgICAgIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gICAgfSk7XG4gICAgaWYgKGFuc3dlcikge1xuICAgICAgYXdhaXQgdGhpcy5zdG9wKCk7XG4gICAgICBhd2FpdCB0aGlzLnJlc2V0KG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBlbHNlIGxldCB0aGUgc2FuZGJveCBjb250aW51ZSBzbyBjdXN0b21lcnMgY2FuIHJldmVydCB0aGVpciBjaGFuZ2VzXG4gIH07XG5cbiAgcHJpdmF0ZSBwcmludFNhbmRib3hOYW1lSW5mbyA9IGFzeW5jIChzYW5kYm94SWRlbnRpZmllcj86IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHNhbmRib3hCYWNrZW5kSWQgPVxuICAgICAgYXdhaXQgdGhpcy5iYWNrZW5kSWRTYW5kYm94UmVzb2x2ZXIoc2FuZGJveElkZW50aWZpZXIpO1xuICAgIGNvbnN0IHN0YWNrTmFtZSA9XG4gICAgICBCYWNrZW5kSWRlbnRpZmllckNvbnZlcnNpb25zLnRvU3RhY2tOYW1lKHNhbmRib3hCYWNrZW5kSWQpO1xuICAgIGNvbnN0IHJlZ2lvbiA9IGF3YWl0IHRoaXMuc3NtQ2xpZW50LmNvbmZpZy5yZWdpb24oKTtcbiAgICB0aGlzLnByaW50ZXIucHJpbnQoXG4gICAgICBmb3JtYXQuaW5kZW50KGZvcm1hdC5oaWdobGlnaHQoZm9ybWF0LmJvbGQoJ1xcbkFtcGxpZnkgU2FuZGJveFxcbicpKSksXG4gICAgKTtcbiAgICB0aGlzLnByaW50ZXIucHJpbnQoXG4gICAgICBmb3JtYXQuaW5kZW50KGAke2Zvcm1hdC5ib2xkKCdJZGVudGlmaWVyOicpfSBcXHQke3NhbmRib3hCYWNrZW5kSWQubmFtZX1gKSxcbiAgICApO1xuICAgIHRoaXMucHJpbnRlci5wcmludChcbiAgICAgIGZvcm1hdC5pbmRlbnQoYCR7Zm9ybWF0LmJvbGQoJ1N0YWNrOicpfSBcXHQke3N0YWNrTmFtZX1gKSxcbiAgICApO1xuICAgIHRoaXMucHJpbnRlci5wcmludChmb3JtYXQuaW5kZW50KGAke2Zvcm1hdC5ib2xkKCdSZWdpb246Jyl9IFxcdCR7cmVnaW9ufWApKTtcbiAgICBpZiAoIXNhbmRib3hJZGVudGlmaWVyKSB7XG4gICAgICB0aGlzLnByaW50ZXIucHJpbnQoXG4gICAgICAgIGAke2Zvcm1hdC5pbmRlbnQoXG4gICAgICAgICAgZm9ybWF0LmRpbSgnXFxuVG8gc3BlY2lmeSBhIGRpZmZlcmVudCBzYW5kYm94IGlkZW50aWZpZXIsIHVzZSAnKSxcbiAgICAgICAgKX0ke2Zvcm1hdC5ib2xkKCctLWlkZW50aWZpZXInKX1gLFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5wcmludGVyLnByaW50TmV3TGluZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYWNrIHRvIHN1cHByZXNzIGNlcnRhaW4gc3RkZXJyIG1lc3NhZ2VzIHVudGlsIGF3cy1jZGsgY29uc3RydWN0c1xuICAgKiBjYW4gdXNlIHRoZSB0b29sa2l0J3MgSW9Ib3N0IHRvIGRlbGl2ZXIgbWVzc2FnZXMuXG4gICAqIFNlZSB0cmFja2luZyBpdGVtcyBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1jZGstY2xpL2lzc3Vlcy8xNThcbiAgICpcbiAgICogUmVzdCBvZiB0aGUgc3RkZXJyIG1lc3NhZ2VzIGFyZSByZXJvdXRlZCB0byBvdXIgcHJpbnRlciBzbyB0aGF0IHRoZXlcbiAgICogZG9uJ3QgZ2V0IGludGVybWluZ2xlZCB3aXRoIHNwaW5uZXJzLlxuICAgKi9cbiAgcHJpdmF0ZSBpbnRlcmNlcHRTdGRlcnIgPSAoKSA9PiB7XG4gICAgcHJvY2Vzcy5zdGRlcnIud3JpdGUgPSAoY2h1bmspID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAhWydCdW5kbGluZyBhc3NldCddLnNvbWUoKHByb2hpYml0ZWRTdHJpbmdzKSA9PlxuICAgICAgICAgIGNodW5rLmluY2x1ZGVzKHByb2hpYml0ZWRTdHJpbmdzKSxcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICAgICAgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyA/IGNodW5rIDogY2h1bmsudG9Mb2NhbGVTdHJpbmcoKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH07XG59XG4iXX0=