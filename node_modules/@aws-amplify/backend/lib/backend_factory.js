import { NestedStackResolver, } from './engine/nested_stack_resolver.js';
import { SingletonConstructContainer } from './engine/singleton_construct_container.js';
import { ToggleableImportPathVerifier } from './engine/validations/toggleable_import_path_verifier.js';
import { AttributionMetadataStorage, StackMetadataBackendOutputStorageStrategy, } from '@aws-amplify/backend-output-storage';
import { createDefaultStack } from './default_stack_factory.js';
import { getBackendIdentifier } from './backend_identifier.js';
import { platformOutputKey } from '@aws-amplify/backend-output-schemas';
import { fileURLToPath } from 'node:url';
import { AmplifyBranchLinkerConstruct } from './engine/branch-linker/branch_linker_construct.js';
import { ClientConfigVersionOption, } from '@aws-amplify/client-config';
import { CustomOutputsAccumulator } from './engine/custom_outputs_accumulator.js';
import { ObjectAccumulator } from '@aws-amplify/platform-core';
import { DefaultResourceNameValidator } from './engine/validations/default_resource_name_validator.js';
// Be very careful editing this value. It is the value used in the BI metrics to attribute stacks as Amplify root stacks
const rootStackTypeIdentifier = 'root';
// Client config version that is used by `backend.addOutput()`
const DEFAULT_CLIENT_CONFIG_VERSION_FOR_BACKEND_ADD_OUTPUT = ClientConfigVersionOption.V1_4;
/**
 * Factory that collects and instantiates all the Amplify backend constructs
 */
export class BackendFactory {
    /**
     * These are the resolved CDK constructs that are created by the inputs to the constructor
     * Used for overriding properties of underlying CDK constructs or to reference in custom CDK code
     */
    resources;
    stack;
    stackResolver;
    customOutputsAccumulator;
    /**
     * Initialize an Amplify backend with the given construct factories and in the given CDK App.
     * If no CDK App is specified a new one is created
     */
    constructor(constructFactories, stack = createDefaultStack()) {
        this.stack = stack;
        new AttributionMetadataStorage().storeAttributionMetadata(stack, rootStackTypeIdentifier, fileURLToPath(new URL('../package.json', import.meta.url)));
        this.stackResolver = new NestedStackResolver(stack, new AttributionMetadataStorage());
        const constructContainer = new SingletonConstructContainer(this.stackResolver);
        const outputStorageStrategy = new StackMetadataBackendOutputStorageStrategy(stack);
        this.customOutputsAccumulator = new CustomOutputsAccumulator(outputStorageStrategy, new ObjectAccumulator({}));
        const backendId = getBackendIdentifier(stack);
        outputStorageStrategy.addBackendOutputEntry(platformOutputKey, {
            version: '1',
            payload: {
                deploymentType: backendId.type,
                region: stack.region,
            },
        });
        const shouldEnableBranchLinker = backendId.type === 'branch';
        if (shouldEnableBranchLinker) {
            new AmplifyBranchLinkerConstruct(stack, backendId);
        }
        const importPathVerifier = new ToggleableImportPathVerifier();
        const resourceNameValidator = new DefaultResourceNameValidator();
        // register providers but don't actually execute anything yet
        Object.values(constructFactories).forEach((factory) => {
            if (typeof factory.provides === 'string') {
                constructContainer.registerConstructFactory(factory.provides, factory);
            }
        });
        // now invoke all the factories and collect the constructs into this.resources
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.resources = {};
        Object.entries(constructFactories).forEach(([resourceName, constructFactory]) => {
            // The type inference on this.resources is not happy about this assignment because it doesn't know the exact type of .getInstance()
            // However, the assignment is okay because we are iterating over the entries of constructFactories and assigning the resource name to the corresponding instance
            this.resources[resourceName] = constructFactory.getInstance({
                constructContainer,
                outputStorageStrategy,
                importPathVerifier,
                resourceNameValidator,
            });
        });
    }
    /**
     * Returns a CDK stack within the Amplify project that can be used for creating custom resources.
     * If a stack has already been created with "name" then an error is thrown.
     */
    createStack = (name) => {
        return this.stackResolver.createCustomStack(name);
    };
    addOutput = (clientConfigPart) => {
        const { version } = clientConfigPart;
        if (!version) {
            clientConfigPart.version =
                DEFAULT_CLIENT_CONFIG_VERSION_FOR_BACKEND_ADD_OUTPUT;
        }
        this.customOutputsAccumulator.addOutput(clientConfigPart);
    };
}
/**
 * Creates a new Amplify backend instance and returns it
 * @param constructFactories - list of backend factories such as those created by `defineAuth` or `defineData`
 */
export const defineBackend = (constructFactories) => {
    const backend = new BackendFactory(constructFactories);
    return {
        ...backend.resources,
        createStack: backend.createStack,
        addOutput: backend.addOutput,
        stack: backend.stack,
    };
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja2VuZF9mYWN0b3J5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2JhY2tlbmRfZmFjdG9yeS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFNQSxPQUFPLEVBQ0wsbUJBQW1CLEdBRXBCLE1BQU0sbUNBQW1DLENBQUM7QUFDM0MsT0FBTyxFQUFFLDJCQUEyQixFQUFFLE1BQU0sMkNBQTJDLENBQUM7QUFDeEYsT0FBTyxFQUFFLDRCQUE0QixFQUFFLE1BQU0seURBQXlELENBQUM7QUFDdkcsT0FBTyxFQUNMLDBCQUEwQixFQUMxQix5Q0FBeUMsR0FDMUMsTUFBTSxxQ0FBcUMsQ0FBQztBQUM3QyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUNoRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUMvRCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUN4RSxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBRXpDLE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxNQUFNLG1EQUFtRCxDQUFDO0FBQ2pHLE9BQU8sRUFFTCx5QkFBeUIsR0FDMUIsTUFBTSw0QkFBNEIsQ0FBQztBQUNwQyxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSx3Q0FBd0MsQ0FBQztBQUNsRixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUMvRCxPQUFPLEVBQUUsNEJBQTRCLEVBQUUsTUFBTSx5REFBeUQsQ0FBQztBQUV2Ryx3SEFBd0g7QUFDeEgsTUFBTSx1QkFBdUIsR0FBRyxNQUFNLENBQUM7QUFFdkMsOERBQThEO0FBQzlELE1BQU0sb0RBQW9ELEdBQ3hELHlCQUF5QixDQUFDLElBQUksQ0FBQztBQUVqQzs7R0FFRztBQUNILE1BQU0sT0FBTyxjQUFjO0lBR3pCOzs7T0FHRztJQUNNLFNBQVMsQ0FFaEI7SUFFTyxLQUFLLENBQUM7SUFD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QyxPQUFPLEVBQUUsQ0FBQztZQUNiLGdCQUFnQixDQUFDLE9BQU87Z0JBQ3RCLG9EQUFvRCxDQUFDO1FBQ3pELENBQUM7UUFDRCxJQUFJLENBQUMsd0JBQXdCLENBQUMsU0FBUyxDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFDNUQsQ0FBQyxDQUFDO0NBQ0g7QUFFRDs7O0dBR0c7QUFDSCxNQUFNLENBQUMsTUFBTSxhQUFhLEdBQUcsQ0FDM0Isa0JBQXFCLEVBQ1QsRUFBRTtJQUNkLE1BQU0sT0FBTyxHQUFHLElBQUksY0FBYyxDQUFDLGtCQUFrQixDQUFDLENBQUM7SUFDdkQsT0FBTztRQUNMLEdBQUcsT0FBTyxDQUFDLFNBQVM7UUFDcEIsV0FBVyxFQUFFLE9BQU8sQ0FBQyxXQUFXO1FBQ2hDLFNBQVMsRUFBRSxPQUFPLENBQUMsU0FBUztRQUM1QixLQUFLLEVBQUUsT0FBTyxDQUFDLEtBQUs7S0FDckIsQ0FBQztBQUNKLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbnN0cnVjdEZhY3RvcnksXG4gIERlZXBQYXJ0aWFsQW1wbGlmeUdlbmVyYXRlZENvbmZpZ3MsXG4gIFJlc291cmNlUHJvdmlkZXIsXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbHVnaW4tdHlwZXMnO1xuaW1wb3J0IHsgU3RhY2sgfSBmcm9tICdhd3MtY2RrLWxpYic7XG5pbXBvcnQge1xuICBOZXN0ZWRTdGFja1Jlc29sdmVyLFxuICBTdGFja1Jlc29sdmVyLFxufSBmcm9tICcuL2VuZ2luZS9uZXN0ZWRfc3RhY2tfcmVzb2x2ZXIuanMnO1xuaW1wb3J0IHsgU2luZ2xldG9uQ29uc3RydWN0Q29udGFpbmVyIH0gZnJvbSAnLi9lbmdpbmUvc2luZ2xldG9uX2NvbnN0cnVjdF9jb250YWluZXIuanMnO1xuaW1wb3J0IHsgVG9nZ2xlYWJsZUltcG9ydFBhdGhWZXJpZmllciB9IGZyb20gJy4vZW5naW5lL3ZhbGlkYXRpb25zL3RvZ2dsZWFibGVfaW1wb3J0X3BhdGhfdmVyaWZpZXIuanMnO1xuaW1wb3J0IHtcbiAgQXR0cmlidXRpb25NZXRhZGF0YVN0b3JhZ2UsXG4gIFN0YWNrTWV0YWRhdGFCYWNrZW5kT3V0cHV0U3RvcmFnZVN0cmF0ZWd5LFxufSBmcm9tICdAYXdzLWFtcGxpZnkvYmFja2VuZC1vdXRwdXQtc3RvcmFnZSc7XG5pbXBvcnQgeyBjcmVhdGVEZWZhdWx0U3RhY2sgfSBmcm9tICcuL2RlZmF1bHRfc3RhY2tfZmFjdG9yeS5qcyc7XG5pbXBvcnQgeyBnZXRCYWNrZW5kSWRlbnRpZmllciB9IGZyb20gJy4vYmFja2VuZF9pZGVudGlmaWVyLmpzJztcbmltcG9ydCB7IHBsYXRmb3JtT3V0cHV0S2V5IH0gZnJvbSAnQGF3cy1hbXBsaWZ5L2JhY2tlbmQtb3V0cHV0LXNjaGVtYXMnO1xuaW1wb3J0IHsgZmlsZVVSTFRvUGF0aCB9IGZyb20gJ25vZGU6dXJsJztcbmltcG9ydCB7IEJhY2tlbmQsIERlZmluZUJhY2tlbmRQcm9wcyB9IGZyb20gJy4vYmFja2VuZC5qcyc7XG5pbXBvcnQgeyBBbXBsaWZ5QnJhbmNoTGlua2VyQ29uc3RydWN0IH0gZnJvbSAnLi9lbmdpbmUvYnJhbmNoLWxpbmtlci9icmFuY2hfbGlua2VyX2NvbnN0cnVjdC5qcyc7XG5pbXBvcnQge1xuICBDbGllbnRDb25maWcsXG4gIENsaWVudENvbmZpZ1ZlcnNpb25PcHRpb24sXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9jbGllbnQtY29uZmlnJztcbmltcG9ydCB7IEN1c3RvbU91dHB1dHNBY2N1bXVsYXRvciB9IGZyb20gJy4vZW5naW5lL2N1c3RvbV9vdXRwdXRzX2FjY3VtdWxhdG9yLmpzJztcbmltcG9ydCB7IE9iamVjdEFjY3VtdWxhdG9yIH0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsYXRmb3JtLWNvcmUnO1xuaW1wb3J0IHsgRGVmYXVsdFJlc291cmNlTmFtZVZhbGlkYXRvciB9IGZyb20gJy4vZW5naW5lL3ZhbGlkYXRpb25zL2RlZmF1bHRfcmVzb3VyY2VfbmFtZV92YWxpZGF0b3IuanMnO1xuXG4vLyBCZSB2ZXJ5IGNhcmVmdWwgZWRpdGluZyB0aGlzIHZhbHVlLiBJdCBpcyB0aGUgdmFsdWUgdXNlZCBpbiB0aGUgQkkgbWV0cmljcyB0byBhdHRyaWJ1dGUgc3RhY2tzIGFzIEFtcGxpZnkgcm9vdCBzdGFja3NcbmNvbnN0IHJvb3RTdGFja1R5cGVJZGVudGlmaWVyID0gJ3Jvb3QnO1xuXG4vLyBDbGllbnQgY29uZmlnIHZlcnNpb24gdGhhdCBpcyB1c2VkIGJ5IGBiYWNrZW5kLmFkZE91dHB1dCgpYFxuY29uc3QgREVGQVVMVF9DTElFTlRfQ09ORklHX1ZFUlNJT05fRk9SX0JBQ0tFTkRfQUREX09VVFBVVCA9XG4gIENsaWVudENvbmZpZ1ZlcnNpb25PcHRpb24uVjFfNDtcblxuLyoqXG4gKiBGYWN0b3J5IHRoYXQgY29sbGVjdHMgYW5kIGluc3RhbnRpYXRlcyBhbGwgdGhlIEFtcGxpZnkgYmFja2VuZCBjb25zdHJ1Y3RzXG4gKi9cbmV4cG9ydCBjbGFzcyBCYWNrZW5kRmFjdG9yeTxcbiAgVCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIENvbnN0cnVjdEZhY3Rvcnk8UmVzb3VyY2VQcm92aWRlcj4+LFxuPiB7XG4gIC8qKlxuICAgKiBUaGVzZSBhcmUgdGhlIHJlc29sdmVkIENESyBjb25zdHJ1Y3RzIHRoYXQgYXJlIGNyZWF0ZWQgYnkgdGhlIGlucHV0cyB0byB0aGUgY29uc3RydWN0b3JcbiAgICogVXNlZCBmb3Igb3ZlcnJpZGluZyBwcm9wZXJ0aWVzIG9mIHVuZGVybHlpbmcgQ0RLIGNvbnN0cnVjdHMgb3IgdG8gcmVmZXJlbmNlIGluIGN1c3RvbSBDREsgY29kZVxuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2VzOiB7XG4gICAgW0sgaW4ga2V5b2YgVF06IFJldHVyblR5cGU8VFtLXVsnZ2V0SW5zdGFuY2UnXT47XG4gIH07XG5cbiAgcmVhZG9ubHkgc3RhY2s7XG4gIHByaXZhdGUgcmVhZG9ubHkgc3RhY2tSZXNvbHZlcjogU3RhY2tSZXNvbHZlcjtcbiAgcHJpdmF0ZSByZWFkb25seSBjdXN0b21PdXRwdXRzQWNjdW11bGF0b3I6IEN1c3RvbU91dHB1dHNBY2N1bXVsYXRvcjtcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYW4gQW1wbGlmeSBiYWNrZW5kIHdpdGggdGhlIGdpdmVuIGNvbnN0cnVjdCBmYWN0b3JpZXMgYW5kIGluIHRoZSBnaXZlbiBDREsgQXBwLlxuICAgKiBJZiBubyBDREsgQXBwIGlzIHNwZWNpZmllZCBhIG5ldyBvbmUgaXMgY3JlYXRlZFxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uc3RydWN0RmFjdG9yaWVzOiBULCBzdGFjazogU3RhY2sgPSBjcmVhdGVEZWZhdWx0U3RhY2soKSkge1xuICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICBuZXcgQXR0cmlidXRpb25NZXRhZGF0YVN0b3JhZ2UoKS5zdG9yZUF0dHJpYnV0aW9uTWV0YWRhdGEoXG4gICAgICBzdGFjayxcbiAgICAgIHJvb3RTdGFja1R5cGVJZGVudGlmaWVyLFxuICAgICAgZmlsZVVSTFRvUGF0aChuZXcgVVJMKCcuLi9wYWNrYWdlLmpzb24nLCBpbXBvcnQubWV0YS51cmwpKSxcbiAgICApO1xuICAgIHRoaXMuc3RhY2tSZXNvbHZlciA9IG5ldyBOZXN0ZWRTdGFja1Jlc29sdmVyKFxuICAgICAgc3RhY2ssXG4gICAgICBuZXcgQXR0cmlidXRpb25NZXRhZGF0YVN0b3JhZ2UoKSxcbiAgICApO1xuXG4gICAgY29uc3QgY29uc3RydWN0Q29udGFpbmVyID0gbmV3IFNpbmdsZXRvbkNvbnN0cnVjdENvbnRhaW5lcihcbiAgICAgIHRoaXMuc3RhY2tSZXNvbHZlcixcbiAgICApO1xuXG4gICAgY29uc3Qgb3V0cHV0U3RvcmFnZVN0cmF0ZWd5ID0gbmV3IFN0YWNrTWV0YWRhdGFCYWNrZW5kT3V0cHV0U3RvcmFnZVN0cmF0ZWd5KFxuICAgICAgc3RhY2ssXG4gICAgKTtcblxuICAgIHRoaXMuY3VzdG9tT3V0cHV0c0FjY3VtdWxhdG9yID0gbmV3IEN1c3RvbU91dHB1dHNBY2N1bXVsYXRvcihcbiAgICAgIG91dHB1dFN0b3JhZ2VTdHJhdGVneSxcbiAgICAgIG5ldyBPYmplY3RBY2N1bXVsYXRvcjxDbGllbnRDb25maWc+KHt9KSxcbiAgICApO1xuXG4gICAgY29uc3QgYmFja2VuZElkID0gZ2V0QmFja2VuZElkZW50aWZpZXIoc3RhY2spO1xuICAgIG91dHB1dFN0b3JhZ2VTdHJhdGVneS5hZGRCYWNrZW5kT3V0cHV0RW50cnkocGxhdGZvcm1PdXRwdXRLZXksIHtcbiAgICAgIHZlcnNpb246ICcxJyxcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgZGVwbG95bWVudFR5cGU6IGJhY2tlbmRJZC50eXBlLFxuICAgICAgICByZWdpb246IHN0YWNrLnJlZ2lvbixcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBzaG91bGRFbmFibGVCcmFuY2hMaW5rZXIgPSBiYWNrZW5kSWQudHlwZSA9PT0gJ2JyYW5jaCc7XG5cbiAgICBpZiAoc2hvdWxkRW5hYmxlQnJhbmNoTGlua2VyKSB7XG4gICAgICBuZXcgQW1wbGlmeUJyYW5jaExpbmtlckNvbnN0cnVjdChzdGFjaywgYmFja2VuZElkKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbXBvcnRQYXRoVmVyaWZpZXIgPSBuZXcgVG9nZ2xlYWJsZUltcG9ydFBhdGhWZXJpZmllcigpO1xuXG4gICAgY29uc3QgcmVzb3VyY2VOYW1lVmFsaWRhdG9yID0gbmV3IERlZmF1bHRSZXNvdXJjZU5hbWVWYWxpZGF0b3IoKTtcblxuICAgIC8vIHJlZ2lzdGVyIHByb3ZpZGVycyBidXQgZG9uJ3QgYWN0dWFsbHkgZXhlY3V0ZSBhbnl0aGluZyB5ZXRcbiAgICBPYmplY3QudmFsdWVzKGNvbnN0cnVjdEZhY3RvcmllcykuZm9yRWFjaCgoZmFjdG9yeSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBmYWN0b3J5LnByb3ZpZGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdHJ1Y3RDb250YWluZXIucmVnaXN0ZXJDb25zdHJ1Y3RGYWN0b3J5KGZhY3RvcnkucHJvdmlkZXMsIGZhY3RvcnkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gbm93IGludm9rZSBhbGwgdGhlIGZhY3RvcmllcyBhbmQgY29sbGVjdCB0aGUgY29uc3RydWN0cyBpbnRvIHRoaXMucmVzb3VyY2VzXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICB0aGlzLnJlc291cmNlcyA9IHt9IGFzIGFueTtcbiAgICBPYmplY3QuZW50cmllcyhjb25zdHJ1Y3RGYWN0b3JpZXMpLmZvckVhY2goXG4gICAgICAoW3Jlc291cmNlTmFtZSwgY29uc3RydWN0RmFjdG9yeV0pID0+IHtcbiAgICAgICAgLy8gVGhlIHR5cGUgaW5mZXJlbmNlIG9uIHRoaXMucmVzb3VyY2VzIGlzIG5vdCBoYXBweSBhYm91dCB0aGlzIGFzc2lnbm1lbnQgYmVjYXVzZSBpdCBkb2Vzbid0IGtub3cgdGhlIGV4YWN0IHR5cGUgb2YgLmdldEluc3RhbmNlKClcbiAgICAgICAgLy8gSG93ZXZlciwgdGhlIGFzc2lnbm1lbnQgaXMgb2theSBiZWNhdXNlIHdlIGFyZSBpdGVyYXRpbmcgb3ZlciB0aGUgZW50cmllcyBvZiBjb25zdHJ1Y3RGYWN0b3JpZXMgYW5kIGFzc2lnbmluZyB0aGUgcmVzb3VyY2UgbmFtZSB0byB0aGUgY29ycmVzcG9uZGluZyBpbnN0YW5jZVxuICAgICAgICB0aGlzLnJlc291cmNlc1tyZXNvdXJjZU5hbWUgYXMga2V5b2YgVF0gPSBjb25zdHJ1Y3RGYWN0b3J5LmdldEluc3RhbmNlKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdENvbnRhaW5lcixcbiAgICAgICAgICAgIG91dHB1dFN0b3JhZ2VTdHJhdGVneSxcbiAgICAgICAgICAgIGltcG9ydFBhdGhWZXJpZmllcixcbiAgICAgICAgICAgIHJlc291cmNlTmFtZVZhbGlkYXRvcixcbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICkgYXMgYW55O1xuICAgICAgfSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBDREsgc3RhY2sgd2l0aGluIHRoZSBBbXBsaWZ5IHByb2plY3QgdGhhdCBjYW4gYmUgdXNlZCBmb3IgY3JlYXRpbmcgY3VzdG9tIHJlc291cmNlcy5cbiAgICogSWYgYSBzdGFjayBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWQgd2l0aCBcIm5hbWVcIiB0aGVuIGFuIGVycm9yIGlzIHRocm93bi5cbiAgICovXG4gIGNyZWF0ZVN0YWNrID0gKG5hbWU6IHN0cmluZyk6IFN0YWNrID0+IHtcbiAgICByZXR1cm4gdGhpcy5zdGFja1Jlc29sdmVyLmNyZWF0ZUN1c3RvbVN0YWNrKG5hbWUpO1xuICB9O1xuXG4gIGFkZE91dHB1dCA9IChcbiAgICBjbGllbnRDb25maWdQYXJ0OiBEZWVwUGFydGlhbEFtcGxpZnlHZW5lcmF0ZWRDb25maWdzPENsaWVudENvbmZpZz4sXG4gICkgPT4ge1xuICAgIGNvbnN0IHsgdmVyc2lvbiB9ID0gY2xpZW50Q29uZmlnUGFydDtcbiAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgIGNsaWVudENvbmZpZ1BhcnQudmVyc2lvbiA9XG4gICAgICAgIERFRkFVTFRfQ0xJRU5UX0NPTkZJR19WRVJTSU9OX0ZPUl9CQUNLRU5EX0FERF9PVVRQVVQ7XG4gICAgfVxuICAgIHRoaXMuY3VzdG9tT3V0cHV0c0FjY3VtdWxhdG9yLmFkZE91dHB1dChjbGllbnRDb25maWdQYXJ0KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEFtcGxpZnkgYmFja2VuZCBpbnN0YW5jZSBhbmQgcmV0dXJucyBpdFxuICogQHBhcmFtIGNvbnN0cnVjdEZhY3RvcmllcyAtIGxpc3Qgb2YgYmFja2VuZCBmYWN0b3JpZXMgc3VjaCBhcyB0aG9zZSBjcmVhdGVkIGJ5IGBkZWZpbmVBdXRoYCBvciBgZGVmaW5lRGF0YWBcbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmluZUJhY2tlbmQgPSA8VCBleHRlbmRzIERlZmluZUJhY2tlbmRQcm9wcz4oXG4gIGNvbnN0cnVjdEZhY3RvcmllczogVCxcbik6IEJhY2tlbmQ8VD4gPT4ge1xuICBjb25zdCBiYWNrZW5kID0gbmV3IEJhY2tlbmRGYWN0b3J5KGNvbnN0cnVjdEZhY3Rvcmllcyk7XG4gIHJldHVybiB7XG4gICAgLi4uYmFja2VuZC5yZXNvdXJjZXMsXG4gICAgY3JlYXRlU3RhY2s6IGJhY2tlbmQuY3JlYXRlU3RhY2ssXG4gICAgYWRkT3V0cHV0OiBiYWNrZW5kLmFkZE91dHB1dCxcbiAgICBzdGFjazogYmFja2VuZC5zdGFjayxcbiAgfTtcbn07XG4iXX0=