"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setSdkTracing = setSdkTracing;
exports.callTrace = callTrace;
exports.traceMemberMethods = traceMemberMethods;
let ENABLED = false;
let INDENT = 0;
function setSdkTracing(enabled) {
    ENABLED = enabled;
}
/**
 * Method decorator to trace a single static or member method, any time it's called
 */
function callTrace(fn, className, logger) {
    if (!ENABLED || !logger) {
        return;
    }
    logger.info(`[trace] ${' '.repeat(INDENT)}${className || '(anonymous)'}#${fn}()`);
}
/**
 * Method decorator to trace a single member method any time it's called
 */
function traceCall(receiver, _propertyKey, descriptor, parentClassName) {
    const fn = descriptor.value;
    const className = typeof receiver === 'function' ? receiver.name : parentClassName;
    descriptor.value = function (...args) {
        const logger = this.logger;
        if (!ENABLED || typeof logger?.info !== 'function') {
            return fn.apply(this, args);
        }
        logger.info.apply(logger, [`[trace] ${' '.repeat(INDENT)}${className || this.constructor.name || '(anonymous)'}#${fn.name}()`]);
        INDENT += 2;
        const ret = fn.apply(this, args);
        if (ret instanceof Promise) {
            return ret.finally(() => {
                INDENT -= 2;
            });
        }
        else {
            INDENT -= 2;
            return ret;
        }
    };
    return descriptor;
}
/**
 * Class decorator, enable tracing for all member methods on this class
 * @deprecated this doesn't work well with localized logging instances, don't use
 */
function traceMemberMethods(constructor) {
    // Instance members
    for (const [name, descriptor] of Object.entries(Object.getOwnPropertyDescriptors(constructor.prototype))) {
        if (typeof descriptor.value !== 'function') {
            continue;
        }
        const newDescriptor = traceCall(constructor.prototype, name, descriptor, constructor.name) ?? descriptor;
        Object.defineProperty(constructor.prototype, name, newDescriptor);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhY2luZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInRyYWNpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFLQSxzQ0FFQztBQUtELDhCQU1DO0FBbUNELGdEQVNDO0FBNURELElBQUksT0FBTyxHQUFHLEtBQUssQ0FBQztBQUNwQixJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFFZixTQUFnQixhQUFhLENBQUMsT0FBZ0I7SUFDNUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztBQUNwQixDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixTQUFTLENBQUMsRUFBVSxFQUFFLFNBQWtCLEVBQUUsTUFBbUI7SUFDM0UsSUFBSSxDQUFDLE9BQU8sSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ3hCLE9BQU87SUFDVCxDQUFDO0lBRUQsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsU0FBUyxJQUFJLGFBQWEsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3BGLENBQUM7QUFFRDs7R0FFRztBQUNILFNBQVMsU0FBUyxDQUFDLFFBQWdCLEVBQUUsWUFBb0IsRUFBRSxVQUE4QixFQUFFLGVBQXdCO0lBQ2pILE1BQU0sRUFBRSxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUM7SUFDNUIsTUFBTSxTQUFTLEdBQUcsT0FBTyxRQUFRLEtBQUssVUFBVSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxlQUFlLENBQUM7SUFFbkYsVUFBVSxDQUFDLEtBQUssR0FBRyxVQUFVLEdBQUcsSUFBVztRQUN6QyxNQUFNLE1BQU0sR0FBSSxJQUFZLENBQUMsTUFBTSxDQUFDO1FBQ3BDLElBQUksQ0FBQyxPQUFPLElBQUksT0FBTyxNQUFNLEVBQUUsSUFBSSxLQUFLLFVBQVUsRUFBRSxDQUFDO1lBQ25ELE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDOUIsQ0FBQztRQUVELE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLFdBQVcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxTQUFTLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLElBQUksYUFBYSxJQUFJLEVBQUUsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDaEksTUFBTSxJQUFJLENBQUMsQ0FBQztRQUVaLE1BQU0sR0FBRyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ2pDLElBQUksR0FBRyxZQUFZLE9BQU8sRUFBRSxDQUFDO1lBQzNCLE9BQU8sR0FBRyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUU7Z0JBQ3RCLE1BQU0sSUFBSSxDQUFDLENBQUM7WUFDZCxDQUFDLENBQUMsQ0FBQztRQUNMLENBQUM7YUFBTSxDQUFDO1lBQ04sTUFBTSxJQUFJLENBQUMsQ0FBQztZQUNaLE9BQU8sR0FBRyxDQUFDO1FBQ2IsQ0FBQztJQUNILENBQUMsQ0FBQztJQUNGLE9BQU8sVUFBVSxDQUFDO0FBQ3BCLENBQUM7QUFFRDs7O0dBR0c7QUFDSCxTQUFnQixrQkFBa0IsQ0FBQyxXQUFxQjtJQUN0RCxtQkFBbUI7SUFDbkIsS0FBSyxNQUFNLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLHlCQUF5QixDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDekcsSUFBSSxPQUFPLFVBQVUsQ0FBQyxLQUFLLEtBQUssVUFBVSxFQUFFLENBQUM7WUFDM0MsU0FBUztRQUNYLENBQUM7UUFDRCxNQUFNLGFBQWEsR0FBRyxTQUFTLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxVQUFVLENBQUM7UUFDekcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsU0FBUyxFQUFFLElBQUksRUFBRSxhQUFhLENBQUMsQ0FBQztJQUNwRSxDQUFDO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgSVNka0xvZ2dlciB9IGZyb20gJy4vc2RrLWxvZ2dlcic7XG5cbmxldCBFTkFCTEVEID0gZmFsc2U7XG5sZXQgSU5ERU5UID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIHNldFNka1RyYWNpbmcoZW5hYmxlZDogYm9vbGVhbikge1xuICBFTkFCTEVEID0gZW5hYmxlZDtcbn1cblxuLyoqXG4gKiBNZXRob2QgZGVjb3JhdG9yIHRvIHRyYWNlIGEgc2luZ2xlIHN0YXRpYyBvciBtZW1iZXIgbWV0aG9kLCBhbnkgdGltZSBpdCdzIGNhbGxlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsbFRyYWNlKGZuOiBzdHJpbmcsIGNsYXNzTmFtZT86IHN0cmluZywgbG9nZ2VyPzogSVNka0xvZ2dlcikge1xuICBpZiAoIUVOQUJMRUQgfHwgIWxvZ2dlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxvZ2dlci5pbmZvKGBbdHJhY2VdICR7JyAnLnJlcGVhdChJTkRFTlQpfSR7Y2xhc3NOYW1lIHx8ICcoYW5vbnltb3VzKSd9IyR7Zm59KClgKTtcbn1cblxuLyoqXG4gKiBNZXRob2QgZGVjb3JhdG9yIHRvIHRyYWNlIGEgc2luZ2xlIG1lbWJlciBtZXRob2QgYW55IHRpbWUgaXQncyBjYWxsZWRcbiAqL1xuZnVuY3Rpb24gdHJhY2VDYWxsKHJlY2VpdmVyOiBvYmplY3QsIF9wcm9wZXJ0eUtleTogc3RyaW5nLCBkZXNjcmlwdG9yOiBQcm9wZXJ0eURlc2NyaXB0b3IsIHBhcmVudENsYXNzTmFtZT86IHN0cmluZykge1xuICBjb25zdCBmbiA9IGRlc2NyaXB0b3IudmFsdWU7XG4gIGNvbnN0IGNsYXNzTmFtZSA9IHR5cGVvZiByZWNlaXZlciA9PT0gJ2Z1bmN0aW9uJyA/IHJlY2VpdmVyLm5hbWUgOiBwYXJlbnRDbGFzc05hbWU7XG5cbiAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uICguLi5hcmdzOiBhbnlbXSkge1xuICAgIGNvbnN0IGxvZ2dlciA9ICh0aGlzIGFzIGFueSkubG9nZ2VyO1xuICAgIGlmICghRU5BQkxFRCB8fCB0eXBlb2YgbG9nZ2VyPy5pbmZvICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuXG4gICAgbG9nZ2VyLmluZm8uYXBwbHkobG9nZ2VyLCBbYFt0cmFjZV0gJHsnICcucmVwZWF0KElOREVOVCl9JHtjbGFzc05hbWUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIHx8ICcoYW5vbnltb3VzKSd9IyR7Zm4ubmFtZX0oKWBdKTtcbiAgICBJTkRFTlQgKz0gMjtcblxuICAgIGNvbnN0IHJldCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIGlmIChyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gcmV0LmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBJTkRFTlQgLT0gMjtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBJTkRFTlQgLT0gMjtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZGVzY3JpcHRvcjtcbn1cblxuLyoqXG4gKiBDbGFzcyBkZWNvcmF0b3IsIGVuYWJsZSB0cmFjaW5nIGZvciBhbGwgbWVtYmVyIG1ldGhvZHMgb24gdGhpcyBjbGFzc1xuICogQGRlcHJlY2F0ZWQgdGhpcyBkb2Vzbid0IHdvcmsgd2VsbCB3aXRoIGxvY2FsaXplZCBsb2dnaW5nIGluc3RhbmNlcywgZG9uJ3QgdXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFjZU1lbWJlck1ldGhvZHMoY29uc3RydWN0b3I6IEZ1bmN0aW9uKSB7XG4gIC8vIEluc3RhbmNlIG1lbWJlcnNcbiAgZm9yIChjb25zdCBbbmFtZSwgZGVzY3JpcHRvcl0gb2YgT2JqZWN0LmVudHJpZXMoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoY29uc3RydWN0b3IucHJvdG90eXBlKSkpIHtcbiAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBuZXdEZXNjcmlwdG9yID0gdHJhY2VDYWxsKGNvbnN0cnVjdG9yLnByb3RvdHlwZSwgbmFtZSwgZGVzY3JpcHRvciwgY29uc3RydWN0b3IubmFtZSkgPz8gZGVzY3JpcHRvcjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29uc3RydWN0b3IucHJvdG90eXBlLCBuYW1lLCBuZXdEZXNjcmlwdG9yKTtcbiAgfVxufVxuIl19