"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  MetadataService: () => MetadataService
});
module.exports = __toCommonJS(index_exports);

// src/MetadataService.ts
var import_node_config_provider = require("@smithy/node-config-provider");
var import_node_http_handler = require("@smithy/node-http-handler");
var import_protocol_http = require("@smithy/protocol-http");
var import_util_stream = require("@smithy/util-stream");

// src/ConfigLoaders.ts
var ENV_ENDPOINT_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT";
var CONFIG_ENDPOINT_NAME = "ec2_metadata_service_endpoint";
var ENDPOINT_SELECTORS = {
  environmentVariableSelector: /* @__PURE__ */ __name((env) => env[ENV_ENDPOINT_NAME], "environmentVariableSelector"),
  configFileSelector: /* @__PURE__ */ __name((profile) => profile[CONFIG_ENDPOINT_NAME], "configFileSelector"),
  default: "http://169.254.169.254" /* IPv4 */
};
var ENV_ENDPOINT_MODE_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE";
var CONFIG_ENDPOINT_MODE_NAME = "ec2_metadata_service_endpoint_mode";
var ENDPOINT_MODE_SELECTORS = {
  environmentVariableSelector: /* @__PURE__ */ __name((env) => env[ENV_ENDPOINT_MODE_NAME], "environmentVariableSelector"),
  configFileSelector: /* @__PURE__ */ __name((profile) => profile[CONFIG_ENDPOINT_MODE_NAME], "configFileSelector"),
  default: "IPv4" /* IPv4 */
};
var AWS_EC2_METADATA_V1_DISABLED = "AWS_EC2_METADATA_V1_DISABLED";
var PROFILE_AWS_EC2_METADATA_V1_DISABLED = "ec2_metadata_v1_disabled";
var IMDSv1_DISABLED_SELECTORS = {
  environmentVariableSelector: /* @__PURE__ */ __name((env) => env[AWS_EC2_METADATA_V1_DISABLED] ? env[AWS_EC2_METADATA_V1_DISABLED] !== "false" : void 0, "environmentVariableSelector"),
  configFileSelector: /* @__PURE__ */ __name((profile) => profile[PROFILE_AWS_EC2_METADATA_V1_DISABLED] ? profile[PROFILE_AWS_EC2_METADATA_V1_DISABLED] !== "false" : void 0, "configFileSelector"),
  default: false
};

// src/MetadataService.ts
var MetadataService = class {
  static {
    __name(this, "MetadataService");
  }
  disableFetchToken;
  config;
  /**
   * Creates a new MetadataService object with a given set of options.
   */
  constructor(options = {}) {
    this.config = (async () => {
      const profile = options?.profile || process.env.AWS_PROFILE;
      return {
        endpoint: options.endpoint ?? await (0, import_node_config_provider.loadConfig)(ENDPOINT_SELECTORS, { profile })(),
        httpOptions: {
          timeout: options?.httpOptions?.timeout || 0
        },
        ec2MetadataV1Disabled: options?.ec2MetadataV1Disabled ?? await (0, import_node_config_provider.loadConfig)(IMDSv1_DISABLED_SELECTORS, { profile })()
      };
    })();
    this.disableFetchToken = options?.disableFetchToken || false;
  }
  async request(path, options) {
    const { endpoint, ec2MetadataV1Disabled, httpOptions } = await this.config;
    const handler = new import_node_http_handler.NodeHttpHandler({
      requestTimeout: httpOptions?.timeout,
      connectionTimeout: httpOptions?.timeout
    });
    const endpointUrl = new URL(endpoint);
    const headers = options.headers || {};
    if (this.disableFetchToken && ec2MetadataV1Disabled) {
      throw new Error("IMDSv1 is disabled and fetching token is disabled, cannot make the request.");
    }
    if (!this.disableFetchToken) {
      try {
        headers["x-aws-ec2-metadata-token"] = await this.fetchMetadataToken();
      } catch (err) {
        if (ec2MetadataV1Disabled) {
          throw err;
        }
      }
    }
    const request = new import_protocol_http.HttpRequest({
      method: options.method || "GET",
      // Default to GET if no method is specified
      headers,
      hostname: endpointUrl.hostname,
      path: endpointUrl.pathname + path,
      protocol: endpointUrl.protocol
    });
    try {
      const { response } = await handler.handle(request, {});
      if (response.statusCode === 200 && response.body) {
        return (0, import_util_stream.sdkStreamMixin)(response.body).transformToString();
      } else {
        throw new Error(`Request failed with status code ${response.statusCode}`);
      }
    } catch (error) {
      throw new Error(`Error making request to the metadata service: ${error}`);
    }
  }
  async fetchMetadataToken() {
    const { endpoint, httpOptions } = await this.config;
    const handler = new import_node_http_handler.NodeHttpHandler({
      requestTimeout: httpOptions?.timeout,
      connectionTimeout: httpOptions?.timeout
    });
    const endpointUrl = new URL(endpoint);
    const tokenRequest = new import_protocol_http.HttpRequest({
      method: "PUT",
      headers: {
        "x-aws-ec2-metadata-token-ttl-seconds": "21600"
        // 6 hours;
      },
      hostname: endpointUrl.hostname,
      path: "/latest/api/token",
      protocol: endpointUrl.protocol
    });
    try {
      const { response } = await handler.handle(tokenRequest, {});
      if (response.statusCode === 200 && response.body) {
        return (0, import_util_stream.sdkStreamMixin)(response.body).transformToString();
      } else {
        throw new Error(`Failed to fetch metadata token with status code ${response.statusCode}`);
      }
    } catch (error) {
      if (error?.statusCode === 400) {
        throw new Error(`Error fetching metadata token: ${error}`);
      } else if (error.message === "TimeoutError" || [403, 404, 405].includes(error.statusCode)) {
        this.disableFetchToken = true;
        throw new Error(`Error fetching metadata token: ${error}. disableFetchToken is enabled`);
      }
      throw new Error(`Error fetching metadata token: ${error}`);
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:

0 && (module.exports = {
  MetadataService
});

