"use strict";
var __addDisposableResource = (this && this.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (this && this.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while (r = env.stack.pop()) {
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                    }
                    else s |= 1;
                }
                catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
Object.defineProperty(exports, "__esModule", { value: true });
exports.BootstrapSource = exports.BootstrapStackParameters = exports.BootstrapEnvironments = void 0;
const private_1 = require("./private");
const private_2 = require("../../api/cloud-assembly/private");
const private_3 = require("../../api/io/private");
const private_4 = require("../../toolkit/private");
/**
 * Create manage bootstrap environments
 */
class BootstrapEnvironments {
    envProvider;
    /**
     * Create from a list of environment descriptors
     * List of strings like `['aws://012345678912/us-east-1', 'aws://234567890123/eu-west-1']`
     */
    static fromList(environments) {
        return new BootstrapEnvironments((0, private_1.environmentsFromDescriptors)(environments));
    }
    /**
     * Create from a cloud assembly source
     */
    static fromCloudAssemblySource(cx) {
        return new BootstrapEnvironments(async (ioHost) => {
            const env_1 = { stack: [], error: void 0, hasError: false };
            try {
                const ioHelper = (0, private_3.asIoHelper)(ioHost, 'bootstrap');
                const assembly = __addDisposableResource(env_1, await (0, private_4.assemblyFromSource)(ioHelper, cx), true);
                const stackCollection = await assembly.selectStacksV2(private_2.ALL_STACKS);
                return stackCollection.stackArtifacts.map(stack => stack.environment);
            }
            catch (e_1) {
                env_1.error = e_1;
                env_1.hasError = true;
            }
            finally {
                const result_1 = __disposeResources(env_1);
                if (result_1)
                    await result_1;
            }
        });
    }
    constructor(envProvider) {
        this.envProvider = envProvider;
    }
    /**
     * Compute the bootstrap enviornments
     *
     * @internal
     */
    async getEnvironments(ioHost) {
        if (Array.isArray(this.envProvider)) {
            return this.envProvider;
        }
        return this.envProvider(ioHost);
    }
}
exports.BootstrapEnvironments = BootstrapEnvironments;
/**
 * Parameters of the bootstrapping template with flexible configuration options
 */
class BootstrapStackParameters {
    /**
     * Use only existing parameters on the stack.
     */
    static onlyExisting() {
        return new BootstrapStackParameters({}, true);
    }
    /**
     * Use exactly these parameters and remove any other existing parameters from the stack.
     */
    static exactly(params) {
        return new BootstrapStackParameters(params, false);
    }
    /**
     * Define additional parameters for the stack, while keeping existing parameters for unspecified values.
     */
    static withExisting(params) {
        return new BootstrapStackParameters(params, true);
    }
    /**
     * The parameters as a Map for easy access and manipulation
     */
    parameters;
    keepExistingParameters;
    constructor(params, usePreviousParameters = true) {
        this.keepExistingParameters = usePreviousParameters;
        this.parameters = params;
    }
}
exports.BootstrapStackParameters = BootstrapStackParameters;
/**
 * Source configuration for bootstrap operations
 */
class BootstrapSource {
    /**
     * Use the default bootstrap template
     */
    static default() {
        return { source: 'default' };
    }
    /**
     * Use a custom bootstrap template
     */
    static customTemplate(templateFile) {
        return {
            source: 'custom',
            templateFile,
        };
    }
}
exports.BootstrapSource = BootstrapSource;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsdUNBQXdEO0FBRXhELDhEQUE4RDtBQUU5RCxrREFBa0Q7QUFFbEQsbURBQTJEO0FBRTNEOztHQUVHO0FBQ0gsTUFBYSxxQkFBcUI7SUFxQks7SUFwQnJDOzs7T0FHRztJQUNILE1BQU0sQ0FBQyxRQUFRLENBQUMsWUFBc0I7UUFDcEMsT0FBTyxJQUFJLHFCQUFxQixDQUFDLElBQUEscUNBQTJCLEVBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztJQUM5RSxDQUFDO0lBRUQ7O09BRUc7SUFDSCxNQUFNLENBQUMsdUJBQXVCLENBQUMsRUFBd0I7UUFDckQsT0FBTyxJQUFJLHFCQUFxQixDQUFDLEtBQUssRUFBRSxNQUFlLEVBQUUsRUFBRTs7O2dCQUN6RCxNQUFNLFFBQVEsR0FBRyxJQUFBLG9CQUFVLEVBQUMsTUFBTSxFQUFFLFdBQVcsQ0FBQyxDQUFDO2dCQUNqRCxNQUFZLFFBQVEsa0NBQUcsTUFBTSxJQUFBLDRCQUFrQixFQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsT0FBQSxDQUFDO2dCQUM5RCxNQUFNLGVBQWUsR0FBRyxNQUFNLFFBQVEsQ0FBQyxjQUFjLENBQUMsb0JBQVUsQ0FBQyxDQUFDO2dCQUNsRSxPQUFPLGVBQWUsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDOzs7Ozs7Ozs7OztTQUN2RSxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsWUFBcUMsV0FBc0Y7UUFBdEYsZ0JBQVcsR0FBWCxXQUFXLENBQTJFO0lBRTNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLGVBQWUsQ0FBQyxNQUFlO1FBQ25DLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQztZQUNwQyxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7UUFDMUIsQ0FBQztRQUNELE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNsQyxDQUFDO0NBQ0Y7QUFwQ0Qsc0RBb0NDO0FBK0lEOztHQUVHO0FBQ0gsTUFBYSx3QkFBd0I7SUFDbkM7O09BRUc7SUFDSSxNQUFNLENBQUMsWUFBWTtRQUN4QixPQUFPLElBQUksd0JBQXdCLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFRDs7T0FFRztJQUNJLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBMkI7UUFDL0MsT0FBTyxJQUFJLHdCQUF3QixDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxNQUFNLENBQUMsWUFBWSxDQUFDLE1BQTJCO1FBQ3BELE9BQU8sSUFBSSx3QkFBd0IsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDcEQsQ0FBQztJQUVEOztPQUVHO0lBQ2EsVUFBVSxDQUF1QjtJQUNqQyxzQkFBc0IsQ0FBVTtJQUVoRCxZQUFvQixNQUE0QixFQUFFLHFCQUFxQixHQUFHLElBQUk7UUFDNUUsSUFBSSxDQUFDLHNCQUFzQixHQUFHLHFCQUFxQixDQUFDO1FBQ3BELElBQUksQ0FBQyxVQUFVLEdBQUcsTUFBTSxDQUFDO0lBQzNCLENBQUM7Q0FDRjtBQWhDRCw0REFnQ0M7QUFFRDs7R0FFRztBQUNILE1BQWEsZUFBZTtJQUMxQjs7T0FFRztJQUNILE1BQU0sQ0FBQyxPQUFPO1FBQ1osT0FBTyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsQ0FBQztJQUMvQixDQUFDO0lBRUQ7O09BRUc7SUFDSCxNQUFNLENBQUMsY0FBYyxDQUFDLFlBQW9CO1FBQ3hDLE9BQU87WUFDTCxNQUFNLEVBQUUsUUFBUTtZQUNoQixZQUFZO1NBQ2IsQ0FBQztJQUNKLENBQUM7Q0FDRjtBQWpCRCwwQ0FpQkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgeyBlbnZpcm9ubWVudHNGcm9tRGVzY3JpcHRvcnMgfSBmcm9tICcuL3ByaXZhdGUnO1xuaW1wb3J0IHR5cGUgeyBJQ2xvdWRBc3NlbWJseVNvdXJjZSB9IGZyb20gJy4uLy4uL2FwaS9jbG91ZC1hc3NlbWJseSc7XG5pbXBvcnQgeyBBTExfU1RBQ0tTIH0gZnJvbSAnLi4vLi4vYXBpL2Nsb3VkLWFzc2VtYmx5L3ByaXZhdGUnO1xuaW1wb3J0IHR5cGUgeyBJSW9Ib3N0IH0gZnJvbSAnLi4vLi4vYXBpL2lvJztcbmltcG9ydCB7IGFzSW9IZWxwZXIgfSBmcm9tICcuLi8uLi9hcGkvaW8vcHJpdmF0ZSc7XG5pbXBvcnQgdHlwZSB7IFRhZyB9IGZyb20gJy4uLy4uL2FwaS90YWdzJztcbmltcG9ydCB7IGFzc2VtYmx5RnJvbVNvdXJjZSB9IGZyb20gJy4uLy4uL3Rvb2xraXQvcHJpdmF0ZSc7XG5cbi8qKlxuICogQ3JlYXRlIG1hbmFnZSBib290c3RyYXAgZW52aXJvbm1lbnRzXG4gKi9cbmV4cG9ydCBjbGFzcyBCb290c3RyYXBFbnZpcm9ubWVudHMge1xuICAvKipcbiAgICogQ3JlYXRlIGZyb20gYSBsaXN0IG9mIGVudmlyb25tZW50IGRlc2NyaXB0b3JzXG4gICAqIExpc3Qgb2Ygc3RyaW5ncyBsaWtlIGBbJ2F3czovLzAxMjM0NTY3ODkxMi91cy1lYXN0LTEnLCAnYXdzOi8vMjM0NTY3ODkwMTIzL2V1LXdlc3QtMSddYFxuICAgKi9cbiAgc3RhdGljIGZyb21MaXN0KGVudmlyb25tZW50czogc3RyaW5nW10pOiBCb290c3RyYXBFbnZpcm9ubWVudHMge1xuICAgIHJldHVybiBuZXcgQm9vdHN0cmFwRW52aXJvbm1lbnRzKGVudmlyb25tZW50c0Zyb21EZXNjcmlwdG9ycyhlbnZpcm9ubWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgZnJvbSBhIGNsb3VkIGFzc2VtYmx5IHNvdXJjZVxuICAgKi9cbiAgc3RhdGljIGZyb21DbG91ZEFzc2VtYmx5U291cmNlKGN4OiBJQ2xvdWRBc3NlbWJseVNvdXJjZSk6IEJvb3RzdHJhcEVudmlyb25tZW50cyB7XG4gICAgcmV0dXJuIG5ldyBCb290c3RyYXBFbnZpcm9ubWVudHMoYXN5bmMgKGlvSG9zdDogSUlvSG9zdCkgPT4ge1xuICAgICAgY29uc3QgaW9IZWxwZXIgPSBhc0lvSGVscGVyKGlvSG9zdCwgJ2Jvb3RzdHJhcCcpO1xuICAgICAgYXdhaXQgdXNpbmcgYXNzZW1ibHkgPSBhd2FpdCBhc3NlbWJseUZyb21Tb3VyY2UoaW9IZWxwZXIsIGN4KTtcbiAgICAgIGNvbnN0IHN0YWNrQ29sbGVjdGlvbiA9IGF3YWl0IGFzc2VtYmx5LnNlbGVjdFN0YWNrc1YyKEFMTF9TVEFDS1MpO1xuICAgICAgcmV0dXJuIHN0YWNrQ29sbGVjdGlvbi5zdGFja0FydGlmYWN0cy5tYXAoc3RhY2sgPT4gc3RhY2suZW52aXJvbm1lbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGVudlByb3ZpZGVyOiBjeGFwaS5FbnZpcm9ubWVudFtdIHwgKChpb0hvc3Q6IElJb0hvc3QpID0+IFByb21pc2U8Y3hhcGkuRW52aXJvbm1lbnRbXT4pKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBib290c3RyYXAgZW52aW9ybm1lbnRzXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgZ2V0RW52aXJvbm1lbnRzKGlvSG9zdDogSUlvSG9zdCk6IFByb21pc2U8Y3hhcGkuRW52aXJvbm1lbnRbXT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZW52UHJvdmlkZXIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbnZQcm92aWRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZW52UHJvdmlkZXIoaW9Ib3N0KTtcbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIEJvb3RzdHJhcFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJvb3RzdHJhcE9wdGlvbnMge1xuXG4gIC8qKlxuICAgKiBCb290c3RyYXAgZW52aXJvbm1lbnQgcGFyYW1ldGVycyBmb3IgQ2xvdWRGb3JtYXRpb24gdXNlZCB3aGVuIGRlcGxveWluZyB0aGUgYm9vdHN0cmFwIHN0YWNrXG4gICAqIEBkZWZhdWx0IEJvb3RzdHJhcEVudmlyb25tZW50UGFyYW1ldGVycy5vbmx5RXhpc3RpbmcoKVxuICAgKi9cbiAgcmVhZG9ubHkgcGFyYW1ldGVycz86IEJvb3RzdHJhcFN0YWNrUGFyYW1ldGVycztcblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHNvdXJjZSBvZiB0aGUgYm9vdHN0cmFwIHN0YWNrXG4gICAqXG4gICAqIEBkZWZhdWx0IEJvb3RzdHJhcFNvdXJjZS5kZWZhdWx0KClcbiAgICovXG4gIHJlYWRvbmx5IHNvdXJjZT86IHsgc291cmNlOiAnZGVmYXVsdCcgfSB8IHsgc291cmNlOiAnY3VzdG9tJzsgdGVtcGxhdGVGaWxlOiBzdHJpbmcgfTtcblxuICAvKipcbiAgICogV2hldGhlciB0byBleGVjdXRlIHRoZSBjaGFuZ2VzZXQgb3Igb25seSBjcmVhdGUgaXQgYW5kIGxlYXZlIGl0IGluIHJldmlld1xuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBleGVjdXRlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogVGFncyBmb3IgY2RrdG9vbGtpdCBzdGFja1xuICAgKlxuICAgKiBAZGVmYXVsdCBbXVxuICAgKi9cbiAgcmVhZG9ubHkgdGFncz86IFRhZ1tdO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzdGFja3MgY3JlYXRlZCBieSB0aGUgYm9vdHN0cmFwIHByb2Nlc3Mgc2hvdWxkIGJlIHByb3RlY3RlZCBmcm9tIHRlcm1pbmF0aW9uXG4gICAqIEBzZWUgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0Nsb3VkRm9ybWF0aW9uL2xhdGVzdC9Vc2VyR3VpZGUvdXNpbmctY2ZuLXByb3RlY3Qtc3RhY2tzLmh0bWxcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgdGVybWluYXRpb25Qcm90ZWN0aW9uPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBQYXJhbWV0ZXIgdmFsdWVzIGZvciB0aGUgYm9vdHN0cmFwcGluZyB0ZW1wbGF0ZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJvb3RzdHJhcFBhcmFtZXRlcnMge1xuICAvKipcbiAgICogVGhlIG5hbWUgdG8gYmUgZ2l2ZW4gdG8gdGhlIENESyBCb290c3RyYXAgYnVja2V0XG4gICAqIEJ5IGRlZmF1bHQsIGEgbmFtZSBpcyBnZW5lcmF0ZWQgYnkgQ2xvdWRGb3JtYXRpb25cbiAgICpcbiAgICogQGRlZmF1bHQgLSBObyB2YWx1ZSwgb3B0aW9uYWwgYXJndW1lbnRcbiAgICovXG4gIHJlYWRvbmx5IGJ1Y2tldE5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiBhbiBleGlzdGluZyBLTVMga2V5IHRvIGJlIHVzZWQgZm9yIGVuY3J5cHRpbmcgaXRlbXMgaW4gdGhlIGJ1Y2tldFxuICAgKiBCeSBkZWZhdWx0LCB0aGUgZGVmYXVsdCBLTVMga2V5IGlzIHVzZWRcbiAgICpcbiAgICogQGRlZmF1bHQgLSBObyB2YWx1ZSwgb3B0aW9uYWwgYXJndW1lbnRcbiAgICovXG4gIHJlYWRvbmx5IGttc0tleUlkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0byBjcmVhdGUgYSBuZXcgY3VzdG9tZXIgbWFzdGVyIGtleSAoQ01LKVxuICAgKlxuICAgKiBPbmx5IGFwcGxpZXMgdG8gbW9kZXJuIGJvb3RzdHJhcHBpbmdcbiAgICogTGVnYWN5IGJvb3RzdHJhcHBpbmcgd2lsbCBuZXZlciBjcmVhdGUgYSBDTUssIG9ubHkgdXNlIHRoZSBkZWZhdWx0IFMzIGtleVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgY3JlYXRlQ3VzdG9tZXJNYXN0ZXJLZXk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBBV1MgYWNjb3VudCBJRHMgdGhhdCBhcmUgdHJ1c3RlZCB0byBkZXBsb3kgaW50byB0aGUgZW52aXJvbm1lbnQgYmVpbmcgYm9vdHN0cmFwcGVkXG4gICAqXG4gICAqIEBkZWZhdWx0IFtdXG4gICAqL1xuICByZWFkb25seSB0cnVzdGVkQWNjb3VudHM/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgQVdTIGFjY291bnQgSURzIHRoYXQgYXJlIHRydXN0ZWQgdG8gbG9vayB1cCB2YWx1ZXMgaW4gdGhlIGVudmlyb25tZW50IGJlaW5nIGJvb3RzdHJhcHBlZFxuICAgKlxuICAgKiBAZGVmYXVsdCBbXVxuICAgKi9cbiAgcmVhZG9ubHkgdHJ1c3RlZEFjY291bnRzRm9yTG9va3VwPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIEFXUyBhY2NvdW50IElEcyB0aGF0IHNob3VsZCBub3QgYmUgdHJ1c3RlZCBieSB0aGUgYm9vdHN0cmFwcGVkIGVudmlyb25tZW50XG4gICAqIElmIHRoZXNlIGFjY291bnRzIGFyZSBhbHJlYWR5IHRydXN0ZWQsIHRoZXkgd2lsbCBiZSByZW1vdmVkIG9uIGJvb3RzdHJhcHBpbmdcbiAgICpcbiAgICogQGRlZmF1bHQgW11cbiAgICovXG4gIHJlYWRvbmx5IHVudHJ1c3RlZEFjY291bnRzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIFRoZSBBUk5zIG9mIHRoZSBJQU0gbWFuYWdlZCBwb2xpY2llcyB0aGF0IHNob3VsZCBiZSBhdHRhY2hlZCB0byB0aGUgcm9sZSBwZXJmb3JtaW5nIENsb3VkRm9ybWF0aW9uIGRlcGxveW1lbnRzXG4gICAqIEluIG1vc3QgY2FzZXMsIHRoaXMgd2lsbCBiZSB0aGUgQWRtaW5pc3RyYXRvckFjY2VzcyBwb2xpY3lcbiAgICogQXQgbGVhc3Qgb25lIHBvbGljeSBpcyByZXF1aXJlZCBpZiBgdHJ1c3RlZEFjY291bnRzYCB3ZXJlIHBhc3NlZFxuICAgKlxuICAgKiBAZGVmYXVsdCBbXVxuICAgKi9cbiAgcmVhZG9ubHkgY2xvdWRGb3JtYXRpb25FeGVjdXRpb25Qb2xpY2llcz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBJZGVudGlmaWVyIHRvIGRpc3Rpbmd1aXNoIG11bHRpcGxlIGJvb3RzdHJhcHBlZCBlbnZpcm9ubWVudHNcbiAgICogVGhlIGRlZmF1bHQgcXVhbGlmaWVyIGlzIGFuIGFyYml0cmFyeSBidXQgdW5pcXVlIHN0cmluZ1xuICAgKlxuICAgKiBAZGVmYXVsdCAnaG5iNjU5ZmRzJ1xuICAgKi9cbiAgcmVhZG9ubHkgcXVhbGlmaWVyPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0byBlbmFibGUgUzMgU3RhZ2luZyBCdWNrZXQgUHVibGljIEFjY2VzcyBCbG9jayBDb25maWd1cmF0aW9uXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IHB1YmxpY0FjY2Vzc0Jsb2NrQ29uZmlndXJhdGlvbj86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEZsYWcgZm9yIHVzaW5nIHRoZSBkZWZhdWx0IHBlcm1pc3Npb25zIGJvdW5kYXJ5IGZvciBib290c3RyYXBwaW5nXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gdmFsdWUsIG9wdGlvbmFsIGFyZ3VtZW50XG4gICAqL1xuICByZWFkb25seSBleGFtcGxlUGVybWlzc2lvbnNCb3VuZGFyeT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIE5hbWUgZm9yIHRoZSBjdXN0b21lcidzIGN1c3RvbSBwZXJtaXNzaW9ucyBib3VuZGFyeSBmb3IgYm9vdHN0cmFwcGluZ1xuICAgKlxuICAgKiBAZGVmYXVsdCAtIE5vIHZhbHVlLCBvcHRpb25hbCBhcmd1bWVudFxuICAgKi9cbiAgcmVhZG9ubHkgY3VzdG9tUGVybWlzc2lvbnNCb3VuZGFyeT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbnZpcm9ubWVudEJvb3RzdHJhcFJlc3VsdCB7XG4gIGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudDtcbiAgc3RhdHVzOiAnc3VjY2VzcycgfCAnbm8tb3AnO1xuICBkdXJhdGlvbjogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJvb3RzdHJhcFJlc3VsdCB7XG4gIGVudmlyb25tZW50czogRW52aXJvbm1lbnRCb290c3RyYXBSZXN1bHRbXTtcbiAgZHVyYXRpb246IG51bWJlcjtcbn1cblxuLyoqXG4gKiBQYXJhbWV0ZXJzIG9mIHRoZSBib290c3RyYXBwaW5nIHRlbXBsYXRlIHdpdGggZmxleGlibGUgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gKi9cbmV4cG9ydCBjbGFzcyBCb290c3RyYXBTdGFja1BhcmFtZXRlcnMge1xuICAvKipcbiAgICogVXNlIG9ubHkgZXhpc3RpbmcgcGFyYW1ldGVycyBvbiB0aGUgc3RhY2suXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG9ubHlFeGlzdGluZygpIHtcbiAgICByZXR1cm4gbmV3IEJvb3RzdHJhcFN0YWNrUGFyYW1ldGVycyh7fSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIGV4YWN0bHkgdGhlc2UgcGFyYW1ldGVycyBhbmQgcmVtb3ZlIGFueSBvdGhlciBleGlzdGluZyBwYXJhbWV0ZXJzIGZyb20gdGhlIHN0YWNrLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBleGFjdGx5KHBhcmFtczogQm9vdHN0cmFwUGFyYW1ldGVycykge1xuICAgIHJldHVybiBuZXcgQm9vdHN0cmFwU3RhY2tQYXJhbWV0ZXJzKHBhcmFtcywgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBzdGFjaywgd2hpbGUga2VlcGluZyBleGlzdGluZyBwYXJhbWV0ZXJzIGZvciB1bnNwZWNpZmllZCB2YWx1ZXMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHdpdGhFeGlzdGluZyhwYXJhbXM6IEJvb3RzdHJhcFBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gbmV3IEJvb3RzdHJhcFN0YWNrUGFyYW1ldGVycyhwYXJhbXMsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwYXJhbWV0ZXJzIGFzIGEgTWFwIGZvciBlYXN5IGFjY2VzcyBhbmQgbWFuaXB1bGF0aW9uXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgcGFyYW1ldGVycz86IEJvb3RzdHJhcFBhcmFtZXRlcnM7XG4gIHB1YmxpYyByZWFkb25seSBrZWVwRXhpc3RpbmdQYXJhbWV0ZXJzOiBib29sZWFuO1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IocGFyYW1zPzogQm9vdHN0cmFwUGFyYW1ldGVycywgdXNlUHJldmlvdXNQYXJhbWV0ZXJzID0gdHJ1ZSkge1xuICAgIHRoaXMua2VlcEV4aXN0aW5nUGFyYW1ldGVycyA9IHVzZVByZXZpb3VzUGFyYW1ldGVycztcbiAgICB0aGlzLnBhcmFtZXRlcnMgPSBwYXJhbXM7XG4gIH1cbn1cblxuLyoqXG4gKiBTb3VyY2UgY29uZmlndXJhdGlvbiBmb3IgYm9vdHN0cmFwIG9wZXJhdGlvbnNcbiAqL1xuZXhwb3J0IGNsYXNzIEJvb3RzdHJhcFNvdXJjZSB7XG4gIC8qKlxuICAgKiBVc2UgdGhlIGRlZmF1bHQgYm9vdHN0cmFwIHRlbXBsYXRlXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdCgpOiBCb290c3RyYXBPcHRpb25zWydzb3VyY2UnXSB7XG4gICAgcmV0dXJuIHsgc291cmNlOiAnZGVmYXVsdCcgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgYSBjdXN0b20gYm9vdHN0cmFwIHRlbXBsYXRlXG4gICAqL1xuICBzdGF0aWMgY3VzdG9tVGVtcGxhdGUodGVtcGxhdGVGaWxlOiBzdHJpbmcpOiBCb290c3RyYXBPcHRpb25zWydzb3VyY2UnXSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNvdXJjZTogJ2N1c3RvbScsXG4gICAgICB0ZW1wbGF0ZUZpbGUsXG4gICAgfTtcbiAgfVxufVxuIl19