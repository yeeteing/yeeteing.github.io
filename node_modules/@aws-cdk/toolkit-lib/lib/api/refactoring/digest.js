"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeResourceDigests = computeResourceDigests;
exports.hashObject = hashObject;
const crypto = require("node:crypto");
const util_1 = require("@aws-cdk/cloudformation-diff/lib/diff/util");
const graph_1 = require("./graph");
/**
 * Computes the digest for each resource in the template.
 *
 * Conceptually, the digest is computed as:
 *
 *     d(resource) = hash(type + physicalId)                       , if physicalId is defined
 *                 = hash(type + properties + dependencies.map(d)) , otherwise
 *
 * where `hash` is a cryptographic hash function. In other words, if a resource has
 * a physical ID, we use the physical ID plus its type to uniquely identify
 * that resource. In this case, the digest can be computed from these two fields
 * alone. A corollary is that such resources can be renamed and have their
 * properties updated at the same time, and still be considered equivalent.
 *
 * Otherwise, the digest is computed from its type, its own properties (that is,
 * excluding properties that refer to other resources), and the digests of each of
 * its dependencies.
 *
 * The digest of a resource, defined recursively this way, remains stable even if
 * one or more of its dependencies gets renamed. Since the resources in a
 * CloudFormation template form a directed acyclic graph, this function is
 * well-defined.
 */
function computeResourceDigests(stacks) {
    const exports = Object.fromEntries(stacks.flatMap((s) => Object.values(s.template.Outputs ?? {})
        .filter((o) => o.Export != null && typeof o.Export.Name === 'string')
        .map((o) => [o.Export.Name, { stackName: s.stackName, value: o.Value }])));
    const resources = Object.fromEntries(stacks.flatMap((s) => Object.entries(s.template.Resources ?? {}).map(([id, res]) => [`${s.stackName}.${id}`, res])));
    const graph = new graph_1.ResourceGraph(stacks);
    const nodes = graph.sortedNodes;
    // 4. Compute digests in sorted order
    const result = {};
    for (const id of nodes) {
        const resource = resources[id];
        const resourceProperties = resource.Properties ?? {};
        const model = (0, util_1.loadResourceModel)(resource.Type);
        const identifier = intersection(Object.keys(resourceProperties), model?.primaryIdentifier ?? []);
        let toHash;
        if (identifier.length === model?.primaryIdentifier?.length) {
            // The resource has a physical ID defined, so we can
            // use the ID and the type as the identity of the resource.
            toHash =
                resource.Type +
                    identifier
                        .sort()
                        .map((attr) => JSON.stringify(resourceProperties[attr]))
                        .join('');
        }
        else {
            // The resource does not have a physical ID defined, so we need to
            // compute the digest based on its properties and dependencies.
            const depDigests = Array.from(graph.outNeighbors(id)).map((d) => result[d]);
            const propertiesHash = hashObject(stripReferences(stripConstructPath(resource), exports));
            toHash = resource.Type + propertiesHash + depDigests.join('');
        }
        result[id] = crypto.createHash('sha256').update(toHash).digest('hex');
    }
    return result;
}
function hashObject(obj) {
    const hash = crypto.createHash('sha256');
    function addToHash(value) {
        if (value == null) {
            addToHash('null');
        }
        else if (typeof value === 'object') {
            if (Array.isArray(value)) {
                value.forEach(addToHash);
            }
            else {
                Object.keys(value)
                    .sort()
                    .forEach((key) => {
                    hash.update(key);
                    addToHash(value[key]);
                });
            }
        }
        else {
            hash.update(typeof value + value.toString());
        }
    }
    addToHash(obj);
    return hash.digest('hex');
}
/**
 * Removes sub-properties containing Ref or Fn::GetAtt to avoid hashing
 * references themselves but keeps the property structure.
 */
function stripReferences(value, exports) {
    if (!value || typeof value !== 'object')
        return value;
    if (Array.isArray(value)) {
        return value.map(x => stripReferences(x, exports));
    }
    if ('Ref' in value) {
        return { __cloud_ref__: 'Ref' };
    }
    if ('Fn::GetAtt' in value) {
        return { __cloud_ref__: 'Fn::GetAtt' };
    }
    if ('DependsOn' in value) {
        return { __cloud_ref__: 'DependsOn' };
    }
    if ('Fn::ImportValue' in value) {
        const v = exports[value['Fn::ImportValue']].value;
        // Treat Fn::ImportValue as if it were a reference with the same stack
        if ('Ref' in v) {
            return { __cloud_ref__: 'Ref' };
        }
        else if ('Fn::GetAtt' in v) {
            return { __cloud_ref__: 'Fn::GetAtt' };
        }
    }
    const result = {};
    for (const [k, v] of Object.entries(value)) {
        result[k] = stripReferences(v, exports);
    }
    return result;
}
function stripConstructPath(resource) {
    if (resource?.Metadata?.['aws:cdk:path'] == null) {
        return resource;
    }
    const copy = JSON.parse(JSON.stringify(resource));
    delete copy.Metadata['aws:cdk:path'];
    return copy;
}
function intersection(a, b) {
    return a.filter((value) => b.includes(value));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlnZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZGlnZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBNEJBLHdEQWlEQztBQUVELGdDQXdCQztBQXZHRCxzQ0FBc0M7QUFDdEMscUVBQStFO0FBRS9FLG1DQUF3QztBQUV4Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXNCRztBQUNILFNBQWdCLHNCQUFzQixDQUFDLE1BQTZCO0lBQ2xFLE1BQU0sT0FBTyxHQUF1RCxNQUFNLENBQUMsV0FBVyxDQUNwRixNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FDbkIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sSUFBSSxFQUFFLENBQUM7U0FDcEMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLElBQUksSUFBSSxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQztTQUNwRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLFNBQVMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFnRCxDQUFDLENBQzFILENBQ0YsQ0FBQztJQUVGLE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQ2xDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUNuQixNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsU0FBUyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FDNUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxTQUFTLElBQUksRUFBRSxF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O1xuaW1wb3J0IHsgbG9hZFJlc291cmNlTW9kZWwgfSBmcm9tICdAYXdzLWNkay9jbG91ZGZvcm1hdGlvbi1kaWZmL2xpYi9kaWZmL3V0aWwnO1xuaW1wb3J0IHR5cGUgeyBDbG91ZEZvcm1hdGlvblJlc291cmNlLCBDbG91ZEZvcm1hdGlvblN0YWNrIH0gZnJvbSAnLi9jbG91ZGZvcm1hdGlvbic7XG5pbXBvcnQgeyBSZXNvdXJjZUdyYXBoIH0gZnJvbSAnLi9ncmFwaCc7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRpZ2VzdCBmb3IgZWFjaCByZXNvdXJjZSBpbiB0aGUgdGVtcGxhdGUuXG4gKlxuICogQ29uY2VwdHVhbGx5LCB0aGUgZGlnZXN0IGlzIGNvbXB1dGVkIGFzOlxuICpcbiAqICAgICBkKHJlc291cmNlKSA9IGhhc2godHlwZSArIHBoeXNpY2FsSWQpICAgICAgICAgICAgICAgICAgICAgICAsIGlmIHBoeXNpY2FsSWQgaXMgZGVmaW5lZFxuICogICAgICAgICAgICAgICAgID0gaGFzaCh0eXBlICsgcHJvcGVydGllcyArIGRlcGVuZGVuY2llcy5tYXAoZCkpICwgb3RoZXJ3aXNlXG4gKlxuICogd2hlcmUgYGhhc2hgIGlzIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uLiBJbiBvdGhlciB3b3JkcywgaWYgYSByZXNvdXJjZSBoYXNcbiAqIGEgcGh5c2ljYWwgSUQsIHdlIHVzZSB0aGUgcGh5c2ljYWwgSUQgcGx1cyBpdHMgdHlwZSB0byB1bmlxdWVseSBpZGVudGlmeVxuICogdGhhdCByZXNvdXJjZS4gSW4gdGhpcyBjYXNlLCB0aGUgZGlnZXN0IGNhbiBiZSBjb21wdXRlZCBmcm9tIHRoZXNlIHR3byBmaWVsZHNcbiAqIGFsb25lLiBBIGNvcm9sbGFyeSBpcyB0aGF0IHN1Y2ggcmVzb3VyY2VzIGNhbiBiZSByZW5hbWVkIGFuZCBoYXZlIHRoZWlyXG4gKiBwcm9wZXJ0aWVzIHVwZGF0ZWQgYXQgdGhlIHNhbWUgdGltZSwgYW5kIHN0aWxsIGJlIGNvbnNpZGVyZWQgZXF1aXZhbGVudC5cbiAqXG4gKiBPdGhlcndpc2UsIHRoZSBkaWdlc3QgaXMgY29tcHV0ZWQgZnJvbSBpdHMgdHlwZSwgaXRzIG93biBwcm9wZXJ0aWVzICh0aGF0IGlzLFxuICogZXhjbHVkaW5nIHByb3BlcnRpZXMgdGhhdCByZWZlciB0byBvdGhlciByZXNvdXJjZXMpLCBhbmQgdGhlIGRpZ2VzdHMgb2YgZWFjaCBvZlxuICogaXRzIGRlcGVuZGVuY2llcy5cbiAqXG4gKiBUaGUgZGlnZXN0IG9mIGEgcmVzb3VyY2UsIGRlZmluZWQgcmVjdXJzaXZlbHkgdGhpcyB3YXksIHJlbWFpbnMgc3RhYmxlIGV2ZW4gaWZcbiAqIG9uZSBvciBtb3JlIG9mIGl0cyBkZXBlbmRlbmNpZXMgZ2V0cyByZW5hbWVkLiBTaW5jZSB0aGUgcmVzb3VyY2VzIGluIGFcbiAqIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlIGZvcm0gYSBkaXJlY3RlZCBhY3ljbGljIGdyYXBoLCB0aGlzIGZ1bmN0aW9uIGlzXG4gKiB3ZWxsLWRlZmluZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlUmVzb3VyY2VEaWdlc3RzKHN0YWNrczogQ2xvdWRGb3JtYXRpb25TdGFja1tdKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gIGNvbnN0IGV4cG9ydHM6IHsgW3A6IHN0cmluZ106IHsgc3RhY2tOYW1lOiBzdHJpbmc7IHZhbHVlOiBhbnkgfSB9ID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIHN0YWNrcy5mbGF0TWFwKChzKSA9PlxuICAgICAgT2JqZWN0LnZhbHVlcyhzLnRlbXBsYXRlLk91dHB1dHMgPz8ge30pXG4gICAgICAgIC5maWx0ZXIoKG8pID0+IG8uRXhwb3J0ICE9IG51bGwgJiYgdHlwZW9mIG8uRXhwb3J0Lk5hbWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAubWFwKChvKSA9PiBbby5FeHBvcnQuTmFtZSwgeyBzdGFja05hbWU6IHMuc3RhY2tOYW1lLCB2YWx1ZTogby5WYWx1ZSB9XSBhcyBbc3RyaW5nLCB7IHN0YWNrTmFtZTogc3RyaW5nOyB2YWx1ZTogYW55IH1dKSxcbiAgICApLFxuICApO1xuXG4gIGNvbnN0IHJlc291cmNlcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBzdGFja3MuZmxhdE1hcCgocykgPT5cbiAgICAgIE9iamVjdC5lbnRyaWVzKHMudGVtcGxhdGUuUmVzb3VyY2VzID8/IHt9KS5tYXAoXG4gICAgICAgIChbaWQsIHJlc10pID0+IFtgJHtzLnN0YWNrTmFtZX0uJHtpZH1gLCByZXNdIGFzIFtzdHJpbmcsIENsb3VkRm9ybWF0aW9uUmVzb3VyY2VdLFxuICAgICAgKSxcbiAgICApLFxuICApO1xuXG4gIGNvbnN0IGdyYXBoID0gbmV3IFJlc291cmNlR3JhcGgoc3RhY2tzKTtcbiAgY29uc3Qgbm9kZXMgPSBncmFwaC5zb3J0ZWROb2RlcztcbiAgLy8gNC4gQ29tcHV0ZSBkaWdlc3RzIGluIHNvcnRlZCBvcmRlclxuICBjb25zdCByZXN1bHQ6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgZm9yIChjb25zdCBpZCBvZiBub2Rlcykge1xuICAgIGNvbnN0IHJlc291cmNlID0gcmVzb3VyY2VzW2lkXTtcbiAgICBjb25zdCByZXNvdXJjZVByb3BlcnRpZXMgPSByZXNvdXJjZS5Qcm9wZXJ0aWVzID8/IHt9O1xuICAgIGNvbnN0IG1vZGVsID0gbG9hZFJlc291cmNlTW9kZWwocmVzb3VyY2UuVHlwZSk7XG4gICAgY29uc3QgaWRlbnRpZmllciA9IGludGVyc2VjdGlvbihPYmplY3Qua2V5cyhyZXNvdXJjZVByb3BlcnRpZXMpLCBtb2RlbD8ucHJpbWFyeUlkZW50aWZpZXIgPz8gW10pO1xuICAgIGxldCB0b0hhc2g6IHN0cmluZztcblxuICAgIGlmIChpZGVudGlmaWVyLmxlbmd0aCA9PT0gbW9kZWw/LnByaW1hcnlJZGVudGlmaWVyPy5sZW5ndGgpIHtcbiAgICAgIC8vIFRoZSByZXNvdXJjZSBoYXMgYSBwaHlzaWNhbCBJRCBkZWZpbmVkLCBzbyB3ZSBjYW5cbiAgICAgIC8vIHVzZSB0aGUgSUQgYW5kIHRoZSB0eXBlIGFzIHRoZSBpZGVudGl0eSBvZiB0aGUgcmVzb3VyY2UuXG4gICAgICB0b0hhc2ggPVxuICAgICAgICByZXNvdXJjZS5UeXBlICtcbiAgICAgICAgaWRlbnRpZmllclxuICAgICAgICAgIC5zb3J0KClcbiAgICAgICAgICAubWFwKChhdHRyKSA9PiBKU09OLnN0cmluZ2lmeShyZXNvdXJjZVByb3BlcnRpZXNbYXR0cl0pKVxuICAgICAgICAgIC5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHJlc291cmNlIGRvZXMgbm90IGhhdmUgYSBwaHlzaWNhbCBJRCBkZWZpbmVkLCBzbyB3ZSBuZWVkIHRvXG4gICAgICAvLyBjb21wdXRlIHRoZSBkaWdlc3QgYmFzZWQgb24gaXRzIHByb3BlcnRpZXMgYW5kIGRlcGVuZGVuY2llcy5cbiAgICAgIGNvbnN0IGRlcERpZ2VzdHMgPSBBcnJheS5mcm9tKGdyYXBoLm91dE5laWdoYm9ycyhpZCkpLm1hcCgoZCkgPT4gcmVzdWx0W2RdKTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXNIYXNoID0gaGFzaE9iamVjdChzdHJpcFJlZmVyZW5jZXMoc3RyaXBDb25zdHJ1Y3RQYXRoKHJlc291cmNlKSwgZXhwb3J0cykpO1xuICAgICAgdG9IYXNoID0gcmVzb3VyY2UuVHlwZSArIHByb3BlcnRpZXNIYXNoICsgZGVwRGlnZXN0cy5qb2luKCcnKTtcbiAgICB9XG5cbiAgICByZXN1bHRbaWRdID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZSh0b0hhc2gpLmRpZ2VzdCgnaGV4Jyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzaE9iamVjdChvYmo6IGFueSk6IHN0cmluZyB7XG4gIGNvbnN0IGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2Jyk7XG5cbiAgZnVuY3Rpb24gYWRkVG9IYXNoKHZhbHVlOiBhbnkpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgYWRkVG9IYXNoKCdudWxsJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChhZGRUb0hhc2gpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmtleXModmFsdWUpXG4gICAgICAgICAgLnNvcnQoKVxuICAgICAgICAgIC5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGhhc2gudXBkYXRlKGtleSk7XG4gICAgICAgICAgICBhZGRUb0hhc2godmFsdWVba2V5XSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc2gudXBkYXRlKHR5cGVvZiB2YWx1ZSArIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfVxuXG4gIGFkZFRvSGFzaChvYmopO1xuICByZXR1cm4gaGFzaC5kaWdlc3QoJ2hleCcpO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgc3ViLXByb3BlcnRpZXMgY29udGFpbmluZyBSZWYgb3IgRm46OkdldEF0dCB0byBhdm9pZCBoYXNoaW5nXG4gKiByZWZlcmVuY2VzIHRoZW1zZWx2ZXMgYnV0IGtlZXBzIHRoZSBwcm9wZXJ0eSBzdHJ1Y3R1cmUuXG4gKi9cbmZ1bmN0aW9uIHN0cmlwUmVmZXJlbmNlcyh2YWx1ZTogYW55LCBleHBvcnRzOiB7IFtwOiBzdHJpbmddOiB7IHN0YWNrTmFtZTogc3RyaW5nOyB2YWx1ZTogYW55IH0gfSk6IGFueSB7XG4gIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgcmV0dXJuIHZhbHVlO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUubWFwKHggPT4gc3RyaXBSZWZlcmVuY2VzKHgsIGV4cG9ydHMpKTtcbiAgfVxuICBpZiAoJ1JlZicgaW4gdmFsdWUpIHtcbiAgICByZXR1cm4geyBfX2Nsb3VkX3JlZl9fOiAnUmVmJyB9O1xuICB9XG4gIGlmICgnRm46OkdldEF0dCcgaW4gdmFsdWUpIHtcbiAgICByZXR1cm4geyBfX2Nsb3VkX3JlZl9fOiAnRm46OkdldEF0dCcgfTtcbiAgfVxuICBpZiAoJ0RlcGVuZHNPbicgaW4gdmFsdWUpIHtcbiAgICByZXR1cm4geyBfX2Nsb3VkX3JlZl9fOiAnRGVwZW5kc09uJyB9O1xuICB9XG4gIGlmICgnRm46OkltcG9ydFZhbHVlJyBpbiB2YWx1ZSkge1xuICAgIGNvbnN0IHYgPSBleHBvcnRzW3ZhbHVlWydGbjo6SW1wb3J0VmFsdWUnXV0udmFsdWU7XG4gICAgLy8gVHJlYXQgRm46OkltcG9ydFZhbHVlIGFzIGlmIGl0IHdlcmUgYSByZWZlcmVuY2Ugd2l0aCB0aGUgc2FtZSBzdGFja1xuICAgIGlmICgnUmVmJyBpbiB2KSB7XG4gICAgICByZXR1cm4geyBfX2Nsb3VkX3JlZl9fOiAnUmVmJyB9O1xuICAgIH0gZWxzZSBpZiAoJ0ZuOjpHZXRBdHQnIGluIHYpIHtcbiAgICAgIHJldHVybiB7IF9fY2xvdWRfcmVmX186ICdGbjo6R2V0QXR0JyB9O1xuICAgIH1cbiAgfVxuICBjb25zdCByZXN1bHQ6IGFueSA9IHt9O1xuICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICByZXN1bHRba10gPSBzdHJpcFJlZmVyZW5jZXModiwgZXhwb3J0cyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc3RyaXBDb25zdHJ1Y3RQYXRoKHJlc291cmNlOiBhbnkpOiBhbnkge1xuICBpZiAocmVzb3VyY2U/Lk1ldGFkYXRhPy5bJ2F3czpjZGs6cGF0aCddID09IG51bGwpIHtcbiAgICByZXR1cm4gcmVzb3VyY2U7XG4gIH1cblxuICBjb25zdCBjb3B5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXNvdXJjZSkpO1xuICBkZWxldGUgY29weS5NZXRhZGF0YVsnYXdzOmNkazpwYXRoJ107XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb248VD4oYTogVFtdLCBiOiBUW10pOiBUW10ge1xuICByZXR1cm4gYS5maWx0ZXIoKHZhbHVlKSA9PiBiLmluY2x1ZGVzKHZhbHVlKSk7XG59XG4iXX0=