import { AmplifyDataDefinition, } from '@aws-amplify/data-construct';
import { resolveEntryPath } from './resolve_entry_path.js';
import { readFileSync } from 'fs';
import { parse, print } from 'graphql';
import { AmplifyUserError } from '@aws-amplify/platform-core';
/**
 * Determine if the input schema is a derived typed schema object (data-schema), and perform type narrowing.
 * @param schema the schema that might be a derived model schema
 * @returns a boolean indicating whether the schema is a derived model schema, with type narrowing
 */
export const isDataSchema = (schema) => {
    return (schema !== null &&
        typeof schema === 'object' &&
        'transform' in schema &&
        typeof schema.transform === 'function');
};
/**
 * Determine if the input schema is a collection of typed schemas, and perform type narrowing.
 * @param schema the schema that might be a collection of model schemas
 * @returns a boolean indicating whether the schema is a collection of derived model schema, with type narrowing
 */
export const isCombinedSchema = (schema) => {
    return (schema !== null &&
        typeof schema === 'object' &&
        'schemas' in schema &&
        Array.isArray(schema.schemas));
};
// DO NOT EDIT THE FOLLOWING VALUES, UPDATES TO DB TYPE OR STRATEGY WILL RESULT IN DB REPROVISIONING
// Conforms to this interface: https://github.com/aws-amplify/amplify-category-api/blob/274d1176d96e265d02817a975848c767d6d43c31/packages/amplify-graphql-api-construct/src/model-datasource-strategy-types.ts#L35-L41
const DYNAMO_DATA_SOURCE_STRATEGY = {
    dbType: 'DYNAMODB',
    provisionStrategy: 'AMPLIFY_TABLE',
};
// DO NOT EDIT THE FOLLOWING VALUES, UPDATES TO DB TYPE OR STRATEGY WILL RESULT IN DB REPROVISIONING
// Conforms to this interface: https://github.com/aws-amplify/amplify-category-api/blob/274d1176d96e265d02817a975848c767d6d43c31/packages/amplify-graphql-api-construct/src/model-datasource-strategy-types.ts#L35-L41
const IMPORTED_DYNAMO_DATA_SOURCE_STRATEGY = {
    dbType: 'DYNAMODB',
    provisionStrategy: 'IMPORTED_AMPLIFY_TABLE',
};
// Translate the external engine types to the config values
// Reference: https://github.com/aws-amplify/amplify-category-api/blob/fd7f6fbc17c199331c4b04debaff69ea0424cd74/packages/amplify-graphql-api-construct/src/model-datasource-strategy-types.ts#L25
const SQL_DB_TYPES = {
    mysql: 'MYSQL',
    postgresql: 'POSTGRES',
};
/**
 * Given an input schema type, produce the relevant CDK Graphql Def interface
 * @param schema TS schema builder definition or string GraphQL schema
 * @param backendSecretResolver secret resolver
 * @param stableBackendIdentifiers backend identifiers
 * @param importedTableName table name to use for imported models. If not defined the model is not imported.
 * @returns the cdk graphql definition interface
 */
export const convertSchemaToCDK = (schema, backendSecretResolver, stableBackendIdentifiers, importedTableName) => {
    if (isDataSchema(schema)) {
        /**
         * This is not super obvious, but the IAmplifyDataDefinition interface requires a record of each model type to a
         * data source strategy (how it should be deployed and managed). Normally this is handled for customers by static
         * methods on AmplifyDataDefinition, but since the data-schema-types don't produce that today, we use the builder
         * to generate that argument for us (so it's consistent with a customer using normal Graphql strings), then
         * apply that value back into the final IAmplifyDataDefinition output for data-schema users.
         */
        const { schema: transformedSchema, functionSlots, customSqlDataSourceStrategies, } = schema.transform();
        const provisionStrategyName = stableBackendIdentifiers.getStableBackendHash();
        const dbStrategy = convertDatabaseConfigurationToDataSourceStrategy(schema.data.configuration.database, customSqlDataSourceStrategies, backendSecretResolver, provisionStrategyName, importedTableName);
        const generatedModelDataSourceStrategies = AmplifyDataDefinition.fromString(transformedSchema, dbStrategy).dataSourceStrategies;
        if (dbStrategy.dbType === 'DYNAMODB') {
            return {
                schema: transformedSchema,
                functionSlots,
                dataSourceStrategies: generatedModelDataSourceStrategies,
            };
        }
        return {
            schema: transformedSchema,
            functionSlots,
            dataSourceStrategies: generatedModelDataSourceStrategies,
            customSqlDataSourceStrategies: customSqlDataSourceStrategies?.map((existing) => ({
                ...existing,
                strategy: dbStrategy,
            })) || [],
        };
    }
    if (importedTableName) {
        return AmplifyDataDefinition.fromString(schema, {
            ...IMPORTED_DYNAMO_DATA_SOURCE_STRATEGY,
            tableName: importedTableName,
        });
    }
    return AmplifyDataDefinition.fromString(schema, DYNAMO_DATA_SOURCE_STRATEGY);
};
/**
 * Given an input list of CDK Graphql Def interface schemas, produce the relevant CDK Graphql Def interface
 * @param schemas the cdk graphql definition interfaces to combine
 * @returns the cdk graphql definition interface
 */
export const combineCDKSchemas = (schemas) => {
    return AmplifyDataDefinition.combine(schemas);
};
/**
 * Given the generated rds builder database configuration, convert it into the DataSource strategy
 * @param configuration the database configuration from `data-schema`
 * @returns the data strategy needed to configure the data source
 */
const convertDatabaseConfigurationToDataSourceStrategy = (configuration, customSqlDataSourceStrategies = [], backendSecretResolver, provisionStrategyName, importedTableName) => {
    if (configuration.engine === 'dynamodb') {
        if (importedTableName) {
            return {
                ...IMPORTED_DYNAMO_DATA_SOURCE_STRATEGY,
                tableName: importedTableName,
            };
        }
        return DYNAMO_DATA_SOURCE_STRATEGY;
    }
    const dbType = SQL_DB_TYPES[configuration.engine];
    let vpcConfiguration = undefined;
    if (configuration.vpcConfig !== undefined) {
        vpcConfiguration = {
            vpcId: configuration.vpcConfig.vpcId,
            securityGroupIds: configuration.vpcConfig.securityGroupIds,
            subnetAvailabilityZoneConfig: configuration.vpcConfig.subnetAvailabilityZones,
        };
    }
    const customSqlStatements = customSqlStatementsFromStrategies(customSqlDataSourceStrategies);
    const { branchSecretPath, sharedSecretPath } = backendSecretResolver.resolvePath(configuration.connectionUri);
    let sslCertConfig;
    if (configuration.sslCert) {
        const { branchSecretPath, sharedSecretPath } = backendSecretResolver.resolvePath(configuration.sslCert);
        sslCertConfig = {
            ssmPath: [branchSecretPath, sharedSecretPath],
        };
    }
    const strategy = {
        dbType,
        name: provisionStrategyName +
            (configuration.identifier ?? configuration.engine),
        dbConnectionConfig: {
            connectionUriSsmPath: [branchSecretPath, sharedSecretPath],
            ...(sslCertConfig ? { sslCertConfig } : undefined),
        },
        vpcConfiguration,
        customSqlStatements,
    };
    return strategy;
};
/**
 * Create a custom sql statement reference dictionary
 * @param customSqlDataSourceStrategies custom sql handler defined in the schema
 * @returns an object mapping the file path to the sql statement
 */
const customSqlStatementsFromStrategies = (customSqlDataSourceStrategies) => {
    const customSqlStatements = customSqlDataSourceStrategies
        .filter((sqlStrategy) => sqlStrategy.entry !== undefined)
        .reduce((acc, sqlStrategy) => {
        const entry = sqlStrategy.entry;
        const reference = typeof entry === 'string' ? entry : entry.relativePath;
        const resolvedPath = resolveEntryPath(entry);
        acc[reference] = readFileSync(resolvedPath, 'utf8');
        return acc;
    }, {});
    return customSqlStatements;
};
/**
 * Split the schema into multiple schemas based on the table map.
 * If the model corresponds to an imported table then move that model to a separate schema and include the table name
 * @param schemas GraphQL schemas
 * @param amplifyGen1DynamoDbTableMapping Table names for the models that should be imported.
 * @returns an array of split schemas with the imported table name if applicable
 */
export const splitSchemasByTableMap = (schemas, amplifyGen1DynamoDbTableMapping) => {
    const splitSchemas = schemas.flatMap((schema) => {
        // data schema not supported for import
        if (!isDataSchema(schema)) {
            const { importedSchemas, nonImportedSchema } = extractImportedModels(schema, amplifyGen1DynamoDbTableMapping?.modelNameToTableNameMapping);
            if (importedSchemas.length > 0) {
                return [
                    ...importedSchemas.map(({ schema, importedTableName }) => ({
                        schema,
                        importedTableName,
                    })),
                    ...(nonImportedSchema ? [{ schema: nonImportedSchema }] : []),
                ];
            }
        }
        return [{ schema }];
    });
    return splitSchemas;
};
/**
 * Extracts the imported models from non-imported models in a single string schema.
 * @param schema String GraphQL schema
 * @param modelNameToTableNameMapping Table names for the models that should be extracted.
 * @returns a schema split into imported models and non-imported models
 */
const extractImportedModels = (schema, modelNameToTableNameMapping) => {
    const importedModels = Object.keys(modelNameToTableNameMapping ?? {});
    if (importedModels?.length) {
        const parsedSchema = parse(schema);
        const [importedDefinitionNodes, nonImportedDefinitionNodes] = partition(parsedSchema.definitions, (definitionNode) => {
            return (definitionNode.kind === 'ObjectTypeDefinition' &&
                importedModels.includes(definitionNode.name.value));
        });
        // ok to cast as ObjectTypeDefinitionNode because the type was checked in the partition function
        const importedObjectTypeDefinitionNodes = importedDefinitionNodes;
        importedModels.forEach((modelName) => {
            if (!importedObjectTypeDefinitionNodes.some((definitionNode) => definitionNode.name.value === modelName)) {
                throw new AmplifyUserError('DefineDataConfigurationError', {
                    message: `Imported model not found in schema: ${modelName}`,
                    resolution: `Add ${modelName} to the schema.`,
                });
            }
        });
        const importedSchemas = importedObjectTypeDefinitionNodes.map((definitionNode) => {
            const importedTableName = (modelNameToTableNameMapping ?? {})[definitionNode.name.value];
            if (!importedTableName) {
                throw new AmplifyUserError('DefineDataConfigurationError', {
                    message: `No table found for imported model ${definitionNode.name.value}.`,
                    resolution: `Add a table name for ${definitionNode.name.value} in the modelNameToTableNameMapping.`,
                });
            }
            return {
                schema: print({
                    definitions: [definitionNode],
                    kind: 'Document',
                }),
                importedTableName,
            };
        });
        const nonImportedSchema = nonImportedDefinitionNodes.length
            ? print({
                definitions: nonImportedDefinitionNodes,
                kind: 'Document',
            })
            : undefined;
        return {
            importedSchemas,
            nonImportedSchema,
        };
    }
    return {
        importedSchemas: [],
        nonImportedSchema: schema,
    };
};
/* partition a list based on a predicate. If isLeft is true, the item goes in the left list, otherwise it goes in the right list */
const partition = (array, isLeft) => {
    return array.reduce(([left, right], item) => {
        return isLeft(item) ? [[...left, item], right] : [left, [...right, item]];
    }, [[], []]);
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udmVydF9zY2hlbWEuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvY29udmVydF9zY2hlbWEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBT0EsT0FBTyxFQUNMLHFCQUFxQixHQUt0QixNQUFNLDZCQUE2QixDQUFDO0FBVXJDLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQzNELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxJQUFJLENBQUM7QUFDbEMsT0FBTyxFQUE0QixLQUFLLEVBQUUsS0FBSyxFQUFFLE1BQU0sU0FBUyxDQUFDO0FBQ2pFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBRTlEOzs7O0dBSUc7QUFDSCxNQUFNLENBQUMsTUFBTSxZQUFZLEdBQUcsQ0FDMUIsTUFBa0IsRUFDVyxFQUFFO0lBQy9CLE9BQU8sQ0FDTCxNQUFNLEtBQUssSUFBSTtRQUNmLE9BQU8sTUFBTSxLQUFLLFFBQVE7UUFDMUIsV0FBVyxJQUFJLE1BQU07UUFDckIsT0FBTyxNQUFNLENBQUMsU0FBUyxLQUFLLFVBQVUsQ0FDdkMsQ0FBQztBQUNKLENBQUMsQ0FBQztBQUVGOzs7O0dBSUc7QUFDSCxNQUFNLENBQUMsTUFBTSxnQkFBZ0IsR0FBRyxDQUM5QixNQUF1QixFQUNVLEVBQUU7SUFDbkMsT0FBTyxDQUNMLE1BQU0sS0FBSyxJQUFJO1FBQ2YsT0FBTyxNQUFNLEtBQUssUUFBUTtRQUMxQixTQUFTLElBQUksTUFBTTtRQUNuQixLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FDOUIsQ0FBQztBQUNKLENBQUMsQ0FBQztBQUVGLG9HQUFvRztBQUNwRyxzTkFBc047QUFDdE4sTUFBTSwyQkFBMkIsR0FBRztJQUNsQyxNQUFNLEVBQUUsVUFBVTtJQUNsQixpQkFBaUIsRUFBRSxlQUFlO0NBQzFCLENBQUM7QUFFWCxvR0FBb0c7QUFDcEcsc05BQXNOO0FBQ3RO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QixDQUFDO1lBQ0osQ0FBQyxDQUFDLFNBQVMsQ0FBQztRQUNkLE9BQU87WUFDTCxlQUFlO1lBQ2YsaUJBQWlCO1NBQ2xCLENBQUM7SUFDSixDQUFDO0lBQ0QsT0FBTztRQUNMLGVBQWUsRUFBRSxFQUFFO1FBQ25CLGlCQUFpQixFQUFFLE1BQU07S0FDMUIsQ0FBQztBQUNKLENBQUMsQ0FBQztBQUVGLG1JQUFtSTtBQUNuSSxNQUFNLFNBQVMsR0FBRyxDQUNoQixLQUFtQixFQUNuQixNQUE0QixFQUNoQixFQUFFO0lBQ2QsT0FBTyxLQUFLLENBQUMsTUFBTSxDQUNqQixDQUFDLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxFQUFFLElBQUksRUFBRSxFQUFFO1FBQ3RCLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUM1RSxDQUFDLEVBQ0QsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFlLENBQ3ZCLENBQUM7QUFDSixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7XG4gIEN1c3RvbVNxbERhdGFTb3VyY2VTdHJhdGVneSxcbiAgRGF0YVNvdXJjZUNvbmZpZ3VyYXRpb24sXG4gIERlcml2ZWRDb21iaW5lZFNjaGVtYSxcbiAgRGVyaXZlZE1vZGVsU2NoZW1hIGFzIERlcml2ZWREYXRhU2NoZW1hLFxuICBEZXJpdmVkTW9kZWxTY2hlbWEsXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9kYXRhLXNjaGVtYS10eXBlcyc7XG5pbXBvcnQge1xuICBBbXBsaWZ5RGF0YURlZmluaXRpb24sXG4gIHR5cGUgSUFtcGxpZnlEYXRhRGVmaW5pdGlvbixcbiAgdHlwZSBNb2RlbERhdGFTb3VyY2VTdHJhdGVneSxcbiAgdHlwZSBTc2xDZXJ0U3NtUGF0aENvbmZpZyxcbiAgdHlwZSBWcGNDb25maWcsXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9kYXRhLWNvbnN0cnVjdCc7XG5pbXBvcnQgdHlwZSB7XG4gIEFtcGxpZnlHZW4xRHluYW1vRGJUYWJsZU1hcHBpbmcsXG4gIERhdGFTY2hlbWEsXG4gIERhdGFTY2hlbWFJbnB1dCxcbn0gZnJvbSAnLi90eXBlcy5qcyc7XG5pbXBvcnQgdHlwZSB7XG4gIEJhY2tlbmRTZWNyZXRSZXNvbHZlcixcbiAgU3RhYmxlQmFja2VuZElkZW50aWZpZXJzLFxufSBmcm9tICdAYXdzLWFtcGxpZnkvcGx1Z2luLXR5cGVzJztcbmltcG9ydCB7IHJlc29sdmVFbnRyeVBhdGggfSBmcm9tICcuL3Jlc29sdmVfZW50cnlfcGF0aC5qcyc7XG5pbXBvcnQgeyByZWFkRmlsZVN5bmMgfSBmcm9tICdmcyc7XG5pbXBvcnQgeyBPYmplY3RUeXBlRGVmaW5pdGlvbk5vZGUsIHBhcnNlLCBwcmludCB9IGZyb20gJ2dyYXBocWwnO1xuaW1wb3J0IHsgQW1wbGlmeVVzZXJFcnJvciB9IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbGF0Zm9ybS1jb3JlJztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGlucHV0IHNjaGVtYSBpcyBhIGRlcml2ZWQgdHlwZWQgc2NoZW1hIG9iamVjdCAoZGF0YS1zY2hlbWEpLCBhbmQgcGVyZm9ybSB0eXBlIG5hcnJvd2luZy5cbiAqIEBwYXJhbSBzY2hlbWEgdGhlIHNjaGVtYSB0aGF0IG1pZ2h0IGJlIGEgZGVyaXZlZCBtb2RlbCBzY2hlbWFcbiAqIEByZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHNjaGVtYSBpcyBhIGRlcml2ZWQgbW9kZWwgc2NoZW1hLCB3aXRoIHR5cGUgbmFycm93aW5nXG4gKi9cbmV4cG9ydCBjb25zdCBpc0RhdGFTY2hlbWEgPSAoXG4gIHNjaGVtYTogRGF0YVNjaGVtYSxcbik6IHNjaGVtYSBpcyBEZXJpdmVkRGF0YVNjaGVtYSA9PiB7XG4gIHJldHVybiAoXG4gICAgc2NoZW1hICE9PSBudWxsICYmXG4gICAgdHlwZW9mIHNjaGVtYSA9PT0gJ29iamVjdCcgJiZcbiAgICAndHJhbnNmb3JtJyBpbiBzY2hlbWEgJiZcbiAgICB0eXBlb2Ygc2NoZW1hLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJ1xuICApO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGlucHV0IHNjaGVtYSBpcyBhIGNvbGxlY3Rpb24gb2YgdHlwZWQgc2NoZW1hcywgYW5kIHBlcmZvcm0gdHlwZSBuYXJyb3dpbmcuXG4gKiBAcGFyYW0gc2NoZW1hIHRoZSBzY2hlbWEgdGhhdCBtaWdodCBiZSBhIGNvbGxlY3Rpb24gb2YgbW9kZWwgc2NoZW1hc1xuICogQHJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgc2NoZW1hIGlzIGEgY29sbGVjdGlvbiBvZiBkZXJpdmVkIG1vZGVsIHNjaGVtYSwgd2l0aCB0eXBlIG5hcnJvd2luZ1xuICovXG5leHBvcnQgY29uc3QgaXNDb21iaW5lZFNjaGVtYSA9IChcbiAgc2NoZW1hOiBEYXRhU2NoZW1hSW5wdXQsXG4pOiBzY2hlbWEgaXMgRGVyaXZlZENvbWJpbmVkU2NoZW1hID0+IHtcbiAgcmV0dXJuIChcbiAgICBzY2hlbWEgIT09IG51bGwgJiZcbiAgICB0eXBlb2Ygc2NoZW1hID09PSAnb2JqZWN0JyAmJlxuICAgICdzY2hlbWFzJyBpbiBzY2hlbWEgJiZcbiAgICBBcnJheS5pc0FycmF5KHNjaGVtYS5zY2hlbWFzKVxuICApO1xufTtcblxuLy8gRE8gTk9UIEVESVQgVEhFIEZPTExPV0lORyBWQUxVRVMsIFVQREFURVMgVE8gREIgVFlQRSBPUiBTVFJBVEVHWSBXSUxMIFJFU1VMVCBJTiBEQiBSRVBST1ZJU0lPTklOR1xuLy8gQ29uZm9ybXMgdG8gdGhpcyBpbnRlcmZhY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MtYW1wbGlmeS9hbXBsaWZ5LWNhdGVnb3J5LWFwaS9ibG9iLzI3NGQxMTc2ZDk2ZTI2NWQwMjgxN2E5NzU4NDhjNzY3ZDZkNDNjMzEvcGFja2FnZXMvYW1wbGlmeS1ncmFwaHFsLWFwaS1jb25zdHJ1Y3Qvc3JjL21vZGVsLWRhdGFzb3VyY2Utc3RyYXRlZ3ktdHlwZXMudHMjTDM1LUw0MVxuY29uc3QgRFlOQU1PX0RBVEFfU09VUkNFX1NUUkFURUdZID0ge1xuICBkYlR5cGU6ICdEWU5BTU9EQicsXG4gIHByb3Zpc2lvblN0cmF0ZWd5OiAnQU1QTElGWV9UQUJMRScsXG59IGFzIGNvbnN0O1xuXG4vLyBETyBOT1QgRURJVCBUSEUgRk9MTE9XSU5HIFZBTFVFUywgVVBEQVRFUyBUTyBEQiBUWVBFIE9SIFNUUkFURUdZIFdJTEwgUkVTVUxUIElOIERCIFJFUFJPVklTSU9OSU5HXG4vLyBDb25mb3JtcyB0byB0aGlzIGludGVyZmFjZTogaHR0cHM6Ly9naXRodWIuY29tL2F3cy1hbXBsaWZ5L2FtcGxpZnktY2F0ZWdvcnktYXBpL2Jsb2IvMjc0ZDExNzZkOTZlMjY1ZDAyODE3YTk3NTg0OGM3NjdkNmQ0M2MzMS9wYWNrYWdlcy9hbXBsaWZ5LWdyYXBocWwtYXBpLWNvbnN0cnVjdC9zcmMvbW9kZWwtZGF0YXNvdXJjZS1zdHJhdGVneS10eXBlcy50cyNMMzUtTDQxXG5jb25zdCBJTVBPUlRFRF9EWU5BTU9fREFUQV9TT1VSQ0VfU1RSQVRFR1kgPSB7XG4gIGRiVHlwZTogJ0RZTkFNT0RCJyxcbiAgcHJvdmlzaW9uU3RyYXRlZ3k6ICdJTVBPUlRFRF9BTVBMSUZZX1RBQkxFJyxcbn0gYXMgY29uc3Q7XG5cbi8vIFRyYW5zbGF0ZSB0aGUgZXh0ZXJuYWwgZW5naW5lIHR5cGVzIHRvIHRoZSBjb25maWcgdmFsdWVzXG4vLyBSZWZlcmVuY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MtYW1wbGlmeS9hbXBsaWZ5LWNhdGVnb3J5LWFwaS9ibG9iL2ZkN2Y2ZmJjMTdjMTk5MzMxYzRiMDRkZWJhZmY2OWVhMDQyNGNkNzQvcGFja2FnZXMvYW1wbGlmeS1ncmFwaHFsLWFwaS1jb25zdHJ1Y3Qvc3JjL21vZGVsLWRhdGFzb3VyY2Utc3RyYXRlZ3ktdHlwZXMudHMjTDI1XG5jb25zdCBTUUxfREJfVFlQRVMgPSB7XG4gIG15c3FsOiAnTVlTUUwnLFxuICBwb3N0Z3Jlc3FsOiAnUE9TVEdSRVMnLFxufSBhcyBjb25zdDtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbnB1dCBzY2hlbWEgdHlwZSwgcHJvZHVjZSB0aGUgcmVsZXZhbnQgQ0RLIEdyYXBocWwgRGVmIGludGVyZmFjZVxuICogQHBhcmFtIHNjaGVtYSBUUyBzY2hlbWEgYnVpbGRlciBkZWZpbml0aW9uIG9yIHN0cmluZyBHcmFwaFFMIHNjaGVtYVxuICogQHBhcmFtIGJhY2tlbmRTZWNyZXRSZXNvbHZlciBzZWNyZXQgcmVzb2x2ZXJcbiAqIEBwYXJhbSBzdGFibGVCYWNrZW5kSWRlbnRpZmllcnMgYmFja2VuZCBpZGVudGlmaWVyc1xuICogQHBhcmFtIGltcG9ydGVkVGFibGVOYW1lIHRhYmxlIG5hbWUgdG8gdXNlIGZvciBpbXBvcnRlZCBtb2RlbHMuIElmIG5vdCBkZWZpbmVkIHRoZSBtb2RlbCBpcyBub3QgaW1wb3J0ZWQuXG4gKiBAcmV0dXJucyB0aGUgY2RrIGdyYXBocWwgZGVmaW5pdGlvbiBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnZlcnRTY2hlbWFUb0NESyA9IChcbiAgc2NoZW1hOiBEYXRhU2NoZW1hLFxuICBiYWNrZW5kU2VjcmV0UmVzb2x2ZXI6IEJhY2tlbmRTZWNyZXRSZXNvbHZlcixcbiAgc3RhYmxlQmFja2VuZElkZW50aWZpZXJzOiBTdGFibGVCYWNrZW5kSWRlbnRpZmllcnMsXG4gIGltcG9ydGVkVGFibGVOYW1lPzogc3RyaW5nLFxuKTogSUFtcGxpZnlEYXRhRGVmaW5pdGlvbiA9PiB7XG4gIGlmIChpc0RhdGFTY2hlbWEoc2NoZW1hKSkge1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgbm90IHN1cGVyIG9idmlvdXMsIGJ1dCB0aGUgSUFtcGxpZnlEYXRhRGVmaW5pdGlvbiBpbnRlcmZhY2UgcmVxdWlyZXMgYSByZWNvcmQgb2YgZWFjaCBtb2RlbCB0eXBlIHRvIGFcbiAgICAgKiBkYXRhIHNvdXJjZSBzdHJhdGVneSAoaG93IGl0IHNob3VsZCBiZSBkZXBsb3llZCBhbmQgbWFuYWdlZCkuIE5vcm1hbGx5IHRoaXMgaXMgaGFuZGxlZCBmb3IgY3VzdG9tZXJzIGJ5IHN0YXRpY1xuICAgICAqIG1ldGhvZHMgb24gQW1wbGlmeURhdGFEZWZpbml0aW9uLCBidXQgc2luY2UgdGhlIGRhdGEtc2NoZW1hLXR5cGVzIGRvbid0IHByb2R1Y2UgdGhhdCB0b2RheSwgd2UgdXNlIHRoZSBidWlsZGVyXG4gICAgICogdG8gZ2VuZXJhdGUgdGhhdCBhcmd1bWVudCBmb3IgdXMgKHNvIGl0J3MgY29uc2lzdGVudCB3aXRoIGEgY3VzdG9tZXIgdXNpbmcgbm9ybWFsIEdyYXBocWwgc3RyaW5ncyksIHRoZW5cbiAgICAgKiBhcHBseSB0aGF0IHZhbHVlIGJhY2sgaW50byB0aGUgZmluYWwgSUFtcGxpZnlEYXRhRGVmaW5pdGlvbiBvdXRwdXQgZm9yIGRhdGEtc2NoZW1hIHVzZXJzLlxuICAgICAqL1xuICAgIGNvbnN0IHtcbiAgICAgIHNjaGVtYTogdHJhbnNmb3JtZWRTY2hlbWEsXG4gICAgICBmdW5jdGlvblNsb3RzLFxuICAgICAgY3VzdG9tU3FsRGF0YVNvdXJjZVN0cmF0ZWdpZXMsXG4gICAgfSA9IHNjaGVtYS50cmFuc2Zvcm0oKTtcblxuICAgIGNvbnN0IHByb3Zpc2lvblN0cmF0ZWd5TmFtZSA9XG4gICAgICBzdGFibGVCYWNrZW5kSWRlbnRpZmllcnMuZ2V0U3RhYmxlQmFja2VuZEhhc2goKTtcblxuICAgIGNvbnN0IGRiU3RyYXRlZ3kgPSBjb252ZXJ0RGF0YWJhc2VDb25maWd1cmF0aW9uVG9EYXRhU291cmNlU3RyYXRlZ3koXG4gICAgICBzY2hlbWEuZGF0YS5jb25maWd1cmF0aW9uLmRhdGFiYXNlLFxuICAgICAgY3VzdG9tU3FsRGF0YVNvdXJjZVN0cmF0ZWdpZXMsXG4gICAgICBiYWNrZW5kU2VjcmV0UmVzb2x2ZXIsXG4gICAgICBwcm92aXNpb25TdHJhdGVneU5hbWUsXG4gICAgICBpbXBvcnRlZFRhYmxlTmFtZSxcbiAgICApO1xuXG4gICAgY29uc3QgZ2VuZXJhdGVkTW9kZWxEYXRhU291cmNlU3RyYXRlZ2llcyA9IEFtcGxpZnlEYXRhRGVmaW5pdGlvbi5mcm9tU3RyaW5nKFxuICAgICAgdHJhbnNmb3JtZWRTY2hlbWEsXG4gICAgICBkYlN0cmF0ZWd5LFxuICAgICkuZGF0YVNvdXJjZVN0cmF0ZWdpZXM7XG5cbiAgICBpZiAoZGJTdHJhdGVneS5kYlR5cGUgPT09ICdEWU5BTU9EQicpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjaGVtYTogdHJhbnNmb3JtZWRTY2hlbWEsXG4gICAgICAgIGZ1bmN0aW9uU2xvdHMsXG4gICAgICAgIGRhdGFTb3VyY2VTdHJhdGVnaWVzOiBnZW5lcmF0ZWRNb2RlbERhdGFTb3VyY2VTdHJhdGVnaWVzLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2NoZW1hOiB0cmFuc2Zvcm1lZFNjaGVtYSxcbiAgICAgIGZ1bmN0aW9uU2xvdHMsXG4gICAgICBkYXRhU291cmNlU3RyYXRlZ2llczogZ2VuZXJhdGVkTW9kZWxEYXRhU291cmNlU3RyYXRlZ2llcyxcbiAgICAgIGN1c3RvbVNxbERhdGFTb3VyY2VTdHJhdGVnaWVzOlxuICAgICAgICBjdXN0b21TcWxEYXRhU291cmNlU3RyYXRlZ2llcz8ubWFwKFxuICAgICAgICAgIChleGlzdGluZzogQ3VzdG9tU3FsRGF0YVNvdXJjZVN0cmF0ZWd5KSA9PiAoe1xuICAgICAgICAgICAgLi4uZXhpc3RpbmcsXG4gICAgICAgICAgICBzdHJhdGVneTogZGJTdHJhdGVneSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgKSB8fCBbXSxcbiAgICB9O1xuICB9XG5cbiAgaWYgKGltcG9ydGVkVGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIEFtcGxpZnlEYXRhRGVmaW5pdGlvbi5mcm9tU3RyaW5nKHNjaGVtYSwge1xuICAgICAgLi4uSU1QT1JURURfRFlOQU1PX0RBVEFfU09VUkNFX1NUUkFURUdZLFxuICAgICAgdGFibGVOYW1lOiBpbXBvcnRlZFRhYmxlTmFtZSxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gQW1wbGlmeURhdGFEZWZpbml0aW9uLmZyb21TdHJpbmcoc2NoZW1hLCBEWU5BTU9fREFUQV9TT1VSQ0VfU1RSQVRFR1kpO1xufTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbnB1dCBsaXN0IG9mIENESyBHcmFwaHFsIERlZiBpbnRlcmZhY2Ugc2NoZW1hcywgcHJvZHVjZSB0aGUgcmVsZXZhbnQgQ0RLIEdyYXBocWwgRGVmIGludGVyZmFjZVxuICogQHBhcmFtIHNjaGVtYXMgdGhlIGNkayBncmFwaHFsIGRlZmluaXRpb24gaW50ZXJmYWNlcyB0byBjb21iaW5lXG4gKiBAcmV0dXJucyB0aGUgY2RrIGdyYXBocWwgZGVmaW5pdGlvbiBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbWJpbmVDREtTY2hlbWFzID0gKFxuICBzY2hlbWFzOiBJQW1wbGlmeURhdGFEZWZpbml0aW9uW10sXG4pOiBJQW1wbGlmeURhdGFEZWZpbml0aW9uID0+IHtcbiAgcmV0dXJuIEFtcGxpZnlEYXRhRGVmaW5pdGlvbi5jb21iaW5lKHNjaGVtYXMpO1xufTtcblxuLyoqXG4gKiBHaXZlbiB0aGUgZ2VuZXJhdGVkIHJkcyBidWlsZGVyIGRhdGFiYXNlIGNvbmZpZ3VyYXRpb24sIGNvbnZlcnQgaXQgaW50byB0aGUgRGF0YVNvdXJjZSBzdHJhdGVneVxuICogQHBhcmFtIGNvbmZpZ3VyYXRpb24gdGhlIGRhdGFiYXNlIGNvbmZpZ3VyYXRpb24gZnJvbSBgZGF0YS1zY2hlbWFgXG4gKiBAcmV0dXJucyB0aGUgZGF0YSBzdHJhdGVneSBuZWVkZWQgdG8gY29uZmlndXJlIHRoZSBkYXRhIHNvdXJjZVxuICovXG5jb25zdCBjb252ZXJ0RGF0YWJhc2VDb25maWd1cmF0aW9uVG9EYXRhU291cmNlU3RyYXRlZ3kgPSAoXG4gIGNvbmZpZ3VyYXRpb246IERhdGFTb3VyY2VDb25maWd1cmF0aW9uLFxuICBjdXN0b21TcWxEYXRhU291cmNlU3RyYXRlZ2llczogQ3VzdG9tU3FsRGF0YVNvdXJjZVN0cmF0ZWd5W10gPSBbXSxcbiAgYmFja2VuZFNlY3JldFJlc29sdmVyOiBCYWNrZW5kU2VjcmV0UmVzb2x2ZXIsXG4gIHByb3Zpc2lvblN0cmF0ZWd5TmFtZTogc3RyaW5nLFxuICBpbXBvcnRlZFRhYmxlTmFtZT86IHN0cmluZyxcbik6IE1vZGVsRGF0YVNvdXJjZVN0cmF0ZWd5ID0+IHtcbiAgaWYgKGNvbmZpZ3VyYXRpb24uZW5naW5lID09PSAnZHluYW1vZGInKSB7XG4gICAgaWYgKGltcG9ydGVkVGFibGVOYW1lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5JTVBPUlRFRF9EWU5BTU9fREFUQV9TT1VSQ0VfU1RSQVRFR1ksXG4gICAgICAgIHRhYmxlTmFtZTogaW1wb3J0ZWRUYWJsZU5hbWUsXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gRFlOQU1PX0RBVEFfU09VUkNFX1NUUkFURUdZO1xuICB9XG5cbiAgY29uc3QgZGJUeXBlID0gU1FMX0RCX1RZUEVTW2NvbmZpZ3VyYXRpb24uZW5naW5lXTtcbiAgbGV0IHZwY0NvbmZpZ3VyYXRpb246IFZwY0NvbmZpZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICBpZiAoY29uZmlndXJhdGlvbi52cGNDb25maWcgIT09IHVuZGVmaW5lZCkge1xuICAgIHZwY0NvbmZpZ3VyYXRpb24gPSB7XG4gICAgICB2cGNJZDogY29uZmlndXJhdGlvbi52cGNDb25maWcudnBjSWQsXG4gICAgICBzZWN1cml0eUdyb3VwSWRzOiBjb25maWd1cmF0aW9uLnZwY0NvbmZpZy5zZWN1cml0eUdyb3VwSWRzLFxuICAgICAgc3VibmV0QXZhaWxhYmlsaXR5Wm9uZUNvbmZpZzpcbiAgICAgICAgY29uZmlndXJhdGlvbi52cGNDb25maWcuc3VibmV0QXZhaWxhYmlsaXR5Wm9uZXMsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGN1c3RvbVNxbFN0YXRlbWVudHMgPSBjdXN0b21TcWxTdGF0ZW1lbnRzRnJvbVN0cmF0ZWdpZXMoXG4gICAgY3VzdG9tU3FsRGF0YVNvdXJjZVN0cmF0ZWdpZXMsXG4gICk7XG5cbiAgY29uc3QgeyBicmFuY2hTZWNyZXRQYXRoLCBzaGFyZWRTZWNyZXRQYXRoIH0gPVxuICAgIGJhY2tlbmRTZWNyZXRSZXNvbHZlci5yZXNvbHZlUGF0aChjb25maWd1cmF0aW9uLmNvbm5lY3Rpb25VcmkpO1xuXG4gIGxldCBzc2xDZXJ0Q29uZmlnOiBTc2xDZXJ0U3NtUGF0aENvbmZpZyB8IHVuZGVmaW5lZDtcbiAgaWYgKGNvbmZpZ3VyYXRpb24uc3NsQ2VydCkge1xuICAgIGNvbnN0IHsgYnJhbmNoU2VjcmV0UGF0aCwgc2hhcmVkU2VjcmV0UGF0aCB9ID1cbiAgICAgIGJhY2tlbmRTZWNyZXRSZXNvbHZlci5yZXNvbHZlUGF0aChjb25maWd1cmF0aW9uLnNzbENlcnQpO1xuICAgIHNzbENlcnRDb25maWcgPSB7XG4gICAgICBzc21QYXRoOiBbYnJhbmNoU2VjcmV0UGF0aCwgc2hhcmVkU2VjcmV0UGF0aF0sXG4gICAgfTtcbiAgfVxuICBjb25zdCBzdHJhdGVneTogTW9kZWxEYXRhU291cmNlU3RyYXRlZ3kgPSB7XG4gICAgZGJUeXBlLFxuICAgIG5hbWU6XG4gICAgICBwcm92aXNpb25TdHJhdGVneU5hbWUgK1xuICAgICAgKGNvbmZpZ3VyYXRpb24uaWRlbnRpZmllciA/PyBjb25maWd1cmF0aW9uLmVuZ2luZSksXG4gICAgZGJDb25uZWN0aW9uQ29uZmlnOiB7XG4gICAgICBjb25uZWN0aW9uVXJpU3NtUGF0aDogW2JyYW5jaFNlY3JldFBhdGgsIHNoYXJlZFNlY3JldFBhdGhdLFxuICAgICAgLi4uKHNzbENlcnRDb25maWcgPyB7IHNzbENlcnRDb25maWcgfSA6IHVuZGVmaW5lZCksXG4gICAgfSxcbiAgICB2cGNDb25maWd1cmF0aW9uLFxuICAgIGN1c3RvbVNxbFN0YXRlbWVudHMsXG4gIH07XG5cbiAgcmV0dXJuIHN0cmF0ZWd5O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBjdXN0b20gc3FsIHN0YXRlbWVudCByZWZlcmVuY2UgZGljdGlvbmFyeVxuICogQHBhcmFtIGN1c3RvbVNxbERhdGFTb3VyY2VTdHJhdGVnaWVzIGN1c3RvbSBzcWwgaGFuZGxlciBkZWZpbmVkIGluIHRoZSBzY2hlbWFcbiAqIEByZXR1cm5zIGFuIG9iamVjdCBtYXBwaW5nIHRoZSBmaWxlIHBhdGggdG8gdGhlIHNxbCBzdGF0ZW1lbnRcbiAqL1xuY29uc3QgY3VzdG9tU3FsU3RhdGVtZW50c0Zyb21TdHJhdGVnaWVzID0gKFxuICBjdXN0b21TcWxEYXRhU291cmNlU3RyYXRlZ2llczogQ3VzdG9tU3FsRGF0YVNvdXJjZVN0cmF0ZWd5W10sXG4pOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0+IHtcbiAgY29uc3QgY3VzdG9tU3FsU3RhdGVtZW50cyA9IGN1c3RvbVNxbERhdGFTb3VyY2VTdHJhdGVnaWVzXG4gICAgLmZpbHRlcigoc3FsU3RyYXRlZ3kpID0+IHNxbFN0cmF0ZWd5LmVudHJ5ICE9PSB1bmRlZmluZWQpXG4gICAgLnJlZHVjZShcbiAgICAgIChhY2MsIHNxbFN0cmF0ZWd5KSA9PiB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gc3FsU3RyYXRlZ3kuZW50cnkhO1xuICAgICAgICBjb25zdCByZWZlcmVuY2UgPVxuICAgICAgICAgIHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycgPyBlbnRyeSA6IGVudHJ5LnJlbGF0aXZlUGF0aDtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRQYXRoID0gcmVzb2x2ZUVudHJ5UGF0aChlbnRyeSk7XG5cbiAgICAgICAgYWNjW3JlZmVyZW5jZV0gPSByZWFkRmlsZVN5bmMocmVzb2x2ZWRQYXRoLCAndXRmOCcpO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSxcbiAgICAgIHt9IGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXG4gICAgKTtcblxuICByZXR1cm4gY3VzdG9tU3FsU3RhdGVtZW50cztcbn07XG5cbi8qKlxuICogU3BsaXQgdGhlIHNjaGVtYSBpbnRvIG11bHRpcGxlIHNjaGVtYXMgYmFzZWQgb24gdGhlIHRhYmxlIG1hcC5cbiAqIElmIHRoZSBtb2RlbCBjb3JyZXNwb25kcyB0byBhbiBpbXBvcnRlZCB0YWJsZSB0aGVuIG1vdmUgdGhhdCBtb2RlbCB0byBhIHNlcGFyYXRlIHNjaGVtYSBhbmQgaW5jbHVkZSB0aGUgdGFibGUgbmFtZVxuICogQHBhcmFtIHNjaGVtYXMgR3JhcGhRTCBzY2hlbWFzXG4gKiBAcGFyYW0gYW1wbGlmeUdlbjFEeW5hbW9EYlRhYmxlTWFwcGluZyBUYWJsZSBuYW1lcyBmb3IgdGhlIG1vZGVscyB0aGF0IHNob3VsZCBiZSBpbXBvcnRlZC5cbiAqIEByZXR1cm5zIGFuIGFycmF5IG9mIHNwbGl0IHNjaGVtYXMgd2l0aCB0aGUgaW1wb3J0ZWQgdGFibGUgbmFtZSBpZiBhcHBsaWNhYmxlXG4gKi9cbmV4cG9ydCBjb25zdCBzcGxpdFNjaGVtYXNCeVRhYmxlTWFwID0gKFxuICBzY2hlbWFzOiAoc3RyaW5nIHwgRGVyaXZlZE1vZGVsU2NoZW1hKVtdLFxuICBhbXBsaWZ5R2VuMUR5bmFtb0RiVGFibGVNYXBwaW5nOiBBbXBsaWZ5R2VuMUR5bmFtb0RiVGFibGVNYXBwaW5nIHwgdW5kZWZpbmVkLFxuKToge1xuICBzY2hlbWE6IHN0cmluZyB8IERlcml2ZWRNb2RlbFNjaGVtYTtcbiAgaW1wb3J0ZWRUYWJsZU5hbWU/OiBzdHJpbmc7XG59W10gPT4ge1xuICBjb25zdCBzcGxpdFNjaGVtYXM6IHtcbiAgICBzY2hlbWE6IHN0cmluZyB8IERlcml2ZWRNb2RlbFNjaGVtYTtcbiAgICBpbXBvcnRlZFRhYmxlTmFtZT86IHN0cmluZztcbiAgfVtdID0gc2NoZW1hcy5mbGF0TWFwKChzY2hlbWEpID0+IHtcbiAgICAvLyBkYXRhIHNjaGVtYSBub3Qgc3VwcG9ydGVkIGZvciBpbXBvcnRcbiAgICBpZiAoIWlzRGF0YVNjaGVtYShzY2hlbWEpKSB7XG4gICAgICBjb25zdCB7IGltcG9ydGVkU2NoZW1hcywgbm9uSW1wb3J0ZWRTY2hlbWEgfSA9IGV4dHJhY3RJbXBvcnRlZE1vZGVscyhcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBhbXBsaWZ5R2VuMUR5bmFtb0RiVGFibGVNYXBwaW5nPy5tb2RlbE5hbWVUb1RhYmxlTmFtZU1hcHBpbmcsXG4gICAgICApO1xuICAgICAgaWYgKGltcG9ydGVkU2NoZW1hcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgLi4uaW1wb3J0ZWRTY2hlbWFzLm1hcCgoeyBzY2hlbWEsIGltcG9ydGVkVGFibGVOYW1lIH0pID0+ICh7XG4gICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICBpbXBvcnRlZFRhYmxlTmFtZSxcbiAgICAgICAgICB9KSksXG4gICAgICAgICAgLi4uKG5vbkltcG9ydGVkU2NoZW1hID8gW3sgc2NoZW1hOiBub25JbXBvcnRlZFNjaGVtYSB9XSA6IFtdKSxcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFt7IHNjaGVtYSB9XTtcbiAgfSk7XG5cbiAgcmV0dXJuIHNwbGl0U2NoZW1hcztcbn07XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIGltcG9ydGVkIG1vZGVscyBmcm9tIG5vbi1pbXBvcnRlZCBtb2RlbHMgaW4gYSBzaW5nbGUgc3RyaW5nIHNjaGVtYS5cbiAqIEBwYXJhbSBzY2hlbWEgU3RyaW5nIEdyYXBoUUwgc2NoZW1hXG4gKiBAcGFyYW0gbW9kZWxOYW1lVG9UYWJsZU5hbWVNYXBwaW5nIFRhYmxlIG5hbWVzIGZvciB0aGUgbW9kZWxzIHRoYXQgc2hvdWxkIGJlIGV4dHJhY3RlZC5cbiAqIEByZXR1cm5zIGEgc2NoZW1hIHNwbGl0IGludG8gaW1wb3J0ZWQgbW9kZWxzIGFuZCBub24taW1wb3J0ZWQgbW9kZWxzXG4gKi9cbmNvbnN0IGV4dHJhY3RJbXBvcnRlZE1vZGVscyA9IChcbiAgc2NoZW1hOiBzdHJpbmcsXG4gIG1vZGVsTmFtZVRvVGFibGVOYW1lTWFwcGluZzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IHVuZGVmaW5lZCxcbik6IHtcbiAgaW1wb3J0ZWRTY2hlbWFzOiB7IHNjaGVtYTogc3RyaW5nOyBpbXBvcnRlZFRhYmxlTmFtZTogc3RyaW5nIH1bXTtcbiAgbm9uSW1wb3J0ZWRTY2hlbWE6IHN0cmluZyB8IHVuZGVmaW5lZDtcbn0gPT4ge1xuICBjb25zdCBpbXBvcnRlZE1vZGVscyA9IE9iamVjdC5rZXlzKG1vZGVsTmFtZVRvVGFibGVOYW1lTWFwcGluZyA/PyB7fSk7XG4gIGlmIChpbXBvcnRlZE1vZGVscz8ubGVuZ3RoKSB7XG4gICAgY29uc3QgcGFyc2VkU2NoZW1hID0gcGFyc2Uoc2NoZW1hKTtcbiAgICBjb25zdCBbaW1wb3J0ZWREZWZpbml0aW9uTm9kZXMsIG5vbkltcG9ydGVkRGVmaW5pdGlvbk5vZGVzXSA9IHBhcnRpdGlvbihcbiAgICAgIHBhcnNlZFNjaGVtYS5kZWZpbml0aW9ucyxcbiAgICAgIChkZWZpbml0aW9uTm9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGRlZmluaXRpb25Ob2RlLmtpbmQgPT09ICdPYmplY3RUeXBlRGVmaW5pdGlvbicgJiZcbiAgICAgICAgICBpbXBvcnRlZE1vZGVscy5pbmNsdWRlcyhkZWZpbml0aW9uTm9kZS5uYW1lLnZhbHVlKVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICApO1xuICAgIC8vIG9rIHRvIGNhc3QgYXMgT2JqZWN0VHlwZURlZmluaXRpb25Ob2RlIGJlY2F1c2UgdGhlIHR5cGUgd2FzIGNoZWNrZWQgaW4gdGhlIHBhcnRpdGlvbiBmdW5jdGlvblxuICAgIGNvbnN0IGltcG9ydGVkT2JqZWN0VHlwZURlZmluaXRpb25Ob2RlcyA9XG4gICAgICBpbXBvcnRlZERlZmluaXRpb25Ob2RlcyBhcyBPYmplY3RUeXBlRGVmaW5pdGlvbk5vZGVbXTtcblxuICAgIGltcG9ydGVkTW9kZWxzLmZvckVhY2goKG1vZGVsTmFtZSkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICAhaW1wb3J0ZWRPYmplY3RUeXBlRGVmaW5pdGlvbk5vZGVzLnNvbWUoXG4gICAgICAgICAgKGRlZmluaXRpb25Ob2RlKSA9PiBkZWZpbml0aW9uTm9kZS5uYW1lLnZhbHVlID09PSBtb2RlbE5hbWUsXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgQW1wbGlmeVVzZXJFcnJvcignRGVmaW5lRGF0YUNvbmZpZ3VyYXRpb25FcnJvcicsIHtcbiAgICAgICAgICBtZXNzYWdlOiBgSW1wb3J0ZWQgbW9kZWwgbm90IGZvdW5kIGluIHNjaGVtYTogJHttb2RlbE5hbWV9YCxcbiAgICAgICAgICByZXNvbHV0aW9uOiBgQWRkICR7bW9kZWxOYW1lfSB0byB0aGUgc2NoZW1hLmAsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgaW1wb3J0ZWRTY2hlbWFzID0gaW1wb3J0ZWRPYmplY3RUeXBlRGVmaW5pdGlvbk5vZGVzLm1hcChcbiAgICAgIChkZWZpbml0aW9uTm9kZSkgPT4ge1xuICAgICAgICBjb25zdCBpbXBvcnRlZFRhYmxlTmFtZSA9IChtb2RlbE5hbWVUb1RhYmxlTmFtZU1hcHBpbmcgPz8ge30pW1xuICAgICAgICAgIGRlZmluaXRpb25Ob2RlLm5hbWUudmFsdWVcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKCFpbXBvcnRlZFRhYmxlTmFtZSkge1xuICAgICAgICAgIHRocm93IG5ldyBBbXBsaWZ5VXNlckVycm9yKCdEZWZpbmVEYXRhQ29uZmlndXJhdGlvbkVycm9yJywge1xuICAgICAgICAgICAgbWVzc2FnZTogYE5vIHRhYmxlIGZvdW5kIGZvciBpbXBvcnRlZCBtb2RlbCAke2RlZmluaXRpb25Ob2RlLm5hbWUudmFsdWV9LmAsXG4gICAgICAgICAgICByZXNvbHV0aW9uOiBgQWRkIGEgdGFibGUgbmFtZSBmb3IgJHtkZWZpbml0aW9uTm9kZS5uYW1lLnZhbHVlfSBpbiB0aGUgbW9kZWxOYW1lVG9UYWJsZU5hbWVNYXBwaW5nLmAsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzY2hlbWE6IHByaW50KHtcbiAgICAgICAgICAgIGRlZmluaXRpb25zOiBbZGVmaW5pdGlvbk5vZGVdLFxuICAgICAgICAgICAga2luZDogJ0RvY3VtZW50JyBhcyBjb25zdCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBpbXBvcnRlZFRhYmxlTmFtZSxcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIGNvbnN0IG5vbkltcG9ydGVkU2NoZW1hID0gbm9uSW1wb3J0ZWREZWZpbml0aW9uTm9kZXMubGVuZ3RoXG4gICAgICA/IHByaW50KHtcbiAgICAgICAgICBkZWZpbml0aW9uczogbm9uSW1wb3J0ZWREZWZpbml0aW9uTm9kZXMsXG4gICAgICAgICAga2luZDogJ0RvY3VtZW50JyBhcyBjb25zdCxcbiAgICAgICAgfSlcbiAgICAgIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiB7XG4gICAgICBpbXBvcnRlZFNjaGVtYXMsXG4gICAgICBub25JbXBvcnRlZFNjaGVtYSxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgaW1wb3J0ZWRTY2hlbWFzOiBbXSxcbiAgICBub25JbXBvcnRlZFNjaGVtYTogc2NoZW1hLFxuICB9O1xufTtcblxuLyogcGFydGl0aW9uIGEgbGlzdCBiYXNlZCBvbiBhIHByZWRpY2F0ZS4gSWYgaXNMZWZ0IGlzIHRydWUsIHRoZSBpdGVtIGdvZXMgaW4gdGhlIGxlZnQgbGlzdCwgb3RoZXJ3aXNlIGl0IGdvZXMgaW4gdGhlIHJpZ2h0IGxpc3QgKi9cbmNvbnN0IHBhcnRpdGlvbiA9IDxJPihcbiAgYXJyYXk6IHJlYWRvbmx5IElbXSxcbiAgaXNMZWZ0OiAoaXRlbTogSSkgPT4gYm9vbGVhbixcbik6IFtJW10sIElbXV0gPT4ge1xuICByZXR1cm4gYXJyYXkucmVkdWNlKFxuICAgIChbbGVmdCwgcmlnaHRdLCBpdGVtKSA9PiB7XG4gICAgICByZXR1cm4gaXNMZWZ0KGl0ZW0pID8gW1suLi5sZWZ0LCBpdGVtXSwgcmlnaHRdIDogW2xlZnQsIFsuLi5yaWdodCwgaXRlbV1dO1xuICAgIH0sXG4gICAgW1tdLCBbXV0gYXMgW0lbXSwgSVtdXSxcbiAgKTtcbn07XG4iXX0=