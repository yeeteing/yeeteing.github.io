import { AmplifyUserError } from '@aws-amplify/platform-core';
import { entityIdPathToken } from './constants.js';
/**
 * Validate that the storage path record keys match our conventions and restrictions.
 * If all of the paths are valid, this function is a noop.
 * If some path is invalid, an error is thrown with details
 */
export const validateStorageAccessPaths = (storagePaths) => {
    storagePaths.forEach(validateStoragePath);
};
const validateStoragePath = (path, index, allPaths) => {
    if (path.startsWith('/')) {
        throw new AmplifyUserError('InvalidStorageAccessPathError', {
            message: `Storage access paths must not start with "/". Found [${path}].`,
            resolution: 'Update all paths to match the format requirements.',
        });
    }
    if (!path.endsWith('/*')) {
        throw new AmplifyUserError('InvalidStorageAccessPathError', {
            message: `Storage access paths must end with "/*". Found [${path}].`,
            resolution: 'Update all paths to match the format requirements.',
        });
    }
    if (path.includes('//')) {
        throw new AmplifyUserError('InvalidStorageAccessPathError', {
            message: `Path cannot contain "//". Found [${path}].`,
            resolution: 'Update all paths to match the format requirements.',
        });
    }
    if (path.indexOf('*') < path.length - 1) {
        throw new AmplifyUserError('InvalidStorageAccessPathError', {
            message: `Wildcards are only allowed as the final part of a path. Found [${path}].`,
            resolution: 'Remove all wildcards that are not the final part of the path.',
        });
    }
    /**
     * For any path, at most one other path can be a prefix of that path
     *
     * For example, consider an access definition with the following paths defined:
     * /foo/* - OK (0 other paths are a prefix of this one)
     * /foo/bar/* - OK (1 other path is a prefix of this one)
     * /foo/bar/baz/* - NOT OK (2 other paths are a prefix of this one (/foo and /foo/bar))
     * /foo/baz/* - OK (1 other path is a prefix of this one)
     */
    const otherPrefixes = getPrefixes(path, allPaths);
    if (otherPrefixes.length > 1) {
        throw new AmplifyUserError('InvalidStorageAccessPathError', {
            message: `For any given path, only one other path can be a prefix of it. Found [${path}] which has prefixes [${otherPrefixes.join(', ')}].`,
            resolution: `Update the storage access paths such that any given path has at most one other path that is a prefix.`,
        });
    }
    validateOwnerTokenRules(path, otherPrefixes);
};
/**
 * Extra validations that are only necessary if the path includes an owner token
 */
const validateOwnerTokenRules = (path, otherPrefixes) => {
    // if there's no owner token in the path, this validation is a noop
    if (!path.includes(entityIdPathToken)) {
        return;
    }
    if (otherPrefixes.length > 0) {
        throw new AmplifyUserError('InvalidStorageAccessPathError', {
            message: `A path cannot be a prefix of another path that contains the ${entityIdPathToken} token.`,
            details: `Found [${path}] which has prefixes [${otherPrefixes.join(', ')}].`,
            resolution: `Update the storage access paths such that any given path has at most one other path that is a prefix.`,
        });
    }
    const ownerSplit = path.split(entityIdPathToken);
    if (ownerSplit.length > 2) {
        throw new AmplifyUserError('InvalidStorageAccessPathError', {
            message: `The ${entityIdPathToken} token can only appear once in a path. Found [${path}]`,
            resolution: `Remove all but one occurrence of the ${entityIdPathToken} token`,
        });
    }
    const [substringBeforeOwnerToken, substringAfterOwnerToken] = ownerSplit;
    if (substringAfterOwnerToken !== '/*') {
        throw new AmplifyUserError('InvalidStorageAccessPathError', {
            message: `The ${entityIdPathToken} token must be the path part right before the ending wildcard. Found [${path}].`,
            resolution: `Update the path such that the owner token is the last path part before the ending wildcard. For example: "foo/bar/${entityIdPathToken}/*.`,
        });
    }
    if (substringBeforeOwnerToken === '') {
        throw new AmplifyUserError('InvalidStorageAccessPathError', {
            message: `The ${entityIdPathToken} token must not be the first path part. Found [${path}].`,
            resolution: `Add an additional prefix to the path. For example: "foo/${entityIdPathToken}/*.`,
        });
    }
    if (!substringBeforeOwnerToken.endsWith('/')) {
        throw new AmplifyUserError('InvalidStorageAccessPathError', {
            message: `A path part that includes the ${entityIdPathToken} token cannot include any other characters. Found [${path}].`,
            resolution: `Remove all other characters from the path part with the ${entityIdPathToken} token. For example: "foo/${entityIdPathToken}/*"`,
        });
    }
};
/**
 * Returns a subset of paths where each element is a prefix of path
 * Equivalent paths are NOT considered prefixes of each other (mainly just for simplicity of the calling logic)
 */
const getPrefixes = (path, paths, treatWildcardAsLiteral = false) => paths.filter((p) => path !== p &&
    path.startsWith(treatWildcardAsLiteral ? p : p.replaceAll('*', '')));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGVfc3RvcmFnZV9hY2Nlc3NfcGF0aHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdmFsaWRhdGVfc3RvcmFnZV9hY2Nlc3NfcGF0aHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDOUQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFHbkQ7Ozs7R0FJRztBQUNILE1BQU0sQ0FBQyxNQUFNLDBCQUEwQixHQUFHLENBQUMsWUFBc0IsRUFBRSxFQUFFO0lBQ25FLFlBQVksQ0FBQyxPQUFPLENBQUMsbUJBQW1CLENBQUMsQ0FBQztBQUM1QyxDQUFDLENBQUM7QUFFRixNQUFNLG1CQUFtQixHQUFHLENBQzFCLElBQVksRUFDWixLQUFhLEVBQ2IsUUFBa0IsRUFDbEIsRUFBRTtJQUNGLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO1FBQ3pCLE1BQU0sSUFBSSxnQkFBZ0IsQ0FBZSwrQkFBK0IsRUFBRTtZQUN4RSxPQUFPLEVBQUUsd0RBQXdELElBQUksSUFBSTtZQUN6RSxVQUFVLEVBQUUsb0RBQW9EO1NBQ2pFLENBQUMsQ0FBQztJQUNMLENBQUM7SUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO1FBQ3pCLE1BQU0sSUFBSSxnQkFBZ0IsQ0FBZSwrQkFBK0IsRUFBRTtZQUN4RSxPQUFPLEVBQUUsbURBQW1ELElBQUksSUFBSTtZQUNwRSxVQUFVLEVBQUUsb0RBQW9EO1NBQ2pFLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztRQUN4QixNQUFNLElBQUksZ0JBQWdCLENBQWUsK0JBQStCLEVBQUU7WUFDeEUsT0FBTyxFQUFFLG9DQUFvQyxJQUFJLElBQUk7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QUFVLEVBQUUsMkRBQTJELGlCQUFpQiw2QkFBNkIsaUJBQWlCLEtBQUs7U0FDNUksQ0FBQyxDQUFDO0lBQ0wsQ0FBQztBQUNILENBQUMsQ0FBQztBQUVGOzs7R0FHRztBQUNILE1BQU0sV0FBVyxHQUFHLENBQ2xCLElBQVksRUFDWixLQUFlLEVBQ2Ysc0JBQXNCLEdBQUcsS0FBSyxFQUNwQixFQUFFLENBQ1osS0FBSyxDQUFDLE1BQU0sQ0FDVixDQUFDLENBQUMsRUFBRSxFQUFFLENBQ0osSUFBSSxLQUFLLENBQUM7SUFDVixJQUFJLENBQUMsVUFBVSxDQUFDLHNCQUFzQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQ3RFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBbXBsaWZ5VXNlckVycm9yIH0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsYXRmb3JtLWNvcmUnO1xuaW1wb3J0IHsgZW50aXR5SWRQYXRoVG9rZW4gfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBTdG9yYWdlRXJyb3IgfSBmcm9tICcuL3ByaXZhdGVfdHlwZXMuanMnO1xuXG4vKipcbiAqIFZhbGlkYXRlIHRoYXQgdGhlIHN0b3JhZ2UgcGF0aCByZWNvcmQga2V5cyBtYXRjaCBvdXIgY29udmVudGlvbnMgYW5kIHJlc3RyaWN0aW9ucy5cbiAqIElmIGFsbCBvZiB0aGUgcGF0aHMgYXJlIHZhbGlkLCB0aGlzIGZ1bmN0aW9uIGlzIGEgbm9vcC5cbiAqIElmIHNvbWUgcGF0aCBpcyBpbnZhbGlkLCBhbiBlcnJvciBpcyB0aHJvd24gd2l0aCBkZXRhaWxzXG4gKi9cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZVN0b3JhZ2VBY2Nlc3NQYXRocyA9IChzdG9yYWdlUGF0aHM6IHN0cmluZ1tdKSA9PiB7XG4gIHN0b3JhZ2VQYXRocy5mb3JFYWNoKHZhbGlkYXRlU3RvcmFnZVBhdGgpO1xufTtcblxuY29uc3QgdmFsaWRhdGVTdG9yYWdlUGF0aCA9IChcbiAgcGF0aDogc3RyaW5nLFxuICBpbmRleDogbnVtYmVyLFxuICBhbGxQYXRoczogc3RyaW5nW10sXG4pID0+IHtcbiAgaWYgKHBhdGguc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgdGhyb3cgbmV3IEFtcGxpZnlVc2VyRXJyb3I8U3RvcmFnZUVycm9yPignSW52YWxpZFN0b3JhZ2VBY2Nlc3NQYXRoRXJyb3InLCB7XG4gICAgICBtZXNzYWdlOiBgU3RvcmFnZSBhY2Nlc3MgcGF0aHMgbXVzdCBub3Qgc3RhcnQgd2l0aCBcIi9cIi4gRm91bmQgWyR7cGF0aH1dLmAsXG4gICAgICByZXNvbHV0aW9uOiAnVXBkYXRlIGFsbCBwYXRocyB0byBtYXRjaCB0aGUgZm9ybWF0IHJlcXVpcmVtZW50cy4nLFxuICAgIH0pO1xuICB9XG4gIGlmICghcGF0aC5lbmRzV2l0aCgnLyonKSkge1xuICAgIHRocm93IG5ldyBBbXBsaWZ5VXNlckVycm9yPFN0b3JhZ2VFcnJvcj4oJ0ludmFsaWRTdG9yYWdlQWNjZXNzUGF0aEVycm9yJywge1xuICAgICAgbWVzc2FnZTogYFN0b3JhZ2UgYWNjZXNzIHBhdGhzIG11c3QgZW5kIHdpdGggXCIvKlwiLiBGb3VuZCBbJHtwYXRofV0uYCxcbiAgICAgIHJlc29sdXRpb246ICdVcGRhdGUgYWxsIHBhdGhzIHRvIG1hdGNoIHRoZSBmb3JtYXQgcmVxdWlyZW1lbnRzLicsXG4gICAgfSk7XG4gIH1cblxuICBpZiAocGF0aC5pbmNsdWRlcygnLy8nKSkge1xuICAgIHRocm93IG5ldyBBbXBsaWZ5VXNlckVycm9yPFN0b3JhZ2VFcnJvcj4oJ0ludmFsaWRTdG9yYWdlQWNjZXNzUGF0aEVycm9yJywge1xuICAgICAgbWVzc2FnZTogYFBhdGggY2Fubm90IGNvbnRhaW4gXCIvL1wiLiBGb3VuZCBbJHtwYXRofV0uYCxcbiAgICAgIHJlc29sdXRpb246ICdVcGRhdGUgYWxsIHBhdGhzIHRvIG1hdGNoIHRoZSBmb3JtYXQgcmVxdWlyZW1lbnRzLicsXG4gICAgfSk7XG4gIH1cblxuICBpZiAocGF0aC5pbmRleE9mKCcqJykgPCBwYXRoLmxlbmd0aCAtIDEpIHtcbiAgICB0aHJvdyBuZXcgQW1wbGlmeVVzZXJFcnJvcjxTdG9yYWdlRXJyb3I+KCdJbnZhbGlkU3RvcmFnZUFjY2Vzc1BhdGhFcnJvcicsIHtcbiAgICAgIG1lc3NhZ2U6IGBXaWxkY2FyZHMgYXJlIG9ubHkgYWxsb3dlZCBhcyB0aGUgZmluYWwgcGFydCBvZiBhIHBhdGguIEZvdW5kIFske3BhdGh9XS5gLFxuICAgICAgcmVzb2x1dGlvbjpcbiAgICAgICAgJ1JlbW92ZSBhbGwgd2lsZGNhcmRzIHRoYXQgYXJlIG5vdCB0aGUgZmluYWwgcGFydCBvZiB0aGUgcGF0aC4nLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciBhbnkgcGF0aCwgYXQgbW9zdCBvbmUgb3RoZXIgcGF0aCBjYW4gYmUgYSBwcmVmaXggb2YgdGhhdCBwYXRoXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBjb25zaWRlciBhbiBhY2Nlc3MgZGVmaW5pdGlvbiB3aXRoIHRoZSBmb2xsb3dpbmcgcGF0aHMgZGVmaW5lZDpcbiAgICogL2Zvby8qIC0gT0sgKDAgb3RoZXIgcGF0aHMgYXJlIGEgcHJlZml4IG9mIHRoaXMgb25lKVxuICAgKiAvZm9vL2Jhci8qIC0gT0sgKDEgb3RoZXIgcGF0aCBpcyBhIHByZWZpeCBvZiB0aGlzIG9uZSlcbiAgICogL2Zvby9iYXIvYmF6LyogLSBOT1QgT0sgKDIgb3RoZXIgcGF0aHMgYXJlIGEgcHJlZml4IG9mIHRoaXMgb25lICgvZm9vIGFuZCAvZm9vL2JhcikpXG4gICAqIC9mb28vYmF6LyogLSBPSyAoMSBvdGhlciBwYXRoIGlzIGEgcHJlZml4IG9mIHRoaXMgb25lKVxuICAgKi9cbiAgY29uc3Qgb3RoZXJQcmVmaXhlcyA9IGdldFByZWZpeGVzKHBhdGgsIGFsbFBhdGhzKTtcbiAgaWYgKG90aGVyUHJlZml4ZXMubGVuZ3RoID4gMSkge1xuICAgIHRocm93IG5ldyBBbXBsaWZ5VXNlckVycm9yPFN0b3JhZ2VFcnJvcj4oJ0ludmFsaWRTdG9yYWdlQWNjZXNzUGF0aEVycm9yJywge1xuICAgICAgbWVzc2FnZTogYEZvciBhbnkgZ2l2ZW4gcGF0aCwgb25seSBvbmUgb3RoZXIgcGF0aCBjYW4gYmUgYSBwcmVmaXggb2YgaXQuIEZvdW5kIFske3BhdGh9XSB3aGljaCBoYXMgcHJlZml4ZXMgWyR7b3RoZXJQcmVmaXhlcy5qb2luKFxuICAgICAgICAnLCAnLFxuICAgICAgKX1dLmAsXG4gICAgICByZXNvbHV0aW9uOiBgVXBkYXRlIHRoZSBzdG9yYWdlIGFjY2VzcyBwYXRocyBzdWNoIHRoYXQgYW55IGdpdmVuIHBhdGggaGFzIGF0IG1vc3Qgb25lIG90aGVyIHBhdGggdGhhdCBpcyBhIHByZWZpeC5gLFxuICAgIH0pO1xuICB9XG5cbiAgdmFsaWRhdGVPd25lclRva2VuUnVsZXMocGF0aCwgb3RoZXJQcmVmaXhlcyk7XG59O1xuXG4vKipcbiAqIEV4dHJhIHZhbGlkYXRpb25zIHRoYXQgYXJlIG9ubHkgbmVjZXNzYXJ5IGlmIHRoZSBwYXRoIGluY2x1ZGVzIGFuIG93bmVyIHRva2VuXG4gKi9cbmNvbnN0IHZhbGlkYXRlT3duZXJUb2tlblJ1bGVzID0gKHBhdGg6IHN0cmluZywgb3RoZXJQcmVmaXhlczogc3RyaW5nW10pID0+IHtcbiAgLy8gaWYgdGhlcmUncyBubyBvd25lciB0b2tlbiBpbiB0aGUgcGF0aCwgdGhpcyB2YWxpZGF0aW9uIGlzIGEgbm9vcFxuICBpZiAoIXBhdGguaW5jbHVkZXMoZW50aXR5SWRQYXRoVG9rZW4pKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG90aGVyUHJlZml4ZXMubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBBbXBsaWZ5VXNlckVycm9yPFN0b3JhZ2VFcnJvcj4oJ0ludmFsaWRTdG9yYWdlQWNjZXNzUGF0aEVycm9yJywge1xuICAgICAgbWVzc2FnZTogYEEgcGF0aCBjYW5ub3QgYmUgYSBwcmVmaXggb2YgYW5vdGhlciBwYXRoIHRoYXQgY29udGFpbnMgdGhlICR7ZW50aXR5SWRQYXRoVG9rZW59IHRva2VuLmAsXG4gICAgICBkZXRhaWxzOiBgRm91bmQgWyR7cGF0aH1dIHdoaWNoIGhhcyBwcmVmaXhlcyBbJHtvdGhlclByZWZpeGVzLmpvaW4oXG4gICAgICAgICcsICcsXG4gICAgICApfV0uYCxcbiAgICAgIHJlc29sdXRpb246IGBVcGRhdGUgdGhlIHN0b3JhZ2UgYWNjZXNzIHBhdGhzIHN1Y2ggdGhhdCBhbnkgZ2l2ZW4gcGF0aCBoYXMgYXQgbW9zdCBvbmUgb3RoZXIgcGF0aCB0aGF0IGlzIGEgcHJlZml4LmAsXG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBvd25lclNwbGl0ID0gcGF0aC5zcGxpdChlbnRpdHlJZFBhdGhUb2tlbik7XG5cbiAgaWYgKG93bmVyU3BsaXQubGVuZ3RoID4gMikge1xuICAgIHRocm93IG5ldyBBbXBsaWZ5VXNlckVycm9yPFN0b3JhZ2VFcnJvcj4oJ0ludmFsaWRTdG9yYWdlQWNjZXNzUGF0aEVycm9yJywge1xuICAgICAgbWVzc2FnZTogYFRoZSAke2VudGl0eUlkUGF0aFRva2VufSB0b2tlbiBjYW4gb25seSBhcHBlYXIgb25jZSBpbiBhIHBhdGguIEZvdW5kIFske3BhdGh9XWAsXG4gICAgICByZXNvbHV0aW9uOiBgUmVtb3ZlIGFsbCBidXQgb25lIG9jY3VycmVuY2Ugb2YgdGhlICR7ZW50aXR5SWRQYXRoVG9rZW59IHRva2VuYCxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IFtzdWJzdHJpbmdCZWZvcmVPd25lclRva2VuLCBzdWJzdHJpbmdBZnRlck93bmVyVG9rZW5dID0gb3duZXJTcGxpdDtcblxuICBpZiAoc3Vic3RyaW5nQWZ0ZXJPd25lclRva2VuICE9PSAnLyonKSB7XG4gICAgdGhyb3cgbmV3IEFtcGxpZnlVc2VyRXJyb3I8U3RvcmFnZUVycm9yPignSW52YWxpZFN0b3JhZ2VBY2Nlc3NQYXRoRXJyb3InLCB7XG4gICAgICBtZXNzYWdlOiBgVGhlICR7ZW50aXR5SWRQYXRoVG9rZW59IHRva2VuIG11c3QgYmUgdGhlIHBhdGggcGFydCByaWdodCBiZWZvcmUgdGhlIGVuZGluZyB3aWxkY2FyZC4gRm91bmQgWyR7cGF0aH1dLmAsXG4gICAgICByZXNvbHV0aW9uOiBgVXBkYXRlIHRoZSBwYXRoIHN1Y2ggdGhhdCB0aGUgb3duZXIgdG9rZW4gaXMgdGhlIGxhc3QgcGF0aCBwYXJ0IGJlZm9yZSB0aGUgZW5kaW5nIHdpbGRjYXJkLiBGb3IgZXhhbXBsZTogXCJmb28vYmFyLyR7ZW50aXR5SWRQYXRoVG9rZW59LyouYCxcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzdWJzdHJpbmdCZWZvcmVPd25lclRva2VuID09PSAnJykge1xuICAgIHRocm93IG5ldyBBbXBsaWZ5VXNlckVycm9yPFN0b3JhZ2VFcnJvcj4oJ0ludmFsaWRTdG9yYWdlQWNjZXNzUGF0aEVycm9yJywge1xuICAgICAgbWVzc2FnZTogYFRoZSAke2VudGl0eUlkUGF0aFRva2VufSB0b2tlbiBtdXN0IG5vdCBiZSB0aGUgZmlyc3QgcGF0aCBwYXJ0LiBGb3VuZCBbJHtwYXRofV0uYCxcbiAgICAgIHJlc29sdXRpb246IGBBZGQgYW4gYWRkaXRpb25hbCBwcmVmaXggdG8gdGhlIHBhdGguIEZvciBleGFtcGxlOiBcImZvby8ke2VudGl0eUlkUGF0aFRva2VufS8qLmAsXG4gICAgfSk7XG4gIH1cblxuICBpZiAoIXN1YnN0cmluZ0JlZm9yZU93bmVyVG9rZW4uZW5kc1dpdGgoJy8nKSkge1xuICAgIHRocm93IG5ldyBBbXBsaWZ5VXNlckVycm9yPFN0b3JhZ2VFcnJvcj4oJ0ludmFsaWRTdG9yYWdlQWNjZXNzUGF0aEVycm9yJywge1xuICAgICAgbWVzc2FnZTogYEEgcGF0aCBwYXJ0IHRoYXQgaW5jbHVkZXMgdGhlICR7ZW50aXR5SWRQYXRoVG9rZW59IHRva2VuIGNhbm5vdCBpbmNsdWRlIGFueSBvdGhlciBjaGFyYWN0ZXJzLiBGb3VuZCBbJHtwYXRofV0uYCxcbiAgICAgIHJlc29sdXRpb246IGBSZW1vdmUgYWxsIG90aGVyIGNoYXJhY3RlcnMgZnJvbSB0aGUgcGF0aCBwYXJ0IHdpdGggdGhlICR7ZW50aXR5SWRQYXRoVG9rZW59IHRva2VuLiBGb3IgZXhhbXBsZTogXCJmb28vJHtlbnRpdHlJZFBhdGhUb2tlbn0vKlwiYCxcbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3Vic2V0IG9mIHBhdGhzIHdoZXJlIGVhY2ggZWxlbWVudCBpcyBhIHByZWZpeCBvZiBwYXRoXG4gKiBFcXVpdmFsZW50IHBhdGhzIGFyZSBOT1QgY29uc2lkZXJlZCBwcmVmaXhlcyBvZiBlYWNoIG90aGVyIChtYWlubHkganVzdCBmb3Igc2ltcGxpY2l0eSBvZiB0aGUgY2FsbGluZyBsb2dpYylcbiAqL1xuY29uc3QgZ2V0UHJlZml4ZXMgPSAoXG4gIHBhdGg6IHN0cmluZyxcbiAgcGF0aHM6IHN0cmluZ1tdLFxuICB0cmVhdFdpbGRjYXJkQXNMaXRlcmFsID0gZmFsc2UsXG4pOiBzdHJpbmdbXSA9PlxuICBwYXRocy5maWx0ZXIoXG4gICAgKHApID0+XG4gICAgICBwYXRoICE9PSBwICYmXG4gICAgICBwYXRoLnN0YXJ0c1dpdGgodHJlYXRXaWxkY2FyZEFzTGl0ZXJhbCA/IHAgOiBwLnJlcGxhY2VBbGwoJyonLCAnJykpLFxuICApO1xuIl19