"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHotswappableEcsServiceChange = isHotswappableEcsServiceChange;
const common_1 = require("./common");
const hotswap_1 = require("../../payloads/hotswap");
const util_1 = require("../../util");
const ECS_SERVICE_RESOURCE_TYPE = 'AWS::ECS::Service';
async function isHotswappableEcsServiceChange(logicalId, change, evaluateCfnTemplate, hotswapPropertyOverrides) {
    // the only resource change we can evaluate here is an ECS TaskDefinition
    if (change.newValue.Type !== 'AWS::ECS::TaskDefinition') {
        return [];
    }
    const ret = [];
    // We only allow a change in the ContainerDefinitions of the TaskDefinition for now -
    // it contains the image and environment variables, so seems like a safe bet for now.
    // We might revisit this decision in the future though!
    const classifiedChanges = (0, common_1.classifyChanges)(change, ['ContainerDefinitions']);
    classifiedChanges.reportNonHotswappablePropertyChanges(ret);
    // find all ECS Services that reference the TaskDefinition that changed
    const resourcesReferencingTaskDef = evaluateCfnTemplate.findReferencesTo(logicalId);
    const ecsServiceResourcesReferencingTaskDef = resourcesReferencingTaskDef.filter((r) => r.Type === ECS_SERVICE_RESOURCE_TYPE);
    const ecsServicesReferencingTaskDef = new Array();
    for (const ecsServiceResource of ecsServiceResourcesReferencingTaskDef) {
        const serviceArn = await evaluateCfnTemplate.findPhysicalNameFor(ecsServiceResource.LogicalId);
        if (serviceArn) {
            ecsServicesReferencingTaskDef.push({
                logicalId: ecsServiceResource.LogicalId,
                serviceArn,
            });
        }
    }
    if (ecsServicesReferencingTaskDef.length === 0) {
        /**
         * ECS Services can have a task definition that doesn't refer to the task definition being updated.
         * We have to log this as a non-hotswappable change to the task definition, but when we do,
         * we wind up hotswapping the task definition and logging it as a non-hotswappable change.
         *
         * This logic prevents us from logging that change as non-hotswappable when we hotswap it.
         */
        ret.push((0, common_1.nonHotswappableChange)(change, hotswap_1.NonHotswappableReason.DEPENDENCY_UNSUPPORTED, 'No ECS services reference the changed task definition', undefined, false));
    }
    if (resourcesReferencingTaskDef.length > ecsServicesReferencingTaskDef.length) {
        // if something besides an ECS Service is referencing the TaskDefinition,
        // hotswap is not possible in FALL_BACK mode
        const nonEcsServiceTaskDefRefs = resourcesReferencingTaskDef.filter((r) => r.Type !== ECS_SERVICE_RESOURCE_TYPE);
        for (const taskRef of nonEcsServiceTaskDefRefs) {
            ret.push((0, common_1.nonHotswappableChange)(change, hotswap_1.NonHotswappableReason.DEPENDENCY_UNSUPPORTED, `A resource '${taskRef.LogicalId}' with Type '${taskRef.Type}' that is not an ECS Service was found referencing the changed TaskDefinition '${logicalId}'`));
        }
    }
    const namesOfHotswappableChanges = Object.keys(classifiedChanges.hotswappableProps);
    if (namesOfHotswappableChanges.length > 0) {
        const taskDefinitionResource = await prepareTaskDefinitionChange(evaluateCfnTemplate, logicalId, change);
        ret.push({
            change: {
                cause: change,
                resources: [
                    {
                        logicalId,
                        resourceType: change.newValue.Type,
                        physicalName: await taskDefinitionResource.Family,
                        metadata: evaluateCfnTemplate.metadataFor(logicalId),
                    },
                    ...ecsServicesReferencingTaskDef.map((ecsService) => ({
                        resourceType: ECS_SERVICE_RESOURCE_TYPE,
                        physicalName: ecsService.serviceArn.split('/')[2],
                        logicalId: ecsService.logicalId,
                        metadata: evaluateCfnTemplate.metadataFor(ecsService.logicalId),
                    })),
                ],
            },
            hotswappable: true,
            service: 'ecs-service',
            apply: async (sdk) => {
                // Step 1 - update the changed TaskDefinition, creating a new TaskDefinition Revision
                // we need to lowercase the evaluated TaskDef from CloudFormation,
                // as the AWS SDK uses lowercase property names for these
                // The SDK requires more properties here than its worth doing explicit typing for
                // instead, just use all the old values in the diff to fill them in implicitly
                const lowercasedTaskDef = (0, util_1.transformObjectKeys)(taskDefinitionResource, util_1.lowerCaseFirstCharacter, {
                    // All the properties that take arbitrary string as keys i.e. { "string" : "string" }
                    // https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RegisterTaskDefinition.html#API_RegisterTaskDefinition_RequestSyntax
                    ContainerDefinitions: {
                        DockerLabels: true,
                        FirelensConfiguration: {
                            Options: true,
                        },
                        LogConfiguration: {
                            Options: true,
                        },
                    },
                    Volumes: {
                        DockerVolumeConfiguration: {
                            DriverOpts: true,
                            Labels: true,
                        },
                    },
                });
                const registerTaskDefResponse = await sdk.ecs().registerTaskDefinition(lowercasedTaskDef);
                const taskDefRevArn = registerTaskDefResponse.taskDefinition?.taskDefinitionArn;
                let ecsHotswapProperties = hotswapPropertyOverrides.ecs;
                let minimumHealthyPercent = ecsHotswapProperties?.minimumHealthyPercent;
                let maximumHealthyPercent = ecsHotswapProperties?.maximumHealthyPercent;
                let stabilizationTimeoutSeconds = ecsHotswapProperties?.stabilizationTimeoutSeconds;
                // Step 2 - update the services using that TaskDefinition to point to the new TaskDefinition Revision
                // Forcing New Deployment and setting Minimum Healthy Percent to 0.
                // As CDK HotSwap is development only, this seems the most efficient way to ensure all tasks are replaced immediately, regardless of original amount
                // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
                await Promise.all(ecsServicesReferencingTaskDef.map(async (service) => {
                    const cluster = service.serviceArn.split('/')[1];
                    const update = await sdk.ecs().updateService({
                        service: service.serviceArn,
                        taskDefinition: taskDefRevArn,
                        cluster,
                        forceNewDeployment: true,
                        deploymentConfiguration: {
                            minimumHealthyPercent: minimumHealthyPercent !== undefined ? minimumHealthyPercent : 0,
                            maximumPercent: maximumHealthyPercent !== undefined ? maximumHealthyPercent : undefined,
                        },
                    });
                    await sdk.ecs().waitUntilServicesStable({
                        cluster: update.service?.clusterArn,
                        services: [service.serviceArn],
                    }, stabilizationTimeoutSeconds);
                }));
            },
        });
    }
    return ret;
}
async function prepareTaskDefinitionChange(evaluateCfnTemplate, logicalId, change) {
    const taskDefinitionResource = {
        ...change.oldValue.Properties,
        ContainerDefinitions: change.newValue.Properties?.ContainerDefinitions,
    };
    // first, let's get the name of the family
    const familyNameOrArn = await evaluateCfnTemplate.establishResourcePhysicalName(logicalId, taskDefinitionResource?.Family);
    if (!familyNameOrArn) {
        // if the Family property has not been provided, and we can't find it in the current Stack,
        // this means hotswapping is not possible
        return;
    }
    // the physical name of the Task Definition in CloudFormation includes its current revision number at the end,
    // remove it if needed
    const familyNameOrArnParts = familyNameOrArn.split(':');
    const family = familyNameOrArnParts.length > 1
        ? // familyNameOrArn is actually an ARN, of the format 'arn:aws:ecs:region:account:task-definition/<family-name>:<revision-nr>'
            // so, take the 6th element, at index 5, and split it on '/'
            familyNameOrArnParts[5].split('/')[1]
        : // otherwise, familyNameOrArn is just the simple name evaluated from the CloudFormation template
            familyNameOrArn;
    // then, let's evaluate the body of the remainder of the TaskDef (without the Family property)
    return {
        ...(await evaluateCfnTemplate.evaluateCfnExpression({
            ...(taskDefinitionResource ?? {}),
            Family: undefined,
        })),
        Family: family,
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWNzLXNlcnZpY2VzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZWNzLXNlcnZpY2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBZUEsd0VBcUpDO0FBaEtELHFDQUdrQjtBQUNsQixvREFBb0Y7QUFDcEYscUNBQTBFO0FBSTFFLE1BQU0seUJBQXlCLEdBQUcsbUJBQW1CLENBQUM7QUFFL0MsS0FBSyxVQUFVLDhCQUE4QixDQUNsRCxTQUFpQixFQUNqQixNQUFzQixFQUN0QixtQkFBbUQsRUFDbkQsd0JBQWtEO0lBRWxELHlFQUF5RTtJQUN6RSxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxLQUFLLDBCQUEwQixFQUFFLENBQUM7UUFDeEQsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0lBRUQsTUFBTSxHQUFHLEdBQW9CLEVBQUUsQ0FBQztJQUVoQyxxRkFBcUY7SUFDckYscUZBQXFGO0lBQ3JGLHVEQUF1RDtJQUN2RCxNQUFNLGlCQUFpQixHQUFHLElBQUEsd0JBQWUsRUFBQyxNQUFNLEVBQUUsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLENBQUM7SUFDNUUsaUJBQWlCLENBQUMsb0NBQW9DLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFNUQsdUVBQXVFO0lBQ3ZFLE1BQU0sMkJBQTJCLEdBQUcsbUJBQW1CLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDcEYsTUFBTSxxQ0FBcUMsR0FBRywyQkFBMkIsQ0FBQyxNQUFNLENBQzlFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLHlCQUF5QixDQUM1QyxDQUFDO0lBQ0YsTUFBTSw2QkFBNkIsR0FBRyxJQUFJLEtBQUssRUFBYyxDQUFDO0lBQzlELEtBQUssTUFBTSxrQkFBa0IsSUFBSSxxQ0FBcUMsRUFBRSxDQUFDO1FBQ3ZFLE1BQU0sVUFBVSxHQUFHLE1BQU0sbUJBQW1CLENBQUMsbUJBQW1CLENBQUMsa0JBQWtCLENBQUMsU0FBUyxD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QTZIO1lBQ2pJLDREQUE0RDtZQUMxRCxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3JDLENBQUMsQ0FBQyxnR0FBZ0c7WUFDbEcsZUFBZSxDQUFDO0lBQ3BCLDhGQUE4RjtJQUM5RixPQUFPO1FBQ0wsR0FBRyxDQUFDLE1BQU0sbUJBQW1CLENBQUMscUJBQXFCLENBQUM7WUFDbEQsR0FBRyxDQUFDLHNCQUFzQixJQUFJLEVBQUUsQ0FBQztZQUNqQyxNQUFNLEVBQUUsU0FBUztTQUNsQixDQUFDLENBQUM7UUFDSCxNQUFNLEVBQUUsTUFBTTtLQUNmLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUge1xuICBIb3Rzd2FwUHJvcGVydHlPdmVycmlkZXMsXG4gIEhvdHN3YXBDaGFuZ2UsXG59IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7XG4gIGNsYXNzaWZ5Q2hhbmdlcyxcbiAgbm9uSG90c3dhcHBhYmxlQ2hhbmdlLFxufSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgeyBOb25Ib3Rzd2FwcGFibGVSZWFzb24sIHR5cGUgUmVzb3VyY2VDaGFuZ2UgfSBmcm9tICcuLi8uLi9wYXlsb2Fkcy9ob3Rzd2FwJztcbmltcG9ydCB7IGxvd2VyQ2FzZUZpcnN0Q2hhcmFjdGVyLCB0cmFuc2Zvcm1PYmplY3RLZXlzIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgdHlwZSB7IFNESyB9IGZyb20gJy4uL2F3cy1hdXRoL3ByaXZhdGUnO1xuaW1wb3J0IHR5cGUgeyBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUgfSBmcm9tICcuLi9jbG91ZGZvcm1hdGlvbic7XG5cbmNvbnN0IEVDU19TRVJWSUNFX1JFU09VUkNFX1RZUEUgPSAnQVdTOjpFQ1M6OlNlcnZpY2UnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNIb3Rzd2FwcGFibGVFY3NTZXJ2aWNlQ2hhbmdlKFxuICBsb2dpY2FsSWQ6IHN0cmluZyxcbiAgY2hhbmdlOiBSZXNvdXJjZUNoYW5nZSxcbiAgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuICBob3Rzd2FwUHJvcGVydHlPdmVycmlkZXM6IEhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcyxcbik6IFByb21pc2U8SG90c3dhcENoYW5nZVtdPiB7XG4gIC8vIHRoZSBvbmx5IHJlc291cmNlIGNoYW5nZSB3ZSBjYW4gZXZhbHVhdGUgaGVyZSBpcyBhbiBFQ1MgVGFza0RlZmluaXRpb25cbiAgaWYgKGNoYW5nZS5uZXdWYWx1ZS5UeXBlICE9PSAnQVdTOjpFQ1M6OlRhc2tEZWZpbml0aW9uJykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IHJldDogSG90c3dhcENoYW5nZVtdID0gW107XG5cbiAgLy8gV2Ugb25seSBhbGxvdyBhIGNoYW5nZSBpbiB0aGUgQ29udGFpbmVyRGVmaW5pdGlvbnMgb2YgdGhlIFRhc2tEZWZpbml0aW9uIGZvciBub3cgLVxuICAvLyBpdCBjb250YWlucyB0aGUgaW1hZ2UgYW5kIGVudmlyb25tZW50IHZhcmlhYmxlcywgc28gc2VlbXMgbGlrZSBhIHNhZmUgYmV0IGZvciBub3cuXG4gIC8vIFdlIG1pZ2h0IHJldmlzaXQgdGhpcyBkZWNpc2lvbiBpbiB0aGUgZnV0dXJlIHRob3VnaCFcbiAgY29uc3QgY2xhc3NpZmllZENoYW5nZXMgPSBjbGFzc2lmeUNoYW5nZXMoY2hhbmdlLCBbJ0NvbnRhaW5lckRlZmluaXRpb25zJ10pO1xuICBjbGFzc2lmaWVkQ2hhbmdlcy5yZXBvcnROb25Ib3Rzd2FwcGFibGVQcm9wZXJ0eUNoYW5nZXMocmV0KTtcblxuICAvLyBmaW5kIGFsbCBFQ1MgU2VydmljZXMgdGhhdCByZWZlcmVuY2UgdGhlIFRhc2tEZWZpbml0aW9uIHRoYXQgY2hhbmdlZFxuICBjb25zdCByZXNvdXJjZXNSZWZlcmVuY2luZ1Rhc2tEZWYgPSBldmFsdWF0ZUNmblRlbXBsYXRlLmZpbmRSZWZlcmVuY2VzVG8obG9naWNhbElkKTtcbiAgY29uc3QgZWNzU2VydmljZVJlc291cmNlc1JlZmVyZW5jaW5nVGFza0RlZiA9IHJlc291cmNlc1JlZmVyZW5jaW5nVGFza0RlZi5maWx0ZXIoXG4gICAgKHIpID0+IHIuVHlwZSA9PT0gRUNTX1NFUlZJQ0VfUkVTT1VSQ0VfVFlQRSxcbiAgKTtcbiAgY29uc3QgZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYgPSBuZXcgQXJyYXk8RWNzU2VydmljZT4oKTtcbiAgZm9yIChjb25zdCBlY3NTZXJ2aWNlUmVzb3VyY2Ugb2YgZWNzU2VydmljZVJlc291cmNlc1JlZmVyZW5jaW5nVGFza0RlZikge1xuICAgIGNvbnN0IHNlcnZpY2VBcm4gPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmZpbmRQaHlzaWNhbE5hbWVGb3IoZWNzU2VydmljZVJlc291cmNlLkxvZ2ljYWxJZCk7XG4gICAgaWYgKHNlcnZpY2VBcm4pIHtcbiAgICAgIGVjc1NlcnZpY2VzUmVmZXJlbmNpbmdUYXNrRGVmLnB1c2goe1xuICAgICAgICBsb2dpY2FsSWQ6IGVjc1NlcnZpY2VSZXNvdXJjZS5Mb2dpY2FsSWQsXG4gICAgICAgIHNlcnZpY2VBcm4sXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGVjc1NlcnZpY2VzUmVmZXJlbmNpbmdUYXNrRGVmLmxlbmd0aCA9PT0gMCkge1xuICAgIC8qKlxuICAgICAqIEVDUyBTZXJ2aWNlcyBjYW4gaGF2ZSBhIHRhc2sgZGVmaW5pdGlvbiB0aGF0IGRvZXNuJ3QgcmVmZXIgdG8gdGhlIHRhc2sgZGVmaW5pdGlvbiBiZWluZyB1cGRhdGVkLlxuICAgICAqIFdlIGhhdmUgdG8gbG9nIHRoaXMgYXMgYSBub24taG90c3dhcHBhYmxlIGNoYW5nZSB0byB0aGUgdGFzayBkZWZpbml0aW9uLCBidXQgd2hlbiB3ZSBkbyxcbiAgICAgKiB3ZSB3aW5kIHVwIGhvdHN3YXBwaW5nIHRoZSB0YXNrIGRlZmluaXRpb24gYW5kIGxvZ2dpbmcgaXQgYXMgYSBub24taG90c3dhcHBhYmxlIGNoYW5nZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbG9naWMgcHJldmVudHMgdXMgZnJvbSBsb2dnaW5nIHRoYXQgY2hhbmdlIGFzIG5vbi1ob3Rzd2FwcGFibGUgd2hlbiB3ZSBob3Rzd2FwIGl0LlxuICAgICAqL1xuICAgIHJldC5wdXNoKG5vbkhvdHN3YXBwYWJsZUNoYW5nZShcbiAgICAgIGNoYW5nZSxcbiAgICAgIE5vbkhvdHN3YXBwYWJsZVJlYXNvbi5ERVBFTkRFTkNZX1VOU1VQUE9SVEVELFxuICAgICAgJ05vIEVDUyBzZXJ2aWNlcyByZWZlcmVuY2UgdGhlIGNoYW5nZWQgdGFzayBkZWZpbml0aW9uJyxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIGZhbHNlLFxuICAgICkpO1xuICB9XG4gIGlmIChyZXNvdXJjZXNSZWZlcmVuY2luZ1Rhc2tEZWYubGVuZ3RoID4gZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYubGVuZ3RoKSB7XG4gICAgLy8gaWYgc29tZXRoaW5nIGJlc2lkZXMgYW4gRUNTIFNlcnZpY2UgaXMgcmVmZXJlbmNpbmcgdGhlIFRhc2tEZWZpbml0aW9uLFxuICAgIC8vIGhvdHN3YXAgaXMgbm90IHBvc3NpYmxlIGluIEZBTExfQkFDSyBtb2RlXG4gICAgY29uc3Qgbm9uRWNzU2VydmljZVRhc2tEZWZSZWZzID0gcmVzb3VyY2VzUmVmZXJlbmNpbmdUYXNrRGVmLmZpbHRlcigocikgPT4gci5UeXBlICE9PSBFQ1NfU0VSVklDRV9SRVNPVVJDRV9UWVBFKTtcbiAgICBmb3IgKGNvbnN0IHRhc2tSZWYgb2Ygbm9uRWNzU2VydmljZVRhc2tEZWZSZWZzKSB7XG4gICAgICByZXQucHVzaChub25Ib3Rzd2FwcGFibGVDaGFuZ2UoXG4gICAgICAgIGNoYW5nZSxcbiAgICAgICAgTm9uSG90c3dhcHBhYmxlUmVhc29uLkRFUEVOREVOQ1lfVU5TVVBQT1JURUQsXG4gICAgICAgIGBBIHJlc291cmNlICcke3Rhc2tSZWYuTG9naWNhbElkfScgd2l0aCBUeXBlICcke3Rhc2tSZWYuVHlwZX0nIHRoYXQgaXMgbm90IGFuIEVDUyBTZXJ2aWNlIHdhcyBmb3VuZCByZWZlcmVuY2luZyB0aGUgY2hhbmdlZCBUYXNrRGVmaW5pdGlvbiAnJHtsb2dpY2FsSWR9J2AsXG4gICAgICApKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBuYW1lc09mSG90c3dhcHBhYmxlQ2hhbmdlcyA9IE9iamVjdC5rZXlzKGNsYXNzaWZpZWRDaGFuZ2VzLmhvdHN3YXBwYWJsZVByb3BzKTtcbiAgaWYgKG5hbWVzT2ZIb3Rzd2FwcGFibGVDaGFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCB0YXNrRGVmaW5pdGlvblJlc291cmNlID0gYXdhaXQgcHJlcGFyZVRhc2tEZWZpbml0aW9uQ2hhbmdlKGV2YWx1YXRlQ2ZuVGVtcGxhdGUsIGxvZ2ljYWxJZCwgY2hhbmdlKTtcbiAgICByZXQucHVzaCh7XG4gICAgICBjaGFuZ2U6IHtcbiAgICAgICAgY2F1c2U6IGNoYW5nZSxcbiAgICAgICAgcmVzb3VyY2VzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbG9naWNhbElkLFxuICAgICAgICAgICAgcmVzb3VyY2VUeXBlOiBjaGFuZ2UubmV3VmFsdWUuVHlwZSxcbiAgICAgICAgICAgIHBoeXNpY2FsTmFtZTogYXdhaXQgdGFza0RlZmluaXRpb25SZXNvdXJjZS5GYW1pbHksXG4gICAgICAgICAgICBtZXRhZGF0YTogZXZhbHVhdGVDZm5UZW1wbGF0ZS5tZXRhZGF0YUZvcihsb2dpY2FsSWQpLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgLi4uZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYubWFwKChlY3NTZXJ2aWNlKSA9PiAoe1xuICAgICAgICAgICAgcmVzb3VyY2VUeXBlOiBFQ1NfU0VSVklDRV9SRVNPVVJDRV9UWVBFLFxuICAgICAgICAgICAgcGh5c2ljYWxOYW1lOiBlY3NTZXJ2aWNlLnNlcnZpY2VBcm4uc3BsaXQoJy8nKVsyXSxcbiAgICAgICAgICAgIGxvZ2ljYWxJZDogZWNzU2VydmljZS5sb2dpY2FsSWQsXG4gICAgICAgICAgICBtZXRhZGF0YTogZXZhbHVhdGVDZm5UZW1wbGF0ZS5tZXRhZGF0YUZvcihlY3NTZXJ2aWNlLmxvZ2ljYWxJZCksXG4gICAgICAgICAgfSkpLFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIGhvdHN3YXBwYWJsZTogdHJ1ZSxcbiAgICAgIHNlcnZpY2U6ICdlY3Mtc2VydmljZScsXG4gICAgICBhcHBseTogYXN5bmMgKHNkazogU0RLKSA9PiB7XG4gICAgICAgIC8vIFN0ZXAgMSAtIHVwZGF0ZSB0aGUgY2hhbmdlZCBUYXNrRGVmaW5pdGlvbiwgY3JlYXRpbmcgYSBuZXcgVGFza0RlZmluaXRpb24gUmV2aXNpb25cbiAgICAgICAgLy8gd2UgbmVlZCB0byBsb3dlcmNhc2UgdGhlIGV2YWx1YXRlZCBUYXNrRGVmIGZyb20gQ2xvdWRGb3JtYXRpb24sXG4gICAgICAgIC8vIGFzIHRoZSBBV1MgU0RLIHVzZXMgbG93ZXJjYXNlIHByb3BlcnR5IG5hbWVzIGZvciB0aGVzZVxuXG4gICAgICAgIC8vIFRoZSBTREsgcmVxdWlyZXMgbW9yZSBwcm9wZXJ0aWVzIGhlcmUgdGhhbiBpdHMgd29ydGggZG9pbmcgZXhwbGljaXQgdHlwaW5nIGZvclxuICAgICAgICAvLyBpbnN0ZWFkLCBqdXN0IHVzZSBhbGwgdGhlIG9sZCB2YWx1ZXMgaW4gdGhlIGRpZmYgdG8gZmlsbCB0aGVtIGluIGltcGxpY2l0bHlcbiAgICAgICAgY29uc3QgbG93ZXJjYXNlZFRhc2tEZWYgPSB0cmFuc2Zvcm1PYmplY3RLZXlzKHRhc2tEZWZpbml0aW9uUmVzb3VyY2UsIGxvd2VyQ2FzZUZpcnN0Q2hhcmFjdGVyLCB7XG4gICAgICAgICAgLy8gQWxsIHRoZSBwcm9wZXJ0aWVzIHRoYXQgdGFrZSBhcmJpdHJhcnkgc3RyaW5nIGFzIGtleXMgaS5lLiB7IFwic3RyaW5nXCIgOiBcInN0cmluZ1wiIH1cbiAgICAgICAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQW1hem9uRUNTL2xhdGVzdC9BUElSZWZlcmVuY2UvQVBJX1JlZ2lzdGVyVGFza0RlZmluaXRpb24uaHRtbCNBUElfUmVnaXN0ZXJUYXNrRGVmaW5pdGlvbl9SZXF1ZXN0U3ludGF4XG4gICAgICAgICAgQ29udGFpbmVyRGVmaW5pdGlvbnM6IHtcbiAgICAgICAgICAgIERvY2tlckxhYmVsczogdHJ1ZSxcbiAgICAgICAgICAgIEZpcmVsZW5zQ29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgICBPcHRpb25zOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIExvZ0NvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgICAgT3B0aW9uczogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBWb2x1bWVzOiB7XG4gICAgICAgICAgICBEb2NrZXJWb2x1bWVDb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgICAgIERyaXZlck9wdHM6IHRydWUsXG4gICAgICAgICAgICAgIExhYmVsczogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyVGFza0RlZlJlc3BvbnNlID0gYXdhaXQgc2RrLmVjcygpLnJlZ2lzdGVyVGFza0RlZmluaXRpb24obG93ZXJjYXNlZFRhc2tEZWYpO1xuICAgICAgICBjb25zdCB0YXNrRGVmUmV2QXJuID0gcmVnaXN0ZXJUYXNrRGVmUmVzcG9uc2UudGFza0RlZmluaXRpb24/LnRhc2tEZWZpbml0aW9uQXJuO1xuXG4gICAgICAgIGxldCBlY3NIb3Rzd2FwUHJvcGVydGllcyA9IGhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcy5lY3M7XG4gICAgICAgIGxldCBtaW5pbXVtSGVhbHRoeVBlcmNlbnQgPSBlY3NIb3Rzd2FwUHJvcGVydGllcz8ubWluaW11bUhlYWx0aHlQZXJjZW50O1xuICAgICAgICBsZXQgbWF4aW11bUhlYWx0aHlQZXJjZW50ID0gZWNzSG90c3dhcFByb3BlcnRpZXM/Lm1heGltdW1IZWFsdGh5UGVyY2VudDtcbiAgICAgICAgbGV0IHN0YWJpbGl6YXRpb25UaW1lb3V0U2Vjb25kcyA9IGVjc0hvdHN3YXBQcm9wZXJ0aWVzPy5zdGFiaWxpemF0aW9uVGltZW91dFNlY29uZHM7XG5cbiAgICAgICAgLy8gU3RlcCAyIC0gdXBkYXRlIHRoZSBzZXJ2aWNlcyB1c2luZyB0aGF0IFRhc2tEZWZpbml0aW9uIHRvIHBvaW50IHRvIHRoZSBuZXcgVGFza0RlZmluaXRpb24gUmV2aXNpb25cbiAgICAgICAgLy8gRm9yY2luZyBOZXcgRGVwbG95bWVudCBhbmQgc2V0dGluZyBNaW5pbXVtIEhlYWx0aHkgUGVyY2VudCB0byAwLlxuICAgICAgICAvLyBBcyBDREsgSG90U3dhcCBpcyBkZXZlbG9wbWVudCBvbmx5LCB0aGlzIHNlZW1zIHRoZSBtb3N0IGVmZmljaWVudCB3YXkgdG8gZW5zdXJlIGFsbCB0YXNrcyBhcmUgcmVwbGFjZWQgaW1tZWRpYXRlbHksIHJlZ2FyZGxlc3Mgb2Ygb3JpZ2luYWwgYW1vdW50XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAY2RrbGFicy9wcm9taXNlYWxsLW5vLXVuYm91bmRlZC1wYXJhbGxlbGlzbVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBlY3NTZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZi5tYXAoYXN5bmMgKHNlcnZpY2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNsdXN0ZXIgPSBzZXJ2aWNlLnNlcnZpY2VBcm4uc3BsaXQoJy8nKVsxXTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZSA9IGF3YWl0IHNkay5lY3MoKS51cGRhdGVTZXJ2aWNlKHtcbiAgICAgICAgICAgICAgc2VydmljZTogc2VydmljZS5zZXJ2aWNlQXJuLFxuICAgICAgICAgICAgICB0YXNrRGVmaW5pdGlvbjogdGFza0RlZlJldkFybixcbiAgICAgICAgICAgICAgY2x1c3RlcixcbiAgICAgICAgICAgICAgZm9yY2VOZXdEZXBsb3ltZW50OiB0cnVlLFxuICAgICAgICAgICAgICBkZXBsb3ltZW50Q29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgICAgIG1pbmltdW1IZWFsdGh5UGVyY2VudDogbWluaW11bUhlYWx0aHlQZXJjZW50ICE9PSB1bmRlZmluZWQgPyBtaW5pbXVtSGVhbHRoeVBlcmNlbnQgOiAwLFxuICAgICAgICAgICAgICAgIG1heGltdW1QZXJjZW50OiBtYXhpbXVtSGVhbHRoeVBlcmNlbnQgIT09IHVuZGVmaW5lZCA/IG1heGltdW1IZWFsdGh5UGVyY2VudCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhd2FpdCBzZGsuZWNzKCkud2FpdFVudGlsU2VydmljZXNTdGFibGUoe1xuICAgICAgICAgICAgICBjbHVzdGVyOiB1cGRhdGUuc2VydmljZT8uY2x1c3RlckFybixcbiAgICAgICAgICAgICAgc2VydmljZXM6IFtzZXJ2aWNlLnNlcnZpY2VBcm5dLFxuICAgICAgICAgICAgfSwgc3RhYmlsaXphdGlvblRpbWVvdXRTZWNvbmRzKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5pbnRlcmZhY2UgRWNzU2VydmljZSB7XG4gIHJlYWRvbmx5IGxvZ2ljYWxJZDogc3RyaW5nO1xuICByZWFkb25seSBzZXJ2aWNlQXJuOiBzdHJpbmc7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHByZXBhcmVUYXNrRGVmaW5pdGlvbkNoYW5nZShcbiAgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuICBsb2dpY2FsSWQ6IHN0cmluZyxcbiAgY2hhbmdlOiBSZXNvdXJjZUNoYW5nZSxcbikge1xuICBjb25zdCB0YXNrRGVmaW5pdGlvblJlc291cmNlOiB7IFtuYW1lOiBzdHJpbmddOiBhbnkgfSA9IHtcbiAgICAuLi5jaGFuZ2Uub2xkVmFsdWUuUHJvcGVydGllcyxcbiAgICBDb250YWluZXJEZWZpbml0aW9uczogY2hhbmdlLm5ld1ZhbHVlLlByb3BlcnRpZXM/LkNvbnRhaW5lckRlZmluaXRpb25zLFxuICB9O1xuICAvLyBmaXJzdCwgbGV0J3MgZ2V0IHRoZSBuYW1lIG9mIHRoZSBmYW1pbHlcbiAgY29uc3QgZmFtaWx5TmFtZU9yQXJuID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5lc3RhYmxpc2hSZXNvdXJjZVBoeXNpY2FsTmFtZShcbiAgICBsb2dpY2FsSWQsXG4gICAgdGFza0RlZmluaXRpb25SZXNvdXJjZT8uRmFtaWx5LFxuICApO1xuICBpZiAoIWZhbWlseU5hbWVPckFybikge1xuICAgIC8vIGlmIHRoZSBGYW1pbHkgcHJvcGVydHkgaGFzIG5vdCBiZWVuIHByb3ZpZGVkLCBhbmQgd2UgY2FuJ3QgZmluZCBpdCBpbiB0aGUgY3VycmVudCBTdGFjayxcbiAgICAvLyB0aGlzIG1lYW5zIGhvdHN3YXBwaW5nIGlzIG5vdCBwb3NzaWJsZVxuICAgIHJldHVybjtcbiAgfVxuICAvLyB0aGUgcGh5c2ljYWwgbmFtZSBvZiB0aGUgVGFzayBEZWZpbml0aW9uIGluIENsb3VkRm9ybWF0aW9uIGluY2x1ZGVzIGl0cyBjdXJyZW50IHJldmlzaW9uIG51bWJlciBhdCB0aGUgZW5kLFxuICAvLyByZW1vdmUgaXQgaWYgbmVlZGVkXG4gIGNvbnN0IGZhbWlseU5hbWVPckFyblBhcnRzID0gZmFtaWx5TmFtZU9yQXJuLnNwbGl0KCc6Jyk7XG4gIGNvbnN0IGZhbWlseSA9XG4gICAgZmFtaWx5TmFtZU9yQXJuUGFydHMubGVuZ3RoID4gMVxuICAgICAgPyAvLyBmYW1pbHlOYW1lT3JBcm4gaXMgYWN0dWFsbHkgYW4gQVJOLCBvZiB0aGUgZm9ybWF0ICdhcm46YXdzOmVjczpyZWdpb246YWNjb3VudDp0YXNrLWRlZmluaXRpb24vPGZhbWlseS1uYW1lPjo8cmV2aXNpb24tbnI+J1xuICAgIC8vIHNvLCB0YWtlIHRoZSA2dGggZWxlbWVudCwgYXQgaW5kZXggNSwgYW5kIHNwbGl0IGl0IG9uICcvJ1xuICAgICAgZmFtaWx5TmFtZU9yQXJuUGFydHNbNV0uc3BsaXQoJy8nKVsxXVxuICAgICAgOiAvLyBvdGhlcndpc2UsIGZhbWlseU5hbWVPckFybiBpcyBqdXN0IHRoZSBzaW1wbGUgbmFtZSBldmFsdWF0ZWQgZnJvbSB0aGUgQ2xvdWRGb3JtYXRpb24gdGVtcGxhdGVcbiAgICAgIGZhbWlseU5hbWVPckFybjtcbiAgLy8gdGhlbiwgbGV0J3MgZXZhbHVhdGUgdGhlIGJvZHkgb2YgdGhlIHJlbWFpbmRlciBvZiB0aGUgVGFza0RlZiAod2l0aG91dCB0aGUgRmFtaWx5IHByb3BlcnR5KVxuICByZXR1cm4ge1xuICAgIC4uLihhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbih7XG4gICAgICAuLi4odGFza0RlZmluaXRpb25SZXNvdXJjZSA/PyB7fSksXG4gICAgICBGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICB9KSksXG4gICAgRmFtaWx5OiBmYW1pbHksXG4gIH07XG59XG4iXX0=