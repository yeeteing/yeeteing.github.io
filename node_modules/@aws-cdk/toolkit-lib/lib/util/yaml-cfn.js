"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serialize = serialize;
exports.deserialize = deserialize;
const yaml = require("yaml");
const yaml_types = require("yaml/types");
/**
 * Serializes the given data structure into valid YAML.
 *
 * @param obj - the data structure to serialize
 * @returns a string containing the YAML representation of {@param obj}
 */
function serialize(obj) {
    const oldFold = yaml_types.strOptions.fold.lineWidth;
    try {
        yaml_types.strOptions.fold.lineWidth = 0;
        return yaml.stringify(obj, { schema: 'yaml-1.1' });
    }
    finally {
        yaml_types.strOptions.fold.lineWidth = oldFold;
    }
}
/**
 * Deserialize the YAML into the appropriate data structure.
 *
 * @param str - the string containing YAML
 * @returns the data structure the YAML represents
 *   (most often in case of CloudFormation, an object)
 */
function deserialize(str) {
    return parseYamlStrWithCfnTags(str);
}
function makeTagForCfnIntrinsic(intrinsicName, addFnPrefix) {
    return {
        identify(value) {
            return typeof value === 'string';
        },
        tag: `!${intrinsicName}`,
        resolve: (_doc, cstNode) => {
            const ret = {};
            ret[addFnPrefix ? `Fn::${intrinsicName}` : intrinsicName] =
                // the +1 is to account for the ! the short form begins with
                parseYamlStrWithCfnTags(cstNode.toString().substring(intrinsicName.length + 1));
            return ret;
        },
    };
}
const shortForms = [
    'Base64', 'Cidr', 'FindInMap', 'GetAZs', 'ImportValue', 'Join', 'Sub',
    'Select', 'Split', 'Transform', 'And', 'Equals', 'If', 'Not', 'Or', 'GetAtt',
].map(name => makeTagForCfnIntrinsic(name, true)).concat(makeTagForCfnIntrinsic('Ref', false), makeTagForCfnIntrinsic('Condition', false));
function parseYamlStrWithCfnTags(text) {
    return yaml.parse(text, {
        customTags: shortForms,
        schema: 'core',
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWFtbC1jZm4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ5YW1sLWNmbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQVVBLDhCQVFDO0FBU0Qsa0NBRUM7QUE3QkQsNkJBQTZCO0FBRTdCLHlDQUF5QztBQUV6Qzs7Ozs7R0FLRztBQUNILFNBQWdCLFNBQVMsQ0FBQyxHQUFRO0lBQ2hDLE1BQU0sT0FBTyxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQztJQUNyRCxJQUFJLENBQUM7UUFDSCxVQUFVLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDO1FBQ3pDLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLENBQUMsQ0FBQztJQUNyRCxDQUFDO1lBQVMsQ0FBQztRQUNULFVBQVUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUM7SUFDakQsQ0FBQztBQUNILENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxTQUFnQixXQUFXLENBQUMsR0FBVztJQUNyQyxPQUFPLHVCQUF1QixDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3RDLENBQUM7QUFFRCxTQUFTLHNCQUFzQixDQUFDLGFBQXFCLEVBQUUsV0FBb0I7SUFDekUsT0FBTztRQUNMLFFBQVEsQ0FBQyxLQUFVO1lBQ2pCLE9BQU8sT0FBTyxLQUFLLEtBQUssUUFBUSxDQUFDO1FBQ25DLENBQUM7UUFDRCxHQUFHLEVBQUUsSUFBSSxhQUFhLEVBQUU7UUFDeEIsT0FBTyxFQUFFLENBQUMsSUFBbUIsRUFBRSxPQUEwQixFQUFFLEVBQUU7WUFDM0QsTUFBTSxHQUFHLEdBQVEsRUFBRSxDQUFDO1lBQ3BCLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLE9BQU8sYUFBYSxFQUFFLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQztnQkFDdkQsNERBQTREO2dCQUM1RCx1QkFBdUIsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNsRixPQUFPLEdBQUcsQ0FBQztRQUNiLENBQUM7S0FDRixDQUFDO0FBQ0osQ0FBQztBQUVELE1BQU0sVUFBVSxHQUFrQztJQUNoRCxRQUFRLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUUsYUFBYSxFQUFFLE1BQU0sRUFBRSxLQUFLO0lBQ3JFLFFBQVEsRUFBRSxPQUFPLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsUUFBUTtDQUM3RSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLHNCQUFzQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FDdEQsc0JBQXNCLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxFQUNwQyxzQkFBc0IsQ0FBQyxXQUFXLEVBQUUsS0FBSyxDQUFDLENBQzNDLENBQUM7QUFFRixTQUFTLHVCQUF1QixDQUFDLElBQVk7SUFDM0MsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRTtRQUN0QixVQUFVLEVBQUUsVUFBVTtRQUN0QixNQUFNLEVBQUUsTUFBTTtLQUNmLENBQUMsQ0FBQztBQUNMLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB5YW1sIGZyb20gJ3lhbWwnO1xuaW1wb3J0IHR5cGUgKiBhcyB5YW1sX2NzdCBmcm9tICd5YW1sL3BhcnNlLWNzdCc7XG5pbXBvcnQgKiBhcyB5YW1sX3R5cGVzIGZyb20gJ3lhbWwvdHlwZXMnO1xuXG4vKipcbiAqIFNlcmlhbGl6ZXMgdGhlIGdpdmVuIGRhdGEgc3RydWN0dXJlIGludG8gdmFsaWQgWUFNTC5cbiAqXG4gKiBAcGFyYW0gb2JqIC0gdGhlIGRhdGEgc3RydWN0dXJlIHRvIHNlcmlhbGl6ZVxuICogQHJldHVybnMgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgWUFNTCByZXByZXNlbnRhdGlvbiBvZiB7QHBhcmFtIG9ian1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZShvYmo6IGFueSk6IHN0cmluZyB7XG4gIGNvbnN0IG9sZEZvbGQgPSB5YW1sX3R5cGVzLnN0ck9wdGlvbnMuZm9sZC5saW5lV2lkdGg7XG4gIHRyeSB7XG4gICAgeWFtbF90eXBlcy5zdHJPcHRpb25zLmZvbGQubGluZVdpZHRoID0gMDtcbiAgICByZXR1cm4geWFtbC5zdHJpbmdpZnkob2JqLCB7IHNjaGVtYTogJ3lhbWwtMS4xJyB9KTtcbiAgfSBmaW5hbGx5IHtcbiAgICB5YW1sX3R5cGVzLnN0ck9wdGlvbnMuZm9sZC5saW5lV2lkdGggPSBvbGRGb2xkO1xuICB9XG59XG5cbi8qKlxuICogRGVzZXJpYWxpemUgdGhlIFlBTUwgaW50byB0aGUgYXBwcm9wcmlhdGUgZGF0YSBzdHJ1Y3R1cmUuXG4gKlxuICogQHBhcmFtIHN0ciAtIHRoZSBzdHJpbmcgY29udGFpbmluZyBZQU1MXG4gKiBAcmV0dXJucyB0aGUgZGF0YSBzdHJ1Y3R1cmUgdGhlIFlBTUwgcmVwcmVzZW50c1xuICogICAobW9zdCBvZnRlbiBpbiBjYXNlIG9mIENsb3VkRm9ybWF0aW9uLCBhbiBvYmplY3QpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZShzdHI6IHN0cmluZyk6IGFueSB7XG4gIHJldHVybiBwYXJzZVlhbWxTdHJXaXRoQ2ZuVGFncyhzdHIpO1xufVxuXG5mdW5jdGlvbiBtYWtlVGFnRm9yQ2ZuSW50cmluc2ljKGludHJpbnNpY05hbWU6IHN0cmluZywgYWRkRm5QcmVmaXg6IGJvb2xlYW4pOiB5YW1sX3R5cGVzLlNjaGVtYS5DdXN0b21UYWcge1xuICByZXR1cm4ge1xuICAgIGlkZW50aWZ5KHZhbHVlOiBhbnkpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICAgIH0sXG4gICAgdGFnOiBgISR7aW50cmluc2ljTmFtZX1gLFxuICAgIHJlc29sdmU6IChfZG9jOiB5YW1sLkRvY3VtZW50LCBjc3ROb2RlOiB5YW1sX2NzdC5DU1QuTm9kZSkgPT4ge1xuICAgICAgY29uc3QgcmV0OiBhbnkgPSB7fTtcbiAgICAgIHJldFthZGRGblByZWZpeCA/IGBGbjo6JHtpbnRyaW5zaWNOYW1lfWAgOiBpbnRyaW5zaWNOYW1lXSA9XG4gICAgICAgIC8vIHRoZSArMSBpcyB0byBhY2NvdW50IGZvciB0aGUgISB0aGUgc2hvcnQgZm9ybSBiZWdpbnMgd2l0aFxuICAgICAgICBwYXJzZVlhbWxTdHJXaXRoQ2ZuVGFncyhjc3ROb2RlLnRvU3RyaW5nKCkuc3Vic3RyaW5nKGludHJpbnNpY05hbWUubGVuZ3RoICsgMSkpO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuICB9O1xufVxuXG5jb25zdCBzaG9ydEZvcm1zOiB5YW1sX3R5cGVzLlNjaGVtYS5DdXN0b21UYWdbXSA9IFtcbiAgJ0Jhc2U2NCcsICdDaWRyJywgJ0ZpbmRJbk1hcCcsICdHZXRBWnMnLCAnSW1wb3J0VmFsdWUnLCAnSm9pbicsICdTdWInLFxuICAnU2VsZWN0JywgJ1NwbGl0JywgJ1RyYW5zZm9ybScsICdBbmQnLCAnRXF1YWxzJywgJ0lmJywgJ05vdCcsICdPcicsICdHZXRBdHQnLFxuXS5tYXAobmFtZSA9PiBtYWtlVGFnRm9yQ2ZuSW50cmluc2ljKG5hbWUsIHRydWUpKS5jb25jYXQoXG4gIG1ha2VUYWdGb3JDZm5JbnRyaW5zaWMoJ1JlZicsIGZhbHNlKSxcbiAgbWFrZVRhZ0ZvckNmbkludHJpbnNpYygnQ29uZGl0aW9uJywgZmFsc2UpLFxuKTtcblxuZnVuY3Rpb24gcGFyc2VZYW1sU3RyV2l0aENmblRhZ3ModGV4dDogc3RyaW5nKTogYW55IHtcbiAgcmV0dXJuIHlhbWwucGFyc2UodGV4dCwge1xuICAgIGN1c3RvbVRhZ3M6IHNob3J0Rm9ybXMsXG4gICAgc2NoZW1hOiAnY29yZScsXG4gIH0pO1xufVxuIl19