"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getResultObj = getResultObj;
exports.findJsonValue = findJsonValue;
/**
 * This gets the values of the jsonObject at the paths specified in propertiesToReturn.
 *
 * For example, jsonObject = {
 *   key1: 'abc',
 *   key2: {
 *     foo: 'qwerty',
 *     bar: 'data',
 *   }
 * }
 *
 * propertiesToReturn = ['key1', 'key2.foo'];
 *
 * The returned object is:
 *
 * ```
 * {
 *   key1: 'abc',
 *   'key2.foo': 'qwerty',
 *   Identifier: identifier
 * }
 * ```
 */
function getResultObj(jsonObject, identifier, propertiesToReturn) {
    const propsObj = {};
    propertiesToReturn.forEach((propName) => {
        Object.assign(propsObj, { [propName]: findJsonValue(jsonObject, propName) });
    });
    Object.assign(propsObj, { ['Identifier']: identifier });
    return propsObj;
}
/**
 * This finds the value of the jsonObject at the path.  Path is delimited by '.'.
 *
 * For example, jsonObject = {
 *   key1: 'abc',
 *   key2: {
 *     foo: 'qwerty',
 *     bar: 'data',
 *   }
 * }
 *
 * If path is 'key1', then it will return 'abc'.
 * If path is 'key2.foo', then it will return 'qwerty'.
 * If path is 'key2', then it will return the object:
 * {
 *   foo: 'qwerty',
 *   bar: 'data',
 * }
 *
 * If the path is not found, an Error will be thrown stating which token is missing.
 */
function findJsonValue(jsonObject, path) {
    const paths = path.split('.');
    let obj = jsonObject;
    paths.forEach(p => {
        obj = obj[p];
        if (obj === undefined) {
            throw new TypeError(`Cannot read field ${path}. ${p} is not found.`);
        }
    });
    return obj;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianNvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImpzb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUF1QkEsb0NBT0M7QUF1QkQsc0NBVUM7QUEvREQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FzQkc7QUFDSCxTQUFnQixZQUFZLENBQUMsVUFBZSxFQUFFLFVBQWtCLEVBQUUsa0JBQTRCO0lBQzVGLE1BQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQztJQUNwQixrQkFBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRTtRQUN0QyxNQUFNLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLEVBQUUsYUFBYSxDQUFDLFVBQVUsRUFBRSxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDL0UsQ0FBQyxDQUFDLENBQUM7SUFDSCxNQUFNLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsWUFBWSxDQUFDLEVBQUUsVUFBVSxFQUFFLENBQUMsQ0FBQztJQUN4RCxPQUFPLFFBQVEsQ0FBQztBQUNsQixDQUFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBb0JHO0FBQ0gsU0FBZ0IsYUFBYSxDQUFDLFVBQWUsRUFBRSxJQUFZO0lBQ3pELE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDOUIsSUFBSSxHQUFHLEdBQUcsVUFBVSxDQUFDO0lBQ3JCLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDaEIsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNiLElBQUksR0FBRyxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQ3RCLE1BQU0sSUFBSSxTQUFTLENBQUMscUJBQXFCLElBQUksS0FBSyxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFDdkUsQ0FBQztJQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0gsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGlzIGdldHMgdGhlIHZhbHVlcyBvZiB0aGUganNvbk9iamVjdCBhdCB0aGUgcGF0aHMgc3BlY2lmaWVkIGluIHByb3BlcnRpZXNUb1JldHVybi5cbiAqXG4gKiBGb3IgZXhhbXBsZSwganNvbk9iamVjdCA9IHtcbiAqICAga2V5MTogJ2FiYycsXG4gKiAgIGtleTI6IHtcbiAqICAgICBmb286ICdxd2VydHknLFxuICogICAgIGJhcjogJ2RhdGEnLFxuICogICB9XG4gKiB9XG4gKlxuICogcHJvcGVydGllc1RvUmV0dXJuID0gWydrZXkxJywgJ2tleTIuZm9vJ107XG4gKlxuICogVGhlIHJldHVybmVkIG9iamVjdCBpczpcbiAqXG4gKiBgYGBcbiAqIHtcbiAqICAga2V5MTogJ2FiYycsXG4gKiAgICdrZXkyLmZvbyc6ICdxd2VydHknLFxuICogICBJZGVudGlmaWVyOiBpZGVudGlmaWVyXG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJlc3VsdE9iaihqc29uT2JqZWN0OiBhbnksIGlkZW50aWZpZXI6IHN0cmluZywgcHJvcGVydGllc1RvUmV0dXJuOiBzdHJpbmdbXSk6IHsgW2tleTogc3RyaW5nXTogYW55IH0ge1xuICBjb25zdCBwcm9wc09iaiA9IHt9O1xuICBwcm9wZXJ0aWVzVG9SZXR1cm4uZm9yRWFjaCgocHJvcE5hbWUpID0+IHtcbiAgICBPYmplY3QuYXNzaWduKHByb3BzT2JqLCB7IFtwcm9wTmFtZV06IGZpbmRKc29uVmFsdWUoanNvbk9iamVjdCwgcHJvcE5hbWUpIH0pO1xuICB9KTtcbiAgT2JqZWN0LmFzc2lnbihwcm9wc09iaiwgeyBbJ0lkZW50aWZpZXInXTogaWRlbnRpZmllciB9KTtcbiAgcmV0dXJuIHByb3BzT2JqO1xufVxuXG4vKipcbiAqIFRoaXMgZmluZHMgdGhlIHZhbHVlIG9mIHRoZSBqc29uT2JqZWN0IGF0IHRoZSBwYXRoLiAgUGF0aCBpcyBkZWxpbWl0ZWQgYnkgJy4nLlxuICpcbiAqIEZvciBleGFtcGxlLCBqc29uT2JqZWN0ID0ge1xuICogICBrZXkxOiAnYWJjJyxcbiAqICAga2V5Mjoge1xuICogICAgIGZvbzogJ3F3ZXJ0eScsXG4gKiAgICAgYmFyOiAnZGF0YScsXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBJZiBwYXRoIGlzICdrZXkxJywgdGhlbiBpdCB3aWxsIHJldHVybiAnYWJjJy5cbiAqIElmIHBhdGggaXMgJ2tleTIuZm9vJywgdGhlbiBpdCB3aWxsIHJldHVybiAncXdlcnR5Jy5cbiAqIElmIHBhdGggaXMgJ2tleTInLCB0aGVuIGl0IHdpbGwgcmV0dXJuIHRoZSBvYmplY3Q6XG4gKiB7XG4gKiAgIGZvbzogJ3F3ZXJ0eScsXG4gKiAgIGJhcjogJ2RhdGEnLFxuICogfVxuICpcbiAqIElmIHRoZSBwYXRoIGlzIG5vdCBmb3VuZCwgYW4gRXJyb3Igd2lsbCBiZSB0aHJvd24gc3RhdGluZyB3aGljaCB0b2tlbiBpcyBtaXNzaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZEpzb25WYWx1ZShqc29uT2JqZWN0OiBhbnksIHBhdGg6IHN0cmluZyk6IGFueSB7XG4gIGNvbnN0IHBhdGhzID0gcGF0aC5zcGxpdCgnLicpO1xuICBsZXQgb2JqID0ganNvbk9iamVjdDtcbiAgcGF0aHMuZm9yRWFjaChwID0+IHtcbiAgICBvYmogPSBvYmpbcF07XG4gICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW5ub3QgcmVhZCBmaWVsZCAke3BhdGh9LiAke3B9IGlzIG5vdCBmb3VuZC5gKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb2JqO1xufVxuIl19