"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateFieldValidationSnippet = exports.generateTypeValidationSnippet = void 0;
const graphql_mapping_template_1 = require("graphql-mapping-template");
const generateTypeValidationSnippet = (typeName, validationsByField) => {
    const fieldValidationBlocks = [];
    for (const [fieldName, validations] of Object.entries(validationsByField)) {
        const fieldBlock = (0, exports.generateFieldValidationSnippet)(fieldName, validations);
        fieldValidationBlocks.push(fieldBlock, '');
    }
    const combinedSnippet = (0, graphql_mapping_template_1.printBlock)(`Validations for type ${typeName}`)((0, graphql_mapping_template_1.raw)('\n' + fieldValidationBlocks.join('\n')));
    return combinedSnippet + '\n\n$util.toJson({})';
};
exports.generateTypeValidationSnippet = generateTypeValidationSnippet;
const generateFieldValidationSnippet = (fieldName, validations) => {
    const validationLines = [`#if(!$util.isNull($ctx.args.input.${fieldName}))`];
    for (const validation of validations) {
        const { validationType, validationValue, errorMessage } = validation;
        const escapedErrorMessage = escapeSingleQuotes(errorMessage);
        const validationVar = `${validationType}ValidationPassed`;
        const validationCheck = getValidationCheck(fieldName, validationVar, validationType, validationValue);
        validationLines.push(`  ${validationCheck}`, `  #if(!$${validationVar})`, `    $util.error('${escapedErrorMessage}')`, '  #end');
    }
    validationLines.push('#end');
    return (0, graphql_mapping_template_1.printBlock)(`Validations for field ${fieldName}`)((0, graphql_mapping_template_1.raw)(validationLines.join('\n')));
};
exports.generateFieldValidationSnippet = generateFieldValidationSnippet;
const getValidationCheck = (fieldName, validationVar, validationType, validationValue) => {
    const fieldRef = `$ctx.args.input.${fieldName}`;
    const escapedValue = escapeSingleQuotes(validationValue);
    switch (validationType.toLowerCase()) {
        case 'gt':
            return `#set($${validationVar} = ${fieldRef} > ${escapedValue})`;
        case 'lt':
            return `#set($${validationVar} = ${fieldRef} < ${escapedValue})`;
        case 'gte':
            return `#set($${validationVar} = ${fieldRef} >= ${escapedValue})`;
        case 'lte':
            return `#set($${validationVar} = ${fieldRef} <= ${escapedValue})`;
        case 'minlength':
            return `#set($${validationVar} = ${fieldRef}.length() >= ${escapedValue})`;
        case 'maxlength':
            return `#set($${validationVar} = ${fieldRef}.length() <= ${escapedValue})`;
        case 'startswith':
            return `#set($${validationVar} = ${fieldRef}.startsWith('${escapedValue}'))`;
        case 'endswith':
            return `#set($${validationVar} = ${fieldRef}.endsWith('${escapedValue}'))`;
        case 'matches':
            return `#set($${validationVar} = $util.matches('${escapedValue}', ${fieldRef}))`;
        default:
            throw new Error(`Unsupported validation type: ${validationType}`);
    }
};
const escapeSingleQuotes = (str) => {
    return str.replace(/'/g, "''");
};
//# sourceMappingURL=vtl-generator.js.map