"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserAgentProvider = void 0;
// This is intentional. There's no other way to read package version.
// 1. The 'imports' field in package.json won't work because this is CommonJS package.
// 2. We can't use `fs.readFile`. This file is bundled by ESBuild. ESBuild needs to know to bundle package.json
//    That is achievable by either require or import statements.
// 3. The package.json is outside the rootDir defined in tsconfig.json
//    Imports require tsconfig to be broken down (as explained here https://stackoverflow.com/questions/55753163/package-json-is-not-under-rootdir).
//    This would however would not work with our scripts that check tsconfig files for correctness.
// 4. Hardcoding version in the code, as opposed to reading package.json file isn't great option either.
//
// Therefore, using require as least problematic solution here.
// eslint-disable-next-line @typescript-eslint/no-require-imports
const packageVersion = require('../../../package.json').version;
// Compliant with https://www.rfc-editor.org/rfc/rfc5234.
const packageName = 'amplify-ai-constructs';
/**
 * Provides user agent.
 */
class UserAgentProvider {
    /**
     * Creates user agent provider instance.
     */
    constructor(event) {
        this.event = event;
        this.getUserAgent = (additionalMetadata) => {
            let userAgent = this.event.request.headers['x-amz-user-agent'];
            // append library version
            if (userAgent) {
                // if user agent was forwarded from AppSync then append our package information as metadata.
                userAgent = `${userAgent} md/${packageName}#${packageVersion}`;
            }
            else {
                // if user agent was not forwarded use our package information as library.
                userAgent = `lib/${packageName}#${packageVersion}`;
            }
            if (additionalMetadata) {
                Object.entries(additionalMetadata).forEach(([key, value]) => {
                    userAgent = `${userAgent} md/${key}#${value}`;
                });
            }
            return userAgent;
        };
    }
}
exports.UserAgentProvider = UserAgentProvider;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXNlcl9hZ2VudF9wcm92aWRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb252ZXJzYXRpb24vcnVudGltZS91c2VyX2FnZW50X3Byb3ZpZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUVBLHFFQUFxRTtBQUNyRSxzRkFBc0Y7QUFDdEYsK0dBQStHO0FBQy9HLGdFQUFnRTtBQUNoRSxzRUFBc0U7QUFDdEUsb0pBQW9KO0FBQ3BKLG1HQUFtRztBQUNuRyx3R0FBd0c7QUFDeEcsRUFBRTtBQUNGLCtEQUErRDtBQUMvRCxpRUFBaUU7QUFDakUsTUFBTSxjQUFjLEdBQUcsT0FBTyxDQUFDLHVCQUF1QixDQUFDLENBQUMsT0FBTyxDQUFDO0FBQ2hFLHlEQUF5RDtBQUN6RCxNQUFNLFdBQVcsR0FBRyx1QkFBdUIsQ0FBQztBQVE1Qzs7R0FFRztBQUNILE1BQWEsaUJBQWlCO0lBQzVCOztPQUVHO0lBQ0gsWUFBNkIsS0FBNEI7UUFBNUIsVUFBSyxHQUFMLEtBQUssQ0FBdUI7UUFFekQsaUJBQVksR0FBRyxDQUFDLGtCQUFnRCxFQUFVLEVBQUU7WUFDMUUsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUM7WUFFL0QseUJBQXlCO1lBQ3pCLElBQUksU0FBUyxFQUFFLENBQUM7Z0JBQ2QsNEZBQTRGO2dCQUM1RixTQUFTLEdBQUcsR0FBRyxTQUFTLE9BQU8sV0FBVyxJQUFJLGNBQWMsRUFBRSxDQUFDO1lBQ2pFLENBQUM7aUJBQU0sQ0FBQztnQkFDTiwwRUFBMEU7Z0JBQzFFLFNBQVMsR0FBRyxPQUFPLFdBQVcsSUFBSSxjQUFjLEVBQUUsQ0FBQztZQUNyRCxDQUFDO1lBRUQsSUFBSSxrQkFBa0IsRUFBRSxDQUFDO2dCQUN2QixNQUFNLENBQUMsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRTtvQkFDMUQsU0FBUyxHQUFHLEdBQUcsU0FBUyxPQUFPLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQztnQkFDaEQsQ0FBQyxDQUFDLENBQUM7WUFDTCxDQUFDO1lBRUQsT0FBTyxTQUFTLENBQUM7UUFDbkIsQ0FBQyxDQUFDO0lBckIwRCxDQUFDO0NBc0I5RDtBQTFCRCw4Q0EwQkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb252ZXJzYXRpb25UdXJuRXZlbnQgfSBmcm9tICcuL3R5cGVzJztcblxuLy8gVGhpcyBpcyBpbnRlbnRpb25hbC4gVGhlcmUncyBubyBvdGhlciB3YXkgdG8gcmVhZCBwYWNrYWdlIHZlcnNpb24uXG4vLyAxLiBUaGUgJ2ltcG9ydHMnIGZpZWxkIGluIHBhY2thZ2UuanNvbiB3b24ndCB3b3JrIGJlY2F1c2UgdGhpcyBpcyBDb21tb25KUyBwYWNrYWdlLlxuLy8gMi4gV2UgY2FuJ3QgdXNlIGBmcy5yZWFkRmlsZWAuIFRoaXMgZmlsZSBpcyBidW5kbGVkIGJ5IEVTQnVpbGQuIEVTQnVpbGQgbmVlZHMgdG8ga25vdyB0byBidW5kbGUgcGFja2FnZS5qc29uXG4vLyAgICBUaGF0IGlzIGFjaGlldmFibGUgYnkgZWl0aGVyIHJlcXVpcmUgb3IgaW1wb3J0IHN0YXRlbWVudHMuXG4vLyAzLiBUaGUgcGFja2FnZS5qc29uIGlzIG91dHNpZGUgdGhlIHJvb3REaXIgZGVmaW5lZCBpbiB0c2NvbmZpZy5qc29uXG4vLyAgICBJbXBvcnRzIHJlcXVpcmUgdHNjb25maWcgdG8gYmUgYnJva2VuIGRvd24gKGFzIGV4cGxhaW5lZCBoZXJlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU1NzUzMTYzL3BhY2thZ2UtanNvbi1pcy1ub3QtdW5kZXItcm9vdGRpcikuXG4vLyAgICBUaGlzIHdvdWxkIGhvd2V2ZXIgd291bGQgbm90IHdvcmsgd2l0aCBvdXIgc2NyaXB0cyB0aGF0IGNoZWNrIHRzY29uZmlnIGZpbGVzIGZvciBjb3JyZWN0bmVzcy5cbi8vIDQuIEhhcmRjb2RpbmcgdmVyc2lvbiBpbiB0aGUgY29kZSwgYXMgb3Bwb3NlZCB0byByZWFkaW5nIHBhY2thZ2UuanNvbiBmaWxlIGlzbid0IGdyZWF0IG9wdGlvbiBlaXRoZXIuXG4vL1xuLy8gVGhlcmVmb3JlLCB1c2luZyByZXF1aXJlIGFzIGxlYXN0IHByb2JsZW1hdGljIHNvbHV0aW9uIGhlcmUuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuY29uc3QgcGFja2FnZVZlcnNpb24gPSByZXF1aXJlKCcuLi8uLi8uLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuLy8gQ29tcGxpYW50IHdpdGggaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzUyMzQuXG5jb25zdCBwYWNrYWdlTmFtZSA9ICdhbXBsaWZ5LWFpLWNvbnN0cnVjdHMnO1xuXG5leHBvcnQgdHlwZSBVc2VyQWdlbnRBZGRpdGlvbmFsTWV0YWRhdGEgPSB7XG4gIC8vIFRoZXNlIGtleXMgYXJlIHVzZXIgYWdlbnQgZnJpZW5kbHkgaW50ZW50aW9uYWxseS5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAndHVybi1yZXNwb25zZS10eXBlJz86ICdzaW5nbGUnIHwgJ3N0cmVhbWluZycgfCAnZXJyb3InO1xufTtcblxuLyoqXG4gKiBQcm92aWRlcyB1c2VyIGFnZW50LlxuICovXG5leHBvcnQgY2xhc3MgVXNlckFnZW50UHJvdmlkZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyB1c2VyIGFnZW50IHByb3ZpZGVyIGluc3RhbmNlLlxuICAgKi9cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBldmVudDogQ29udmVyc2F0aW9uVHVybkV2ZW50KSB7fVxuXG4gIGdldFVzZXJBZ2VudCA9IChhZGRpdGlvbmFsTWV0YWRhdGE/OiBVc2VyQWdlbnRBZGRpdGlvbmFsTWV0YWRhdGEpOiBzdHJpbmcgPT4ge1xuICAgIGxldCB1c2VyQWdlbnQgPSB0aGlzLmV2ZW50LnJlcXVlc3QuaGVhZGVyc1sneC1hbXotdXNlci1hZ2VudCddO1xuXG4gICAgLy8gYXBwZW5kIGxpYnJhcnkgdmVyc2lvblxuICAgIGlmICh1c2VyQWdlbnQpIHtcbiAgICAgIC8vIGlmIHVzZXIgYWdlbnQgd2FzIGZvcndhcmRlZCBmcm9tIEFwcFN5bmMgdGhlbiBhcHBlbmQgb3VyIHBhY2thZ2UgaW5mb3JtYXRpb24gYXMgbWV0YWRhdGEuXG4gICAgICB1c2VyQWdlbnQgPSBgJHt1c2VyQWdlbnR9IG1kLyR7cGFja2FnZU5hbWV9IyR7cGFja2FnZVZlcnNpb259YDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgdXNlciBhZ2VudCB3YXMgbm90IGZvcndhcmRlZCB1c2Ugb3VyIHBhY2thZ2UgaW5mb3JtYXRpb24gYXMgbGlicmFyeS5cbiAgICAgIHVzZXJBZ2VudCA9IGBsaWIvJHtwYWNrYWdlTmFtZX0jJHtwYWNrYWdlVmVyc2lvbn1gO1xuICAgIH1cblxuICAgIGlmIChhZGRpdGlvbmFsTWV0YWRhdGEpIHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKGFkZGl0aW9uYWxNZXRhZGF0YSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIHVzZXJBZ2VudCA9IGAke3VzZXJBZ2VudH0gbWQvJHtrZXl9IyR7dmFsdWV9YDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB1c2VyQWdlbnQ7XG4gIH07XG59XG4iXX0=