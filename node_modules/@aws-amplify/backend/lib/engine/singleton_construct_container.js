import { getBackendIdentifier } from '../backend_identifier.js';
import { DefaultBackendSecretResolver } from './backend-secret/backend_secret_resolver.js';
import { BackendIdScopedSsmEnvironmentEntriesGenerator } from './backend_id_scoped_ssm_environment_entries_generator.js';
import { BackendIdScopedStableBackendIdentifiers } from '../backend_id_scoped_stable_backend_identifiers.js';
/**
 * Serves as a DI container and shared state store for initializing Amplify constructs
 */
export class SingletonConstructContainer {
    stackResolver;
    // uses the CacheEntryGenerator as the map key. The value is what the generator returned the first time it was seen
    providerCache = new Map();
    providerFactoryTokenMap = {};
    /**
     * Initialize the BackendBuildState with a root stack
     */
    constructor(stackResolver) {
        this.stackResolver = stackResolver;
    }
    /**
     * If generator has been seen before, the cached Construct instance is returned
     * Otherwise, the generator is called and the value is cached and returned
     */
    getOrCompute = (generator) => {
        if (!this.providerCache.has(generator)) {
            const scope = this.stackResolver.getStackFor(generator.resourceGroupName);
            const backendId = getBackendIdentifier(scope);
            const ssmEnvironmentEntriesGenerator = new BackendIdScopedSsmEnvironmentEntriesGenerator(scope, backendId);
            const backendSecretResolver = new DefaultBackendSecretResolver(scope, backendId);
            const stableBackendIdentifiers = new BackendIdScopedStableBackendIdentifiers(backendId);
            this.providerCache.set(generator, generator.generateContainerEntry({
                scope,
                backendSecretResolver,
                ssmEnvironmentEntriesGenerator,
                stableBackendIdentifiers,
            }));
        }
        // safe because we set if it doesn't exist above
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.providerCache.get(generator);
    };
    /**
     * Gets a ConstructFactory that has previously been registered to a given token.
     * Returns undefined if no construct factory is found for the specified token.
     *
     * NOTE: The return type of this function cannot be guaranteed at compile time because factories are dynamically registered at runtime
     * The return type of the factory is a contract that must be negotiated by the entity that registers a token and the entity that retrieves a token.
     *
     * By convention, tokens should be the name of type T
     */
    getConstructFactory = (token) => {
        if (token in this.providerFactoryTokenMap) {
            return this.providerFactoryTokenMap[token];
        }
        return;
    };
    /**
     * Register a ConstructFactory to a specified token. This ConstructFactory can be retrieved later using getConstructFactory
     * Throws if the token is already registered to a different factory
     */
    registerConstructFactory = (token, provider) => {
        if (token in this.providerFactoryTokenMap &&
            this.providerFactoryTokenMap[token] !== provider) {
            throw new Error(`Token ${token} is already registered to a ProviderFactory`);
        }
        this.providerFactoryTokenMap[token] = provider;
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2luZ2xldG9uX2NvbnN0cnVjdF9jb250YWluZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvZW5naW5lL3NpbmdsZXRvbl9jb25zdHJ1Y3RfY29udGFpbmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQU9BLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxNQUFNLDZDQUE2QyxDQUFDO0FBQzNGLE9BQU8sRUFBRSw2Q0FBNkMsRUFBRSxNQUFNLDBEQUEwRCxDQUFDO0FBQ3pILE9BQU8sRUFBRSx1Q0FBdUMsRUFBRSxNQUFNLG9EQUFvRCxDQUFDO0FBRTdHOztHQUVHO0FBQ0gsTUFBTSxPQUFPLDJCQUEyQjtJQWFUO0lBWjdCLG1IQUFtSDtJQUNsRyxhQUFhLEdBRzFCLElBQUksR0FBRyxFQUFFLENBQUM7SUFFRyx1QkFBdUIsR0FDdEMsRUFBRSxDQUFDO0lBRUw7O09BRUc7SUFDSCxZQUE2QixhQUE0QjtRQUE1QixrQkFBYSxHQUFiLGFBQWEsQ0FBZTtJQUFHLENBQUM7SUFFN0Q7OztPQUdHO0lBQ0gsWUFBWSxHQUFHLENBQ2IsU0FBMkMsRUFDekIsRUFBRTtRQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQztZQUN2QyxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsaUJBQWlCLENBQUMsQ0FBQztZQUMxRSxNQUFNLFNBQVMsR0FBRyxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUM5QyxNQUFNLDhCQUE4QixHQUNsQyxJQUFJLDZDQUE2QyxDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsQ0FBQztZQUN0RSxNQUFNLHFCQUFxQixHQUFHLElBQUksNEJBQTRCLENBQzVELEtBQUssRUFDTCxTQUFTLENBQ1YsQ0FBQztZQUNGLE1BQU0sd0JBQXdCLEdBQzVCLElBQUksdUNBQXVDLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDekQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQ3BCLFNBQVMsRUFDVCxTQUFTLENBQUMsc0JBQXNCLENBQUM7Z0JBQy9CLEtBQUs7Z0JBQ0wscUJBQXFCO2dCQUNyQiw4QkFBOEI7Z0JBQzlCLHdCQUF3QjthQUN6QixDQUFDLENBQ0gsQ0FBQztRQUNKLENBQUM7UUFDRCxnREFBZ0Q7UUFDaEQsb0VBQW9FO1FBQ3BFLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFFLENBQUM7SUFDNUMsQ0FBQyxDQUFDO0lBRUY7Ozs7Ozs7O09BUUc7SUFDSCxtQkFBbUIsR0FBRyxDQUNwQixLQUFhLEVBQ29CLEVBQUU7UUFDbkMsSUFBSSxLQUFLLElBQUksSUFBSSxDQUFDLHVCQUF1QixFQUFFLENBQUM7WUFDMUMsT0FBTyxJQUFJLENBQUMsdUJBQXVCLENBQUMsS0FBSyxDQUF3QixDQUFDO1FBQ3BFLENBQUM7UUFDRCxPQUFPO0lBQ1QsQ0FBQyxDQUFDO0lBRUY7OztPQUdHO0lBQ0gsd0JBQXdCLEdBQUcsQ0FDekIsS0FBYSxFQUNiLFFBQTBCLEVBQ3BCLEVBQUU7UUFDUixJQUNFLEtBQUssSUFBSSxJQUFJLENBQUMsdUJBQXVCO1lBQ3JDLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxLQUFLLENBQUMsS0FBSyxRQUFRLEVBQ2hELENBQUM7WUFDRCxNQUFNLElBQUksS0FBSyxDQUNiLFNBQVMsS0FBSyw2Q0FBNkMsQ0FDNUQsQ0FBQztRQUNKLENBQUM7UUFDRCxJQUFJLENBQUMsdUJBQXVCLENBQUMsS0FBSyxDQUFDLEdBQUcsUUFBUSxDQUFDO0lBQ2pELENBQUMsQ0FBQztDQUNIIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU3RhY2tSZXNvbHZlciB9IGZyb20gJy4vbmVzdGVkX3N0YWNrX3Jlc29sdmVyLmpzJztcbmltcG9ydCB7XG4gIENvbnN0cnVjdENvbnRhaW5lcixcbiAgQ29uc3RydWN0Q29udGFpbmVyRW50cnlHZW5lcmF0b3IsXG4gIENvbnN0cnVjdEZhY3RvcnksXG4gIFJlc291cmNlUHJvdmlkZXIsXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbHVnaW4tdHlwZXMnO1xuaW1wb3J0IHsgZ2V0QmFja2VuZElkZW50aWZpZXIgfSBmcm9tICcuLi9iYWNrZW5kX2lkZW50aWZpZXIuanMnO1xuaW1wb3J0IHsgRGVmYXVsdEJhY2tlbmRTZWNyZXRSZXNvbHZlciB9IGZyb20gJy4vYmFja2VuZC1zZWNyZXQvYmFja2VuZF9zZWNyZXRfcmVzb2x2ZXIuanMnO1xuaW1wb3J0IHsgQmFja2VuZElkU2NvcGVkU3NtRW52aXJvbm1lbnRFbnRyaWVzR2VuZXJhdG9yIH0gZnJvbSAnLi9iYWNrZW5kX2lkX3Njb3BlZF9zc21fZW52aXJvbm1lbnRfZW50cmllc19nZW5lcmF0b3IuanMnO1xuaW1wb3J0IHsgQmFja2VuZElkU2NvcGVkU3RhYmxlQmFja2VuZElkZW50aWZpZXJzIH0gZnJvbSAnLi4vYmFja2VuZF9pZF9zY29wZWRfc3RhYmxlX2JhY2tlbmRfaWRlbnRpZmllcnMuanMnO1xuXG4vKipcbiAqIFNlcnZlcyBhcyBhIERJIGNvbnRhaW5lciBhbmQgc2hhcmVkIHN0YXRlIHN0b3JlIGZvciBpbml0aWFsaXppbmcgQW1wbGlmeSBjb25zdHJ1Y3RzXG4gKi9cbmV4cG9ydCBjbGFzcyBTaW5nbGV0b25Db25zdHJ1Y3RDb250YWluZXIgaW1wbGVtZW50cyBDb25zdHJ1Y3RDb250YWluZXIge1xuICAvLyB1c2VzIHRoZSBDYWNoZUVudHJ5R2VuZXJhdG9yIGFzIHRoZSBtYXAga2V5LiBUaGUgdmFsdWUgaXMgd2hhdCB0aGUgZ2VuZXJhdG9yIHJldHVybmVkIHRoZSBmaXJzdCB0aW1lIGl0IHdhcyBzZWVuXG4gIHByaXZhdGUgcmVhZG9ubHkgcHJvdmlkZXJDYWNoZTogTWFwPFxuICAgIENvbnN0cnVjdENvbnRhaW5lckVudHJ5R2VuZXJhdG9yLFxuICAgIFJlc291cmNlUHJvdmlkZXJcbiAgPiA9IG5ldyBNYXAoKTtcblxuICBwcml2YXRlIHJlYWRvbmx5IHByb3ZpZGVyRmFjdG9yeVRva2VuTWFwOiBSZWNvcmQ8c3RyaW5nLCBDb25zdHJ1Y3RGYWN0b3J5PiA9XG4gICAge307XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIEJhY2tlbmRCdWlsZFN0YXRlIHdpdGggYSByb290IHN0YWNrXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHN0YWNrUmVzb2x2ZXI6IFN0YWNrUmVzb2x2ZXIpIHt9XG5cbiAgLyoqXG4gICAqIElmIGdlbmVyYXRvciBoYXMgYmVlbiBzZWVuIGJlZm9yZSwgdGhlIGNhY2hlZCBDb25zdHJ1Y3QgaW5zdGFuY2UgaXMgcmV0dXJuZWRcbiAgICogT3RoZXJ3aXNlLCB0aGUgZ2VuZXJhdG9yIGlzIGNhbGxlZCBhbmQgdGhlIHZhbHVlIGlzIGNhY2hlZCBhbmQgcmV0dXJuZWRcbiAgICovXG4gIGdldE9yQ29tcHV0ZSA9IChcbiAgICBnZW5lcmF0b3I6IENvbnN0cnVjdENvbnRhaW5lckVudHJ5R2VuZXJhdG9yLFxuICApOiBSZXNvdXJjZVByb3ZpZGVyID0+IHtcbiAgICBpZiAoIXRoaXMucHJvdmlkZXJDYWNoZS5oYXMoZ2VuZXJhdG9yKSkge1xuICAgICAgY29uc3Qgc2NvcGUgPSB0aGlzLnN0YWNrUmVzb2x2ZXIuZ2V0U3RhY2tGb3IoZ2VuZXJhdG9yLnJlc291cmNlR3JvdXBOYW1lKTtcbiAgICAgIGNvbnN0IGJhY2tlbmRJZCA9IGdldEJhY2tlbmRJZGVudGlmaWVyKHNjb3BlKTtcbiAgICAgIGNvbnN0IHNzbUVudmlyb25tZW50RW50cmllc0dlbmVyYXRvciA9XG4gICAgICAgIG5ldyBCYWNrZW5kSWRTY29wZWRTc21FbnZpcm9ubWVudEVudHJpZXNHZW5lcmF0b3Ioc2NvcGUsIGJhY2tlbmRJZCk7XG4gICAgICBjb25zdCBiYWNrZW5kU2VjcmV0UmVzb2x2ZXIgPSBuZXcgRGVmYXVsdEJhY2tlbmRTZWNyZXRSZXNvbHZlcihcbiAgICAgICAgc2NvcGUsXG4gICAgICAgIGJhY2tlbmRJZCxcbiAgICAgICk7XG4gICAgICBjb25zdCBzdGFibGVCYWNrZW5kSWRlbnRpZmllcnMgPVxuICAgICAgICBuZXcgQmFja2VuZElkU2NvcGVkU3RhYmxlQmFja2VuZElkZW50aWZpZXJzKGJhY2tlbmRJZCk7XG4gICAgICB0aGlzLnByb3ZpZGVyQ2FjaGUuc2V0KFxuICAgICAgICBnZW5lcmF0b3IsXG4gICAgICAgIGdlbmVyYXRvci5nZW5lcmF0ZUNvbnRhaW5lckVudHJ5KHtcbiAgICAgICAgICBzY29wZSxcbiAgICAgICAgICBiYWNrZW5kU2VjcmV0UmVzb2x2ZXIsXG4gICAgICAgICAgc3NtRW52aXJvbm1lbnRFbnRyaWVzR2VuZXJhdG9yLFxuICAgICAgICAgIHN0YWJsZUJhY2tlbmRJZGVudGlmaWVycyxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBzYWZlIGJlY2F1c2Ugd2Ugc2V0IGlmIGl0IGRvZXNuJ3QgZXhpc3QgYWJvdmVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyQ2FjaGUuZ2V0KGdlbmVyYXRvcikhO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGEgQ29uc3RydWN0RmFjdG9yeSB0aGF0IGhhcyBwcmV2aW91c2x5IGJlZW4gcmVnaXN0ZXJlZCB0byBhIGdpdmVuIHRva2VuLlxuICAgKiBSZXR1cm5zIHVuZGVmaW5lZCBpZiBubyBjb25zdHJ1Y3QgZmFjdG9yeSBpcyBmb3VuZCBmb3IgdGhlIHNwZWNpZmllZCB0b2tlbi5cbiAgICpcbiAgICogTk9URTogVGhlIHJldHVybiB0eXBlIG9mIHRoaXMgZnVuY3Rpb24gY2Fubm90IGJlIGd1YXJhbnRlZWQgYXQgY29tcGlsZSB0aW1lIGJlY2F1c2UgZmFjdG9yaWVzIGFyZSBkeW5hbWljYWxseSByZWdpc3RlcmVkIGF0IHJ1bnRpbWVcbiAgICogVGhlIHJldHVybiB0eXBlIG9mIHRoZSBmYWN0b3J5IGlzIGEgY29udHJhY3QgdGhhdCBtdXN0IGJlIG5lZ290aWF0ZWQgYnkgdGhlIGVudGl0eSB0aGF0IHJlZ2lzdGVycyBhIHRva2VuIGFuZCB0aGUgZW50aXR5IHRoYXQgcmV0cmlldmVzIGEgdG9rZW4uXG4gICAqXG4gICAqIEJ5IGNvbnZlbnRpb24sIHRva2VucyBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdHlwZSBUXG4gICAqL1xuICBnZXRDb25zdHJ1Y3RGYWN0b3J5ID0gPFQgZXh0ZW5kcyBSZXNvdXJjZVByb3ZpZGVyPihcbiAgICB0b2tlbjogc3RyaW5nLFxuICApOiBDb25zdHJ1Y3RGYWN0b3J5PFQ+IHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAodG9rZW4gaW4gdGhpcy5wcm92aWRlckZhY3RvcnlUb2tlbk1hcCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXJGYWN0b3J5VG9rZW5NYXBbdG9rZW5dIGFzIENvbnN0cnVjdEZhY3Rvcnk8VD47XG4gICAgfVxuICAgIHJldHVybjtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBDb25zdHJ1Y3RGYWN0b3J5IHRvIGEgc3BlY2lmaWVkIHRva2VuLiBUaGlzIENvbnN0cnVjdEZhY3RvcnkgY2FuIGJlIHJldHJpZXZlZCBsYXRlciB1c2luZyBnZXRDb25zdHJ1Y3RGYWN0b3J5XG4gICAqIFRocm93cyBpZiB0aGUgdG9rZW4gaXMgYWxyZWFkeSByZWdpc3RlcmVkIHRvIGEgZGlmZmVyZW50IGZhY3RvcnlcbiAgICovXG4gIHJlZ2lzdGVyQ29uc3RydWN0RmFjdG9yeSA9IChcbiAgICB0b2tlbjogc3RyaW5nLFxuICAgIHByb3ZpZGVyOiBDb25zdHJ1Y3RGYWN0b3J5LFxuICApOiB2b2lkID0+IHtcbiAgICBpZiAoXG4gICAgICB0b2tlbiBpbiB0aGlzLnByb3ZpZGVyRmFjdG9yeVRva2VuTWFwICYmXG4gICAgICB0aGlzLnByb3ZpZGVyRmFjdG9yeVRva2VuTWFwW3Rva2VuXSAhPT0gcHJvdmlkZXJcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRva2VuICR7dG9rZW59IGlzIGFscmVhZHkgcmVnaXN0ZXJlZCB0byBhIFByb3ZpZGVyRmFjdG9yeWAsXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnByb3ZpZGVyRmFjdG9yeVRva2VuTWFwW3Rva2VuXSA9IHByb3ZpZGVyO1xuICB9O1xufVxuIl19