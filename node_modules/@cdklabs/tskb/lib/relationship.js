"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRelationshipCollection = exports.relationshipCollection = exports.NO_RELATIONSHIPS = void 0;
const NO_RELATIONSHIPS = () => ({});
exports.NO_RELATIONSHIPS = NO_RELATIONSHIPS;
function relationshipCollection(fromField, toField) {
    const forward = new Map();
    const backward = new Map();
    function add(fromId, toId, attrs) {
        let f = forward.get(fromId);
        if (!f) {
            f = [];
            forward.set(fromId, f);
        }
        let b = backward.get(toId);
        if (!b) {
            b = [];
            backward.set(toId, b);
        }
        // Behaves like a set, only add new relationship if it is structurally distinct
        const forwardRel = { $id: toId, ...attrs };
        const forwardRelStr = JSON.stringify(forwardRel);
        const existingRelationship = f.find((x) => JSON.stringify(x) === forwardRelStr);
        if (!existingRelationship) {
            f.push(forwardRel);
            b.push({ $id: fromId, ...attrs });
        }
    }
    return {
        type: 'rel',
        fromColl: fromField,
        toColl: toField,
        forward,
        backward,
        add(from, to, attributes) {
            add(from.$id, to.$id, attributes);
        },
        dehydrate() {
            return {
                type: 'rel',
                forward: Object.fromEntries(forward.entries()),
            };
        },
        hydrateFrom(x) {
            forward.clear();
            backward.clear();
            for (const [fromId, targets] of Object.entries(x.forward)) {
                for (const target of targets) {
                    add(fromId, target.$id, removeId(target));
                }
            }
        },
    };
}
exports.relationshipCollection = relationshipCollection;
function isRelationshipCollection(x) {
    return typeof x === 'object' && !!x && x.type === 'rel';
}
exports.isRelationshipCollection = isRelationshipCollection;
function removeId(x) {
    const ret = { ...x };
    delete ret.$id;
    return ret;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVsYXRpb25zaGlwLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3JlbGF0aW9uc2hpcC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUE2Qk8sTUFBTSxnQkFBZ0IsR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQTlCLFFBQUEsZ0JBQWdCLG9CQUFjO0FBRTNDLFNBQWdCLHNCQUFzQixDQUNwQyxTQUF3QixFQUN4QixPQUFvQjtJQUVwQixNQUFNLE9BQU8sR0FBRyxJQUFJLEdBQUcsRUFBMkIsQ0FBQztJQUNuRCxNQUFNLFFBQVEsR0FBRyxJQUFJLEdBQUcsRUFBMkIsQ0FBQztJQUVwRCxTQUFTLEdBQUcsQ0FBQyxNQUFjLEVBQUUsSUFBWSxFQUFFLEtBQVU7UUFDbkQsSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM1QixJQUFJLENBQUMsQ0FBQyxFQUFFO1lBQ04sQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUNQLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ3hCO1FBQ0QsSUFBSSxDQUFDLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMzQixJQUFJLENBQUMsQ0FBQyxFQUFFO1lBQ04sQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUNQLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ3ZCO1FBRUQsK0VBQStFO1FBQy9FLE1BQU0sVUFBVSxHQUFHLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxHQUFHLEtBQUssRUFBRSxDQUFDO1FBQzNDLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDakQsTUFBTSxvQkFBb0IsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLLGFBQWEsQ0FBQyxDQUFDO1FBRWhGLElBQUksQ0FBQyxvQkFBb0IsRUFBRTtZQUN6QixDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ25CLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsS0FBSyxFQUFFLENBQUMsQ0FBQztTQUNuQztJQUNILENBQUM7SUFFRCxPQUFPO1FBQ0wsSUFBSSxFQUFFLEtBQUs7UUFDWCxRQUFRLEVBQUUsU0FBUztRQUNuQixNQUFNLEVBQUUsT0FBTztRQUNmLE9BQU87UUFDUCxRQUFRO1FBQ1IsR0FBRyxDQUFDLElBQVksRUFBRSxFQUFVLEVBQUUsVUFBZTtZQUMzQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBQ3BDLENBQUM7UUFDRCxTQUFTO1lBQ1AsT0FBTztnQkFDTCxJQUFJLEVBQUUsS0FBSztnQkFDWCxPQUFPLEVBQUUsTUFBTSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7YUFDL0MsQ0FBQztRQUNKLENBQUM7UUFDRCxXQUFXLENBQUMsQ0FBTTtZQUNoQixPQUFPLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDaEIsUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBRWpCLEtBQUssTUFBTSxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRTtnQkFDekQsS0FBSyxNQUFNLE1BQU0sSUFBSSxPQUEwQixFQUFFO29CQUMvQyxHQUFHLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7aUJBQzNDO2FBQ0Y7UUFDSCxDQUFDO0tBQ0YsQ0FBQztBQUNKLENBQUM7QUF4REQsd0RBd0RDO0FBRUQsU0FBZ0Isd0JBQXdCLENBQUMsQ0FBVTtJQUNqRCxPQUFPLE9BQU8sQ0FBQyxLQUFLLFFBQVEsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFLLENBQVMsQ0FBQyxJQUFJLEtBQUssS0FBSyxDQUFDO0FBQ25FLENBQUM7QUFGRCw0REFFQztBQUVELFNBQVMsUUFBUSxDQUFtQixDQUFJO0lBQ3RDLE1BQU0sR0FBRyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQztJQUNyQixPQUFRLEdBQVcsQ0FBQyxHQUFHLENBQUM7SUFDeEIsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRW50aXR5LCBFbnRpdHlDb2xsZWN0aW9uIH0gZnJvbSAnLi9lbnRpdHknO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlbGF0aW9uc2hpcDxGcm9tIGV4dGVuZHMgRW50aXR5LCBUbyBleHRlbmRzIEVudGl0eSwgQXR0cmlidXRlcyA9IHt9PiB7XG4gIHJlYWRvbmx5IGZyb206IEZyb207XG4gIHJlYWRvbmx5IHRvOiBUbztcbiAgcmVhZG9ubHkgYXR0cjogQXR0cmlidXRlcztcbn1cblxudHlwZSBGcm9tR2V0dGVyPFIgZXh0ZW5kcyBSZWxhdGlvbnNoaXA8YW55LCBhbnksIGFueT4+ID0gKGlkOiBzdHJpbmcpID0+IFJbJ2Zyb20nXTtcbnR5cGUgVG9HZXR0ZXI8UiBleHRlbmRzIFJlbGF0aW9uc2hpcDxhbnksIGFueSwgYW55Pj4gPSAoaWQ6IHN0cmluZykgPT4gUlsndG8nXTtcblxuZXhwb3J0IGludGVyZmFjZSBSZWxhdGlvbnNoaXBDb2xsZWN0aW9uPFIgZXh0ZW5kcyBSZWxhdGlvbnNoaXA8YW55LCBhbnksIGFueT4+IHtcbiAgcmVhZG9ubHkgdHlwZTogJ3JlbCc7XG4gIHJlYWRvbmx5IGZyb21Db2xsOiBGcm9tR2V0dGVyPFI+O1xuICByZWFkb25seSB0b0NvbGw6IFRvR2V0dGVyPFI+O1xuICByZWFkb25seSBmb3J3YXJkOiBNYXA8c3RyaW5nLCBSZWw8UlsnYXR0ciddPltdPjtcbiAgcmVhZG9ubHkgYmFja3dhcmQ6IE1hcDxzdHJpbmcsIFJlbDxSWydhdHRyJ10+W10+O1xuXG4gIGFkZChmcm9tOiBSWydmcm9tJ10sIHRvOiBSWyd0byddLCBhdHRyaWJ1dGVzOiBSWydhdHRyJ10pOiB2b2lkO1xuICBkZWh5ZHJhdGUoKTogYW55O1xuICBoeWRyYXRlRnJvbSh4OiBhbnkpOiB2b2lkO1xufVxuXG5leHBvcnQgdHlwZSBSZWw8QXR0cmlidXRlcz4gPSB7IHJlYWRvbmx5ICRpZDogc3RyaW5nIH0gJiBBdHRyaWJ1dGVzO1xuXG5leHBvcnQgdHlwZSBLZXlGb3JFbnRpdHlDb2xsZWN0aW9uPFMsIEUgZXh0ZW5kcyBFbnRpdHk+ID0ge1xuICBbSyBpbiBrZXlvZiBTXTogU1tLXSBleHRlbmRzIEVudGl0eUNvbGxlY3Rpb248RT4gPyBLIDogbmV2ZXI7XG59W2tleW9mIFNdO1xuXG5leHBvcnQgY29uc3QgTk9fUkVMQVRJT05TSElQUyA9ICgpID0+ICh7fSk7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWxhdGlvbnNoaXBDb2xsZWN0aW9uPFIgZXh0ZW5kcyBSZWxhdGlvbnNoaXA8YW55LCBhbnksIGFueT4+KFxuICBmcm9tRmllbGQ6IEZyb21HZXR0ZXI8Uj4sXG4gIHRvRmllbGQ6IFRvR2V0dGVyPFI+LFxuKTogUmVsYXRpb25zaGlwQ29sbGVjdGlvbjxSPiB7XG4gIGNvbnN0IGZvcndhcmQgPSBuZXcgTWFwPHN0cmluZywgQXJyYXk8UmVsPGFueT4+PigpO1xuICBjb25zdCBiYWNrd2FyZCA9IG5ldyBNYXA8c3RyaW5nLCBBcnJheTxSZWw8YW55Pj4+KCk7XG5cbiAgZnVuY3Rpb24gYWRkKGZyb21JZDogc3RyaW5nLCB0b0lkOiBzdHJpbmcsIGF0dHJzOiBhbnkpIHtcbiAgICBsZXQgZiA9IGZvcndhcmQuZ2V0KGZyb21JZCk7XG4gICAgaWYgKCFmKSB7XG4gICAgICBmID0gW107XG4gICAgICBmb3J3YXJkLnNldChmcm9tSWQsIGYpO1xuICAgIH1cbiAgICBsZXQgYiA9IGJhY2t3YXJkLmdldCh0b0lkKTtcbiAgICBpZiAoIWIpIHtcbiAgICAgIGIgPSBbXTtcbiAgICAgIGJhY2t3YXJkLnNldCh0b0lkLCBiKTtcbiAgICB9XG5cbiAgICAvLyBCZWhhdmVzIGxpa2UgYSBzZXQsIG9ubHkgYWRkIG5ldyByZWxhdGlvbnNoaXAgaWYgaXQgaXMgc3RydWN0dXJhbGx5IGRpc3RpbmN0XG4gICAgY29uc3QgZm9yd2FyZFJlbCA9IHsgJGlkOiB0b0lkLCAuLi5hdHRycyB9O1xuICAgIGNvbnN0IGZvcndhcmRSZWxTdHIgPSBKU09OLnN0cmluZ2lmeShmb3J3YXJkUmVsKTtcbiAgICBjb25zdCBleGlzdGluZ1JlbGF0aW9uc2hpcCA9IGYuZmluZCgoeCkgPT4gSlNPTi5zdHJpbmdpZnkoeCkgPT09IGZvcndhcmRSZWxTdHIpO1xuXG4gICAgaWYgKCFleGlzdGluZ1JlbGF0aW9uc2hpcCkge1xuICAgICAgZi5wdXNoKGZvcndhcmRSZWwpO1xuICAgICAgYi5wdXNoKHsgJGlkOiBmcm9tSWQsIC4uLmF0dHJzIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ3JlbCcsXG4gICAgZnJvbUNvbGw6IGZyb21GaWVsZCxcbiAgICB0b0NvbGw6IHRvRmllbGQsXG4gICAgZm9yd2FyZCxcbiAgICBiYWNrd2FyZCxcbiAgICBhZGQoZnJvbTogRW50aXR5LCB0bzogRW50aXR5LCBhdHRyaWJ1dGVzOiBhbnkpIHtcbiAgICAgIGFkZChmcm9tLiRpZCwgdG8uJGlkLCBhdHRyaWJ1dGVzKTtcbiAgICB9LFxuICAgIGRlaHlkcmF0ZSgpOiBhbnkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3JlbCcsXG4gICAgICAgIGZvcndhcmQ6IE9iamVjdC5mcm9tRW50cmllcyhmb3J3YXJkLmVudHJpZXMoKSksXG4gICAgICB9O1xuICAgIH0sXG4gICAgaHlkcmF0ZUZyb20oeDogYW55KTogdm9pZCB7XG4gICAgICBmb3J3YXJkLmNsZWFyKCk7XG4gICAgICBiYWNrd2FyZC5jbGVhcigpO1xuXG4gICAgICBmb3IgKGNvbnN0IFtmcm9tSWQsIHRhcmdldHNdIG9mIE9iamVjdC5lbnRyaWVzKHguZm9yd2FyZCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXQgb2YgdGFyZ2V0cyBhcyBBcnJheTxSZWw8YW55Pj4pIHtcbiAgICAgICAgICBhZGQoZnJvbUlkLCB0YXJnZXQuJGlkLCByZW1vdmVJZCh0YXJnZXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JlbGF0aW9uc2hpcENvbGxlY3Rpb24oeDogdW5rbm93bik6IHggaXMgUmVsYXRpb25zaGlwQ29sbGVjdGlvbjxhbnk+IHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiAhIXggJiYgKHggYXMgYW55KS50eXBlID09PSAncmVsJztcbn1cblxuZnVuY3Rpb24gcmVtb3ZlSWQ8QSBleHRlbmRzIG9iamVjdD4oeDogQSk6IE9taXQ8QSwgJyRpZCc+IHtcbiAgY29uc3QgcmV0ID0geyAuLi54IH07XG4gIGRlbGV0ZSAocmV0IGFzIGFueSkuJGlkO1xuICByZXR1cm4gcmV0O1xufVxuIl19