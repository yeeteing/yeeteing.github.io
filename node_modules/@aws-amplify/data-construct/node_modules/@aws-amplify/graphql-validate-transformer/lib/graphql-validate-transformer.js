"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidateTransformer = void 0;
const graphql_directives_1 = require("@aws-amplify/graphql-directives");
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const validators_1 = require("./validators");
const vtl_generator_1 = require("./vtl-generator");
class ValidateTransformer extends graphql_transformer_core_1.TransformerPluginBase {
    constructor() {
        super('amplify-graphql-validate-transformer', graphql_directives_1.ValidateDirective.definition);
        this.directiveMap = new Map();
        this.field = (parent, definition, directive, _) => {
            const directiveWrapped = new graphql_transformer_core_1.DirectiveWrapper(directive);
            const config = this.getValidateDirectiveConfiguration(directiveWrapped, parent, definition);
            (0, validators_1.validate)(parent, definition, directive, config);
            const parentName = parent.name.value;
            if (!this.directiveMap.has(parentName)) {
                this.directiveMap.set(parentName, []);
            }
            this.directiveMap.get(parentName).push(config);
        };
        this.generateResolvers = (ctx) => {
            const mutationTypeName = ctx.output.getMutationTypeName();
            if (!mutationTypeName) {
                return;
            }
            for (const [typeName, configs] of this.directiveMap.entries()) {
                const validationsByField = {};
                for (const config of configs) {
                    const fieldName = config.fieldNode.name.value;
                    if (!validationsByField[fieldName]) {
                        validationsByField[fieldName] = [];
                    }
                    const defaultErrorMessage = constructDefaultErrorMessage(typeName, fieldName, config.validationType, config.validationValue);
                    validationsByField[fieldName].push({
                        validationType: config.validationType,
                        validationValue: config.validationValue,
                        errorMessage: config.errorMessage || defaultErrorMessage,
                    });
                }
                const combinedTypeSnippet = (0, vtl_generator_1.generateTypeValidationSnippet)(typeName, validationsByField);
                const createFieldName = `create${typeName}`;
                const createResolver = ctx.resolvers.getResolver(mutationTypeName, createFieldName);
                if (createResolver) {
                    createResolver.addVtlFunctionToSlot('validate', graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(combinedTypeSnippet, `${mutationTypeName}.${createFieldName}.{slotName}.{slotIndex}.req.vtl`));
                }
                const updateFieldName = `update${typeName}`;
                const updateResolver = ctx.resolvers.getResolver(mutationTypeName, updateFieldName);
                if (updateResolver) {
                    updateResolver.addVtlFunctionToSlot('validate', graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(combinedTypeSnippet, `${mutationTypeName}.${updateFieldName}.{slotName}.{slotIndex}.req.vtl`));
                }
            }
        };
    }
    getValidateDirectiveConfiguration(directive, parentNode, fieldNode) {
        const defaultArgs = {
            type: '',
            value: '',
            errorMessage: '',
        };
        const args = directive.getArguments(defaultArgs);
        return {
            parentNode,
            fieldNode,
            validationType: args.type,
            validationValue: args.value,
            errorMessage: args.errorMessage,
        };
    }
}
exports.ValidateTransformer = ValidateTransformer;
const constructDefaultErrorMessage = (typeName, fieldName, validationType, validationValue) => {
    switch (validationType) {
        case 'gt':
            return `Field ${fieldName} of type ${typeName} must be greater than ${validationValue}`;
        case 'lt':
            return `Field ${fieldName} of type ${typeName} must be less than ${validationValue}`;
        case 'gte':
            return `Field ${fieldName} of type ${typeName} must be greater than or equal to ${validationValue}`;
        case 'lte':
            return `Field ${fieldName} of type ${typeName} must be less than or equal to ${validationValue}`;
        case 'minLength':
            return `Field ${fieldName} of type ${typeName} must have a minimum length of ${validationValue}`;
        case 'maxLength':
            return `Field ${fieldName} of type ${typeName} must have a maximum length of ${validationValue}`;
        case 'startsWith':
            return `Field ${fieldName} of type ${typeName} must start with ${validationValue}`;
        case 'endsWith':
            return `Field ${fieldName} of type ${typeName} must end with ${validationValue}`;
        case 'matches':
            return `Field ${fieldName} of type ${typeName} must match ${validationValue}`;
        default:
            throw new Error(`Unsupported validation type: ${validationType}`);
    }
};
//# sourceMappingURL=graphql-validate-transformer.js.map