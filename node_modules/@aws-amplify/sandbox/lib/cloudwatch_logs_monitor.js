import { LogLevel, Printer, colorNames, format, printer, } from '@aws-amplify/cli-core';
import { FilterLogEventsCommand, ResourceNotFoundException, } from '@aws-sdk/client-cloudwatch-logs';
import fs from 'fs';
import path from 'path';
/**
 * After reading events from all CloudWatch log groups how long should we wait to read more events.
 *
 * If there is some error with reading events (i.e. Throttle) then this is also how long we wait until we try again
 */
const SLEEP_MS = 2_000;
/**
 * Monitors CloudWatch logs and stream it to stdout or a user provided file location
 * Consumers can activate and deactivate the monitor. The monitor on reactivation, starts
 * streaming from the last time it was deactivated to avoid missing any logs while the monitor
 * was deactivated.
 */
export class CloudWatchLogEventMonitor {
    cloudWatchLogsClient;
    /**
     * Determines from what time the logs should be streamed
     */
    startTime;
    /**
     * Collection of all LogGroups that need to be streamed
     */
    allLogGroups = [];
    logGroupEventDisplay = {};
    active = false;
    printer = printer; // default stdout
    enableColors = true; // show colors on console but not while writing to files
    /**
     * Initializes the start time to be `now`
     */
    constructor(cloudWatchLogsClient) {
        this.cloudWatchLogsClient = cloudWatchLogsClient;
        this.startTime = Date.now();
    }
    /**
     * resume writing/printing events
     * If output location file is specified, the logs will be appended to that file.
     * If the file doesn't exist it will be created.
     * @param outputLocation file location
     */
    activate = (outputLocation) => {
        if (outputLocation) {
            const targetPath = path.isAbsolute(outputLocation)
                ? outputLocation
                : path.resolve(process.cwd(), outputLocation);
            this.printer = new Printer(LogLevel.INFO, fs.createWriteStream(targetPath, { flags: 'a', autoClose: true }));
            this.enableColors = false;
        }
        this.active = true;
        this.scheduleNextTick(0);
    };
    /**
     * Pause the monitor so no new events are read
     * use case for this is when we are in the middle of performing a deployment
     * and don't want to interweave all the logs together with the CFN
     * deployment logs
     *
     * Also resets the start time to be when the new deployment was triggered so that we
     * start streaming the logs from when it was deactivated.
     * and clears the list of tracked log groups
     */
    pause = () => {
        this.active = false;
        this.startTime = Date.now();
        this.allLogGroups.splice(0, this.allLogGroups.length);
    };
    /**
     * Adds CloudWatch log groups to read log events from.
     * Since we could be watching multiple logs groups we need a friendly
     * name for to associate the log group to make it easier
     * for the user to identify which log groups are being monitored
     * @param friendlyResourceName The friendly name of the resource that is being monitored
     * @param logGroupName The log group to read events from
     */
    addLogGroups = (friendlyResourceName, logGroupName) => {
        this.allLogGroups.push({
            logGroupName,
            startTime: this.startTime,
        });
        this.logGroupEventDisplay[logGroupName] = {
            friendlyName: friendlyResourceName,
            color: this.getNextColorForLogGroup(),
        };
    };
    /**
     * Pick the next color in the object `colors` in round robin fashion
     */
    getNextColorForLogGroup = () => {
        return colorNames[this.allLogGroups.length % colorNames.length];
    };
    scheduleNextTick = (sleep) => {
        setTimeout(() => void this.tick(), sleep);
    };
    tick = async () => {
        if (!this.active) {
            return;
        }
        try {
            const events = await this.readNewEvents();
            events.forEach((event) => {
                this.print(event);
            });
        }
        catch (error) {
            printer.log(`${format.error('Error streaming logs from CloudWatch.')} ${format.error(error)}`, LogLevel.ERROR);
            printer.log('Logs streaming has been paused.');
            this.pause();
        }
        this.scheduleNextTick(SLEEP_MS);
    };
    /**
     * Reads all new log events from a set of CloudWatch Log Groups in parallel
     */
    readNewEvents = async () => {
        const results = [];
        for (const logGroup of this.allLogGroups) {
            results.push(await this.readEventsFromLogGroup(logGroup));
            // There is a hard limit on TPS for `FilterLogEvents` API that is Account wide.
            // We don't want to get throttled is customers are filtering for a lot of functions.
            await new Promise((resolve) => setTimeout(resolve, 500));
        }
        return results.flat();
    };
    /**
     * Print out one CloudWatch event using the local printer.
     */
    print = (event) => {
        const cloudWatchEventDisplay = this.logGroupEventDisplay[event.logGroupName];
        if (!cloudWatchEventDisplay) {
            return;
        }
        if (this.enableColors) {
            this.printer.print(`${format.note(event.timestamp.toLocaleTimeString())} [${format.color(cloudWatchEventDisplay.friendlyName, cloudWatchEventDisplay.color)}] ${event.message.trim()}`);
        }
        else {
            this.printer.print(`${event.timestamp.toLocaleTimeString()} [${cloudWatchEventDisplay.friendlyName}] ${event.message.trim()}`);
        }
    };
    /**
     * Reads all new log events from a CloudWatch Log Group
     * starting at either the time the last deployment was triggered or
     * when the last event was read on the previous tick
     */
    readEventsFromLogGroup = async (cloudWatchLogsToMonitor) => {
        const events = [];
        // log events from some service are ingested faster than others
        // so we need to track the start/end time for each log group individually
        // to make sure that we process all events from each log group.
        // endTime tracks the latest event received
        const startTime = cloudWatchLogsToMonitor.startTime ?? this.startTime;
        let endTime = startTime;
        try {
            const response = await this.cloudWatchLogsClient.send(new FilterLogEventsCommand({
                logGroupName: cloudWatchLogsToMonitor.logGroupName,
                limit: 100,
                startTime,
            }));
            const filteredEvents = response.events ?? [];
            for (const event of filteredEvents) {
                if (event.message) {
                    events.push({
                        message: event.message,
                        logGroupName: cloudWatchLogsToMonitor.logGroupName,
                        timestamp: event.timestamp ? new Date(event.timestamp) : new Date(),
                    });
                    if (event.timestamp && endTime < event.timestamp) {
                        endTime = event.timestamp;
                    }
                }
            }
            // As long as there are _any_ events in the log group `filterLogEvents` will return a nextToken.
            // This is true even if these events are before `startTime`. So if we have 100 events and a nextToken
            // then assume that we have hit the limit and let the user know some messages have been suppressed.
            // We are essentially showing them a sampling (10000 events printed out is not very useful)
            if (filteredEvents.length === 100 && response.nextToken) {
                events.push({
                    message: '>>> `sandbox` shows only the first 100 log messages - the rest have been truncated...',
                    logGroupName: cloudWatchLogsToMonitor.logGroupName,
                    timestamp: new Date(endTime),
                });
            }
        }
        catch (e) {
            // with Lambda functions the Log Group is not created
            // until something is logged, so just keep polling until
            // there is something to find
            if (e && e instanceof ResourceNotFoundException) {
                return [];
            }
            throw e;
        }
        cloudWatchLogsToMonitor.startTime = endTime + 1;
        return events;
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWR3YXRjaF9sb2dzX21vbml0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvY2xvdWR3YXRjaF9sb2dzX21vbml0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUVMLFFBQVEsRUFDUixPQUFPLEVBQ1AsVUFBVSxFQUNWLE1BQU0sRUFDTixPQUFPLEdBQ1IsTUFBTSx1QkFBdUIsQ0FBQztBQUMvQixPQUFPLEVBRUwsc0JBQXNCLEVBQ3RCLHlCQUF5QixHQUMxQixNQUFNLGlDQUFpQyxDQUFDO0FBQ3pDLE9BQU8sRUFBRSxNQUFNLElBQUksQ0FBQztBQUNwQixPQUFPLElBQUksTUFBTSxNQUFNLENBQUM7QUFFeEI7Ozs7R0FJRztBQUNILE1BQU0sUUFBUSxHQUFHLEtBQUssQ0FBQztBQTJDdkI7Ozs7O0dBS0c7QUFDSCxNQUFNLE9BQU8seUJBQXlCO0lBdUJmO0lBdEJyQjs7T0FFRztJQUNLLFNBQVMsQ0FBUztJQUUxQjs7T0FFRztJQUNjLFlBQVksR0FBOEIsRUFBRSxDQUFDO0lBRTdDLG9CQUFvQixHQUNuQyxFQUFFLENBQUM7SUFFRyxNQUFNLEdBQUcsS0FBSyxDQUFDO0lBRWYsT0FBTyxHQUFHLE9BQU8sQ0FBQyxDQUFDLGlCQUFpQjtJQUVwQyxZQUFZLEdBQUcsSUFBSSxDQUFDLENBQUMsd0RBQXdEO0lBRXJGOztPQUVHO0lBQ0gsWUFBcUIsb0JBQTBDO1FBQTFDLHlCQUFvQixHQUFwQixvQkFBb0IsQ0FBc0I7UUFDN0QsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDOUIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsUUFBUSxHQUFHLENBQUMsY0FBdUIsRUFBUSxFQUFFO1FBQzNDLElBQUksY0FBYyxFQUFFLENBQUM7WUFDbkIsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUM7Z0JBQ2hELENBQUMsQ0FBQyxjQUFjO2dCQUNo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LENBQUM7WUFDSCxDQUFDO1lBQ0QsZ0dBQWdHO1lBQ2hHLHFHQUFxRztZQUNyRyxtR0FBbUc7WUFDbkcsMkZBQTJGO1lBQzNGLElBQUksY0FBYyxDQUFDLE1BQU0sS0FBSyxHQUFHLElBQUksUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFDO2dCQUN4RCxNQUFNLENBQUMsSUFBSSxDQUFDO29CQUNWLE9BQU8sRUFDTCx1RkFBdUY7b0JBQ3pGLFlBQVksRUFBRSx1QkFBdUIsQ0FBQyxZQUFZO29CQUNsRCxTQUFTLEVBQUUsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDO2lCQUM3QixDQUFDLENBQUM7WUFDTCxDQUFDO1FBQ0gsQ0FBQztRQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7WUFDWCxxREFBcUQ7WUFDckQsd0RBQXdEO1lBQ3hELDZCQUE2QjtZQUM3QixJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVkseUJBQXlCLEVBQUUsQ0FBQztnQkFDaEQsT0FBTyxFQUFFLENBQUM7WUFDWixDQUFDO1lBQ0QsTUFBTSxDQUFDLENBQUM7UUFDVixDQUFDO1FBQ0QsdUJBQXVCLENBQUMsU0FBUyxHQUFHLE9BQU8sR0FBRyxDQUFDLENBQUM7UUFDaEQsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQyxDQUFDO0NBQ0giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb2xvck5hbWUsXG4gIExvZ0xldmVsLFxuICBQcmludGVyLFxuICBjb2xvck5hbWVzLFxuICBmb3JtYXQsXG4gIHByaW50ZXIsXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9jbGktY29yZSc7XG5pbXBvcnQge1xuICBDbG91ZFdhdGNoTG9nc0NsaWVudCxcbiAgRmlsdGVyTG9nRXZlbnRzQ29tbWFuZCxcbiAgUmVzb3VyY2VOb3RGb3VuZEV4Y2VwdGlvbixcbn0gZnJvbSAnQGF3cy1zZGsvY2xpZW50LWNsb3Vkd2F0Y2gtbG9ncyc7XG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5cbi8qKlxuICogQWZ0ZXIgcmVhZGluZyBldmVudHMgZnJvbSBhbGwgQ2xvdWRXYXRjaCBsb2cgZ3JvdXBzIGhvdyBsb25nIHNob3VsZCB3ZSB3YWl0IHRvIHJlYWQgbW9yZSBldmVudHMuXG4gKlxuICogSWYgdGhlcmUgaXMgc29tZSBlcnJvciB3aXRoIHJlYWRpbmcgZXZlbnRzIChpLmUuIFRocm90dGxlKSB0aGVuIHRoaXMgaXMgYWxzbyBob3cgbG9uZyB3ZSB3YWl0IHVudGlsIHdlIHRyeSBhZ2FpblxuICovXG5jb25zdCBTTEVFUF9NUyA9IDJfMDAwO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBDbG91ZFdhdGNoIExvZyBFdmVudCB0aGF0IHdpbGwgYmUgcHJpbnRlZCB0byB0aGUgdGVybWluYWxcbiAqL1xudHlwZSBDbG91ZFdhdGNoTG9nRXZlbnQgPSB7XG4gIC8qKlxuICAgKiBUaGUgbG9nIGV2ZW50IG1lc3NhZ2VcbiAgICovXG4gIHJlYWRvbmx5IG1lc3NhZ2U6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGxvZyBncm91cFxuICAgKi9cbiAgcmVhZG9ubHkgbG9nR3JvdXBOYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB0aW1lIGF0IHdoaWNoIHRoZSBldmVudCBvY2N1cnJlZFxuICAgKi9cbiAgcmVhZG9ubHkgdGltZXN0YW1wOiBEYXRlO1xufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGhvdyBhbiBldmVudCBmcm9tIGEgQ2xvdWRXYXRjaCBMb2cgR3JvdXAgd2lsbCBiZSBkaXNwbGF5ZWRcbiAqIEluZGV4ZWQgb2ZmIG9mIGxvZ0dyb3VwTmFtZSBmb3IgZWFzeSByZXRyaWV2YWwgZHVyaW5nIGxvZ3MgZXZlbiBwb2xsaW5nXG4gKi9cbnR5cGUgTG9nR3JvdXBFdmVudERpc3BsYXkgPSB7XG4gIGZyaWVuZGx5TmFtZTogc3RyaW5nO1xuICBjb2xvcjogQ29sb3JOYW1lO1xufTtcblxudHlwZSBMb2dHcm91cFN0cmVhbWluZ0N1cnNvciA9IHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBsb2cgZ3JvdXBcbiAgICovXG4gIHJlYWRvbmx5IGxvZ0dyb3VwTmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTdGFydCB0aW1lXG4gICAqL1xuICBzdGFydFRpbWU6IG51bWJlcjtcbn07XG5cbi8qKlxuICogTW9uaXRvcnMgQ2xvdWRXYXRjaCBsb2dzIGFuZCBzdHJlYW0gaXQgdG8gc3Rkb3V0IG9yIGEgdXNlciBwcm92aWRlZCBmaWxlIGxvY2F0aW9uXG4gKiBDb25zdW1lcnMgY2FuIGFjdGl2YXRlIGFuZCBkZWFjdGl2YXRlIHRoZSBtb25pdG9yLiBUaGUgbW9uaXRvciBvbiByZWFjdGl2YXRpb24sIHN0YXJ0c1xuICogc3RyZWFtaW5nIGZyb20gdGhlIGxhc3QgdGltZSBpdCB3YXMgZGVhY3RpdmF0ZWQgdG8gYXZvaWQgbWlzc2luZyBhbnkgbG9ncyB3aGlsZSB0aGUgbW9uaXRvclxuICogd2FzIGRlYWN0aXZhdGVkLlxuICovXG5leHBvcnQgY2xhc3MgQ2xvdWRXYXRjaExvZ0V2ZW50TW9uaXRvciB7XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGZyb20gd2hhdCB0aW1lIHRoZSBsb2dzIHNob3VsZCBiZSBzdHJlYW1lZFxuICAgKi9cbiAgcHJpdmF0ZSBzdGFydFRpbWU6IG51bWJlcjtcblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBhbGwgTG9nR3JvdXBzIHRoYXQgbmVlZCB0byBiZSBzdHJlYW1lZFxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBhbGxMb2dHcm91cHM6IExvZ0dyb3VwU3RyZWFtaW5nQ3Vyc29yW10gPSBbXTtcblxuICBwcml2YXRlIHJlYWRvbmx5IGxvZ0dyb3VwRXZlbnREaXNwbGF5OiBSZWNvcmQ8c3RyaW5nLCBMb2dHcm91cEV2ZW50RGlzcGxheT4gPVxuICAgIHt9O1xuXG4gIHByaXZhdGUgYWN0aXZlID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBwcmludGVyID0gcHJpbnRlcjsgLy8gZGVmYXVsdCBzdGRvdXRcblxuICBwcml2YXRlIGVuYWJsZUNvbG9ycyA9IHRydWU7IC8vIHNob3cgY29sb3JzIG9uIGNvbnNvbGUgYnV0IG5vdCB3aGlsZSB3cml0aW5nIHRvIGZpbGVzXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBzdGFydCB0aW1lIHRvIGJlIGBub3dgXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZWFkb25seSBjbG91ZFdhdGNoTG9nc0NsaWVudDogQ2xvdWRXYXRjaExvZ3NDbGllbnQpIHtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gIH1cblxuICAvKipcbiAgICogcmVzdW1lIHdyaXRpbmcvcHJpbnRpbmcgZXZlbnRzXG4gICAqIElmIG91dHB1dCBsb2NhdGlvbiBmaWxlIGlzIHNwZWNpZmllZCwgdGhlIGxvZ3Mgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGF0IGZpbGUuXG4gICAqIElmIHRoZSBmaWxlIGRvZXNuJ3QgZXhpc3QgaXQgd2lsbCBiZSBjcmVhdGVkLlxuICAgKiBAcGFyYW0gb3V0cHV0TG9jYXRpb24gZmlsZSBsb2NhdGlvblxuICAgKi9cbiAgYWN0aXZhdGUgPSAob3V0cHV0TG9jYXRpb24/OiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgICBpZiAob3V0cHV0TG9jYXRpb24pIHtcbiAgICAgIGNvbnN0IHRhcmdldFBhdGggPSBwYXRoLmlzQWJzb2x1dGUob3V0cHV0TG9jYXRpb24pXG4gICAgICAgID8gb3V0cHV0TG9jYXRpb25cbiAgICAgICAgOiBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgb3V0cHV0TG9jYXRpb24pO1xuICAgICAgdGhpcy5wcmludGVyID0gbmV3IFByaW50ZXIoXG4gICAgICAgIExvZ0xldmVsLklORk8sXG4gICAgICAgIGZzLmNyZWF0ZVdyaXRlU3RyZWFtKHRhcmdldFBhdGgsIHsgZmxhZ3M6ICdhJywgYXV0b0Nsb3NlOiB0cnVlIH0pLFxuICAgICAgKTtcbiAgICAgIHRoaXMuZW5hYmxlQ29sb3JzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuc2NoZWR1bGVOZXh0VGljaygwKTtcbiAgfTtcblxuICAvKipcbiAgICogUGF1c2UgdGhlIG1vbml0b3Igc28gbm8gbmV3IGV2ZW50cyBhcmUgcmVhZFxuICAgKiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB3aGVuIHdlIGFyZSBpbiB0aGUgbWlkZGxlIG9mIHBlcmZvcm1pbmcgYSBkZXBsb3ltZW50XG4gICAqIGFuZCBkb24ndCB3YW50IHRvIGludGVyd2VhdmUgYWxsIHRoZSBsb2dzIHRvZ2V0aGVyIHdpdGggdGhlIENGTlxuICAgKiBkZXBsb3ltZW50IGxvZ3NcbiAgICpcbiAgICogQWxzbyByZXNldHMgdGhlIHN0YXJ0IHRpbWUgdG8gYmUgd2hlbiB0aGUgbmV3IGRlcGxveW1lbnQgd2FzIHRyaWdnZXJlZCBzbyB0aGF0IHdlXG4gICAqIHN0YXJ0IHN0cmVhbWluZyB0aGUgbG9ncyBmcm9tIHdoZW4gaXQgd2FzIGRlYWN0aXZhdGVkLlxuICAgKiBhbmQgY2xlYXJzIHRoZSBsaXN0IG9mIHRyYWNrZWQgbG9nIGdyb3Vwc1xuICAgKi9cbiAgcGF1c2UgPSAoKTogdm9pZCA9PiB7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5hbGxMb2dHcm91cHMuc3BsaWNlKDAsIHRoaXMuYWxsTG9nR3JvdXBzLmxlbmd0aCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgQ2xvdWRXYXRjaCBsb2cgZ3JvdXBzIHRvIHJlYWQgbG9nIGV2ZW50cyBmcm9tLlxuICAgKiBTaW5jZSB3ZSBjb3VsZCBiZSB3YXRjaGluZyBtdWx0aXBsZSBsb2dzIGdyb3VwcyB3ZSBuZWVkIGEgZnJpZW5kbHlcbiAgICogbmFtZSBmb3IgdG8gYXNzb2NpYXRlIHRoZSBsb2cgZ3JvdXAgdG8gbWFrZSBpdCBlYXNpZXJcbiAgICogZm9yIHRoZSB1c2VyIHRvIGlkZW50aWZ5IHdoaWNoIGxvZyBncm91cHMgYXJlIGJlaW5nIG1vbml0b3JlZFxuICAgKiBAcGFyYW0gZnJpZW5kbHlSZXNvdXJjZU5hbWUgVGhlIGZyaWVuZGx5IG5hbWUgb2YgdGhlIHJlc291cmNlIHRoYXQgaXMgYmVpbmcgbW9uaXRvcmVkXG4gICAqIEBwYXJhbSBsb2dHcm91cE5hbWUgVGhlIGxvZyBncm91cCB0byByZWFkIGV2ZW50cyBmcm9tXG4gICAqL1xuICBhZGRMb2dHcm91cHMgPSAoZnJpZW5kbHlSZXNvdXJjZU5hbWU6IHN0cmluZywgbG9nR3JvdXBOYW1lOiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgICB0aGlzLmFsbExvZ0dyb3Vwcy5wdXNoKHtcbiAgICAgIGxvZ0dyb3VwTmFtZSxcbiAgICAgIHN0YXJ0VGltZTogdGhpcy5zdGFydFRpbWUsXG4gICAgfSk7XG4gICAgdGhpcy5sb2dHcm91cEV2ZW50RGlzcGxheVtsb2dHcm91cE5hbWVdID0ge1xuICAgICAgZnJpZW5kbHlOYW1lOiBmcmllbmRseVJlc291cmNlTmFtZSxcbiAgICAgIGNvbG9yOiB0aGlzLmdldE5leHRDb2xvckZvckxvZ0dyb3VwKCksXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogUGljayB0aGUgbmV4dCBjb2xvciBpbiB0aGUgb2JqZWN0IGBjb2xvcnNgIGluIHJvdW5kIHJvYmluIGZhc2hpb25cbiAgICovXG4gIHByaXZhdGUgZ2V0TmV4dENvbG9yRm9yTG9nR3JvdXAgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGNvbG9yTmFtZXNbXG4gICAgICB0aGlzLmFsbExvZ0dyb3Vwcy5sZW5ndGggJSBjb2xvck5hbWVzLmxlbmd0aFxuICAgIF0gYXMgQ29sb3JOYW1lO1xuICB9O1xuXG4gIHByaXZhdGUgc2NoZWR1bGVOZXh0VGljayA9IChzbGVlcDogbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB2b2lkIHRoaXMudGljaygpLCBzbGVlcCk7XG4gIH07XG5cbiAgcHJpdmF0ZSB0aWNrID0gYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGlmICghdGhpcy5hY3RpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IGF3YWl0IHRoaXMucmVhZE5ld0V2ZW50cygpO1xuICAgICAgZXZlbnRzLmZvckVhY2goKGV2ZW50OiBDbG91ZFdhdGNoTG9nRXZlbnQpID0+IHtcbiAgICAgICAgdGhpcy5wcmludChldmVudCk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcHJpbnRlci5sb2coXG4gICAgICAgIGAke2Zvcm1hdC5lcnJvcihcbiAgICAgICAgICAnRXJyb3Igc3RyZWFtaW5nIGxvZ3MgZnJvbSBDbG91ZFdhdGNoLicsXG4gICAgICAgICl9ICR7Zm9ybWF0LmVycm9yKGVycm9yKX1gLFxuICAgICAgICBMb2dMZXZlbC5FUlJPUixcbiAgICAgICk7XG4gICAgICBwcmludGVyLmxvZygnTG9ncyBzdHJlYW1pbmcgaGFzIGJlZW4gcGF1c2VkLicpO1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgIH1cblxuICAgIHRoaXMuc2NoZWR1bGVOZXh0VGljayhTTEVFUF9NUyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlYWRzIGFsbCBuZXcgbG9nIGV2ZW50cyBmcm9tIGEgc2V0IG9mIENsb3VkV2F0Y2ggTG9nIEdyb3VwcyBpbiBwYXJhbGxlbFxuICAgKi9cbiAgcHJpdmF0ZSByZWFkTmV3RXZlbnRzID0gYXN5bmMgKCk6IFByb21pc2U8QXJyYXk8Q2xvdWRXYXRjaExvZ0V2ZW50Pj4gPT4ge1xuICAgIGNvbnN0IHJlc3VsdHM6IEFycmF5PEFycmF5PENsb3VkV2F0Y2hMb2dFdmVudD4+ID0gW107XG4gICAgZm9yIChjb25zdCBsb2dHcm91cCBvZiB0aGlzLmFsbExvZ0dyb3Vwcykge1xuICAgICAgcmVzdWx0cy5wdXNoKGF3YWl0IHRoaXMucmVhZEV2ZW50c0Zyb21Mb2dHcm91cChsb2dHcm91cCkpO1xuICAgICAgLy8gVGhlcmUgaXMgYSBoYXJkIGxpbWl0IG9uIFRQUyBmb3IgYEZpbHRlckxvZ0V2ZW50c2AgQVBJIHRoYXQgaXMgQWNjb3VudCB3aWRlLlxuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBnZXQgdGhyb3R0bGVkIGlzIGN1c3RvbWVycyBhcmUgZmlsdGVyaW5nIGZvciBhIGxvdCBvZiBmdW5jdGlvbnMuXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHMuZmxhdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcmludCBvdXQgb25lIENsb3VkV2F0Y2ggZXZlbnQgdXNpbmcgdGhlIGxvY2FsIHByaW50ZXIuXG4gICAqL1xuICBwcml2YXRlIHByaW50ID0gKGV2ZW50OiBDbG91ZFdhdGNoTG9nRXZlbnQpOiB2b2lkID0+IHtcbiAgICBjb25zdCBjbG91ZFdhdGNoRXZlbnREaXNwbGF5ID1cbiAgICAgIHRoaXMubG9nR3JvdXBFdmVudERpc3BsYXlbZXZlbnQubG9nR3JvdXBOYW1lXTtcbiAgICBpZiAoIWNsb3VkV2F0Y2hFdmVudERpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lbmFibGVDb2xvcnMpIHtcbiAgICAgIHRoaXMucHJpbnRlci5wcmludChcbiAgICAgICAgYCR7Zm9ybWF0Lm5vdGUoZXZlbnQudGltZXN0YW1wLnRvTG9jYWxlVGltZVN0cmluZygpKX0gWyR7Zm9ybWF0LmNvbG9yKFxuICAgICAgICAgIGNsb3VkV2F0Y2hFdmVudERpc3BsYXkuZnJpZW5kbHlOYW1lLFxuICAgICAgICAgIGNsb3VkV2F0Y2hFdmVudERpc3BsYXkuY29sb3IsXG4gICAgICAgICl9XSAke2V2ZW50Lm1lc3NhZ2UudHJpbSgpfWAsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByaW50ZXIucHJpbnQoXG4gICAgICAgIGAke2V2ZW50LnRpbWVzdGFtcC50b0xvY2FsZVRpbWVTdHJpbmcoKX0gWyR7XG4gICAgICAgICAgY2xvdWRXYXRjaEV2ZW50RGlzcGxheS5mcmllbmRseU5hbWVcbiAgICAgICAgfV0gJHtldmVudC5tZXNzYWdlLnRyaW0oKX1gLFxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlYWRzIGFsbCBuZXcgbG9nIGV2ZW50cyBmcm9tIGEgQ2xvdWRXYXRjaCBMb2cgR3JvdXBcbiAgICogc3RhcnRpbmcgYXQgZWl0aGVyIHRoZSB0aW1lIHRoZSBsYXN0IGRlcGxveW1lbnQgd2FzIHRyaWdnZXJlZCBvclxuICAgKiB3aGVuIHRoZSBsYXN0IGV2ZW50IHdhcyByZWFkIG9uIHRoZSBwcmV2aW91cyB0aWNrXG4gICAqL1xuICBwcml2YXRlIHJlYWRFdmVudHNGcm9tTG9nR3JvdXAgPSBhc3luYyAoXG4gICAgY2xvdWRXYXRjaExvZ3NUb01vbml0b3I6IExvZ0dyb3VwU3RyZWFtaW5nQ3Vyc29yLFxuICApOiBQcm9taXNlPEFycmF5PENsb3VkV2F0Y2hMb2dFdmVudD4+ID0+IHtcbiAgICBjb25zdCBldmVudHM6IENsb3VkV2F0Y2hMb2dFdmVudFtdID0gW107XG5cbiAgICAvLyBsb2cgZXZlbnRzIGZyb20gc29tZSBzZXJ2aWNlIGFyZSBpbmdlc3RlZCBmYXN0ZXIgdGhhbiBvdGhlcnNcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIHRyYWNrIHRoZSBzdGFydC9lbmQgdGltZSBmb3IgZWFjaCBsb2cgZ3JvdXAgaW5kaXZpZHVhbGx5XG4gICAgLy8gdG8gbWFrZSBzdXJlIHRoYXQgd2UgcHJvY2VzcyBhbGwgZXZlbnRzIGZyb20gZWFjaCBsb2cgZ3JvdXAuXG4gICAgLy8gZW5kVGltZSB0cmFja3MgdGhlIGxhdGVzdCBldmVudCByZWNlaXZlZFxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IGNsb3VkV2F0Y2hMb2dzVG9Nb25pdG9yLnN0YXJ0VGltZSA/PyB0aGlzLnN0YXJ0VGltZTtcbiAgICBsZXQgZW5kVGltZSA9IHN0YXJ0VGltZTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsb3VkV2F0Y2hMb2dzQ2xpZW50LnNlbmQoXG4gICAgICAgIG5ldyBGaWx0ZXJMb2dFdmVudHNDb21tYW5kKHtcbiAgICAgICAgICBsb2dHcm91cE5hbWU6IGNsb3VkV2F0Y2hMb2dzVG9Nb25pdG9yLmxvZ0dyb3VwTmFtZSxcbiAgICAgICAgICBsaW1pdDogMTAwLFxuICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgICAgY29uc3QgZmlsdGVyZWRFdmVudHMgPSByZXNwb25zZS5ldmVudHMgPz8gW107XG5cbiAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZmlsdGVyZWRFdmVudHMpIHtcbiAgICAgICAgaWYgKGV2ZW50Lm1lc3NhZ2UpIHtcbiAgICAgICAgICBldmVudHMucHVzaCh7XG4gICAgICAgICAgICBtZXNzYWdlOiBldmVudC5tZXNzYWdlLFxuICAgICAgICAgICAgbG9nR3JvdXBOYW1lOiBjbG91ZFdhdGNoTG9nc1RvTW9uaXRvci5sb2dHcm91cE5hbWUsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGV2ZW50LnRpbWVzdGFtcCA/IG5ldyBEYXRlKGV2ZW50LnRpbWVzdGFtcCkgOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGV2ZW50LnRpbWVzdGFtcCAmJiBlbmRUaW1lIDwgZXZlbnQudGltZXN0YW1wKSB7XG4gICAgICAgICAgICBlbmRUaW1lID0gZXZlbnQudGltZXN0YW1wO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQXMgbG9uZyBhcyB0aGVyZSBhcmUgX2FueV8gZXZlbnRzIGluIHRoZSBsb2cgZ3JvdXAgYGZpbHRlckxvZ0V2ZW50c2Agd2lsbCByZXR1cm4gYSBuZXh0VG9rZW4uXG4gICAgICAvLyBUaGlzIGlzIHRydWUgZXZlbiBpZiB0aGVzZSBldmVudHMgYXJlIGJlZm9yZSBgc3RhcnRUaW1lYC4gU28gaWYgd2UgaGF2ZSAxMDAgZXZlbnRzIGFuZCBhIG5leHRUb2tlblxuICAgICAgLy8gdGhlbiBhc3N1bWUgdGhhdCB3ZSBoYXZlIGhpdCB0aGUgbGltaXQgYW5kIGxldCB0aGUgdXNlciBrbm93IHNvbWUgbWVzc2FnZXMgaGF2ZSBiZWVuIHN1cHByZXNzZWQuXG4gICAgICAvLyBXZSBhcmUgZXNzZW50aWFsbHkgc2hvd2luZyB0aGVtIGEgc2FtcGxpbmcgKDEwMDAwIGV2ZW50cyBwcmludGVkIG91dCBpcyBub3QgdmVyeSB1c2VmdWwpXG4gICAgICBpZiAoZmlsdGVyZWRFdmVudHMubGVuZ3RoID09PSAxMDAgJiYgcmVzcG9uc2UubmV4dFRva2VuKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgJz4+PiBgc2FuZGJveGAgc2hvd3Mgb25seSB0aGUgZmlyc3QgMTAwIGxvZyBtZXNzYWdlcyAtIHRoZSByZXN0IGhhdmUgYmVlbiB0cnVuY2F0ZWQuLi4nLFxuICAgICAgICAgIGxvZ0dyb3VwTmFtZTogY2xvdWRXYXRjaExvZ3NUb01vbml0b3IubG9nR3JvdXBOYW1lLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoZW5kVGltZSksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHdpdGggTGFtYmRhIGZ1bmN0aW9ucyB0aGUgTG9nIEdyb3VwIGlzIG5vdCBjcmVhdGVkXG4gICAgICAvLyB1bnRpbCBzb21ldGhpbmcgaXMgbG9nZ2VkLCBzbyBqdXN0IGtlZXAgcG9sbGluZyB1bnRpbFxuICAgICAgLy8gdGhlcmUgaXMgc29tZXRoaW5nIHRvIGZpbmRcbiAgICAgIGlmIChlICYmIGUgaW5zdGFuY2VvZiBSZXNvdXJjZU5vdEZvdW5kRXhjZXB0aW9uKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGNsb3VkV2F0Y2hMb2dzVG9Nb25pdG9yLnN0YXJ0VGltZSA9IGVuZFRpbWUgKyAxO1xuICAgIHJldHVybiBldmVudHM7XG4gIH07XG59XG4iXX0=