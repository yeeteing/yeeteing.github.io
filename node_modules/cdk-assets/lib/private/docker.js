"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DockerFactory = exports.Docker = void 0;
const fs = require("fs");
const os = require("os");
const path = require("path");
const docker_credentials_1 = require("./docker-credentials");
const shell_1 = require("./shell");
const util_1 = require("./util");
const progress_1 = require("../progress");
var InspectImageErrorCode;
(function (InspectImageErrorCode) {
    InspectImageErrorCode[InspectImageErrorCode["Docker"] = 1] = "Docker";
    InspectImageErrorCode[InspectImageErrorCode["Podman"] = 125] = "Podman";
})(InspectImageErrorCode || (InspectImageErrorCode = {}));
class Docker {
    constructor(eventEmitter, subprocessOutputDestination) {
        this.eventEmitter = eventEmitter;
        this.subprocessOutputDestination = subprocessOutputDestination;
        this.configDir = undefined;
    }
    /**
     * Whether an image with the given tag exists
     */
    async exists(tag) {
        try {
            await this.execute(['inspect', tag], {
                subprocessOutputDestination: 'ignore',
            });
            return true;
        }
        catch (e) {
            const error = e;
            /**
             * The only error we expect to be thrown will have this property and value.
             * If it doesn't, it's unrecognized so re-throw it.
             */
            if (error.code !== 'PROCESS_FAILED') {
                throw error;
            }
            /**
             * If we know the shell command above returned an error, check to see
             * if the exit code is one we know to actually mean that the image doesn't
             * exist.
             */
            switch (error.exitCode) {
                case InspectImageErrorCode.Docker:
                case InspectImageErrorCode.Podman:
                    // Docker and Podman will return this exit code when an image doesn't exist, return false
                    // context: https://github.com/aws/aws-cdk/issues/16209
                    return false;
                default:
                    // This is an error but it's not an exit code we recognize, throw.
                    throw error;
            }
        }
    }
    async build(options) {
        const buildCommand = [
            'build',
            ...flatten(Object.entries(options.buildArgs || {}).map(([k, v]) => ['--build-arg', `${k}=${v}`])),
            ...flatten(Object.entries(options.buildSecrets || {}).map(([k, v]) => ['--secret', `id=${k},${v}`])),
            ...(options.buildSsh ? ['--ssh', options.buildSsh] : []),
            '--tag',
            options.tag,
            ...(options.target ? ['--target', options.target] : []),
            ...(options.file ? ['--file', options.file] : []),
            ...(options.networkMode ? ['--network', options.networkMode] : []),
            ...(options.platform ? ['--platform', options.platform] : []),
            ...(options.outputs ? options.outputs.map((output) => [`--output=${output}`]) : []),
            ...(options.cacheFrom
                ? [
                    ...options.cacheFrom
                        .map((cacheFrom) => ['--cache-from', this.cacheOptionToFlag(cacheFrom)])
                        .flat(),
                ]
                : []),
            ...(options.cacheTo ? ['--cache-to', this.cacheOptionToFlag(options.cacheTo)] : []),
            ...(options.cacheDisabled ? ['--no-cache'] : []),
            '.',
        ];
        await this.execute(buildCommand, {
            cwd: options.directory,
            subprocessOutputDestination: this.subprocessOutputDestination,
            env: {
                BUILDX_NO_DEFAULT_ATTESTATIONS: '1', // Docker Build adds provenance attestations by default that confuse cdk-assets
            },
        });
    }
    /**
     * Get credentials from ECR and run docker login
     */
    async login(ecr) {
        const credentials = await (0, docker_credentials_1.obtainEcrCredentials)(ecr, this.eventEmitter);
        // Use --password-stdin otherwise docker will complain. Loudly.
        await this.execute(['login', '--username', credentials.username, '--password-stdin', credentials.endpoint.replace(/^https?:\/\/|\/$/g, '')], {
            input: credentials.password,
            // Need to ignore otherwise Docker will complain
            // 'WARNING! Your password will be stored unencrypted'
            // doesn't really matter since it's a token.
            subprocessOutputDestination: 'ignore',
        });
    }
    async tag(sourceTag, targetTag) {
        await this.execute(['tag', sourceTag, targetTag]);
    }
    async push(options) {
        await this.execute(['push', options.tag], {
            subprocessOutputDestination: this.subprocessOutputDestination,
        });
    }
    /**
     * If a CDK Docker Credentials file exists, creates a new Docker config directory.
     * Sets up `docker-credential-cdk-assets` to be the credential helper for each domain in the CDK config.
     * All future commands (e.g., `build`, `push`) will use this config.
     *
     * See https://docs.docker.com/engine/reference/commandline/login/#credential-helpers for more details on cred helpers.
     *
     * @returns true if CDK config was found and configured, false otherwise
     */
    configureCdkCredentials() {
        const config = (0, docker_credentials_1.cdkCredentialsConfig)();
        if (!config) {
            return false;
        }
        this.configDir = fs.mkdtempSync(path.join(os.tmpdir(), 'cdkDockerConfig'));
        const domains = Object.keys(config.domainCredentials);
        const credHelpers = domains.reduce((map, domain) => {
            map[domain] = 'cdk-assets'; // Use docker-credential-cdk-assets for this domain
            return map;
        }, {});
        fs.writeFileSync(path.join(this.configDir, 'config.json'), JSON.stringify({ credHelpers }), {
            encoding: 'utf-8',
        });
        return true;
    }
    /**
     * Removes any configured Docker config directory.
     * All future commands (e.g., `build`, `push`) will use the default config.
     *
     * This is useful after calling `configureCdkCredentials` to reset to default credentials.
     */
    resetAuthPlugins() {
        this.configDir = undefined;
    }
    async execute(args, options = {}) {
        const configArgs = this.configDir ? ['--config', this.configDir] : [];
        const pathToCdkAssets = path.resolve(__dirname, '..', '..', 'bin');
        const shellEventPublisher = (0, progress_1.shellEventPublisherFromEventEmitter)(this.eventEmitter);
        try {
            await (0, shell_1.shell)([getDockerCmd(), ...configArgs, ...args], {
                ...options,
                shellEventPublisher: shellEventPublisher,
                env: {
                    ...process.env,
                    ...options.env,
                    PATH: `${pathToCdkAssets}${path.delimiter}${options.env?.PATH ?? process.env.PATH}`,
                },
            });
        }
        catch (e) {
            if (e.code === 'ENOENT') {
                throw new Error(`Failed to find and execute '${getDockerCmd()}' while attempting to build a container asset. Please install '${getDockerCmd()}' and try again. (Or set the 'CDK_DOCKER ' environment variable to choose a different compatible container client.)`);
            }
            throw e;
        }
    }
    cacheOptionToFlag(option) {
        let flag = `type=${option.type}`;
        if (option.params) {
            flag +=
                ',' +
                    Object.entries(option.params)
                        .map(([k, v]) => `${k}=${v}`)
                        .join(',');
        }
        return flag;
    }
}
exports.Docker = Docker;
/**
 * Helps get appropriately configured Docker instances during the container
 * image publishing process.
 */
class DockerFactory {
    constructor() {
        this.enterLoggedInDestinationsCriticalSection = (0, util_1.createCriticalSection)();
        this.loggedInDestinations = new Set();
    }
    /**
     * Gets a Docker instance for building images.
     */
    async forBuild(options) {
        const docker = new Docker(options.eventEmitter, options.subprocessOutputDestination);
        // Default behavior is to login before build so that the Dockerfile can reference images in the ECR repo
        // However, if we're in a pipelines environment (for example),
        // we may have alternative credentials to the default ones to use for the build itself.
        // If the special config file is present, delay the login to the default credentials until the push.
        // If the config file is present, we will configure and use those credentials for the build.
        let cdkDockerCredentialsConfigured = docker.configureCdkCredentials();
        if (!cdkDockerCredentialsConfigured) {
            await this.loginOncePerDestination(docker, options);
        }
        return docker;
    }
    /**
     * Gets a Docker instance for pushing images to ECR.
     */
    async forEcrPush(options) {
        const docker = new Docker(options.eventEmitter, options.subprocessOutputDestination);
        await this.loginOncePerDestination(docker, options);
        return docker;
    }
    async loginOncePerDestination(docker, options) {
        // Changes: 012345678910.dkr.ecr.us-west-2.amazonaws.com/tagging-test
        // To this: 012345678910.dkr.ecr.us-west-2.amazonaws.com
        const repositoryDomain = options.repoUri.split('/')[0];
        // Ensure one-at-a-time access to loggedInDestinations.
        await this.enterLoggedInDestinationsCriticalSection(async () => {
            if (this.loggedInDestinations.has(repositoryDomain)) {
                return;
            }
            await docker.login(options.ecr);
            this.loggedInDestinations.add(repositoryDomain);
        });
    }
}
exports.DockerFactory = DockerFactory;
function getDockerCmd() {
    return process.env.CDK_DOCKER ?? 'docker';
}
function flatten(x) {
    return Array.prototype.concat([], ...x);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG9ja2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZG9ja2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLDZEQUFrRjtBQUVsRixtQ0FBZ0M7QUFDaEMsaUNBQStDO0FBSS9DLDBDQUFrRTtBQW9DbEUsSUFBSyxxQkFHSjtBQUhELFdBQUsscUJBQXFCO0lBQ3hCLHFFQUFVLENBQUE7SUFDVix1RUFBWSxDQUFBO0FBQ2QsQ0FBQyxFQUhJLHFCQUFxQixLQUFyQixxQkFBcUIsUUFHekI7QUFPRCxNQUFhLE1BQU07SUFHakIsWUFDbUIsWUFBMEIsRUFDMUIsMkJBQXdEO1FBRHhELGlCQUFZLEdBQVosWUFBWSxDQUFjO1FBQzFCLGdDQUEyQixHQUEzQiwyQkFBMkIsQ0FBNkI7UUFKbkUsY0FBUyxHQUF1QixTQUFTLENBQUM7SUFNbEQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFXO1FBQzdCLElBQUksQ0FBQztZQUNILE1BQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLFNBQVMsRUFBRSxHQUFHLENBQUMsRUFBRTtnQkFDbkMsMkJBQTJCLEVBQUUsUUFBUTthQUN0QyxDQUFDLENBQUM7WUFDSCxPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFBQyxPQUFPLENBQU0sRUFBRSxDQUFDO1lBQ2hCLE1BQU0sS0FBSyxHQUF1QixDQUFDLENBQUM7WUFFcEM7OztlQUdHO1lBQ0gsSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLGdCQUFnQixFQUFFLENBQUM7Z0JBQ3BDLE1BQU0sS0FBSyxDQUFDO1lBQ2QsQ0FBQztZQUVEOzs7O2VBSUc7WUFDSCxRQUFRLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFDdkIsS0FBSyxxQkFBcUIsQ0FBQyxNQUFNLENBQUM7Z0JBQ2xDLEtBQUsscUJBQXFCLENBQUMsTUFBTTtvQkFDL0IseUZBQXlG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QUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUV2RCx1REFBdUQ7UUFDdkQsTUFBTSxJQUFJLENBQUMsd0NBQXdDLENBQUMsS0FBSyxJQUFJLEVBQUU7WUFDN0QsSUFBSSxJQUFJLENBQUMsb0JBQW9CLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQztnQkFDcEQsT0FBTztZQUNULENBQUM7WUFFRCxNQUFNLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ2hDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUNsRCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQS9DRCxzQ0ErQ0M7QUFFRCxTQUFTLFlBQVk7SUFDbkIsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUFDLFVBQVUsSUFBSSxRQUFRLENBQUM7QUFDNUMsQ0FBQztBQUVELFNBQVMsT0FBTyxDQUFDLENBQWE7SUFDNUIsT0FBTyxLQUFLLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUMxQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgb3MgZnJvbSAnb3MnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IGNka0NyZWRlbnRpYWxzQ29uZmlnLCBvYnRhaW5FY3JDcmVkZW50aWFscyB9IGZyb20gJy4vZG9ja2VyLWNyZWRlbnRpYWxzJztcbmltcG9ydCB0eXBlIHsgU2hlbGxPcHRpb25zLCBQcm9jZXNzRmFpbGVkRXJyb3IgfSBmcm9tICcuL3NoZWxsJztcbmltcG9ydCB7IHNoZWxsIH0gZnJvbSAnLi9zaGVsbCc7XG5pbXBvcnQgeyBjcmVhdGVDcml0aWNhbFNlY3Rpb24gfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHR5cGUgeyBJRUNSQ2xpZW50IH0gZnJvbSAnLi4vYXdzJztcbmltcG9ydCB0eXBlIHsgU3VicHJvY2Vzc091dHB1dERlc3RpbmF0aW9uIH0gZnJvbSAnLi9hc3NldC1oYW5kbGVyJztcbmltcG9ydCB0eXBlIHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vcHJvZ3Jlc3MnO1xuaW1wb3J0IHsgc2hlbGxFdmVudFB1Ymxpc2hlckZyb21FdmVudEVtaXR0ZXIgfSBmcm9tICcuLi9wcm9ncmVzcyc7XG5cbmludGVyZmFjZSBCdWlsZE9wdGlvbnMge1xuICByZWFkb25seSBkaXJlY3Rvcnk6IHN0cmluZztcblxuICAvKipcbiAgICogVGFnIHRoZSBpbWFnZSB3aXRoIGEgZ2l2ZW4gcmVwb05hbWU6dGFnIGNvbWJpbmF0aW9uXG4gICAqL1xuICByZWFkb25seSB0YWc6IHN0cmluZztcbiAgcmVhZG9ubHkgdGFyZ2V0Pzogc3RyaW5nO1xuICByZWFkb25seSBmaWxlPzogc3RyaW5nO1xuICByZWFkb25seSBidWlsZEFyZ3M/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICByZWFkb25seSBidWlsZFNlY3JldHM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICByZWFkb25seSBidWlsZFNzaD86IHN0cmluZztcbiAgcmVhZG9ubHkgbmV0d29ya01vZGU/OiBzdHJpbmc7XG4gIHJlYWRvbmx5IHBsYXRmb3JtPzogc3RyaW5nO1xuICByZWFkb25seSBvdXRwdXRzPzogc3RyaW5nW107XG4gIHJlYWRvbmx5IGNhY2hlRnJvbT86IERvY2tlckNhY2hlT3B0aW9uW107XG4gIHJlYWRvbmx5IGNhY2hlVG8/OiBEb2NrZXJDYWNoZU9wdGlvbjtcbiAgcmVhZG9ubHkgY2FjaGVEaXNhYmxlZD86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBQdXNoT3B0aW9ucyB7XG4gIHJlYWRvbmx5IHRhZzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERvY2tlckNyZWRlbnRpYWxzQ29uZmlnIHtcbiAgcmVhZG9ubHkgdmVyc2lvbjogc3RyaW5nO1xuICByZWFkb25seSBkb21haW5DcmVkZW50aWFsczogUmVjb3JkPHN0cmluZywgRG9ja2VyRG9tYWluQ3JlZGVudGlhbHM+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERvY2tlckRvbWFpbkNyZWRlbnRpYWxzIHtcbiAgcmVhZG9ubHkgc2VjcmV0c01hbmFnZXJTZWNyZXRJZD86IHN0cmluZztcbiAgcmVhZG9ubHkgZWNyUmVwb3NpdG9yeT86IHN0cmluZztcbn1cblxuZW51bSBJbnNwZWN0SW1hZ2VFcnJvckNvZGUge1xuICBEb2NrZXIgPSAxLFxuICBQb2RtYW4gPSAxMjUsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRG9ja2VyQ2FjaGVPcHRpb24ge1xuICByZWFkb25seSB0eXBlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHBhcmFtcz86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG59XG5cbmV4cG9ydCBjbGFzcyBEb2NrZXIge1xuICBwcml2YXRlIGNvbmZpZ0Rpcjogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZXZlbnRFbWl0dGVyOiBFdmVudEVtaXR0ZXIsXG4gICAgcHJpdmF0ZSByZWFkb25seSBzdWJwcm9jZXNzT3V0cHV0RGVzdGluYXRpb246IFN1YnByb2Nlc3NPdXRwdXREZXN0aW5hdGlvbixcbiAgKSB7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciBhbiBpbWFnZSB3aXRoIHRoZSBnaXZlbiB0YWcgZXhpc3RzXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZXhpc3RzKHRhZzogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuZXhlY3V0ZShbJ2luc3BlY3QnLCB0YWddLCB7XG4gICAgICAgIHN1YnByb2Nlc3NPdXRwdXREZXN0aW5hdGlvbjogJ2lnbm9yZScsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgY29uc3QgZXJyb3I6IFByb2Nlc3NGYWlsZWRFcnJvciA9IGU7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG9ubHkgZXJyb3Igd2UgZXhwZWN0IHRvIGJlIHRocm93biB3aWxsIGhhdmUgdGhpcyBwcm9wZXJ0eSBhbmQgdmFsdWUuXG4gICAgICAgKiBJZiBpdCBkb2Vzbid0LCBpdCdzIHVucmVjb2duaXplZCBzbyByZS10aHJvdyBpdC5cbiAgICAgICAqL1xuICAgICAgaWYgKGVycm9yLmNvZGUgIT09ICdQUk9DRVNTX0ZBSUxFRCcpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgd2Uga25vdyB0aGUgc2hlbGwgY29tbWFuZCBhYm92ZSByZXR1cm5lZCBhbiBlcnJvciwgY2hlY2sgdG8gc2VlXG4gICAgICAgKiBpZiB0aGUgZXhpdCBjb2RlIGlzIG9uZSB3ZSBrbm93IHRvIGFjdHVhbGx5IG1lYW4gdGhhdCB0aGUgaW1hZ2UgZG9lc24ndFxuICAgICAgICogZXhpc3QuXG4gICAgICAgKi9cbiAgICAgIHN3aXRjaCAoZXJyb3IuZXhpdENvZGUpIHtcbiAgICAgICAgY2FzZSBJbnNwZWN0SW1hZ2VFcnJvckNvZGUuRG9ja2VyOlxuICAgICAgICBjYXNlIEluc3BlY3RJbWFnZUVycm9yQ29kZS5Qb2RtYW46XG4gICAgICAgICAgLy8gRG9ja2VyIGFuZCBQb2RtYW4gd2lsbCByZXR1cm4gdGhpcyBleGl0IGNvZGUgd2hlbiBhbiBpbWFnZSBkb2Vzbid0IGV4aXN0LCByZXR1cm4gZmFsc2VcbiAgICAgICAgICAvLyBjb250ZXh0OiBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1jZGsvaXNzdWVzLzE2MjA5XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIFRoaXMgaXMgYW4gZXJyb3IgYnV0IGl0J3Mgbm90IGFuIGV4aXQgY29kZSB3ZSByZWNvZ25pemUsIHRocm93LlxuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBidWlsZChvcHRpb25zOiBCdWlsZE9wdGlvbnMpIHtcbiAgICBjb25zdCBidWlsZENvbW1hbmQgPSBbXG4gICAgICAnYnVpbGQnLFxuICAgICAgLi4uZmxhdHRlbihcbiAgICAgICAgT2JqZWN0LmVudHJpZXMob3B0aW9ucy5idWlsZEFyZ3MgfHwge30pLm1hcCgoW2ssIHZdKSA9PiBbJy0tYnVpbGQtYXJnJywgYCR7a309JHt2fWBdKSxcbiAgICAgICksXG4gICAgICAuLi5mbGF0dGVuKFxuICAgICAgICBPYmplY3QuZW50cmllcyhvcHRpb25zLmJ1aWxkU2VjcmV0cyB8fCB7fSkubWFwKChbaywgdl0pID0+IFsnLS1zZWNyZXQnLCBgaWQ9JHtrfSwke3Z9YF0pLFxuICAgICAgKSxcbiAgICAgIC4uLihvcHRpb25zLmJ1aWxkU3NoID8gWyctLXNzaCcsIG9wdGlvbnMuYnVpbGRTc2hdIDogW10pLFxuICAgICAgJy0tdGFnJyxcbiAgICAgIG9wdGlvbnMudGFnLFxuICAgICAgLi4uKG9wdGlvbnMudGFyZ2V0ID8gWyctLXRhcmdldCcsIG9wdGlvbnMudGFyZ2V0XSA6IFtdKSxcbiAgICAgIC4uLihvcHRpb25zLmZpbGUgPyBbJy0tZmlsZScsIG9wdGlvbnMuZmlsZV0gOiBbXSksXG4gICAgICAuLi4ob3B0aW9ucy5uZXR3b3JrTW9kZSA/IFsnLS1uZXR3b3JrJywgb3B0aW9ucy5uZXR3b3JrTW9kZV0gOiBbXSksXG4gICAgICAuLi4ob3B0aW9ucy5wbGF0Zm9ybSA/IFsnLS1wbGF0Zm9ybScsIG9wdGlvbnMucGxhdGZvcm1dIDogW10pLFxuICAgICAgLi4uKG9wdGlvbnMub3V0cHV0cyA/IG9wdGlvbnMub3V0cHV0cy5tYXAoKG91dHB1dCkgPT4gW2AtLW91dHB1dD0ke291dHB1dH1gXSkgOiBbXSksXG4gICAgICAuLi4ob3B0aW9ucy5jYWNoZUZyb21cbiAgICAgICAgPyBbXG4gICAgICAgICAgLi4ub3B0aW9ucy5jYWNoZUZyb21cbiAgICAgICAgICAgIC5tYXAoKGNhY2hlRnJvbSkgPT4gWyctLWNhY2hlLWZyb20nLCB0aGlzLmNhY2hlT3B0aW9uVG9GbGFnKGNhY2hlRnJvbSldKVxuICAgICAgICAgICAgLmZsYXQoKSxcbiAgICAgICAgXVxuICAgICAgICA6IFtdKSxcbiAgICAgIC4uLihvcHRpb25zLmNhY2hlVG8gPyBbJy0tY2FjaGUtdG8nLCB0aGlzLmNhY2hlT3B0aW9uVG9GbGFnKG9wdGlvbnMuY2FjaGVUbyldIDogW10pLFxuICAgICAgLi4uKG9wdGlvbnMuY2FjaGVEaXNhYmxlZCA/IFsnLS1uby1jYWNoZSddIDogW10pLFxuICAgICAgJy4nLFxuICAgIF07XG4gICAgYXdhaXQgdGhpcy5leGVjdXRlKGJ1aWxkQ29tbWFuZCwge1xuICAgICAgY3dkOiBvcHRpb25zLmRpcmVjdG9yeSxcbiAgICAgIHN1YnByb2Nlc3NPdXRwdXREZXN0aW5hdGlvbjogdGhpcy5zdWJwcm9jZXNzT3V0cHV0RGVzdGluYXRpb24sXG4gICAgICBlbnY6IHtcbiAgICAgICAgQlVJTERYX05PX0RFRkFVTFRfQVRURVNUQVRJT05TOiAnMScsIC8vIERvY2tlciBCdWlsZCBhZGRzIHByb3ZlbmFuY2UgYXR0ZXN0YXRpb25zIGJ5IGRlZmF1bHQgdGhhdCBjb25mdXNlIGNkay1hc3NldHNcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNyZWRlbnRpYWxzIGZyb20gRUNSIGFuZCBydW4gZG9ja2VyIGxvZ2luXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbG9naW4oZWNyOiBJRUNSQ2xpZW50KSB7XG4gICAgY29uc3QgY3JlZGVudGlhbHMgPSBhd2FpdCBvYnRhaW5FY3JDcmVkZW50aWFscyhlY3IsIHRoaXMuZXZlbnRFbWl0dGVyKTtcblxuICAgIC8vIFVzZSAtLXBhc3N3b3JkLXN0ZGluIG90aGVyd2lzZSBkb2NrZXIgd2lsbCBjb21wbGFpbi4gTG91ZGx5LlxuICAgIGF3YWl0IHRoaXMuZXhlY3V0ZShcbiAgICAgIFsnbG9naW4nLCAnLS11c2VybmFtZScsIGNyZWRlbnRpYWxzLnVzZXJuYW1lLCAnLS1wYXNzd29yZC1zdGRpbicsIGNyZWRlbnRpYWxzLmVuZHBvaW50LnJlcGxhY2UoL15odHRwcz86XFwvXFwvfFxcLyQvZywgJycpXSxcbiAgICAgIHtcbiAgICAgICAgaW5wdXQ6IGNyZWRlbnRpYWxzLnBhc3N3b3JkLFxuXG4gICAgICAgIC8vIE5lZWQgdG8gaWdub3JlIG90aGVyd2lzZSBEb2NrZXIgd2lsbCBjb21wbGFpblxuICAgICAgICAvLyAnV0FSTklORyEgWW91ciBwYXNzd29yZCB3aWxsIGJlIHN0b3JlZCB1bmVuY3J5cHRlZCdcbiAgICAgICAgLy8gZG9lc24ndCByZWFsbHkgbWF0dGVyIHNpbmNlIGl0J3MgYSB0b2tlbi5cbiAgICAgICAgc3VicHJvY2Vzc091dHB1dERlc3RpbmF0aW9uOiAnaWdub3JlJyxcbiAgICAgIH0sXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyB0YWcoc291cmNlVGFnOiBzdHJpbmcsIHRhcmdldFRhZzogc3RyaW5nKSB7XG4gICAgYXdhaXQgdGhpcy5leGVjdXRlKFsndGFnJywgc291cmNlVGFnLCB0YXJnZXRUYWddKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBwdXNoKG9wdGlvbnM6IFB1c2hPcHRpb25zKSB7XG4gICAgYXdhaXQgdGhpcy5leGVjdXRlKFsncHVzaCcsIG9wdGlvbnMudGFnXSwge1xuICAgICAgc3VicHJvY2Vzc091dHB1dERlc3RpbmF0aW9uOiB0aGlzLnN1YnByb2Nlc3NPdXRwdXREZXN0aW5hdGlvbixcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBhIENESyBEb2NrZXIgQ3JlZGVudGlhbHMgZmlsZSBleGlzdHMsIGNyZWF0ZXMgYSBuZXcgRG9ja2VyIGNvbmZpZyBkaXJlY3RvcnkuXG4gICAqIFNldHMgdXAgYGRvY2tlci1jcmVkZW50aWFsLWNkay1hc3NldHNgIHRvIGJlIHRoZSBjcmVkZW50aWFsIGhlbHBlciBmb3IgZWFjaCBkb21haW4gaW4gdGhlIENESyBjb25maWcuXG4gICAqIEFsbCBmdXR1cmUgY29tbWFuZHMgKGUuZy4sIGBidWlsZGAsIGBwdXNoYCkgd2lsbCB1c2UgdGhpcyBjb25maWcuXG4gICAqXG4gICAqIFNlZSBodHRwczovL2RvY3MuZG9ja2VyLmNvbS9lbmdpbmUvcmVmZXJlbmNlL2NvbW1hbmRsaW5lL2xvZ2luLyNjcmVkZW50aWFsLWhlbHBlcnMgZm9yIG1vcmUgZGV0YWlscyBvbiBjcmVkIGhlbHBlcnMuXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgQ0RLIGNvbmZpZyB3YXMgZm91bmQgYW5kIGNvbmZpZ3VyZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgcHVibGljIGNvbmZpZ3VyZUNka0NyZWRlbnRpYWxzKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGNvbmZpZyA9IGNka0NyZWRlbnRpYWxzQ29uZmlnKCk7XG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmZpZ0RpciA9IGZzLm1rZHRlbXBTeW5jKHBhdGguam9pbihvcy50bXBkaXIoKSwgJ2Nka0RvY2tlckNvbmZpZycpKTtcblxuICAgIGNvbnN0IGRvbWFpbnMgPSBPYmplY3Qua2V5cyhjb25maWcuZG9tYWluQ3JlZGVudGlhbHMpO1xuICAgIGNvbnN0IGNyZWRIZWxwZXJzID0gZG9tYWlucy5yZWR1Y2UoKG1hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPiwgZG9tYWluKSA9PiB7XG4gICAgICBtYXBbZG9tYWluXSA9ICdjZGstYXNzZXRzJzsgLy8gVXNlIGRvY2tlci1jcmVkZW50aWFsLWNkay1hc3NldHMgZm9yIHRoaXMgZG9tYWluXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH0sIHt9KTtcbiAgICBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbih0aGlzLmNvbmZpZ0RpciwgJ2NvbmZpZy5qc29uJyksIEpTT04uc3RyaW5naWZ5KHsgY3JlZEhlbHBlcnMgfSksIHtcbiAgICAgIGVuY29kaW5nOiAndXRmLTgnLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbnkgY29uZmlndXJlZCBEb2NrZXIgY29uZmlnIGRpcmVjdG9yeS5cbiAgICogQWxsIGZ1dHVyZSBjb21tYW5kcyAoZS5nLiwgYGJ1aWxkYCwgYHB1c2hgKSB3aWxsIHVzZSB0aGUgZGVmYXVsdCBjb25maWcuXG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZnVsIGFmdGVyIGNhbGxpbmcgYGNvbmZpZ3VyZUNka0NyZWRlbnRpYWxzYCB0byByZXNldCB0byBkZWZhdWx0IGNyZWRlbnRpYWxzLlxuICAgKi9cbiAgcHVibGljIHJlc2V0QXV0aFBsdWdpbnMoKSB7XG4gICAgdGhpcy5jb25maWdEaXIgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGV4ZWN1dGUoYXJnczogc3RyaW5nW10sIG9wdGlvbnM6IE9taXQ8U2hlbGxPcHRpb25zLCAnc2hlbGxFdmVudFB1Ymxpc2hlcic+ID0ge30pIHtcbiAgICBjb25zdCBjb25maWdBcmdzID0gdGhpcy5jb25maWdEaXIgPyBbJy0tY29uZmlnJywgdGhpcy5jb25maWdEaXJdIDogW107XG5cbiAgICBjb25zdCBwYXRoVG9DZGtBc3NldHMgPSBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4nLCAnLi4nLCAnYmluJyk7XG5cbiAgICBjb25zdCBzaGVsbEV2ZW50UHVibGlzaGVyID0gc2hlbGxFdmVudFB1Ymxpc2hlckZyb21FdmVudEVtaXR0ZXIodGhpcy5ldmVudEVtaXR0ZXIpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBzaGVsbChbZ2V0RG9ja2VyQ21kKCksIC4uLmNvbmZpZ0FyZ3MsIC4uLmFyZ3NdLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHNoZWxsRXZlbnRQdWJsaXNoZXI6IHNoZWxsRXZlbnRQdWJsaXNoZXIsXG4gICAgICAgIGVudjoge1xuICAgICAgICAgIC4uLnByb2Nlc3MuZW52LFxuICAgICAgICAgIC4uLm9wdGlvbnMuZW52LFxuICAgICAgICAgIFBBVEg6IGAke3BhdGhUb0Nka0Fzc2V0c30ke3BhdGguZGVsaW1pdGVyfSR7b3B0aW9ucy5lbnY/LlBBVEggPz8gcHJvY2Vzcy5lbnYuUEFUSH1gLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBpZiAoZS5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZhaWxlZCB0byBmaW5kIGFuZCBleGVjdXRlICcke2dldERvY2tlckNtZCgpfScgd2hpbGUgYXR0ZW1wdGluZyB0byBidWlsZCBhIGNvbnRhaW5lciBhc3NldC4gUGxlYXNlIGluc3RhbGwgJyR7Z2V0RG9ja2VyQ21kKCl9JyBhbmQgdHJ5IGFnYWluLiAoT3Igc2V0IHRoZSAnQ0RLX0RPQ0tFUiAnIGVudmlyb25tZW50IHZhcmlhYmxlIHRvIGNob29zZSBhIGRpZmZlcmVudCBjb21wYXRpYmxlIGNvbnRhaW5lciBjbGllbnQuKWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2FjaGVPcHRpb25Ub0ZsYWcob3B0aW9uOiBEb2NrZXJDYWNoZU9wdGlvbik6IHN0cmluZyB7XG4gICAgbGV0IGZsYWcgPSBgdHlwZT0ke29wdGlvbi50eXBlfWA7XG4gICAgaWYgKG9wdGlvbi5wYXJhbXMpIHtcbiAgICAgIGZsYWcgKz1cbiAgICAgICAgJywnICtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMob3B0aW9uLnBhcmFtcylcbiAgICAgICAgICAubWFwKChbaywgdl0pID0+IGAke2t9PSR7dn1gKVxuICAgICAgICAgIC5qb2luKCcsJyk7XG4gICAgfVxuICAgIHJldHVybiBmbGFnO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRG9ja2VyRmFjdG9yeU9wdGlvbnMge1xuICByZWFkb25seSByZXBvVXJpOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGVjcjogSUVDUkNsaWVudDtcbiAgcmVhZG9ubHkgZXZlbnRFbWl0dGVyOiBFdmVudEVtaXR0ZXI7XG4gIHJlYWRvbmx5IHN1YnByb2Nlc3NPdXRwdXREZXN0aW5hdGlvbjogU3VicHJvY2Vzc091dHB1dERlc3RpbmF0aW9uO1xufVxuXG4vKipcbiAqIEhlbHBzIGdldCBhcHByb3ByaWF0ZWx5IGNvbmZpZ3VyZWQgRG9ja2VyIGluc3RhbmNlcyBkdXJpbmcgdGhlIGNvbnRhaW5lclxuICogaW1hZ2UgcHVibGlzaGluZyBwcm9jZXNzLlxuICovXG5leHBvcnQgY2xhc3MgRG9ja2VyRmFjdG9yeSB7XG4gIHByaXZhdGUgZW50ZXJMb2dnZWRJbkRlc3RpbmF0aW9uc0NyaXRpY2FsU2VjdGlvbiA9IGNyZWF0ZUNyaXRpY2FsU2VjdGlvbigpO1xuICBwcml2YXRlIGxvZ2dlZEluRGVzdGluYXRpb25zID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgLyoqXG4gICAqIEdldHMgYSBEb2NrZXIgaW5zdGFuY2UgZm9yIGJ1aWxkaW5nIGltYWdlcy5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBmb3JCdWlsZChvcHRpb25zOiBEb2NrZXJGYWN0b3J5T3B0aW9ucyk6IFByb21pc2U8RG9ja2VyPiB7XG4gICAgY29uc3QgZG9ja2VyID0gbmV3IERvY2tlcihvcHRpb25zLmV2ZW50RW1pdHRlciwgb3B0aW9ucy5zdWJwcm9jZXNzT3V0cHV0RGVzdGluYXRpb24pO1xuXG4gICAgLy8gRGVmYXVsdCBiZWhhdmlvciBpcyB0byBsb2dpbiBiZWZvcmUgYnVpbGQgc28gdGhhdCB0aGUgRG9ja2VyZmlsZSBjYW4gcmVmZXJlbmNlIGltYWdlcyBpbiB0aGUgRUNSIHJlcG9cbiAgICAvLyBIb3dldmVyLCBpZiB3ZSdyZSBpbiBhIHBpcGVsaW5lcyBlbnZpcm9ubWVudCAoZm9yIGV4YW1wbGUpLFxuICAgIC8vIHdlIG1heSBoYXZlIGFsdGVybmF0aXZlIGNyZWRlbnRpYWxzIHRvIHRoZSBkZWZhdWx0IG9uZXMgdG8gdXNlIGZvciB0aGUgYnVpbGQgaXRzZWxmLlxuICAgIC8vIElmIHRoZSBzcGVjaWFsIGNvbmZpZyBmaWxlIGlzIHByZXNlbnQsIGRlbGF5IHRoZSBsb2dpbiB0byB0aGUgZGVmYXVsdCBjcmVkZW50aWFscyB1bnRpbCB0aGUgcHVzaC5cbiAgICAvLyBJZiB0aGUgY29uZmlnIGZpbGUgaXMgcHJlc2VudCwgd2Ugd2lsbCBjb25maWd1cmUgYW5kIHVzZSB0aG9zZSBjcmVkZW50aWFscyBmb3IgdGhlIGJ1aWxkLlxuICAgIGxldCBjZGtEb2NrZXJDcmVkZW50aWFsc0NvbmZpZ3VyZWQgPSBkb2NrZXIuY29uZmlndXJlQ2RrQ3JlZGVudGlhbHMoKTtcbiAgICBpZiAoIWNka0RvY2tlckNyZWRlbnRpYWxzQ29uZmlndXJlZCkge1xuICAgICAgYXdhaXQgdGhpcy5sb2dpbk9uY2VQZXJEZXN0aW5hdGlvbihkb2NrZXIsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBkb2NrZXI7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIERvY2tlciBpbnN0YW5jZSBmb3IgcHVzaGluZyBpbWFnZXMgdG8gRUNSLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGZvckVjclB1c2gob3B0aW9uczogRG9ja2VyRmFjdG9yeU9wdGlvbnMpIHtcbiAgICBjb25zdCBkb2NrZXIgPSBuZXcgRG9ja2VyKG9wdGlvbnMuZXZlbnRFbWl0dGVyLCBvcHRpb25zLnN1YnByb2Nlc3NPdXRwdXREZXN0aW5hdGlvbik7XG4gICAgYXdhaXQgdGhpcy5sb2dpbk9uY2VQZXJEZXN0aW5hdGlvbihkb2NrZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiBkb2NrZXI7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGxvZ2luT25jZVBlckRlc3RpbmF0aW9uKGRvY2tlcjogRG9ja2VyLCBvcHRpb25zOiBEb2NrZXJGYWN0b3J5T3B0aW9ucykge1xuICAgIC8vIENoYW5nZXM6IDAxMjM0NTY3ODkxMC5ka3IuZWNyLnVzLXdlc3QtMi5hbWF6b25hd3MuY29tL3RhZ2dpbmctdGVzdFxuICAgIC8vIFRvIHRoaXM6IDAxMjM0NTY3ODkxMC5ka3IuZWNyLnVzLXdlc3QtMi5hbWF6b25hd3MuY29tXG4gICAgY29uc3QgcmVwb3NpdG9yeURvbWFpbiA9IG9wdGlvbnMucmVwb1VyaS5zcGxpdCgnLycpWzBdO1xuXG4gICAgLy8gRW5zdXJlIG9uZS1hdC1hLXRpbWUgYWNjZXNzIHRvIGxvZ2dlZEluRGVzdGluYXRpb25zLlxuICAgIGF3YWl0IHRoaXMuZW50ZXJMb2dnZWRJbkRlc3RpbmF0aW9uc0NyaXRpY2FsU2VjdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5sb2dnZWRJbkRlc3RpbmF0aW9ucy5oYXMocmVwb3NpdG9yeURvbWFpbikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBhd2FpdCBkb2NrZXIubG9naW4ob3B0aW9ucy5lY3IpO1xuICAgICAgdGhpcy5sb2dnZWRJbkRlc3RpbmF0aW9ucy5hZGQocmVwb3NpdG9yeURvbWFpbik7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RG9ja2VyQ21kKCk6IHN0cmluZyB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5DREtfRE9DS0VSID8/ICdkb2NrZXInO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuKHg6IHN0cmluZ1tdW10pIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQoW10sIC4uLngpO1xufVxuIl19