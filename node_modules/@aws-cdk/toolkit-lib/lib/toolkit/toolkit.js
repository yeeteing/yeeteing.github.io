"use strict";
var __addDisposableResource = (this && this.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (this && this.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while (r = env.stack.pop()) {
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                    }
                    else s |= 1;
                }
                catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
Object.defineProperty(exports, "__esModule", { value: true });
exports.Toolkit = void 0;
require("../private/dispose-polyfill");
const path = require("node:path");
const cxapi = require("@aws-cdk/cx-api");
const chalk = require("chalk");
const chokidar = require("chokidar");
const fs = require("fs-extra");
const non_interactive_io_host_1 = require("./non-interactive-io-host");
const private_1 = require("./private");
const toolkit_error_1 = require("./toolkit-error");
const bootstrap_1 = require("../actions/bootstrap");
const deploy_1 = require("../actions/deploy");
const private_2 = require("../actions/deploy/private");
const private_3 = require("../actions/diff/private");
const refactor_1 = require("../actions/refactor");
const private_4 = require("../actions/watch/private");
const aws_auth_1 = require("../api/aws-auth");
const awscli_compatible_1 = require("../api/aws-auth/awscli-compatible");
const private_5 = require("../api/aws-auth/private");
const bootstrap_2 = require("../api/bootstrap");
const cloud_assembly_1 = require("../api/cloud-assembly");
const private_6 = require("../api/cloud-assembly/private");
const source_builder_1 = require("../api/cloud-assembly/source-builder");
const deployments_1 = require("../api/deployments");
const diff_1 = require("../api/diff");
const drift_1 = require("../api/drift");
const drift_formatter_1 = require("../api/drift/drift-formatter");
const private_7 = require("../api/io/private");
const logs_monitor_1 = require("../api/logs-monitor");
const plugin_1 = require("../api/plugin");
const refactoring_1 = require("../api/refactoring");
const context_1 = require("../api/refactoring/context");
const digest_1 = require("../api/refactoring/digest");
const resource_import_1 = require("../api/resource-import");
const private_8 = require("../api/tags/private");
const toolkit_info_1 = require("../api/toolkit-info");
const work_graph_1 = require("../api/work-graph");
const payloads_1 = require("../payloads");
const util_1 = require("../util");
const concurrency_1 = require("../util/concurrency");
const promises_1 = require("../util/promises");
/**
 * The AWS CDK Programmatic Toolkit
 */
class Toolkit extends source_builder_1.CloudAssemblySourceBuilder {
    props;
    /**
     * The toolkit stack name used for bootstrapping resources.
     */
    toolkitStackName;
    /**
     * The IoHost of this Toolkit
     */
    ioHost;
    /**
     * The plugin host for loading and managing plugins
     */
    pluginHost;
    /**
     * Cache of the internal SDK Provider instance
     */
    sdkProviderCache;
    baseCredentials;
    unstableFeatures;
    constructor(props = {}) {
        super();
        this.props = props;
        this.toolkitStackName = props.toolkitStackName ?? toolkit_info_1.DEFAULT_TOOLKIT_STACK_NAME;
        this.pluginHost = props.pluginHost ?? new plugin_1.PluginHost();
        let ioHost = props.ioHost ?? new non_interactive_io_host_1.NonInteractiveIoHost();
        if (props.emojis === false) {
            ioHost = (0, private_7.withoutEmojis)(ioHost);
        }
        if (props.color === false) {
            ioHost = (0, private_7.withoutColor)(ioHost);
        }
        // After removing emojis and color, we might end up with floating whitespace at either end of the message
        // This also removes newlines that we currently emit for CLI backwards compatibility.
        this.ioHost = (0, private_7.withTrimmedWhitespace)(ioHost);
        this.baseCredentials = props.sdkConfig?.baseCredentials ?? aws_auth_1.BaseCredentials.awsCliCompatible();
        this.unstableFeatures = props.unstableFeatures ?? [];
    }
    /**
     * Access to the AWS SDK
     * @internal
     */
    async sdkProvider(action) {
        // @todo this needs to be different instance per action
        if (!this.sdkProviderCache) {
            const ioHelper = (0, private_7.asIoHelper)(this.ioHost, action);
            const clientConfig = {
                requestHandler: (0, awscli_compatible_1.sdkRequestHandler)(this.props.sdkConfig?.httpOptions?.agent),
            };
            const config = await this.baseCredentials.sdkBaseConfig(ioHelper, clientConfig);
            this.sdkProviderCache = new private_5.SdkProvider(config.credentialProvider, config.defaultRegion, {
                ioHelper,
                logger: new private_5.IoHostSdkLogger(ioHelper),
                pluginHost: this.pluginHost,
                requestHandler: clientConfig.requestHandler,
            });
        }
        return this.sdkProviderCache;
    }
    /**
     * Helper to provide the CloudAssemblySourceBuilder with required toolkit services
     * @internal
     */
    async sourceBuilderServices() {
        return {
            ioHelper: (0, private_7.asIoHelper)(this.ioHost, 'assembly'),
            sdkProvider: await this.sdkProvider('assembly'),
            pluginHost: this.pluginHost,
        };
    }
    /**
     * Bootstrap Action
     */
    async bootstrap(environments, options = {}) {
        const startTime = Date.now();
        const results = [];
        const ioHelper = (0, private_7.asIoHelper)(this.ioHost, 'bootstrap');
        const bootstrapEnvironments = await environments.getEnvironments(this.ioHost);
        const source = options.source ?? bootstrap_1.BootstrapSource.default();
        const parameters = options.parameters;
        const bootstrapper = new bootstrap_2.Bootstrapper(source, ioHelper);
        const sdkProvider = await this.sdkProvider('bootstrap');
        const limit = (0, concurrency_1.pLimit)(20);
        // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
        await Promise.all(bootstrapEnvironments.map((environment, currentIdx) => limit(async () => {
            const bootstrapSpan = await ioHelper.span(private_7.SPAN.BOOTSTRAP_SINGLE)
                .begin(`${chalk.bold(environment.name)}: bootstrapping...`, {
                total: bootstrapEnvironments.length,
                current: currentIdx + 1,
                environment,
            });
            try {
                const bootstrapResult = await bootstrapper.bootstrapEnvironment(environment, sdkProvider, {
                    ...options,
                    toolkitStackName: this.toolkitStackName,
                    source,
                    parameters: parameters?.parameters,
                    usePreviousParameters: parameters?.keepExistingParameters,
                });
                const message = bootstrapResult.noOp
                    ? ` ✅  ${environment.name} (no changes)`
                    : ` ✅  ${environment.name}`;
                await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I9900.msg(chalk.green('\n' + message), { environment }));
                const envTime = await bootstrapSpan.end();
                const result = {
                    environment,
                    status: bootstrapResult.noOp ? 'no-op' : 'success',
                    duration: envTime.asMs,
                };
                results.push(result);
            }
            catch (e) {
                await ioHelper.notify(private_7.IO.CDK_TOOLKIT_E9900.msg(`\n ❌  ${chalk.bold(environment.name)} failed: ${(0, util_1.formatErrorMessage)(e)}`, { error: e }));
                throw e;
            }
        })));
        return {
            environments: results,
            duration: Date.now() - startTime,
        };
    }
    /**
     * Synth Action
     *
     * The caller assumes ownership of the `CachedCloudAssembly` and is responsible for calling `dispose()` on
     * it after use.
     */
    async synth(cx, options = {}) {
        const ioHelper = (0, private_7.asIoHelper)(this.ioHost, 'synth');
        const selectStacks = options.stacks ?? private_6.ALL_STACKS;
        const synthSpan = await ioHelper.span(private_7.SPAN.SYNTH_ASSEMBLY).begin({ stacks: selectStacks });
        // NOTE: NOT 'await using' because we return ownership to the caller
        const assembly = await (0, private_1.assemblyFromSource)(synthSpan.asHelper, cx);
        const stacks = await assembly.selectStacksV2(selectStacks);
        const autoValidateStacks = options.validateStacks ? [assembly.selectStacksForValidation()] : [];
        await this.validateStacksMetadata(stacks.concat(...autoValidateStacks), synthSpan.asHelper);
        await synthSpan.end();
        // if we have a single stack, print it to STDOUT
        const message = `Successfully synthesized to ${chalk.blue(path.resolve(stacks.assembly.directory))}`;
        const assemblyData = {
            assemblyDirectory: stacks.assembly.directory,
            stacksCount: stacks.stackCount,
            stackIds: stacks.hierarchicalIds,
        };
        if (stacks.stackCount === 1) {
            const firstStack = stacks.firstStack;
            const template = firstStack.template;
            const obscuredTemplate = (0, util_1.obscureTemplate)(template);
            await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I1901.msg(message, {
                ...assemblyData,
                stack: {
                    stackName: firstStack.stackName,
                    hierarchicalId: firstStack.hierarchicalId,
                    template,
                    stringifiedJson: (0, util_1.serializeStructure)(obscuredTemplate, true),
                    stringifiedYaml: (0, util_1.serializeStructure)(obscuredTemplate, false),
                },
            }));
        }
        else {
            // not outputting template to stdout, let's explain things to the user a little bit...
            await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I1902.msg(chalk.green(message), assemblyData));
            await ioHelper.defaults.info(`Supply a stack id (${stacks.stackArtifacts.map((s) => chalk.green(s.hierarchicalId)).join(', ')}) to display its template.`);
        }
        return new cloud_assembly_1.CachedCloudAssembly(assembly);
    }
    /**
     * Diff Action
     */
    async diff(cx, options = {}) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
            const ioHelper = (0, private_7.asIoHelper)(this.ioHost, 'diff');
            const selectStacks = options.stacks ?? private_6.ALL_STACKS;
            const synthSpan = await ioHelper.span(private_7.SPAN.SYNTH_ASSEMBLY).begin({ stacks: selectStacks });
            const assembly = __addDisposableResource(env_1, await (0, private_1.assemblyFromSource)(synthSpan.asHelper, cx), true);
            const stacks = await assembly.selectStacksV2(selectStacks);
            await synthSpan.end();
            const diffSpan = await ioHelper.span(private_7.SPAN.DIFF_STACK).begin({ stacks: selectStacks });
            const deployments = await this.deploymentsForAction('diff');
            const strict = !!options.strict;
            const contextLines = options.contextLines || 3;
            let diffs = 0;
            const templateInfos = await (0, private_3.prepareDiff)(diffSpan.asHelper, stacks, deployments, await this.sdkProvider('diff'), options);
            const templateDiffs = {};
            for (const templateInfo of templateInfos) {
                const formatter = new diff_1.DiffFormatter({ templateInfo });
                const stackDiff = formatter.formatStackDiff({ strict, contextLines });
                // Security Diff
                const securityDiff = formatter.formatSecurityDiff();
                const formattedSecurityDiff = securityDiff.permissionChangeType !== payloads_1.PermissionChangeType.NONE ? stackDiff.formattedDiff : undefined;
                // We only warn about BROADENING changes
                if (securityDiff.permissionChangeType == payloads_1.PermissionChangeType.BROADENING) {
                    const warningMessage = 'This deployment will make potentially sensitive changes according to your current security approval level.\nPlease confirm you intend to make the following modifications:\n';
                    await diffSpan.defaults.warn(warningMessage);
                    await diffSpan.defaults.info(securityDiff.formattedDiff);
                }
                // Stack Diff
                diffs += stackDiff.numStacksWithChanges;
                (0, private_3.appendObject)(templateDiffs, formatter.diffs);
                await diffSpan.notify(private_7.IO.CDK_TOOLKIT_I4002.msg(stackDiff.formattedDiff, {
                    stack: templateInfo.newTemplate,
                    diffs: formatter.diffs,
                    numStacksWithChanges: stackDiff.numStacksWithChanges,
                    permissionChanges: securityDiff.permissionChangeType,
                    formattedDiff: {
                        diff: stackDiff.formattedDiff,
                        security: formattedSecurityDiff,
                    },
                }));
            }
            await diffSpan.end(`✨ Number of stacks with differences: ${diffs}`, {
                numStacksWithChanges: diffs,
                diffs: templateDiffs,
            });
            return templateDiffs;
        }
        catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
        }
        finally {
            const result_1 = __disposeResources(env_1);
            if (result_1)
                await result_1;
        }
    }
    /**
     * Drift Action
     */
    async drift(cx, options = {}) {
        const env_2 = { stack: [], error: void 0, hasError: false };
        try {
            const ioHelper = (0, private_7.asIoHelper)(this.ioHost, 'drift');
            const selectStacks = options.stacks ?? private_6.ALL_STACKS;
            const synthSpan = await ioHelper.span(private_7.SPAN.SYNTH_ASSEMBLY).begin({ stacks: selectStacks });
            const assembly = __addDisposableResource(env_2, await (0, private_1.assemblyFromSource)(synthSpan.asHelper, cx), true);
            const stacks = await assembly.selectStacksV2(selectStacks);
            await synthSpan.end();
            const driftSpan = await ioHelper.span(private_7.SPAN.DRIFT_APP).begin({ stacks: selectStacks });
            const allDriftResults = {};
            const unavailableDrifts = [];
            const sdkProvider = await this.sdkProvider('drift');
            for (const stack of stacks.stackArtifacts) {
                const cfn = (await sdkProvider.forEnvironment(stack.environment, plugin_1.Mode.ForReading)).sdk.cloudFormation();
                const driftResults = await (0, drift_1.detectStackDrift)(cfn, driftSpan.asHelper, stack.stackName);
                if (!driftResults.StackResourceDrifts) {
                    const stackName = stack.displayName ?? stack.stackName;
                    unavailableDrifts.push(stackName);
                    await driftSpan.notify(private_7.IO.CDK_TOOLKIT_W4591.msg(`${stackName}: No drift results available`, { stack }));
                    continue;
                }
                const formatter = new drift_formatter_1.DriftFormatter({ stack, resourceDrifts: driftResults.StackResourceDrifts });
                const driftOutput = formatter.formatStackDrift();
                const stackDrift = {
                    numResourcesWithDrift: driftOutput.numResourcesWithDrift,
                    numResourcesUnchecked: driftOutput.numResourcesUnchecked,
                    formattedDrift: {
                        unchanged: driftOutput.unchanged,
                        unchecked: driftOutput.unchecked,
                        modified: driftOutput.modified,
                        deleted: driftOutput.deleted,
                    },
                };
                allDriftResults[formatter.stackName] = stackDrift;
                // header
                await driftSpan.defaults.info(driftOutput.stackHeader);
                // print the different sections at different levels
                if (driftOutput.unchanged) {
                    await driftSpan.defaults.debug(driftOutput.unchanged);
                }
                if (driftOutput.unchecked) {
                    await driftSpan.defaults.debug(driftOutput.unchecked);
                }
                if (driftOutput.modified) {
                    await driftSpan.defaults.info(driftOutput.modified);
                }
                if (driftOutput.deleted) {
                    await driftSpan.defaults.info(driftOutput.deleted);
                }
                // main stack result
                await driftSpan.notify(private_7.IO.CDK_TOOLKIT_I4590.msg(driftOutput.summary, {
                    stack,
                    drift: stackDrift,
                }));
            }
            // print summary
            const totalDrifts = Object.values(allDriftResults).reduce((total, current) => total + (current.numResourcesWithDrift ?? 0), 0);
            const totalUnchecked = Object.values(allDriftResults).reduce((total, current) => total + (current.numResourcesUnchecked ?? 0), 0);
            await driftSpan.end(`\n✨  Number of resources with drift: ${totalDrifts}${totalUnchecked ? ` (${totalUnchecked} unchecked)` : ''}`);
            if (unavailableDrifts.length) {
                await driftSpan.defaults.warn(`\n⚠️  Failed to check drift for ${unavailableDrifts.length} stack(s). Check log for more details.`);
            }
            return allDriftResults;
        }
        catch (e_2) {
            env_2.error = e_2;
            env_2.hasError = true;
        }
        finally {
            const result_2 = __disposeResources(env_2);
            if (result_2)
                await result_2;
        }
    }
    /**
     * List Action
     *
     * List selected stacks and their dependencies
     */
    async list(cx, options = {}) {
        const env_3 = { stack: [], error: void 0, hasError: false };
        try {
            const ioHelper = (0, private_7.asIoHelper)(this.ioHost, 'list');
            const selectStacks = options.stacks ?? private_6.ALL_STACKS;
            const synthSpan = await ioHelper.span(private_7.SPAN.SYNTH_ASSEMBLY).begin({ stacks: selectStacks });
            const assembly = __addDisposableResource(env_3, await (0, private_1.assemblyFromSource)(ioHelper, cx), true);
            const stackCollection = await assembly.selectStacksV2(selectStacks);
            await synthSpan.end();
            const stacks = stackCollection.withDependencies();
            const message = stacks.map(s => s.id).join('\n');
            await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I2901.msg(message, { stacks }));
            return stacks;
        }
        catch (e_3) {
            env_3.error = e_3;
            env_3.hasError = true;
        }
        finally {
            const result_3 = __disposeResources(env_3);
            if (result_3)
                await result_3;
        }
    }
    /**
     * Deploy Action
     *
     * Deploys the selected stacks into an AWS account
     */
    async deploy(cx, options = {}) {
        const env_4 = { stack: [], error: void 0, hasError: false };
        try {
            const ioHelper = (0, private_7.asIoHelper)(this.ioHost, 'deploy');
            const assembly = __addDisposableResource(env_4, await (0, private_1.assemblyFromSource)(ioHelper, cx), true);
            return await this._deploy(assembly, 'deploy', options);
        }
        catch (e_4) {
            env_4.error = e_4;
            env_4.hasError = true;
        }
        finally {
            const result_4 = __disposeResources(env_4);
            if (result_4)
                await result_4;
        }
    }
    /**
     * Helper to allow deploy being called as part of the watch action.
     */
    async _deploy(assembly, action, options = {}) {
        const ioHelper = (0, private_7.asIoHelper)(this.ioHost, action);
        const selectStacks = options.stacks ?? private_6.ALL_STACKS;
        const synthSpan = await ioHelper.span(private_7.SPAN.SYNTH_ASSEMBLY).begin({ stacks: selectStacks });
        const stackCollection = await assembly.selectStacksV2(selectStacks);
        await this.validateStacksMetadata(stackCollection, ioHelper);
        const synthDuration = await synthSpan.end();
        const ret = {
            stacks: [],
        };
        if (stackCollection.stackCount === 0) {
            await ioHelper.notify(private_7.IO.CDK_TOOLKIT_E5001.msg('This app contains no stacks'));
            return ret;
        }
        const deployments = await this.deploymentsForAction('deploy');
        const migrator = new resource_import_1.ResourceMigrator({ deployments, ioHelper });
        await migrator.tryMigrateResources(stackCollection, options);
        const parameterMap = (0, private_2.buildParameterMap)(options.parameters?.parameters);
        if (options.deploymentMethod?.method === 'hotswap') {
            await ioHelper.notify(private_7.IO.CDK_TOOLKIT_W5400.msg([
                '⚠️ Hotswap deployments deliberately introduce CloudFormation drift to speed up deployments',
                '⚠️ They should only be used for development - never use them for your production Stacks!',
            ].join('\n')));
        }
        const stacks = stackCollection.stackArtifacts;
        const stackOutputs = {};
        const outputsFile = options.outputsFile;
        const buildAsset = async (assetNode) => {
            const buildAssetSpan = await ioHelper.span(private_7.SPAN.BUILD_ASSET).begin({
                asset: assetNode.asset,
            });
            await deployments.buildSingleAsset(assetNode.assetManifestArtifact, assetNode.assetManifest, assetNode.asset, {
                stack: assetNode.parentStack,
                roleArn: options.roleArn,
                stackName: assetNode.parentStack.stackName,
            });
            await buildAssetSpan.end();
        };
        const publishAsset = async (assetNode) => {
            const publishAssetSpan = await ioHelper.span(private_7.SPAN.PUBLISH_ASSET).begin({
                asset: assetNode.asset,
            });
            await deployments.publishSingleAsset(assetNode.assetManifest, assetNode.asset, {
                stack: assetNode.parentStack,
                roleArn: options.roleArn,
                stackName: assetNode.parentStack.stackName,
                forcePublish: options.forceAssetPublishing,
            });
            await publishAssetSpan.end();
        };
        const deployStack = async (stackNode) => {
            const stack = stackNode.stack;
            if (stackCollection.stackCount !== 1) {
                await ioHelper.defaults.info(chalk.bold(stack.displayName));
            }
            if (!stack.environment) {
                throw new toolkit_error_1.ToolkitError(`Stack ${stack.displayName} does not define an environment, and AWS credentials could not be obtained from standard locations or no region was configured.`);
            }
            // The generated stack has no resources
            if (Object.keys(stack.template.Resources || {}).length === 0) {
                // stack is empty and doesn't exist => do nothing
                const stackExists = await deployments.stackExists({ stack });
                if (!stackExists) {
                    return ioHelper.notify(private_7.IO.CDK_TOOLKIT_W5021.msg(`${chalk.bold(stack.displayName)}: stack has no resources, skipping deployment.`));
                }
                // stack is empty, but exists => delete
                await ioHelper.notify(private_7.IO.CDK_TOOLKIT_W5022.msg(`${chalk.bold(stack.displayName)}: stack has no resources, deleting existing stack.`));
                await this._destroy(assembly, 'deploy', {
                    stacks: { patterns: [stack.hierarchicalId], strategy: cloud_assembly_1.StackSelectionStrategy.PATTERN_MUST_MATCH_SINGLE },
                    roleArn: options.roleArn,
                });
                return;
            }
            const currentTemplate = await deployments.readCurrentTemplate(stack);
            const formatter = new diff_1.DiffFormatter({
                templateInfo: {
                    oldTemplate: currentTemplate,
                    newTemplate: stack,
                },
            });
            const securityDiff = formatter.formatSecurityDiff();
            // Send a request response with the formatted security diff as part of the message,
            // and the template diff as data
            // (IoHost decides whether to print depending on permissionChangeType)
            const deployMotivation = '"--require-approval" is enabled and stack includes security-sensitive updates.';
            const deployQuestion = `${securityDiff.formattedDiff}\n\n${deployMotivation}\nDo you wish to deploy these changes`;
            const deployConfirmed = await ioHelper.requestResponse(private_7.IO.CDK_TOOLKIT_I5060.req(deployQuestion, {
                motivation: deployMotivation,
                concurrency,
                permissionChangeType: securityDiff.permissionChangeType,
                templateDiffs: formatter.diffs,
            }));
            if (!deployConfirmed) {
                throw new toolkit_error_1.ToolkitError('Aborted by user');
            }
            // Following are the same semantics we apply with respect to Notification ARNs (dictated by the SDK)
            //
            //  - undefined  =>  cdk ignores it, as if it wasn't supported (allows external management).
            //  - []:        =>  cdk manages it, and the user wants to wipe it out.
            //  - ['arn-1']  =>  cdk manages it, and the user wants to set it to ['arn-1'].
            const notificationArns = (!!options.notificationArns || !!stack.notificationArns)
                ? (options.notificationArns ?? []).concat(stack.notificationArns ?? [])
                : undefined;
            for (const notificationArn of notificationArns ?? []) {
                if (!(0, util_1.validateSnsTopicArn)(notificationArn)) {
                    throw new toolkit_error_1.ToolkitError(`Notification arn ${notificationArn} is not a valid arn for an SNS topic`);
                }
            }
            const stackIndex = stacks.indexOf(stack) + 1;
            const deploySpan = await ioHelper.span(private_7.SPAN.DEPLOY_STACK)
                .begin(`${chalk.bold(stack.displayName)}: deploying... [${stackIndex}/${stackCollection.stackCount}]`, {
                total: stackCollection.stackCount,
                current: stackIndex,
                stack,
            });
            let tags = options.tags;
            if (!tags || tags.length === 0) {
                tags = (0, private_8.tagsForStack)(stack);
            }
            let deployDuration;
            try {
                let deployResult;
                let rollback = options.rollback;
                let iteration = 0;
                while (!deployResult) {
                    if (++iteration > 2) {
                        throw new toolkit_error_1.ToolkitError('This loop should have stabilized in 2 iterations, but didn\'t. If you are seeing this error, please report it at https://github.com/aws/aws-cdk/issues/new/choose');
                    }
                    const r = await deployments.deployStack({
                        stack,
                        deployName: stack.stackName,
                        roleArn: options.roleArn,
                        toolkitStackName: this.toolkitStackName,
                        reuseAssets: options.reuseAssets,
                        notificationArns,
                        tags,
                        deploymentMethod: options.deploymentMethod,
                        forceDeployment: options.forceDeployment,
                        parameters: Object.assign({}, parameterMap['*'], parameterMap[stack.stackName]),
                        usePreviousParameters: options.parameters?.keepExistingParameters,
                        rollback,
                        extraUserAgent: options.extraUserAgent,
                        assetParallelism: options.assetParallelism,
                    });
                    switch (r.type) {
                        case 'did-deploy-stack':
                            deployResult = r;
                            break;
                        case 'failpaused-need-rollback-first': {
                            const motivation = r.reason === 'replacement'
                                ? `Stack is in a paused fail state (${r.status}) and change includes a replacement which cannot be deployed with "--no-rollback"`
                                : `Stack is in a paused fail state (${r.status}) and command line arguments do not include "--no-rollback"`;
                            const question = `${motivation}. Perform a regular deployment`;
                            const confirmed = await ioHelper.requestResponse(private_7.IO.CDK_TOOLKIT_I5050.req(question, {
                                motivation,
                                concurrency,
                            }));
                            if (!confirmed) {
                                throw new toolkit_error_1.ToolkitError('Aborted by user');
                            }
                            // Perform a rollback
                            await this._rollback(assembly, action, {
                                stacks: {
                                    patterns: [stack.hierarchicalId],
                                    strategy: cloud_assembly_1.StackSelectionStrategy.PATTERN_MUST_MATCH_SINGLE,
                                },
                                orphanFailedResources: options.orphanFailedResourcesDuringRollback,
                            });
                            // Go around through the 'while' loop again but switch rollback to true.
                            rollback = true;
                            break;
                        }
                        case 'replacement-requires-rollback': {
                            const motivation = 'Change includes a replacement which cannot be deployed with "--no-rollback"';
                            const question = `${motivation}. Perform a regular deployment`;
                            const confirmed = await ioHelper.requestResponse(private_7.IO.CDK_TOOLKIT_I5050.req(question, {
                                motivation,
                                concurrency,
                            }));
                            if (!confirmed) {
                                throw new toolkit_error_1.ToolkitError('Aborted by user');
                            }
                            // Go around through the 'while' loop again but switch rollback to true.
                            rollback = true;
                            break;
                        }
                        default:
                            throw new toolkit_error_1.ToolkitError(`Unexpected result type from deployStack: ${JSON.stringify(r)}. If you are seeing this error, please report it at https://github.com/aws/aws-cdk/issues/new/choose`);
                    }
                }
                const message = deployResult.noOp
                    ? ` ✅  ${stack.displayName} (no changes)`
                    : ` ✅  ${stack.displayName}`;
                await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I5900.msg(chalk.green('\n' + message), deployResult));
                deployDuration = await deploySpan.timing(private_7.IO.CDK_TOOLKIT_I5000);
                if (Object.keys(deployResult.outputs).length > 0) {
                    const buffer = ['Outputs:'];
                    stackOutputs[stack.stackName] = deployResult.outputs;
                    for (const name of Object.keys(deployResult.outputs).sort()) {
                        const value = deployResult.outputs[name];
                        buffer.push(`${chalk.cyan(stack.id)}.${chalk.cyan(name)} = ${chalk.underline(chalk.cyan(value))}`);
                    }
                    await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I5901.msg(buffer.join('\n')));
                }
                await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I5901.msg(`Stack ARN:\n${deployResult.stackArn}`));
                ret.stacks.push({
                    stackName: stack.stackName,
                    environment: {
                        account: stack.environment.account,
                        region: stack.environment.region,
                    },
                    stackArn: deployResult.stackArn,
                    outputs: deployResult.outputs,
                    hierarchicalId: stack.hierarchicalId,
                });
            }
            catch (e) {
                // It has to be exactly this string because an integration test tests for
                // "bold(stackname) failed: ResourceNotReady: <error>"
                throw new toolkit_error_1.ToolkitError([`❌  ${chalk.bold(stack.stackName)} failed:`, ...(e.name ? [`${e.name}:`] : []), e.message].join(' '));
            }
            finally {
                if (options.traceLogs) {
                    // deploy calls that originate from watch will come with their own cloudWatchLogMonitor
                    const cloudWatchLogMonitor = options.cloudWatchLogMonitor ?? new logs_monitor_1.CloudWatchLogEventMonitor({ ioHelper });
                    const foundLogGroupsResult = await (0, logs_monitor_1.findCloudWatchLogGroups)(await this.sdkProvider('deploy'), ioHelper, stack);
                    cloudWatchLogMonitor.addLogGroups(foundLogGroupsResult.env, foundLogGroupsResult.sdk, foundLogGroupsResult.logGroupNames);
                    await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I5031.msg(`The following log groups are added: ${foundLogGroupsResult.logGroupNames}`));
                }
                // If an outputs file has been specified, create the file path and write stack outputs to it once.
                // Outputs are written after all stacks have been deployed. If a stack deployment fails,
                // all of the outputs from successfully deployed stacks before the failure will still be written.
                if (outputsFile) {
                    fs.ensureFileSync(outputsFile);
                    await fs.writeJson(outputsFile, stackOutputs, {
                        spaces: 2,
                        encoding: 'utf8',
                    });
                }
            }
            const duration = synthDuration.asMs + (deployDuration?.asMs ?? 0);
            await deploySpan.end(`\n✨  Total time: ${(0, util_1.formatTime)(duration)}s\n`, { duration });
        };
        const assetBuildTime = options.assetBuildTime ?? deploy_1.AssetBuildTime.ALL_BEFORE_DEPLOY;
        const prebuildAssets = assetBuildTime === deploy_1.AssetBuildTime.ALL_BEFORE_DEPLOY;
        const concurrency = options.concurrency || 1;
        const stacksAndTheirAssetManifests = stacks.flatMap((stack) => [
            stack,
            ...stack.dependencies.filter(x => cxapi.AssetManifestArtifact.isAssetManifestArtifact(x)),
        ]);
        const workGraph = new work_graph_1.WorkGraphBuilder(ioHelper, prebuildAssets).build(stacksAndTheirAssetManifests);
        // Unless we are running with '--force', skip already published assets
        if (!options.forceAssetPublishing) {
            await (0, private_2.removePublishedAssetsFromWorkGraph)(workGraph, deployments, options);
        }
        const graphConcurrency = {
            'stack': concurrency,
            'asset-build': 1, // This will be CPU-bound/memory bound, mostly matters for Docker builds
            'asset-publish': (options.assetParallelism ?? true) ? 8 : 1, // This will be I/O-bound, 8 in parallel seems reasonable
        };
        await workGraph.doParallel(graphConcurrency, {
            deployStack,
            buildAsset,
            publishAsset,
        });
        return ret;
    }
    /**
     * Watch Action
     *
     * Continuously observe project files and deploy the selected stacks
     * automatically when changes are detected. Defaults to hotswap deployments.
     *
     * This function returns immediately, starting a watcher in the background.
     */
    async watch(cx, options = {}) {
        const env_5 = { stack: [], error: void 0, hasError: false };
        try {
            const ioHelper = (0, private_7.asIoHelper)(this.ioHost, 'watch');
            const assembly = __addDisposableResource(env_5, await (0, private_1.assemblyFromSource)(ioHelper, cx, false), true);
            const rootDir = options.watchDir ?? process.cwd();
            // For the "include" setting, the behavior is:
            // 1. "watch" setting without an "include" key? We default to observing "**".
            // 2. "watch" setting with an empty "include" key? We default to observing "**".
            // 3. Non-empty "include" key? Just use the "include" key.
            const watchIncludes = options.include ?? [];
            if (watchIncludes.length <= 0) {
                watchIncludes.push('**');
            }
            // For the "exclude" setting, the behavior is to add some default excludes in addition to
            // patterns specified by the user sensible default patterns:
            const watchExcludes = options.exclude ?? [...private_4.WATCH_EXCLUDE_DEFAULTS];
            // 1. The CDK output directory, if it is under the rootDir
            const relativeOutDir = path.relative(rootDir, assembly.directory);
            if (Boolean(relativeOutDir && !relativeOutDir.startsWith('..' + path.sep) && !path.isAbsolute(relativeOutDir))) {
                watchExcludes.push(`${relativeOutDir}/**`);
            }
            // 2. Any file whose name starts with a dot.
            watchExcludes.push('.*', '**/.*');
            // 3. Any directory's content whose name starts with a dot.
            watchExcludes.push('**/.*/**');
            // 4. Any node_modules and its content (even if it's not a JS/TS project, you might be using a local aws-cli package)
            watchExcludes.push('**/node_modules/**');
            // Print some debug information on computed settings
            await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I5310.msg([
                `root directory used for 'watch' is: ${rootDir}`,
                `'include' patterns for 'watch': ${JSON.stringify(watchIncludes)}`,
                `'exclude' patterns for 'watch': ${JSON.stringify(watchExcludes)}`,
            ].join('\n'), {
                watchDir: rootDir,
                includes: watchIncludes,
                excludes: watchExcludes,
            }));
            let latch = 'pre-ready';
            const cloudWatchLogMonitor = options.traceLogs ? new logs_monitor_1.CloudWatchLogEventMonitor({ ioHelper }) : undefined;
            const deployAndWatch = async () => {
                latch = 'deploying';
                await cloudWatchLogMonitor?.deactivate();
                await this.invokeDeployFromWatch(assembly, options, cloudWatchLogMonitor);
                // If latch is still 'deploying' after the 'await', that's fine,
                // but if it's 'queued', that means we need to deploy again
                while (latch === 'queued') {
                    // TypeScript doesn't realize latch can change between 'awaits',
                    // and thinks the above 'while' condition is always 'false' without the cast
                    latch = 'deploying';
                    await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I5315.msg("Detected file changes during deployment. Invoking 'cdk deploy' again"));
                    await this.invokeDeployFromWatch(assembly, options, cloudWatchLogMonitor);
                }
                latch = 'open';
                await cloudWatchLogMonitor?.activate();
            };
            const watcher = chokidar
                .watch(watchIncludes, {
                ignored: watchExcludes,
                cwd: rootDir,
            })
                .on('ready', async () => {
                latch = 'open';
                await ioHelper.defaults.debug("'watch' received the 'ready' event. From now on, all file changes will trigger a deployment");
                await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I5314.msg("Triggering initial 'cdk deploy'"));
                await deployAndWatch();
            })
                .on('all', async (event, filePath) => {
                const watchEvent = {
                    event,
                    path: filePath,
                };
                if (latch === 'pre-ready') {
                    await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I5311.msg(`'watch' is observing ${event === 'addDir' ? 'directory' : 'the file'} '${filePath}' for changes`, watchEvent));
                }
                else if (latch === 'open') {
                    await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I5312.msg(`Detected change to '${filePath}' (type: ${event}). Triggering 'cdk deploy'`, watchEvent));
                    await deployAndWatch();
                }
                else {
                    // this means latch is either 'deploying' or 'queued'
                    latch = 'queued';
                    await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I5313.msg(`Detected change to '${filePath}' (type: ${event}) while 'cdk deploy' is still running. Will queue for another deployment after this one finishes'`, watchEvent));
                }
            });
            const stoppedPromise = (0, promises_1.promiseWithResolvers)();
            return {
                async dispose() {
                    // stop the logs monitor, if it exists
                    await cloudWatchLogMonitor?.deactivate();
                    // close the watcher itself
                    await watcher.close();
                    // Prevents Node from staying alive. There is no 'end' event that the watcher emits
                    // that we can know it's definitely done, so best we can do is tell it to stop watching,
                    // stop keeping Node alive, and then pretend that's everything we needed to do.
                    watcher.unref();
                    stoppedPromise.resolve();
                    return stoppedPromise.promise;
                },
                async waitForEnd() {
                    return stoppedPromise.promise;
                },
                async [Symbol.asyncDispose]() {
                    return this.dispose();
                },
            };
        }
        catch (e_5) {
            env_5.error = e_5;
            env_5.hasError = true;
        }
        finally {
            const result_5 = __disposeResources(env_5);
            if (result_5)
                await result_5;
        }
    }
    /**
     * Rollback Action
     *
     * Rolls back the selected stacks.
     */
    async rollback(cx, options = {}) {
        const env_6 = { stack: [], error: void 0, hasError: false };
        try {
            const ioHelper = (0, private_7.asIoHelper)(this.ioHost, 'rollback');
            const assembly = __addDisposableResource(env_6, await (0, private_1.assemblyFromSource)(ioHelper, cx), true);
            return await this._rollback(assembly, 'rollback', options);
        }
        catch (e_6) {
            env_6.error = e_6;
            env_6.hasError = true;
        }
        finally {
            const result_6 = __disposeResources(env_6);
            if (result_6)
                await result_6;
        }
    }
    /**
     * Helper to allow rollback being called as part of the deploy or watch action.
     */
    async _rollback(assembly, action, options) {
        const selectStacks = options.stacks ?? private_6.ALL_STACKS;
        const ioHelper = (0, private_7.asIoHelper)(this.ioHost, action);
        const synthSpan = await ioHelper.span(private_7.SPAN.SYNTH_ASSEMBLY).begin({ stacks: selectStacks });
        const stacks = await assembly.selectStacksV2(selectStacks);
        await this.validateStacksMetadata(stacks, ioHelper);
        await synthSpan.end();
        const ret = {
            stacks: [],
        };
        if (stacks.stackCount === 0) {
            await ioHelper.notify(private_7.IO.CDK_TOOLKIT_E6001.msg('No stacks selected'));
            return ret;
        }
        let anyRollbackable = false;
        for (const [index, stack] of stacks.stackArtifacts.entries()) {
            const rollbackSpan = await ioHelper.span(private_7.SPAN.ROLLBACK_STACK).begin(`Rolling back ${chalk.bold(stack.displayName)}`, {
                total: stacks.stackCount,
                current: index + 1,
                stack,
            });
            const deployments = await this.deploymentsForAction('rollback');
            try {
                const stackResult = await deployments.rollbackStack({
                    stack,
                    roleArn: options.roleArn,
                    toolkitStackName: this.toolkitStackName,
                    orphanFailedResources: options.orphanFailedResources,
                    validateBootstrapStackVersion: options.validateBootstrapStackVersion,
                    orphanLogicalIds: options.orphanLogicalIds,
                });
                if (!stackResult.notInRollbackableState) {
                    anyRollbackable = true;
                }
                await rollbackSpan.end();
                ret.stacks.push({
                    environment: {
                        account: stack.environment.account,
                        region: stack.environment.region,
                    },
                    stackName: stack.stackName,
                    stackArn: stackResult.stackArn,
                    result: stackResult.notInRollbackableState ? 'already-stable' : 'rolled-back',
                });
            }
            catch (e) {
                await ioHelper.notify(private_7.IO.CDK_TOOLKIT_E6900.msg(`\n ❌  ${chalk.bold(stack.displayName)} failed: ${(0, util_1.formatErrorMessage)(e)}`, { error: e }));
                throw toolkit_error_1.ToolkitError.withCause('Rollback failed (use --force to orphan failing resources)', e);
            }
        }
        if (!anyRollbackable) {
            throw new toolkit_error_1.ToolkitError('No stacks were in a state that could be rolled back');
        }
        return ret;
    }
    /**
     * Refactor Action. Moves resources from one location (stack + logical ID) to another.
     */
    async refactor(cx, options = {}) {
        this.requireUnstableFeature('refactor');
        const ioHelper = (0, private_7.asIoHelper)(this.ioHost, 'refactor');
        const assembly = await (0, private_1.assemblyFromSource)(ioHelper, cx);
        return this._refactor(assembly, ioHelper, options);
    }
    async _refactor(assembly, ioHelper, options = {}) {
        if (!options.dryRun) {
            throw new toolkit_error_1.ToolkitError('Refactor is not available yet. Too see the proposed changes, use the --dry-run flag.');
        }
        const sdkProvider = await this.sdkProvider('refactor');
        const stacks = await assembly.selectStacksV2(private_6.ALL_STACKS);
        const mappingSource = options.mappingSource ?? refactor_1.MappingSource.auto();
        const exclude = mappingSource.exclude.union(new refactoring_1.ManifestExcludeList(assembly.cloudAssembly.manifest));
        const filteredStacks = await assembly.selectStacksV2(options.stacks ?? private_6.ALL_STACKS);
        const refactoringContexts = [];
        for (let { environment, localStacks, deployedStacks } of await groupStacksByEnvironment()) {
            refactoringContexts.push(new context_1.RefactoringContext({
                environment,
                deployedStacks,
                localStacks,
                filteredStacks: filteredStacks.stackArtifacts,
                mappings: await getUserProvidedMappings(environment),
            }));
        }
        const nonAmbiguousContexts = refactoringContexts.filter(c => !c.isAmbiguous);
        if (nonAmbiguousContexts.length > 0) {
            await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I8900.msg((0, refactoring_1.formatMappingsHeader)(), {}));
        }
        for (const context of nonAmbiguousContexts) {
            const mappings = context.mappings.filter((m) => !exclude.isExcluded(m.destination));
            const typedMappings = mappings.map(m => m.toTypedMapping());
            const environment = context.environment;
            await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I8900.msg((0, refactoring_1.formatTypedMappings)(environment, typedMappings), {
                typedMappings,
            }));
        }
        const ambiguousContexts = refactoringContexts.filter(c => c.isAmbiguous);
        if (ambiguousContexts.length > 0) {
            await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I8900.msg((0, refactoring_1.formatAmbiguitySectionHeader)(), {}));
        }
        for (const context of ambiguousContexts) {
            const paths = context.ambiguousPaths;
            const environment = context.environment;
            await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I8900.msg((0, refactoring_1.formatAmbiguousMappings)(environment, paths), {
                ambiguousPaths: paths,
            }));
        }
        async function groupStacksByEnvironment() {
            const stackGroups = new Map();
            const environments = new Map();
            for (const stack of stacks.stackArtifacts) {
                const environment = await sdkProvider.resolveEnvironment(stack.environment);
                const key = (0, digest_1.hashObject)(environment);
                environments.set(key, environment);
                if (stackGroups.has(key)) {
                    stackGroups.get(key)[1].push(stack);
                }
                else {
                    // The first time we see an environment, we need to fetch all stacks deployed to it.
                    const before = await (0, refactoring_1.getDeployedStacks)(sdkProvider, environment);
                    stackGroups.set(key, [before, [stack]]);
                }
            }
            const result = [];
            for (const [hash, [deployedStacks, localStacks]] of stackGroups) {
                result.push({
                    environment: environments.get(hash),
                    localStacks,
                    deployedStacks,
                });
            }
            return result;
        }
        async function getUserProvidedMappings(environment) {
            return mappingSource.source == 'explicit'
                ? (0, refactoring_1.usePrescribedMappings)(mappingSource.groups.filter(matchesEnvironment), sdkProvider)
                : undefined;
            function matchesEnvironment(g) {
                return g.account === environment.account && g.region === environment.region;
            }
        }
    }
    /**
     * Destroy Action
     *
     * Destroys the selected Stacks.
     */
    async destroy(cx, options = {}) {
        const env_7 = { stack: [], error: void 0, hasError: false };
        try {
            const ioHelper = (0, private_7.asIoHelper)(this.ioHost, 'destroy');
            const assembly = __addDisposableResource(env_7, await (0, private_1.assemblyFromSource)(ioHelper, cx), true);
            return await this._destroy(assembly, 'destroy', options);
        }
        catch (e_7) {
            env_7.error = e_7;
            env_7.hasError = true;
        }
        finally {
            const result_7 = __disposeResources(env_7);
            if (result_7)
                await result_7;
        }
    }
    /**
     * Helper to allow destroy being called as part of the deploy action.
     */
    async _destroy(assembly, action, options) {
        const selectStacks = options.stacks ?? private_6.ALL_STACKS;
        const ioHelper = (0, private_7.asIoHelper)(this.ioHost, action);
        const synthSpan = await ioHelper.span(private_7.SPAN.SYNTH_ASSEMBLY).begin({ stacks: selectStacks });
        // The stacks will have been ordered for deployment, so reverse them for deletion.
        const stacks = (await assembly.selectStacksV2(selectStacks)).reversed();
        await synthSpan.end();
        const ret = {
            stacks: [],
        };
        const motivation = 'Destroying stacks is an irreversible action';
        const question = `Are you sure you want to delete: ${chalk.red(stacks.hierarchicalIds.join(', '))}`;
        const confirmed = await ioHelper.requestResponse(private_7.IO.CDK_TOOLKIT_I7010.req(question, { motivation }));
        if (!confirmed) {
            await ioHelper.notify(private_7.IO.CDK_TOOLKIT_E7010.msg('Aborted by user'));
            return ret;
        }
        const destroySpan = await ioHelper.span(private_7.SPAN.DESTROY_ACTION).begin({
            stacks: stacks.stackArtifacts,
        });
        try {
            for (const [index, stack] of stacks.stackArtifacts.entries()) {
                try {
                    const singleDestroySpan = await ioHelper.span(private_7.SPAN.DESTROY_STACK)
                        .begin(chalk.green(`${chalk.blue(stack.displayName)}: destroying... [${index + 1}/${stacks.stackCount}]`), {
                        total: stacks.stackCount,
                        current: index + 1,
                        stack,
                    });
                    const deployments = await this.deploymentsForAction(action);
                    const result = await deployments.destroyStack({
                        stack,
                        deployName: stack.stackName,
                        roleArn: options.roleArn,
                    });
                    ret.stacks.push({
                        environment: {
                            account: stack.environment.account,
                            region: stack.environment.region,
                        },
                        stackName: stack.stackName,
                        stackArn: result.stackArn,
                        stackExisted: result.stackArn !== undefined,
                    });
                    await ioHelper.notify(private_7.IO.CDK_TOOLKIT_I7900.msg(chalk.green(`\n ✅  ${chalk.blue(stack.displayName)}: ${action}ed`), stack));
                    await singleDestroySpan.end();
                }
                catch (e) {
                    await ioHelper.notify(private_7.IO.CDK_TOOLKIT_E7900.msg(`\n ❌  ${chalk.blue(stack.displayName)}: ${action} failed ${e}`, { error: e }));
                    throw e;
                }
            }
            return ret;
        }
        finally {
            await destroySpan.end();
        }
    }
    /**
     * Validate the stacks for errors and warnings according to the CLI's current settings
     */
    async validateStacksMetadata(stacks, ioHost) {
        const builder = (level) => {
            switch (level) {
                case 'error':
                    return private_7.IO.CDK_ASSEMBLY_E9999;
                case 'warn':
                    return private_7.IO.CDK_ASSEMBLY_W9999;
                default:
                    return private_7.IO.CDK_ASSEMBLY_I9999;
            }
        };
        await stacks.validateMetadata(this.props.assemblyFailureAt, async (level, msg) => ioHost.notify(builder(level).msg(`[${level} at ${msg.id}] ${msg.entry.data}`, msg)));
    }
    /**
     * Create a deployments class
     */
    async deploymentsForAction(action) {
        return new deployments_1.Deployments({
            sdkProvider: await this.sdkProvider(action),
            toolkitStackName: this.toolkitStackName,
            ioHelper: (0, private_7.asIoHelper)(this.ioHost, action),
        });
    }
    async invokeDeployFromWatch(assembly, options, cloudWatchLogMonitor) {
        // watch defaults to hotswap deployment
        const deploymentMethod = options.deploymentMethod ?? { method: 'hotswap' };
        const deployOptions = {
            ...options,
            cloudWatchLogMonitor,
            deploymentMethod,
            extraUserAgent: `cdk-watch/hotswap-${deploymentMethod.method === 'hotswap' ? 'on' : 'off'}`,
        };
        try {
            await this._deploy(assembly, 'watch', deployOptions);
        }
        catch {
            // just continue - deploy will show the error
        }
    }
    requireUnstableFeature(requestedFeature) {
        if (!this.unstableFeatures.includes(requestedFeature)) {
            throw new toolkit_error_1.ToolkitError(`Unstable feature '${requestedFeature}' is not enabled. Please enable it under 'unstableFeatures'`);
        }
    }
}
exports.Toolkit = Toolkit;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vbGtpdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInRvb2xraXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHVDQUFxQztBQUNyQyxrQ0FBa0M7QUFFbEMseUNBQXlDO0FBQ3pDLCtCQUErQjtBQUMvQixxQ0FBcUM7QUFDckMsK0JBQStCO0FBQy9CLHVFQUFpRTtBQUVqRSx1Q0FBK0M7QUFDL0MsbURBQStDO0FBUS9DLG9EQUF1RDtBQUN2RCw4Q0FBdUU7QUFDdkUsdURBSW1DO0FBR25DLHFEQUFvRTtBQUlwRSxrREFBb0Q7QUFJcEQsc0RBQWtFO0FBQ2xFLDhDQUt5QjtBQUN6Qix5RUFBc0U7QUFDdEUscURBQXVFO0FBQ3ZFLGdEQUFnRDtBQUVoRCwwREFBb0Y7QUFFcEYsMkRBQTJEO0FBQzNELHlFQUFrRjtBQUVsRixvREFBaUQ7QUFDakQsc0NBQTRDO0FBQzVDLHdDQUFnRDtBQUNoRCxrRUFBOEQ7QUFHOUQsK0NBQTZHO0FBQzdHLHNEQUF5RjtBQUN6RiwwQ0FBaUQ7QUFDakQsb0RBUTRCO0FBRTVCLHdEQUFnRTtBQUNoRSxzREFBdUQ7QUFDdkQsNERBQTBEO0FBQzFELGlEQUFtRDtBQUNuRCxzREFBaUU7QUFFakUsa0RBQXFEO0FBRXJELDBDQUFtRDtBQUNuRCxrQ0FBbUg7QUFDbkgscURBQTZDO0FBQzdDLCtDQUF3RDtBQTJFeEQ7O0dBRUc7QUFDSCxNQUFhLE9BQVEsU0FBUSwyQ0FBMEI7SUF5QmpCO0lBeEJwQzs7T0FFRztJQUNhLGdCQUFnQixDQUFTO0lBRXpDOztPQUVHO0lBQ2EsTUFBTSxDQUFVO0lBRWhDOztPQUVHO0lBQ2EsVUFBVSxDQUFhO0lBRXZDOztPQUVHO0lBQ0ssZ0JBQWdCLENBQWU7SUFFL0IsZUFBZSxDQUEyQjtJQUVqQyxnQkFBZ0IsQ0FBeUI7SUFFMUQsWUFBb0MsUUFBd0IsRUFBRTtRQUM1RCxLQUFL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USxFQUFFLE9BQU8sRUFBRSxhQUFhLENBQUMsQ0FBQztRQUN2RCxDQUFDO1FBQUMsTUFBTSxDQUFDO1lBQ1AsNkNBQTZDO1FBQy9DLENBQUM7SUFDSCxDQUFDO0lBRU8sc0JBQXNCLENBQUMsZ0JBQWlDO1FBQzlELElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQztZQUN0RCxNQUFNLElBQUksNEJBQVksQ0FBQyxxQkFBcUIsZ0JBQWdCLDZEQUE2RCxDQUFDLENBQUM7UUFDN0gsQ0FBQztJQUNILENBQUM7Q0FDRjtBQXptQ0QsMEJBeW1DQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi4vcHJpdmF0ZS9kaXNwb3NlLXBvbHlmaWxsJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAnbm9kZTpwYXRoJztcbmltcG9ydCB0eXBlIHsgVGVtcGxhdGVEaWZmIH0gZnJvbSAnQGF3cy1jZGsvY2xvdWRmb3JtYXRpb24tZGlmZic7XG5pbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0ICogYXMgY2hhbGsgZnJvbSAnY2hhbGsnO1xuaW1wb3J0ICogYXMgY2hva2lkYXIgZnJvbSAnY2hva2lkYXInO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHsgTm9uSW50ZXJhY3RpdmVJb0hvc3QgfSBmcm9tICcuL25vbi1pbnRlcmFjdGl2ZS1pby1ob3N0JztcbmltcG9ydCB0eXBlIHsgVG9vbGtpdFNlcnZpY2VzIH0gZnJvbSAnLi9wcml2YXRlJztcbmltcG9ydCB7IGFzc2VtYmx5RnJvbVNvdXJjZSB9IGZyb20gJy4vcHJpdmF0ZSc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuL3Rvb2xraXQtZXJyb3InO1xuaW1wb3J0IHR5cGUgeyBEZXBsb3lSZXN1bHQsIERlc3Ryb3lSZXN1bHQsIFJvbGxiYWNrUmVzdWx0IH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgdHlwZSB7XG4gIEJvb3RzdHJhcEVudmlyb25tZW50cyxcbiAgQm9vdHN0cmFwT3B0aW9ucyxcbiAgQm9vdHN0cmFwUmVzdWx0LFxuICBFbnZpcm9ubWVudEJvb3RzdHJhcFJlc3VsdCxcbn0gZnJvbSAnLi4vYWN0aW9ucy9ib290c3RyYXAnO1xuaW1wb3J0IHsgQm9vdHN0cmFwU291cmNlIH0gZnJvbSAnLi4vYWN0aW9ucy9ib290c3RyYXAnO1xuaW1wb3J0IHsgQXNzZXRCdWlsZFRpbWUsIHR5cGUgRGVwbG95T3B0aW9ucyB9IGZyb20gJy4uL2FjdGlvbnMvZGVwbG95JztcbmltcG9ydCB7XG4gIGJ1aWxkUGFyYW1ldGVyTWFwLFxuICB0eXBlIFByaXZhdGVEZXBsb3lPcHRpb25zLFxuICByZW1vdmVQdWJsaXNoZWRBc3NldHNGcm9tV29ya0dyYXBoLFxufSBmcm9tICcuLi9hY3Rpb25zL2RlcGxveS9wcml2YXRlJztcbmltcG9ydCB7IHR5cGUgRGVzdHJveU9wdGlvbnMgfSBmcm9tICcuLi9hY3Rpb25zL2Rlc3Ryb3knO1xuaW1wb3J0IHR5cGUgeyBEaWZmT3B0aW9ucyB9IGZyb20gJy4uL2FjdGlvbnMvZGlmZic7XG5pbXBvcnQgeyBhcHBlbmRPYmplY3QsIHByZXBhcmVEaWZmIH0gZnJvbSAnLi4vYWN0aW9ucy9kaWZmL3ByaXZhdGUnO1xuaW1wb3J0IHR5cGUgeyBEcmlmdE9wdGlvbnMsIERyaWZ0UmVzdWx0IH0gZnJvbSAnLi4vYWN0aW9ucy9kcmlmdCc7XG5pbXBvcnQgeyB0eXBlIExpc3RPcHRpb25zIH0gZnJvbSAnLi4vYWN0aW9ucy9saXN0JztcbmltcG9ydCB0eXBlIHsgTWFwcGluZ0dyb3VwLCBSZWZhY3Rvck9wdGlvbnMgfSBmcm9tICcuLi9hY3Rpb25zL3JlZmFjdG9yJztcbmltcG9ydCB7IE1hcHBpbmdTb3VyY2UgfSBmcm9tICcuLi9hY3Rpb25zL3JlZmFjdG9yJztcbmltcG9ydCB7IHR5cGUgUm9sbGJhY2tPcHRpb25zIH0gZnJvbSAnLi4vYWN0aW9ucy9yb2xsYmFjayc7XG5pbXBvcnQgeyB0eXBlIFN5bnRoT3B0aW9ucyB9IGZyb20gJy4uL2FjdGlvbnMvc3ludGgnO1xuaW1wb3J0IHR5cGUgeyBJV2F0Y2hlciwgV2F0Y2hPcHRpb25zIH0gZnJvbSAnLi4vYWN0aW9ucy93YXRjaCc7XG5pbXBvcnQgeyBXQVRDSF9FWENMVURFX0RFRkFVTFRTIH0gZnJvbSAnLi4vYWN0aW9ucy93YXRjaC9wcml2YXRlJztcbmltcG9ydCB7XG4gIEJhc2VDcmVkZW50aWFscyxcbiAgdHlwZSBJQmFzZUNyZWRlbnRpYWxzUHJvdmlkZXIsXG4gIHR5cGUgU2RrQmFzZUNsaWVudENvbmZpZyxcbiAgdHlwZSBTZGtDb25maWcsXG59IGZyb20gJy4uL2FwaS9hd3MtYXV0aCc7XG5pbXBvcnQgeyBzZGtSZXF1ZXN0SGFuZGxlciB9IGZyb20gJy4uL2FwaS9hd3MtYXV0aC9hd3NjbGktY29tcGF0aWJsZSc7XG5pbXBvcnQgeyBJb0hvc3RTZGtMb2dnZXIsIFNka1Byb3ZpZGVyIH0gZnJvbSAnLi4vYXBpL2F3cy1hdXRoL3ByaXZhdGUnO1xuaW1wb3J0IHsgQm9vdHN0cmFwcGVyIH0gZnJvbSAnLi4vYXBpL2Jvb3RzdHJhcCc7XG5pbXBvcnQgdHlwZSB7IElDbG91ZEFzc2VtYmx5U291cmNlIH0gZnJvbSAnLi4vYXBpL2Nsb3VkLWFzc2VtYmx5JztcbmltcG9ydCB7IENhY2hlZENsb3VkQXNzZW1ibHksIFN0YWNrU2VsZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuLi9hcGkvY2xvdWQtYXNzZW1ibHknO1xuaW1wb3J0IHR5cGUgeyBTdGFja0Fzc2VtYmx5IH0gZnJvbSAnLi4vYXBpL2Nsb3VkLWFzc2VtYmx5L3ByaXZhdGUnO1xuaW1wb3J0IHsgQUxMX1NUQUNLUyB9IGZyb20gJy4uL2FwaS9jbG91ZC1hc3NlbWJseS9wcml2YXRlJztcbmltcG9ydCB7IENsb3VkQXNzZW1ibHlTb3VyY2VCdWlsZGVyIH0gZnJvbSAnLi4vYXBpL2Nsb3VkLWFzc2VtYmx5L3NvdXJjZS1idWlsZGVyJztcbmltcG9ydCB0eXBlIHsgU3RhY2tDb2xsZWN0aW9uIH0gZnJvbSAnLi4vYXBpL2Nsb3VkLWFzc2VtYmx5L3N0YWNrLWNvbGxlY3Rpb24nO1xuaW1wb3J0IHsgRGVwbG95bWVudHMgfSBmcm9tICcuLi9hcGkvZGVwbG95bWVudHMnO1xuaW1wb3J0IHsgRGlmZkZvcm1hdHRlciB9IGZyb20gJy4uL2FwaS9kaWZmJztcbmltcG9ydCB7IGRldGVjdFN0YWNrRHJpZnQgfSBmcm9tICcuLi9hcGkvZHJpZnQnO1xuaW1wb3J0IHsgRHJpZnRGb3JtYXR0ZXIgfSBmcm9tICcuLi9hcGkvZHJpZnQvZHJpZnQtZm9ybWF0dGVyJztcbmltcG9ydCB0eXBlIHsgSUlvSG9zdCwgSW9NZXNzYWdlTGV2ZWwsIFRvb2xraXRBY3Rpb24gfSBmcm9tICcuLi9hcGkvaW8nO1xuaW1wb3J0IHR5cGUgeyBJb0hlbHBlciB9IGZyb20gJy4uL2FwaS9pby9wcml2YXRlJztcbmltcG9ydCB7IGFzSW9IZWxwZXIsIElPLCBTUEFOLCB3aXRob3V0Q29sb3IsIHdpdGhvdXRFbW9qaXMsIHdpdGhUcmltbWVkV2hpdGVzcGFjZSB9IGZyb20gJy4uL2FwaS9pby9wcml2YXRlJztcbmltcG9ydCB7IENsb3VkV2F0Y2hMb2dFdmVudE1vbml0b3IsIGZpbmRDbG91ZFdhdGNoTG9nR3JvdXBzIH0gZnJvbSAnLi4vYXBpL2xvZ3MtbW9uaXRvcic7XG5pbXBvcnQgeyBNb2RlLCBQbHVnaW5Ib3N0IH0gZnJvbSAnLi4vYXBpL3BsdWdpbic7XG5pbXBvcnQge1xuICBmb3JtYXRBbWJpZ3VpdHlTZWN0aW9uSGVhZGVyLFxuICBmb3JtYXRBbWJpZ3VvdXNNYXBwaW5ncyxcbiAgZm9ybWF0TWFwcGluZ3NIZWFkZXIsXG4gIGZvcm1hdFR5cGVkTWFwcGluZ3MsXG4gIGdldERlcGxveWVkU3RhY2tzLFxuICBNYW5pZmVzdEV4Y2x1ZGVMaXN0LFxuICB1c2VQcmVzY3JpYmVkTWFwcGluZ3MsXG59IGZyb20gJy4uL2FwaS9yZWZhY3RvcmluZyc7XG5pbXBvcnQgdHlwZSB7IENsb3VkRm9ybWF0aW9uU3RhY2ssIFJlc291cmNlTWFwcGluZyB9IGZyb20gJy4uL2FwaS9yZWZhY3RvcmluZy9jbG91ZGZvcm1hdGlvbic7XG5pbXBvcnQgeyBSZWZhY3RvcmluZ0NvbnRleHQgfSBmcm9tICcuLi9hcGkvcmVmYWN0b3JpbmcvY29udGV4dCc7XG5pbXBvcnQgeyBoYXNoT2JqZWN0IH0gZnJvbSAnLi4vYXBpL3JlZmFjdG9yaW5nL2RpZ2VzdCc7XG5pbXBvcnQgeyBSZXNvdXJjZU1pZ3JhdG9yIH0gZnJvbSAnLi4vYXBpL3Jlc291cmNlLWltcG9ydCc7XG5pbXBvcnQgeyB0YWdzRm9yU3RhY2sgfSBmcm9tICcuLi9hcGkvdGFncy9wcml2YXRlJztcbmltcG9ydCB7IERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FIH0gZnJvbSAnLi4vYXBpL3Rvb2xraXQtaW5mbyc7XG5pbXBvcnQgdHlwZSB7IEFzc2V0QnVpbGROb2RlLCBBc3NldFB1Ymxpc2hOb2RlLCBDb25jdXJyZW5jeSwgU3RhY2tOb2RlIH0gZnJvbSAnLi4vYXBpL3dvcmstZ3JhcGgnO1xuaW1wb3J0IHsgV29ya0dyYXBoQnVpbGRlciB9IGZyb20gJy4uL2FwaS93b3JrLWdyYXBoJztcbmltcG9ydCB0eXBlIHsgQXNzZW1ibHlEYXRhLCBTdGFja0RldGFpbHMsIFN1Y2Nlc3NmdWxEZXBsb3lTdGFja1Jlc3VsdCB9IGZyb20gJy4uL3BheWxvYWRzJztcbmltcG9ydCB7IFBlcm1pc3Npb25DaGFuZ2VUeXBlIH0gZnJvbSAnLi4vcGF5bG9hZHMnO1xuaW1wb3J0IHsgZm9ybWF0RXJyb3JNZXNzYWdlLCBmb3JtYXRUaW1lLCBvYnNjdXJlVGVtcGxhdGUsIHNlcmlhbGl6ZVN0cnVjdHVyZSwgdmFsaWRhdGVTbnNUb3BpY0FybiB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHsgcExpbWl0IH0gZnJvbSAnLi4vdXRpbC9jb25jdXJyZW5jeSc7XG5pbXBvcnQgeyBwcm9taXNlV2l0aFJlc29sdmVycyB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRvb2xraXRPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBJb0hvc3QgaW1wbGVtZW50YXRpb24sIGhhbmRsaW5nIHRoZSBpbmxpbmUgaW50ZXJhY3Rpb25zIGJldHdlZW4gdGhlIFRvb2xraXQgYW5kIGFuIGludGVncmF0aW9uLlxuICAgKi9cbiAgcmVhZG9ubHkgaW9Ib3N0PzogSUlvSG9zdDtcblxuICAvKipcbiAgICogQWxsb3cgZW1vamlzIGluIG1lc3NhZ2VzIHNlbnQgdG8gdGhlIElvSG9zdC5cbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgZW1vamlzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogV2hldGhlciB0byBhbGxvdyBBTlNJIGNvbG9ycyBhbmQgZm9ybWF0dGluZyBpbiBJb0hvc3QgbWVzc2FnZXMuXG4gICAqIFNldHRpbmcgdGhpcyB2YWx1ZSB0byBgZmFsc2VgIGVuZm9yY2VzIHRoYXQgbm8gY29sb3Igb3Igc3R5bGUgc2hvd3MgdXBcbiAgICogaW4gbWVzc2FnZXMgc2VudCB0byB0aGUgSW9Ib3N0LlxuICAgKiBTZXR0aW5nIHRoaXMgdmFsdWUgdG8gdHJ1ZSBpcyBhIG5vLW9wOyBpdCBpcyBlcXVpdmFsZW50IHRvIHRoZSBkZWZhdWx0LlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIERldGVjdHMgY29sb3IgZnJvbSB0aGUgVFRZIHN0YXR1cyBvZiB0aGUgSW9Ib3N0XG4gICAqL1xuICByZWFkb25seSBjb2xvcj86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIFNESy5cbiAgICovXG4gIHJlYWRvbmx5IHNka0NvbmZpZz86IFNka0NvbmZpZztcblxuICAvKipcbiAgICogTmFtZSBvZiB0aGUgdG9vbGtpdCBzdGFjayB0byBiZSB1c2VkLlxuICAgKlxuICAgKiBAZGVmYXVsdCBcIkNES1Rvb2xraXRcIlxuICAgKi9cbiAgcmVhZG9ubHkgdG9vbGtpdFN0YWNrTmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogRmFpbCBDbG91ZCBBc3NlbWJsaWVzXG4gICAqXG4gICAqIEBkZWZhdWx0IFwiZXJyb3JcIlxuICAgKi9cbiAgcmVhZG9ubHkgYXNzZW1ibHlGYWlsdXJlQXQ/OiAnZXJyb3InIHwgJ3dhcm4nIHwgJ25vbmUnO1xuXG4gIC8qKlxuICAgKiBUaGUgcGx1Z2luIGhvc3QgdG8gdXNlIGZvciBsb2FkaW5nIGFuZCBxdWVyeWluZyBwbHVnaW5zXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGEgdW5pcXVlIGluc3RhbmNlIG9mIGEgcGx1Z2luIG1hbmFnaW5nIGNsYXNzIHdpbGwgYmUgdXNlZC5cbiAgICpcbiAgICogVXNlIGB0b29sa2l0LnBsdWdpbkhvc3QubG9hZCgpYCB0byBsb2FkIHBsdWdpbnMgaW50byB0aGUgcGx1Z2luIGhvc3QgZnJvbSBkaXNrLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIEEgZnJlc2ggcGx1Z2luIGhvc3RcbiAgICovXG4gIHJlYWRvbmx5IHBsdWdpbkhvc3Q/OiBQbHVnaW5Ib3N0O1xuXG4gIC8qKlxuICAgKiBTZXQgb2YgdW5zdGFibGUgZmVhdHVyZXMgdG8gb3B0IGludG8uIElmIHlvdSBhcmUgdXNpbmcgYW4gdW5zdGFibGUgZmVhdHVyZSxcbiAgICogeW91IG11c3QgZXhwbGljaXRseSBhY2tub3dsZWRnZSB0aGF0IHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2tzIG9mIHVzaW5nIGl0LFxuICAgKiBieSBwYXNzaW5nIGl0IGluIHRoaXMgc2V0LlxuICAgKi9cbiAgcmVhZG9ubHkgdW5zdGFibGVGZWF0dXJlcz86IEFycmF5PFVuc3RhYmxlRmVhdHVyZT47XG59XG5cbmludGVyZmFjZSBTdGFja0dyb3VwIHtcbiAgZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50O1xuICBsb2NhbFN0YWNrczogQ2xvdWRGb3JtYXRpb25TdGFja1tdO1xuICBkZXBsb3llZFN0YWNrczogQ2xvdWRGb3JtYXRpb25TdGFja1tdO1xufVxuXG4vKipcbiAqIE5hbWVzIG9mIHRvb2xraXQgZmVhdHVyZXMgdGhhdCBhcmUgc3RpbGwgdW5kZXIgZGV2ZWxvcG1lbnQsIGFuZCBtYXkgY2hhbmdlIGluXG4gKiB0aGUgZnV0dXJlLlxuICovXG5leHBvcnQgdHlwZSBVbnN0YWJsZUZlYXR1cmUgPSAncmVmYWN0b3InO1xuXG4vKipcbiAqIFRoZSBBV1MgQ0RLIFByb2dyYW1tYXRpYyBUb29sa2l0XG4gKi9cbmV4cG9ydCBjbGFzcyBUb29sa2l0IGV4dGVuZHMgQ2xvdWRBc3NlbWJseVNvdXJjZUJ1aWxkZXIge1xuICAvKipcbiAgICogVGhlIHRvb2xraXQgc3RhY2sgbmFtZSB1c2VkIGZvciBib290c3RyYXBwaW5nIHJlc291cmNlcy5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSB0b29sa2l0U3RhY2tOYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJb0hvc3Qgb2YgdGhpcyBUb29sa2l0XG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgaW9Ib3N0OiBJSW9Ib3N0O1xuXG4gIC8qKlxuICAgKiBUaGUgcGx1Z2luIGhvc3QgZm9yIGxvYWRpbmcgYW5kIG1hbmFnaW5nIHBsdWdpbnNcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBwbHVnaW5Ib3N0OiBQbHVnaW5Ib3N0O1xuXG4gIC8qKlxuICAgKiBDYWNoZSBvZiB0aGUgaW50ZXJuYWwgU0RLIFByb3ZpZGVyIGluc3RhbmNlXG4gICAqL1xuICBwcml2YXRlIHNka1Byb3ZpZGVyQ2FjaGU/OiBTZGtQcm92aWRlcjtcblxuICBwcml2YXRlIGJhc2VDcmVkZW50aWFsczogSUJhc2VDcmVkZW50aWFsc1Byb3ZpZGVyO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgdW5zdGFibGVGZWF0dXJlczogQXJyYXk8VW5zdGFibGVGZWF0dXJlPjtcblxuICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBwcm9wczogVG9vbGtpdE9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50b29sa2l0U3RhY2tOYW1lID0gcHJvcHMudG9vbGtpdFN0YWNrTmFtZSA/PyBERUZBVUxUX1RPT0xLSVRfU1RBQ0tfTkFNRTtcblxuICAgIHRoaXMucGx1Z2luSG9zdCA9IHByb3BzLnBsdWdpbkhvc3QgPz8gbmV3IFBsdWdpbkhvc3QoKTtcblxuICAgIGxldCBpb0hvc3QgPSBwcm9wcy5pb0hvc3QgPz8gbmV3IE5vbkludGVyYWN0aXZlSW9Ib3N0KCk7XG4gICAgaWYgKHByb3BzLmVtb2ppcyA9PT0gZmFsc2UpIHtcbiAgICAgIGlvSG9zdCA9IHdpdGhvdXRFbW9qaXMoaW9Ib3N0KTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNvbG9yID09PSBmYWxzZSkge1xuICAgICAgaW9Ib3N0ID0gd2l0aG91dENvbG9yKGlvSG9zdCk7XG4gICAgfVxuICAgIC8vIEFmdGVyIHJlbW92aW5nIGVtb2ppcyBhbmQgY29sb3IsIHdlIG1pZ2h0IGVuZCB1cCB3aXRoIGZsb2F0aW5nIHdoaXRlc3BhY2UgYXQgZWl0aGVyIGVuZCBvZiB0aGUgbWVzc2FnZVxuICAgIC8vIFRoaXMgYWxzbyByZW1vdmVzIG5ld2xpbmVzIHRoYXQgd2UgY3VycmVudGx5IGVtaXQgZm9yIENMSSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICB0aGlzLmlvSG9zdCA9IHdpdGhUcmltbWVkV2hpdGVzcGFjZShpb0hvc3QpO1xuXG4gICAgdGhpcy5iYXNlQ3JlZGVudGlhbHMgPSBwcm9wcy5zZGtDb25maWc/LmJhc2VDcmVkZW50aWFscyA/PyBCYXNlQ3JlZGVudGlhbHMuYXdzQ2xpQ29tcGF0aWJsZSgpO1xuICAgIHRoaXMudW5zdGFibGVGZWF0dXJlcyA9IHByb3BzLnVuc3RhYmxlRmVhdHVyZXMgPz8gW107XG4gIH1cblxuICAvKipcbiAgICogQWNjZXNzIHRvIHRoZSBBV1MgU0RLXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIHNka1Byb3ZpZGVyKGFjdGlvbjogVG9vbGtpdEFjdGlvbik6IFByb21pc2U8U2RrUHJvdmlkZXI+IHtcbiAgICAvLyBAdG9kbyB0aGlzIG5lZWRzIHRvIGJlIGRpZmZlcmVudCBpbnN0YW5jZSBwZXIgYWN0aW9uXG4gICAgaWYgKCF0aGlzLnNka1Byb3ZpZGVyQ2FjaGUpIHtcbiAgICAgIGNvbnN0IGlvSGVscGVyID0gYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgYWN0aW9uKTtcbiAgICAgIGNvbnN0IGNsaWVudENvbmZpZzogU2RrQmFzZUNsaWVudENvbmZpZyA9IHtcbiAgICAgICAgcmVxdWVzdEhhbmRsZXI6IHNka1JlcXVlc3RIYW5kbGVyKHRoaXMucHJvcHMuc2RrQ29uZmlnPy5odHRwT3B0aW9ucz8uYWdlbnQpLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgY29uZmlnID0gYXdhaXQgdGhpcy5iYXNlQ3JlZGVudGlhbHMuc2RrQmFzZUNvbmZpZyhpb0hlbHBlciwgY2xpZW50Q29uZmlnKTtcbiAgICAgIHRoaXMuc2RrUHJvdmlkZXJDYWNoZSA9IG5ldyBTZGtQcm92aWRlcihjb25maWcuY3JlZGVudGlhbFByb3ZpZGVyLCBjb25maWcuZGVmYXVsdFJlZ2lvbiwge1xuICAgICAgICBpb0hlbHBlcixcbiAgICAgICAgbG9nZ2VyOiBuZXcgSW9Ib3N0U2RrTG9nZ2VyKGlvSGVscGVyKSxcbiAgICAgICAgcGx1Z2luSG9zdDogdGhpcy5wbHVnaW5Ib3N0LFxuICAgICAgICByZXF1ZXN0SGFuZGxlcjogY2xpZW50Q29uZmlnLnJlcXVlc3RIYW5kbGVyLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2RrUHJvdmlkZXJDYWNoZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gcHJvdmlkZSB0aGUgQ2xvdWRBc3NlbWJseVNvdXJjZUJ1aWxkZXIgd2l0aCByZXF1aXJlZCB0b29sa2l0IHNlcnZpY2VzXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvdGVjdGVkIG92ZXJyaWRlIGFzeW5jIHNvdXJjZUJ1aWxkZXJTZXJ2aWNlcygpOiBQcm9taXNlPFRvb2xraXRTZXJ2aWNlcz4ge1xuICAgIHJldHVybiB7XG4gICAgICBpb0hlbHBlcjogYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgJ2Fzc2VtYmx5JyksXG4gICAgICBzZGtQcm92aWRlcjogYXdhaXQgdGhpcy5zZGtQcm92aWRlcignYXNzZW1ibHknKSxcbiAgICAgIHBsdWdpbkhvc3Q6IHRoaXMucGx1Z2luSG9zdCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEJvb3RzdHJhcCBBY3Rpb25cbiAgICovXG4gIHB1YmxpYyBhc3luYyBib290c3RyYXAoZW52aXJvbm1lbnRzOiBCb290c3RyYXBFbnZpcm9ubWVudHMsIG9wdGlvbnM6IEJvb3RzdHJhcE9wdGlvbnMgPSB7fSk6IFByb21pc2U8Qm9vdHN0cmFwUmVzdWx0PiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCByZXN1bHRzOiBFbnZpcm9ubWVudEJvb3RzdHJhcFJlc3VsdFtdID0gW107XG5cbiAgICBjb25zdCBpb0hlbHBlciA9IGFzSW9IZWxwZXIodGhpcy5pb0hvc3QsICdib290c3RyYXAnKTtcbiAgICBjb25zdCBib290c3RyYXBFbnZpcm9ubWVudHMgPSBhd2FpdCBlbnZpcm9ubWVudHMuZ2V0RW52aXJvbm1lbnRzKHRoaXMuaW9Ib3N0KTtcbiAgICBjb25zdCBzb3VyY2UgPSBvcHRpb25zLnNvdXJjZSA/PyBCb290c3RyYXBTb3VyY2UuZGVmYXVsdCgpO1xuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBvcHRpb25zLnBhcmFtZXRlcnM7XG4gICAgY29uc3QgYm9vdHN0cmFwcGVyID0gbmV3IEJvb3RzdHJhcHBlcihzb3VyY2UsIGlvSGVscGVyKTtcbiAgICBjb25zdCBzZGtQcm92aWRlciA9IGF3YWl0IHRoaXMuc2RrUHJvdmlkZXIoJ2Jvb3RzdHJhcCcpO1xuICAgIGNvbnN0IGxpbWl0ID0gcExpbWl0KDIwKTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAY2RrbGFicy9wcm9taXNlYWxsLW5vLXVuYm91bmRlZC1wYXJhbGxlbGlzbVxuICAgIGF3YWl0IFByb21pc2UuYWxsKGJvb3RzdHJhcEVudmlyb25tZW50cy5tYXAoKGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudCwgY3VycmVudElkeCkgPT4gbGltaXQoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYm9vdHN0cmFwU3BhbiA9IGF3YWl0IGlvSGVscGVyLnNwYW4oU1BBTi5CT09UU1RSQVBfU0lOR0xFKVxuICAgICAgICAuYmVnaW4oYCR7Y2hhbGsuYm9sZChlbnZpcm9ubWVudC5uYW1lKX06IGJvb3RzdHJhcHBpbmcuLi5gLCB7XG4gICAgICAgICAgdG90YWw6IGJvb3RzdHJhcEVudmlyb25tZW50cy5sZW5ndGgsXG4gICAgICAgICAgY3VycmVudDogY3VycmVudElkeCArIDEsXG4gICAgICAgICAgZW52aXJvbm1lbnQsXG4gICAgICAgIH0pO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBib290c3RyYXBSZXN1bHQgPSBhd2FpdCBib290c3RyYXBwZXIuYm9vdHN0cmFwRW52aXJvbm1lbnQoXG4gICAgICAgICAgZW52aXJvbm1lbnQsXG4gICAgICAgICAgc2RrUHJvdmlkZXIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHRvb2xraXRTdGFja05hbWU6IHRoaXMudG9vbGtpdFN0YWNrTmFtZSxcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHBhcmFtZXRlcnM/LnBhcmFtZXRlcnMsXG4gICAgICAgICAgICB1c2VQcmV2aW91c1BhcmFtZXRlcnM6IHBhcmFtZXRlcnM/LmtlZXBFeGlzdGluZ1BhcmFtZXRlcnMsXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBtZXNzYWdlID0gYm9vdHN0cmFwUmVzdWx0Lm5vT3BcbiAgICAgICAgICA/IGAg4pyFICAke2Vudmlyb25tZW50Lm5hbWV9IChubyBjaGFuZ2VzKWBcbiAgICAgICAgICA6IGAg4pyFICAke2Vudmlyb25tZW50Lm5hbWV9YDtcblxuICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTk5MDAubXNnKGNoYWxrLmdyZWVuKCdcXG4nICsgbWVzc2FnZSksIHsgZW52aXJvbm1lbnQgfSkpO1xuICAgICAgICBjb25zdCBlbnZUaW1lID0gYXdhaXQgYm9vdHN0cmFwU3Bhbi5lbmQoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBFbnZpcm9ubWVudEJvb3RzdHJhcFJlc3VsdCA9IHtcbiAgICAgICAgICBlbnZpcm9ubWVudCxcbiAgICAgICAgICBzdGF0dXM6IGJvb3RzdHJhcFJlc3VsdC5ub09wID8gJ25vLW9wJyA6ICdzdWNjZXNzJyxcbiAgICAgICAgICBkdXJhdGlvbjogZW52VGltZS5hc01zLFxuICAgICAgICB9O1xuICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfRTk5MDAubXNnKGBcXG4g4p2MICAke2NoYWxrLmJvbGQoZW52aXJvbm1lbnQubmFtZSl9IGZhaWxlZDogJHtmb3JtYXRFcnJvck1lc3NhZ2UoZSl9YCwgeyBlcnJvcjogZSB9KSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSkpKTtcblxuICAgIHJldHVybiB7XG4gICAgICBlbnZpcm9ubWVudHM6IHJlc3VsdHMsXG4gICAgICBkdXJhdGlvbjogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFN5bnRoIEFjdGlvblxuICAgKlxuICAgKiBUaGUgY2FsbGVyIGFzc3VtZXMgb3duZXJzaGlwIG9mIHRoZSBgQ2FjaGVkQ2xvdWRBc3NlbWJseWAgYW5kIGlzIHJlc3BvbnNpYmxlIGZvciBjYWxsaW5nIGBkaXNwb3NlKClgIG9uXG4gICAqIGl0IGFmdGVyIHVzZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzeW50aChjeDogSUNsb3VkQXNzZW1ibHlTb3VyY2UsIG9wdGlvbnM6IFN5bnRoT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxDYWNoZWRDbG91ZEFzc2VtYmx5PiB7XG4gICAgY29uc3QgaW9IZWxwZXIgPSBhc0lvSGVscGVyKHRoaXMuaW9Ib3N0LCAnc3ludGgnKTtcbiAgICBjb25zdCBzZWxlY3RTdGFja3MgPSBvcHRpb25zLnN0YWNrcyA/PyBBTExfU1RBQ0tTO1xuICAgIGNvbnN0IHN5bnRoU3BhbiA9IGF3YWl0IGlvSGVscGVyLnNwYW4oU1BBTi5TWU5USF9BU1NFTUJMWSkuYmVnaW4oeyBzdGFja3M6IHNlbGVjdFN0YWNrcyB9KTtcblxuICAgIC8vIE5PVEU6IE5PVCAnYXdhaXQgdXNpbmcnIGJlY2F1c2Ugd2UgcmV0dXJuIG93bmVyc2hpcCB0byB0aGUgY2FsbGVyXG4gICAgY29uc3QgYXNzZW1ibHkgPSBhd2FpdCBhc3NlbWJseUZyb21Tb3VyY2Uoc3ludGhTcGFuLmFzSGVscGVyLCBjeCk7XG5cbiAgICBjb25zdCBzdGFja3MgPSBhd2FpdCBhc3NlbWJseS5zZWxlY3RTdGFja3NWMihzZWxlY3RTdGFja3MpO1xuICAgIGNvbnN0IGF1dG9WYWxpZGF0ZVN0YWNrcyA9IG9wdGlvbnMudmFsaWRhdGVTdGFja3MgPyBbYXNzZW1ibHkuc2VsZWN0U3RhY2tzRm9yVmFsaWRhdGlvbigpXSA6IFtdO1xuICAgIGF3YWl0IHRoaXMudmFsaWRhdGVTdGFja3NNZXRhZGF0YShzdGFja3MuY29uY2F0KC4uLmF1dG9WYWxpZGF0ZVN0YWNrcyksIHN5bnRoU3Bhbi5hc0hlbHBlcik7XG4gICAgYXdhaXQgc3ludGhTcGFuLmVuZCgpO1xuXG4gICAgLy8gaWYgd2UgaGF2ZSBhIHNpbmdsZSBzdGFjaywgcHJpbnQgaXQgdG8gU1RET1VUXG4gICAgY29uc3QgbWVzc2FnZSA9IGBTdWNjZXNzZnVsbHkgc3ludGhlc2l6ZWQgdG8gJHtjaGFsay5ibHVlKHBhdGgucmVzb2x2ZShzdGFja3MuYXNzZW1ibHkuZGlyZWN0b3J5KSl9YDtcbiAgICBjb25zdCBhc3NlbWJseURhdGE6IEFzc2VtYmx5RGF0YSA9IHtcbiAgICAgIGFzc2VtYmx5RGlyZWN0b3J5OiBzdGFja3MuYXNzZW1ibHkuZGlyZWN0b3J5LFxuICAgICAgc3RhY2tzQ291bnQ6IHN0YWNrcy5zdGFja0NvdW50LFxuICAgICAgc3RhY2tJZHM6IHN0YWNrcy5oaWVyYXJjaGljYWxJZHMsXG4gICAgfTtcblxuICAgIGlmIChzdGFja3Muc3RhY2tDb3VudCA9PT0gMSkge1xuICAgICAgY29uc3QgZmlyc3RTdGFjayA9IHN0YWNrcy5maXJzdFN0YWNrITtcbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gZmlyc3RTdGFjay50ZW1wbGF0ZTtcbiAgICAgIGNvbnN0IG9ic2N1cmVkVGVtcGxhdGUgPSBvYnNjdXJlVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0kxOTAxLm1zZyhtZXNzYWdlLCB7XG4gICAgICAgIC4uLmFzc2VtYmx5RGF0YSxcbiAgICAgICAgc3RhY2s6IHtcbiAgICAgICAgICBzdGFja05hbWU6IGZpcnN0U3RhY2suc3RhY2tOYW1lLFxuICAgICAgICAgIGhpZXJhcmNoaWNhbElkOiBmaXJzdFN0YWNrLmhpZXJhcmNoaWNhbElkLFxuICAgICAgICAgIHRlbXBsYXRlLFxuICAgICAgICAgIHN0cmluZ2lmaWVkSnNvbjogc2VyaWFsaXplU3RydWN0dXJlKG9ic2N1cmVkVGVtcGxhdGUsIHRydWUpLFxuICAgICAgICAgIHN0cmluZ2lmaWVkWWFtbDogc2VyaWFsaXplU3RydWN0dXJlKG9ic2N1cmVkVGVtcGxhdGUsIGZhbHNlKSxcbiAgICAgICAgfSxcbiAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm90IG91dHB1dHRpbmcgdGVtcGxhdGUgdG8gc3Rkb3V0LCBsZXQncyBleHBsYWluIHRoaW5ncyB0byB0aGUgdXNlciBhIGxpdHRsZSBiaXQuLi5cbiAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9JMTkwMi5tc2coY2hhbGsuZ3JlZW4obWVzc2FnZSksIGFzc2VtYmx5RGF0YSkpO1xuICAgICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMuaW5mbyhgU3VwcGx5IGEgc3RhY2sgaWQgKCR7c3RhY2tzLnN0YWNrQXJ0aWZhY3RzLm1hcCgocykgPT4gY2hhbGsuZ3JlZW4ocy5oaWVyYXJjaGljYWxJZCkpLmpvaW4oJywgJyl9KSB0byBkaXNwbGF5IGl0cyB0ZW1wbGF0ZS5gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENhY2hlZENsb3VkQXNzZW1ibHkoYXNzZW1ibHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpZmYgQWN0aW9uXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGlmZihjeDogSUNsb3VkQXNzZW1ibHlTb3VyY2UsIG9wdGlvbnM6IERpZmZPcHRpb25zID0ge30pOiBQcm9taXNlPHsgW25hbWU6IHN0cmluZ106IFRlbXBsYXRlRGlmZiB9PiB7XG4gICAgY29uc3QgaW9IZWxwZXIgPSBhc0lvSGVscGVyKHRoaXMuaW9Ib3N0LCAnZGlmZicpO1xuICAgIGNvbnN0IHNlbGVjdFN0YWNrcyA9IG9wdGlvbnMuc3RhY2tzID8/IEFMTF9TVEFDS1M7XG4gICAgY29uc3Qgc3ludGhTcGFuID0gYXdhaXQgaW9IZWxwZXIuc3BhbihTUEFOLlNZTlRIX0FTU0VNQkxZKS5iZWdpbih7IHN0YWNrczogc2VsZWN0U3RhY2tzIH0pO1xuICAgIGF3YWl0IHVzaW5nIGFzc2VtYmx5ID0gYXdhaXQgYXNzZW1ibHlGcm9tU291cmNlKHN5bnRoU3Bhbi5hc0hlbHBlciwgY3gpO1xuICAgIGNvbnN0IHN0YWNrcyA9IGF3YWl0IGFzc2VtYmx5LnNlbGVjdFN0YWNrc1YyKHNlbGVjdFN0YWNrcyk7XG4gICAgYXdhaXQgc3ludGhTcGFuLmVuZCgpO1xuXG4gICAgY29uc3QgZGlmZlNwYW4gPSBhd2FpdCBpb0hlbHBlci5zcGFuKFNQQU4uRElGRl9TVEFDSykuYmVnaW4oeyBzdGFja3M6IHNlbGVjdFN0YWNrcyB9KTtcbiAgICBjb25zdCBkZXBsb3ltZW50cyA9IGF3YWl0IHRoaXMuZGVwbG95bWVudHNGb3JBY3Rpb24oJ2RpZmYnKTtcblxuICAgIGNvbnN0IHN0cmljdCA9ICEhb3B0aW9ucy5zdHJpY3Q7XG4gICAgY29uc3QgY29udGV4dExpbmVzID0gb3B0aW9ucy5jb250ZXh0TGluZXMgfHwgMztcblxuICAgIGxldCBkaWZmcyA9IDA7XG5cbiAgICBjb25zdCB0ZW1wbGF0ZUluZm9zID0gYXdhaXQgcHJlcGFyZURpZmYoZGlmZlNwYW4uYXNIZWxwZXIsIHN0YWNrcywgZGVwbG95bWVudHMsIGF3YWl0IHRoaXMuc2RrUHJvdmlkZXIoJ2RpZmYnKSwgb3B0aW9ucyk7XG4gICAgY29uc3QgdGVtcGxhdGVEaWZmczogeyBbbmFtZTogc3RyaW5nXTogVGVtcGxhdGVEaWZmIH0gPSB7fTtcbiAgICBmb3IgKGNvbnN0IHRlbXBsYXRlSW5mbyBvZiB0ZW1wbGF0ZUluZm9zKSB7XG4gICAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgRGlmZkZvcm1hdHRlcih7IHRlbXBsYXRlSW5mbyB9KTtcbiAgICAgIGNvbnN0IHN0YWNrRGlmZiA9IGZvcm1hdHRlci5mb3JtYXRTdGFja0RpZmYoeyBzdHJpY3QsIGNvbnRleHRMaW5lcyB9KTtcblxuICAgICAgLy8gU2VjdXJpdHkgRGlmZlxuICAgICAgY29uc3Qgc2VjdXJpdHlEaWZmID0gZm9ybWF0dGVyLmZvcm1hdFNlY3VyaXR5RGlmZigpO1xuICAgICAgY29uc3QgZm9ybWF0dGVkU2VjdXJpdHlEaWZmID0gc2VjdXJpdHlEaWZmLnBlcm1pc3Npb25DaGFuZ2VUeXBlICE9PSBQZXJtaXNzaW9uQ2hhbmdlVHlwZS5OT05FID8gc3RhY2tEaWZmLmZvcm1hdHRlZERpZmYgOiB1bmRlZmluZWQ7XG4gICAgICAvLyBXZSBvbmx5IHdhcm4gYWJvdXQgQlJPQURFTklORyBjaGFuZ2VzXG4gICAgICBpZiAoc2VjdXJpdHlEaWZmLnBlcm1pc3Npb25DaGFuZ2VUeXBlID09IFBlcm1pc3Npb25DaGFuZ2VUeXBlLkJST0FERU5JTkcpIHtcbiAgICAgICAgY29uc3Qgd2FybmluZ01lc3NhZ2UgPSAnVGhpcyBkZXBsb3ltZW50IHdpbGwgbWFrZSBwb3RlbnRpYWxseSBzZW5zaXRpdmUgY2hhbmdlcyBhY2NvcmRpbmcgdG8geW91ciBjdXJyZW50IHNlY3VyaXR5IGFwcHJvdmFsIGxldmVsLlxcblBsZWFzZSBjb25maXJtIHlvdSBpbnRlbmQgdG8gbWFrZSB0aGUgZm9sbG93aW5nIG1vZGlmaWNhdGlvbnM6XFxuJztcbiAgICAgICAgYXdhaXQgZGlmZlNwYW4uZGVmYXVsdHMud2Fybih3YXJuaW5nTWVzc2FnZSk7XG4gICAgICAgIGF3YWl0IGRpZmZTcGFuLmRlZmF1bHRzLmluZm8oc2VjdXJpdHlEaWZmLmZvcm1hdHRlZERpZmYpO1xuICAgICAgfVxuXG4gICAgICAvLyBTdGFjayBEaWZmXG4gICAgICBkaWZmcyArPSBzdGFja0RpZmYubnVtU3RhY2tzV2l0aENoYW5nZXM7XG4gICAgICBhcHBlbmRPYmplY3QodGVtcGxhdGVEaWZmcywgZm9ybWF0dGVyLmRpZmZzKTtcbiAgICAgIGF3YWl0IGRpZmZTcGFuLm5vdGlmeShJTy5DREtfVE9PTEtJVF9JNDAwMi5tc2coc3RhY2tEaWZmLmZvcm1hdHRlZERpZmYsIHtcbiAgICAgICAgc3RhY2s6IHRlbXBsYXRlSW5mby5uZXdUZW1wbGF0ZSxcbiAgICAgICAgZGlmZnM6IGZvcm1hdHRlci5kaWZmcyxcbiAgICAgICAgbnVtU3RhY2tzV2l0aENoYW5nZXM6IHN0YWNrRGlmZi5udW1TdGFja3NXaXRoQ2hhbmdlcyxcbiAgICAgICAgcGVybWlzc2lvbkNoYW5nZXM6IHNlY3VyaXR5RGlmZi5wZXJtaXNzaW9uQ2hhbmdlVHlwZSxcbiAgICAgICAgZm9ybWF0dGVkRGlmZjoge1xuICAgICAgICAgIGRpZmY6IHN0YWNrRGlmZi5mb3JtYXR0ZWREaWZmLFxuICAgICAgICAgIHNlY3VyaXR5OiBmb3JtYXR0ZWRTZWN1cml0eURpZmYsXG4gICAgICAgIH0sXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgYXdhaXQgZGlmZlNwYW4uZW5kKGDinKggTnVtYmVyIG9mIHN0YWNrcyB3aXRoIGRpZmZlcmVuY2VzOiAke2RpZmZzfWAsIHtcbiAgICAgIG51bVN0YWNrc1dpdGhDaGFuZ2VzOiBkaWZmcyxcbiAgICAgIGRpZmZzOiB0ZW1wbGF0ZURpZmZzLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlRGlmZnM7XG4gIH1cblxuICAvKipcbiAgICogRHJpZnQgQWN0aW9uXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZHJpZnQoY3g6IElDbG91ZEFzc2VtYmx5U291cmNlLCBvcHRpb25zOiBEcmlmdE9wdGlvbnMgPSB7fSk6IFByb21pc2U8eyBbbmFtZTogc3RyaW5nXTogRHJpZnRSZXN1bHQgfT4ge1xuICAgIGNvbnN0IGlvSGVscGVyID0gYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgJ2RyaWZ0Jyk7XG4gICAgY29uc3Qgc2VsZWN0U3RhY2tzID0gb3B0aW9ucy5zdGFja3MgPz8gQUxMX1NUQUNLUztcbiAgICBjb25zdCBzeW50aFNwYW4gPSBhd2FpdCBpb0hlbHBlci5zcGFuKFNQQU4uU1lOVEhfQVNTRU1CTFkpLmJlZ2luKHsgc3RhY2tzOiBzZWxlY3RTdGFja3MgfSk7XG4gICAgYXdhaXQgdXNpbmcgYXNzZW1ibHkgPSBhd2FpdCBhc3NlbWJseUZyb21Tb3VyY2Uoc3ludGhTcGFuLmFzSGVscGVyLCBjeCk7XG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgYXNzZW1ibHkuc2VsZWN0U3RhY2tzVjIoc2VsZWN0U3RhY2tzKTtcbiAgICBhd2FpdCBzeW50aFNwYW4uZW5kKCk7XG5cbiAgICBjb25zdCBkcmlmdFNwYW4gPSBhd2FpdCBpb0hlbHBlci5zcGFuKFNQQU4uRFJJRlRfQVBQKS5iZWdpbih7IHN0YWNrczogc2VsZWN0U3RhY2tzIH0pO1xuICAgIGNvbnN0IGFsbERyaWZ0UmVzdWx0czogeyBbbmFtZTogc3RyaW5nXTogRHJpZnRSZXN1bHQgfSA9IHt9O1xuICAgIGNvbnN0IHVuYXZhaWxhYmxlRHJpZnRzID0gW107XG4gICAgY29uc3Qgc2RrUHJvdmlkZXIgPSBhd2FpdCB0aGlzLnNka1Byb3ZpZGVyKCdkcmlmdCcpO1xuXG4gICAgZm9yIChjb25zdCBzdGFjayBvZiBzdGFja3Muc3RhY2tBcnRpZmFjdHMpIHtcbiAgICAgIGNvbnN0IGNmbiA9IChhd2FpdCBzZGtQcm92aWRlci5mb3JFbnZpcm9ubWVudChzdGFjay5lbnZpcm9ubWVudCwgTW9kZS5Gb3JSZWFkaW5nKSkuc2RrLmNsb3VkRm9ybWF0aW9uKCk7XG4gICAgICBjb25zdCBkcmlmdFJlc3VsdHMgPSBhd2FpdCBkZXRlY3RTdGFja0RyaWZ0KGNmbiwgZHJpZnRTcGFuLmFzSGVscGVyLCBzdGFjay5zdGFja05hbWUpO1xuXG4gICAgICBpZiAoIWRyaWZ0UmVzdWx0cy5TdGFja1Jlc291cmNlRHJpZnRzKSB7XG4gICAgICAgIGNvbnN0IHN0YWNrTmFtZSA9IHN0YWNrLmRpc3BsYXlOYW1lID8/IHN0YWNrLnN0YWNrTmFtZTtcbiAgICAgICAgdW5hdmFpbGFibGVEcmlmdHMucHVzaChzdGFja05hbWUpO1xuICAgICAgICBhd2FpdCBkcmlmdFNwYW4ubm90aWZ5KElPLkNES19UT09MS0lUX1c0NTkxLm1zZyhgJHtzdGFja05hbWV9OiBObyBkcmlmdCByZXN1bHRzIGF2YWlsYWJsZWAsIHsgc3RhY2sgfSkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IERyaWZ0Rm9ybWF0dGVyKHsgc3RhY2ssIHJlc291cmNlRHJpZnRzOiBkcmlmdFJlc3VsdHMuU3RhY2tSZXNvdXJjZURyaWZ0cyB9KTtcbiAgICAgIGNvbnN0IGRyaWZ0T3V0cHV0ID0gZm9ybWF0dGVyLmZvcm1hdFN0YWNrRHJpZnQoKTtcbiAgICAgIGNvbnN0IHN0YWNrRHJpZnQgPSB7XG4gICAgICAgIG51bVJlc291cmNlc1dpdGhEcmlmdDogZHJpZnRPdXRwdXQubnVtUmVzb3VyY2VzV2l0aERyaWZ0LFxuICAgICAgICBudW1SZXNvdXJjZXNVbmNoZWNrZWQ6IGRyaWZ0T3V0cHV0Lm51bVJlc291cmNlc1VuY2hlY2tlZCxcbiAgICAgICAgZm9ybWF0dGVkRHJpZnQ6IHtcbiAgICAgICAgICB1bmNoYW5nZWQ6IGRyaWZ0T3V0cHV0LnVuY2hhbmdlZCxcbiAgICAgICAgICB1bmNoZWNrZWQ6IGRyaWZ0T3V0cHV0LnVuY2hlY2tlZCxcbiAgICAgICAgICBtb2RpZmllZDogZHJpZnRPdXRwdXQubW9kaWZpZWQsXG4gICAgICAgICAgZGVsZXRlZDogZHJpZnRPdXRwdXQuZGVsZXRlZCxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgICBhbGxEcmlmdFJlc3VsdHNbZm9ybWF0dGVyLnN0YWNrTmFtZV0gPSBzdGFja0RyaWZ0O1xuXG4gICAgICAvLyBoZWFkZXJcbiAgICAgIGF3YWl0IGRyaWZ0U3Bhbi5kZWZhdWx0cy5pbmZvKGRyaWZ0T3V0cHV0LnN0YWNrSGVhZGVyKTtcblxuICAgICAgLy8gcHJpbnQgdGhlIGRpZmZlcmVudCBzZWN0aW9ucyBhdCBkaWZmZXJlbnQgbGV2ZWxzXG4gICAgICBpZiAoZHJpZnRPdXRwdXQudW5jaGFuZ2VkKSB7XG4gICAgICAgIGF3YWl0IGRyaWZ0U3Bhbi5kZWZhdWx0cy5kZWJ1ZyhkcmlmdE91dHB1dC51bmNoYW5nZWQpO1xuICAgICAgfVxuICAgICAgaWYgKGRyaWZ0T3V0cHV0LnVuY2hlY2tlZCkge1xuICAgICAgICBhd2FpdCBkcmlmdFNwYW4uZGVmYXVsdHMuZGVidWcoZHJpZnRPdXRwdXQudW5jaGVja2VkKTtcbiAgICAgIH1cbiAgICAgIGlmIChkcmlmdE91dHB1dC5tb2RpZmllZCkge1xuICAgICAgICBhd2FpdCBkcmlmdFNwYW4uZGVmYXVsdHMuaW5mbyhkcmlmdE91dHB1dC5tb2RpZmllZCk7XG4gICAgICB9XG4gICAgICBpZiAoZHJpZnRPdXRwdXQuZGVsZXRlZCkge1xuICAgICAgICBhd2FpdCBkcmlmdFNwYW4uZGVmYXVsdHMuaW5mbyhkcmlmdE91dHB1dC5kZWxldGVkKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWFpbiBzdGFjayByZXN1bHRcbiAgICAgIGF3YWl0IGRyaWZ0U3Bhbi5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTQ1OTAubXNnKGRyaWZ0T3V0cHV0LnN1bW1hcnksIHtcbiAgICAgICAgc3RhY2ssXG4gICAgICAgIGRyaWZ0OiBzdGFja0RyaWZ0LFxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8vIHByaW50IHN1bW1hcnlcbiAgICBjb25zdCB0b3RhbERyaWZ0cyA9IE9iamVjdC52YWx1ZXMoYWxsRHJpZnRSZXN1bHRzKS5yZWR1Y2UoKHRvdGFsLCBjdXJyZW50KSA9PiB0b3RhbCArIChjdXJyZW50Lm51bVJlc291cmNlc1dpdGhEcmlmdCA/PyAwKSwgMCk7XG4gICAgY29uc3QgdG90YWxVbmNoZWNrZWQgPSBPYmplY3QudmFsdWVzKGFsbERyaWZ0UmVzdWx0cykucmVkdWNlKCh0b3RhbCwgY3VycmVudCkgPT4gdG90YWwgKyAoY3VycmVudC5udW1SZXNvdXJjZXNVbmNoZWNrZWQgPz8gMCksIDApO1xuICAgIGF3YWl0IGRyaWZ0U3Bhbi5lbmQoYFxcbuKcqCAgTnVtYmVyIG9mIHJlc291cmNlcyB3aXRoIGRyaWZ0OiAke3RvdGFsRHJpZnRzfSR7dG90YWxVbmNoZWNrZWQgPyBgICgke3RvdGFsVW5jaGVja2VkfSB1bmNoZWNrZWQpYCA6ICcnfWApO1xuICAgIGlmICh1bmF2YWlsYWJsZURyaWZ0cy5sZW5ndGgpIHtcbiAgICAgIGF3YWl0IGRyaWZ0U3Bhbi5kZWZhdWx0cy53YXJuKGBcXG7imqDvuI8gIEZhaWxlZCB0byBjaGVjayBkcmlmdCBmb3IgJHt1bmF2YWlsYWJsZURyaWZ0cy5sZW5ndGh9IHN0YWNrKHMpLiBDaGVjayBsb2cgZm9yIG1vcmUgZGV0YWlscy5gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWxsRHJpZnRSZXN1bHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgQWN0aW9uXG4gICAqXG4gICAqIExpc3Qgc2VsZWN0ZWQgc3RhY2tzIGFuZCB0aGVpciBkZXBlbmRlbmNpZXNcbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0KGN4OiBJQ2xvdWRBc3NlbWJseVNvdXJjZSwgb3B0aW9uczogTGlzdE9wdGlvbnMgPSB7fSk6IFByb21pc2U8U3RhY2tEZXRhaWxzW10+IHtcbiAgICBjb25zdCBpb0hlbHBlciA9IGFzSW9IZWxwZXIodGhpcy5pb0hvc3QsICdsaXN0Jyk7XG4gICAgY29uc3Qgc2VsZWN0U3RhY2tzID0gb3B0aW9ucy5zdGFja3MgPz8gQUxMX1NUQUNLUztcbiAgICBjb25zdCBzeW50aFNwYW4gPSBhd2FpdCBpb0hlbHBlci5zcGFuKFNQQU4uU1lOVEhfQVNTRU1CTFkpLmJlZ2luKHsgc3RhY2tzOiBzZWxlY3RTdGFja3MgfSk7XG4gICAgYXdhaXQgdXNpbmcgYXNzZW1ibHkgPSBhd2FpdCBhc3NlbWJseUZyb21Tb3VyY2UoaW9IZWxwZXIsIGN4KTtcbiAgICBjb25zdCBzdGFja0NvbGxlY3Rpb24gPSBhd2FpdCBhc3NlbWJseS5zZWxlY3RTdGFja3NWMihzZWxlY3RTdGFja3MpO1xuICAgIGF3YWl0IHN5bnRoU3Bhbi5lbmQoKTtcblxuICAgIGNvbnN0IHN0YWNrcyA9IHN0YWNrQ29sbGVjdGlvbi53aXRoRGVwZW5kZW5jaWVzKCk7XG4gICAgY29uc3QgbWVzc2FnZSA9IHN0YWNrcy5tYXAocyA9PiBzLmlkKS5qb2luKCdcXG4nKTtcblxuICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9JMjkwMS5tc2cobWVzc2FnZSwgeyBzdGFja3MgfSkpO1xuICAgIHJldHVybiBzdGFja3M7XG4gIH1cblxuICAvKipcbiAgICogRGVwbG95IEFjdGlvblxuICAgKlxuICAgKiBEZXBsb3lzIHRoZSBzZWxlY3RlZCBzdGFja3MgaW50byBhbiBBV1MgYWNjb3VudFxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRlcGxveShjeDogSUNsb3VkQXNzZW1ibHlTb3VyY2UsIG9wdGlvbnM6IERlcGxveU9wdGlvbnMgPSB7fSk6IFByb21pc2U8RGVwbG95UmVzdWx0PiB7XG4gICAgY29uc3QgaW9IZWxwZXIgPSBhc0lvSGVscGVyKHRoaXMuaW9Ib3N0LCAnZGVwbG95Jyk7XG4gICAgYXdhaXQgdXNpbmcgYXNzZW1ibHkgPSBhd2FpdCBhc3NlbWJseUZyb21Tb3VyY2UoaW9IZWxwZXIsIGN4KTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fZGVwbG95KGFzc2VtYmx5LCAnZGVwbG95Jywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIHRvIGFsbG93IGRlcGxveSBiZWluZyBjYWxsZWQgYXMgcGFydCBvZiB0aGUgd2F0Y2ggYWN0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfZGVwbG95KGFzc2VtYmx5OiBTdGFja0Fzc2VtYmx5LCBhY3Rpb246ICdkZXBsb3knIHwgJ3dhdGNoJywgb3B0aW9uczogUHJpdmF0ZURlcGxveU9wdGlvbnMgPSB7fSk6IFByb21pc2U8RGVwbG95UmVzdWx0PiB7XG4gICAgY29uc3QgaW9IZWxwZXIgPSBhc0lvSGVscGVyKHRoaXMuaW9Ib3N0LCBhY3Rpb24pO1xuICAgIGNvbnN0IHNlbGVjdFN0YWNrcyA9IG9wdGlvbnMuc3RhY2tzID8/IEFMTF9TVEFDS1M7XG4gICAgY29uc3Qgc3ludGhTcGFuID0gYXdhaXQgaW9IZWxwZXIuc3BhbihTUEFOLlNZTlRIX0FTU0VNQkxZKS5iZWdpbih7IHN0YWNrczogc2VsZWN0U3RhY2tzIH0pO1xuICAgIGNvbnN0IHN0YWNrQ29sbGVjdGlvbiA9IGF3YWl0IGFzc2VtYmx5LnNlbGVjdFN0YWNrc1YyKHNlbGVjdFN0YWNrcyk7XG4gICAgYXdhaXQgdGhpcy52YWxpZGF0ZVN0YWNrc01ldGFkYXRhKHN0YWNrQ29sbGVjdGlvbiwgaW9IZWxwZXIpO1xuICAgIGNvbnN0IHN5bnRoRHVyYXRpb24gPSBhd2FpdCBzeW50aFNwYW4uZW5kKCk7XG5cbiAgICBjb25zdCByZXQ6IERlcGxveVJlc3VsdCA9IHtcbiAgICAgIHN0YWNrczogW10sXG4gICAgfTtcblxuICAgIGlmIChzdGFja0NvbGxlY3Rpb24uc3RhY2tDb3VudCA9PT0gMCkge1xuICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0U1MDAxLm1zZygnVGhpcyBhcHAgY29udGFpbnMgbm8gc3RhY2tzJykpO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBjb25zdCBkZXBsb3ltZW50cyA9IGF3YWl0IHRoaXMuZGVwbG95bWVudHNGb3JBY3Rpb24oJ2RlcGxveScpO1xuICAgIGNvbnN0IG1pZ3JhdG9yID0gbmV3IFJlc291cmNlTWlncmF0b3IoeyBkZXBsb3ltZW50cywgaW9IZWxwZXIgfSk7XG5cbiAgICBhd2FpdCBtaWdyYXRvci50cnlNaWdyYXRlUmVzb3VyY2VzKHN0YWNrQ29sbGVjdGlvbiwgb3B0aW9ucyk7XG5cbiAgICBjb25zdCBwYXJhbWV0ZXJNYXAgPSBidWlsZFBhcmFtZXRlck1hcChvcHRpb25zLnBhcmFtZXRlcnM/LnBhcmFtZXRlcnMpO1xuXG4gICAgaWYgKG9wdGlvbnMuZGVwbG95bWVudE1ldGhvZD8ubWV0aG9kID09PSAnaG90c3dhcCcpIHtcbiAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9XNTQwMC5tc2coW1xuICAgICAgICAn4pqg77iPIEhvdHN3YXAgZGVwbG95bWVudHMgZGVsaWJlcmF0ZWx5IGludHJvZHVjZSBDbG91ZEZvcm1hdGlvbiBkcmlmdCB0byBzcGVlZCB1cCBkZXBsb3ltZW50cycsXG4gICAgICAgICfimqDvuI8gVGhleSBzaG91bGQgb25seSBiZSB1c2VkIGZvciBkZXZlbG9wbWVudCAtIG5ldmVyIHVzZSB0aGVtIGZvciB5b3VyIHByb2R1Y3Rpb24gU3RhY2tzIScsXG4gICAgICBdLmpvaW4oJ1xcbicpKSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhY2tzID0gc3RhY2tDb2xsZWN0aW9uLnN0YWNrQXJ0aWZhY3RzO1xuICAgIGNvbnN0IHN0YWNrT3V0cHV0czogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9O1xuICAgIGNvbnN0IG91dHB1dHNGaWxlID0gb3B0aW9ucy5vdXRwdXRzRmlsZTtcblxuICAgIGNvbnN0IGJ1aWxkQXNzZXQgPSBhc3luYyAoYXNzZXROb2RlOiBBc3NldEJ1aWxkTm9kZSkgPT4ge1xuICAgICAgY29uc3QgYnVpbGRBc3NldFNwYW4gPSBhd2FpdCBpb0hlbHBlci5zcGFuKFNQQU4uQlVJTERfQVNTRVQpLmJlZ2luKHtcbiAgICAgICAgYXNzZXQ6IGFzc2V0Tm9kZS5hc3NldCxcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgZGVwbG95bWVudHMuYnVpbGRTaW5nbGVBc3NldChcbiAgICAgICAgYXNzZXROb2RlLmFzc2V0TWFuaWZlc3RBcnRpZmFjdCxcbiAgICAgICAgYXNzZXROb2RlLmFzc2V0TWFuaWZlc3QsXG4gICAgICAgIGFzc2V0Tm9kZS5hc3NldCxcbiAgICAgICAge1xuICAgICAgICAgIHN0YWNrOiBhc3NldE5vZGUucGFyZW50U3RhY2ssXG4gICAgICAgICAgcm9sZUFybjogb3B0aW9ucy5yb2xlQXJuLFxuICAgICAgICAgIHN0YWNrTmFtZTogYXNzZXROb2RlLnBhcmVudFN0YWNrLnN0YWNrTmFtZSxcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgICBhd2FpdCBidWlsZEFzc2V0U3Bhbi5lbmQoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcHVibGlzaEFzc2V0ID0gYXN5bmMgKGFzc2V0Tm9kZTogQXNzZXRQdWJsaXNoTm9kZSkgPT4ge1xuICAgICAgY29uc3QgcHVibGlzaEFzc2V0U3BhbiA9IGF3YWl0IGlvSGVscGVyLnNwYW4oU1BBTi5QVUJMSVNIX0FTU0VUKS5iZWdpbih7XG4gICAgICAgIGFzc2V0OiBhc3NldE5vZGUuYXNzZXQsXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IGRlcGxveW1lbnRzLnB1Ymxpc2hTaW5nbGVBc3NldChhc3NldE5vZGUuYXNzZXRNYW5pZmVzdCwgYXNzZXROb2RlLmFzc2V0LCB7XG4gICAgICAgIHN0YWNrOiBhc3NldE5vZGUucGFyZW50U3RhY2ssXG4gICAgICAgIHJvbGVBcm46IG9wdGlvbnMucm9sZUFybixcbiAgICAgICAgc3RhY2tOYW1lOiBhc3NldE5vZGUucGFyZW50U3RhY2suc3RhY2tOYW1lLFxuICAgICAgICBmb3JjZVB1Ymxpc2g6IG9wdGlvbnMuZm9yY2VBc3NldFB1Ymxpc2hpbmcsXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IHB1Ymxpc2hBc3NldFNwYW4uZW5kKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGRlcGxveVN0YWNrID0gYXN5bmMgKHN0YWNrTm9kZTogU3RhY2tOb2RlKSA9PiB7XG4gICAgICBjb25zdCBzdGFjayA9IHN0YWNrTm9kZS5zdGFjaztcbiAgICAgIGlmIChzdGFja0NvbGxlY3Rpb24uc3RhY2tDb3VudCAhPT0gMSkge1xuICAgICAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy5pbmZvKGNoYWxrLmJvbGQoc3RhY2suZGlzcGxheU5hbWUpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzdGFjay5lbnZpcm9ubWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKFxuICAgICAgICAgIGBTdGFjayAke3N0YWNrLmRpc3BsYXlOYW1lfSBkb2VzIG5vdCBkZWZpbmUgYW4gZW52aXJvbm1lbnQsIGFuZCBBV1MgY3JlZGVudGlhbHMgY291bGQgbm90IGJlIG9idGFpbmVkIGZyb20gc3RhbmRhcmQgbG9jYXRpb25zIG9yIG5vIHJlZ2lvbiB3YXMgY29uZmlndXJlZC5gLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgZ2VuZXJhdGVkIHN0YWNrIGhhcyBubyByZXNvdXJjZXNcbiAgICAgIGlmIChPYmplY3Qua2V5cyhzdGFjay50ZW1wbGF0ZS5SZXNvdXJjZXMgfHwge30pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBzdGFjayBpcyBlbXB0eSBhbmQgZG9lc24ndCBleGlzdCA9PiBkbyBub3RoaW5nXG4gICAgICAgIGNvbnN0IHN0YWNrRXhpc3RzID0gYXdhaXQgZGVwbG95bWVudHMuc3RhY2tFeGlzdHMoeyBzdGFjayB9KTtcbiAgICAgICAgaWYgKCFzdGFja0V4aXN0cykge1xuICAgICAgICAgIHJldHVybiBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfVzUwMjEubXNnKGAke2NoYWxrLmJvbGQoc3RhY2suZGlzcGxheU5hbWUpfTogc3RhY2sgaGFzIG5vIHJlc291cmNlcywgc2tpcHBpbmcgZGVwbG95bWVudC5gKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdGFjayBpcyBlbXB0eSwgYnV0IGV4aXN0cyA9PiBkZWxldGVcbiAgICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX1c1MDIyLm1zZyhgJHtjaGFsay5ib2xkKHN0YWNrLmRpc3BsYXlOYW1lKX06IHN0YWNrIGhhcyBubyByZXNvdXJjZXMsIGRlbGV0aW5nIGV4aXN0aW5nIHN0YWNrLmApKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZGVzdHJveShhc3NlbWJseSwgJ2RlcGxveScsIHtcbiAgICAgICAgICBzdGFja3M6IHsgcGF0dGVybnM6IFtzdGFjay5oaWVyYXJjaGljYWxJZF0sIHN0cmF0ZWd5OiBTdGFja1NlbGVjdGlvblN0cmF0ZWd5LlBBVFRFUk5fTVVTVF9NQVRDSF9TSU5HTEUgfSxcbiAgICAgICAgICByb2xlQXJuOiBvcHRpb25zLnJvbGVBcm4sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY3VycmVudFRlbXBsYXRlID0gYXdhaXQgZGVwbG95bWVudHMucmVhZEN1cnJlbnRUZW1wbGF0ZShzdGFjayk7XG5cbiAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBEaWZmRm9ybWF0dGVyKHtcbiAgICAgICAgdGVtcGxhdGVJbmZvOiB7XG4gICAgICAgICAgb2xkVGVtcGxhdGU6IGN1cnJlbnRUZW1wbGF0ZSxcbiAgICAgICAgICBuZXdUZW1wbGF0ZTogc3RhY2ssXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc2VjdXJpdHlEaWZmID0gZm9ybWF0dGVyLmZvcm1hdFNlY3VyaXR5RGlmZigpO1xuXG4gICAgICAvLyBTZW5kIGEgcmVxdWVzdCByZXNwb25zZSB3aXRoIHRoZSBmb3JtYXR0ZWQgc2VjdXJpdHkgZGlmZiBhcyBwYXJ0IG9mIHRoZSBtZXNzYWdlLFxuICAgICAgLy8gYW5kIHRoZSB0ZW1wbGF0ZSBkaWZmIGFzIGRhdGFcbiAgICAgIC8vIChJb0hvc3QgZGVjaWRlcyB3aGV0aGVyIHRvIHByaW50IGRlcGVuZGluZyBvbiBwZXJtaXNzaW9uQ2hhbmdlVHlwZSlcbiAgICAgIGNvbnN0IGRlcGxveU1vdGl2YXRpb24gPSAnXCItLXJlcXVpcmUtYXBwcm92YWxcIiBpcyBlbmFibGVkIGFuZCBzdGFjayBpbmNsdWRlcyBzZWN1cml0eS1zZW5zaXRpdmUgdXBkYXRlcy4nO1xuICAgICAgY29uc3QgZGVwbG95UXVlc3Rpb24gPSBgJHtzZWN1cml0eURpZmYuZm9ybWF0dGVkRGlmZn1cXG5cXG4ke2RlcGxveU1vdGl2YXRpb259XFxuRG8geW91IHdpc2ggdG8gZGVwbG95IHRoZXNlIGNoYW5nZXNgO1xuICAgICAgY29uc3QgZGVwbG95Q29uZmlybWVkID0gYXdhaXQgaW9IZWxwZXIucmVxdWVzdFJlc3BvbnNlKElPLkNES19UT09MS0lUX0k1MDYwLnJlcShkZXBsb3lRdWVzdGlvbiwge1xuICAgICAgICBtb3RpdmF0aW9uOiBkZXBsb3lNb3RpdmF0aW9uLFxuICAgICAgICBjb25jdXJyZW5jeSxcbiAgICAgICAgcGVybWlzc2lvbkNoYW5nZVR5cGU6IHNlY3VyaXR5RGlmZi5wZXJtaXNzaW9uQ2hhbmdlVHlwZSxcbiAgICAgICAgdGVtcGxhdGVEaWZmczogZm9ybWF0dGVyLmRpZmZzLFxuICAgICAgfSkpO1xuICAgICAgaWYgKCFkZXBsb3lDb25maXJtZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignQWJvcnRlZCBieSB1c2VyJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZvbGxvd2luZyBhcmUgdGhlIHNhbWUgc2VtYW50aWNzIHdlIGFwcGx5IHdpdGggcmVzcGVjdCB0byBOb3RpZmljYXRpb24gQVJOcyAoZGljdGF0ZWQgYnkgdGhlIFNESylcbiAgICAgIC8vXG4gICAgICAvLyAgLSB1bmRlZmluZWQgID0+ICBjZGsgaWdub3JlcyBpdCwgYXMgaWYgaXQgd2Fzbid0IHN1cHBvcnRlZCAoYWxsb3dzIGV4dGVybmFsIG1hbmFnZW1lbnQpLlxuICAgICAgLy8gIC0gW106ICAgICAgICA9PiAgY2RrIG1hbmFnZXMgaXQsIGFuZCB0aGUgdXNlciB3YW50cyB0byB3aXBlIGl0IG91dC5cbiAgICAgIC8vICAtIFsnYXJuLTEnXSAgPT4gIGNkayBtYW5hZ2VzIGl0LCBhbmQgdGhlIHVzZXIgd2FudHMgdG8gc2V0IGl0IHRvIFsnYXJuLTEnXS5cbiAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbkFybnMgPSAoISFvcHRpb25zLm5vdGlmaWNhdGlvbkFybnMgfHwgISFzdGFjay5ub3RpZmljYXRpb25Bcm5zKVxuICAgICAgICA/IChvcHRpb25zLm5vdGlmaWNhdGlvbkFybnMgPz8gW10pLmNvbmNhdChzdGFjay5ub3RpZmljYXRpb25Bcm5zID8/IFtdKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgZm9yIChjb25zdCBub3RpZmljYXRpb25Bcm4gb2Ygbm90aWZpY2F0aW9uQXJucyA/PyBbXSkge1xuICAgICAgICBpZiAoIXZhbGlkYXRlU25zVG9waWNBcm4obm90aWZpY2F0aW9uQXJuKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYE5vdGlmaWNhdGlvbiBhcm4gJHtub3RpZmljYXRpb25Bcm59IGlzIG5vdCBhIHZhbGlkIGFybiBmb3IgYW4gU05TIHRvcGljYCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RhY2tJbmRleCA9IHN0YWNrcy5pbmRleE9mKHN0YWNrKSArIDE7XG4gICAgICBjb25zdCBkZXBsb3lTcGFuID0gYXdhaXQgaW9IZWxwZXIuc3BhbihTUEFOLkRFUExPWV9TVEFDSylcbiAgICAgICAgLmJlZ2luKGAke2NoYWxrLmJvbGQoc3RhY2suZGlzcGxheU5hbWUpfTogZGVwbG95aW5nLi4uIFske3N0YWNrSW5kZXh9LyR7c3RhY2tDb2xsZWN0aW9uLnN0YWNrQ291bnR9XWAsIHtcbiAgICAgICAgICB0b3RhbDogc3RhY2tDb2xsZWN0aW9uLnN0YWNrQ291bnQsXG4gICAgICAgICAgY3VycmVudDogc3RhY2tJbmRleCxcbiAgICAgICAgICBzdGFjayxcbiAgICAgICAgfSk7XG5cbiAgICAgIGxldCB0YWdzID0gb3B0aW9ucy50YWdzO1xuICAgICAgaWYgKCF0YWdzIHx8IHRhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRhZ3MgPSB0YWdzRm9yU3RhY2soc3RhY2spO1xuICAgICAgfVxuXG4gICAgICBsZXQgZGVwbG95RHVyYXRpb247XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgZGVwbG95UmVzdWx0OiBTdWNjZXNzZnVsRGVwbG95U3RhY2tSZXN1bHQgfCB1bmRlZmluZWQ7XG5cbiAgICAgICAgbGV0IHJvbGxiYWNrID0gb3B0aW9ucy5yb2xsYmFjaztcbiAgICAgICAgbGV0IGl0ZXJhdGlvbiA9IDA7XG4gICAgICAgIHdoaWxlICghZGVwbG95UmVzdWx0KSB7XG4gICAgICAgICAgaWYgKCsraXRlcmF0aW9uID4gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignVGhpcyBsb29wIHNob3VsZCBoYXZlIHN0YWJpbGl6ZWQgaW4gMiBpdGVyYXRpb25zLCBidXQgZGlkblxcJ3QuIElmIHlvdSBhcmUgc2VlaW5nIHRoaXMgZXJyb3IsIHBsZWFzZSByZXBvcnQgaXQgYXQgaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrL2lzc3Vlcy9uZXcvY2hvb3NlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgciA9IGF3YWl0IGRlcGxveW1lbnRzLmRlcGxveVN0YWNrKHtcbiAgICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgICAgZGVwbG95TmFtZTogc3RhY2suc3RhY2tOYW1lLFxuICAgICAgICAgICAgcm9sZUFybjogb3B0aW9ucy5yb2xlQXJuLFxuICAgICAgICAgICAgdG9vbGtpdFN0YWNrTmFtZTogdGhpcy50b29sa2l0U3RhY2tOYW1lLFxuICAgICAgICAgICAgcmV1c2VBc3NldHM6IG9wdGlvbnMucmV1c2VBc3NldHMsXG4gICAgICAgICAgICBub3RpZmljYXRpb25Bcm5zLFxuICAgICAgICAgICAgdGFncyxcbiAgICAgICAgICAgIGRlcGxveW1lbnRNZXRob2Q6IG9wdGlvbnMuZGVwbG95bWVudE1ldGhvZCxcbiAgICAgICAgICAgIGZvcmNlRGVwbG95bWVudDogb3B0aW9ucy5mb3JjZURlcGxveW1lbnQsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBPYmplY3QuYXNzaWduKHt9LCBwYXJhbWV0ZXJNYXBbJyonXSwgcGFyYW1ldGVyTWFwW3N0YWNrLnN0YWNrTmFtZV0pLFxuICAgICAgICAgICAgdXNlUHJldmlvdXNQYXJhbWV0ZXJzOiBvcHRpb25zLnBhcmFtZXRlcnM/LmtlZXBFeGlzdGluZ1BhcmFtZXRlcnMsXG4gICAgICAgICAgICByb2xsYmFjayxcbiAgICAgICAgICAgIGV4dHJhVXNlckFnZW50OiBvcHRpb25zLmV4dHJhVXNlckFnZW50LFxuICAgICAgICAgICAgYXNzZXRQYXJhbGxlbGlzbTogb3B0aW9ucy5hc3NldFBhcmFsbGVsaXNtLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgc3dpdGNoIChyLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RpZC1kZXBsb3ktc3RhY2snOlxuICAgICAgICAgICAgICBkZXBsb3lSZXN1bHQgPSByO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnZmFpbHBhdXNlZC1uZWVkLXJvbGxiYWNrLWZpcnN0Jzoge1xuICAgICAgICAgICAgICBjb25zdCBtb3RpdmF0aW9uID0gci5yZWFzb24gPT09ICdyZXBsYWNlbWVudCdcbiAgICAgICAgICAgICAgICA/IGBTdGFjayBpcyBpbiBhIHBhdXNlZCBmYWlsIHN0YXRlICgke3Iuc3RhdHVzfSkgYW5kIGNoYW5nZSBpbmNsdWRlcyBhIHJlcGxhY2VtZW50IHdoaWNoIGNhbm5vdCBiZSBkZXBsb3llZCB3aXRoIFwiLS1uby1yb2xsYmFja1wiYFxuICAgICAgICAgICAgICAgIDogYFN0YWNrIGlzIGluIGEgcGF1c2VkIGZhaWwgc3RhdGUgKCR7ci5zdGF0dXN9KSBhbmQgY29tbWFuZCBsaW5lIGFyZ3VtZW50cyBkbyBub3QgaW5jbHVkZSBcIi0tbm8tcm9sbGJhY2tcImA7XG4gICAgICAgICAgICAgIGNvbnN0IHF1ZXN0aW9uID0gYCR7bW90aXZhdGlvbn0uIFBlcmZvcm0gYSByZWd1bGFyIGRlcGxveW1lbnRgO1xuXG4gICAgICAgICAgICAgIGNvbnN0IGNvbmZpcm1lZCA9IGF3YWl0IGlvSGVscGVyLnJlcXVlc3RSZXNwb25zZShJTy5DREtfVE9PTEtJVF9JNTA1MC5yZXEocXVlc3Rpb24sIHtcbiAgICAgICAgICAgICAgICBtb3RpdmF0aW9uLFxuICAgICAgICAgICAgICAgIGNvbmN1cnJlbmN5LFxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIGlmICghY29uZmlybWVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignQWJvcnRlZCBieSB1c2VyJyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBQZXJmb3JtIGEgcm9sbGJhY2tcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcm9sbGJhY2soYXNzZW1ibHksIGFjdGlvbiwge1xuICAgICAgICAgICAgICAgIHN0YWNrczoge1xuICAgICAgICAgICAgICAgICAgcGF0dGVybnM6IFtzdGFjay5oaWVyYXJjaGljYWxJZF0sXG4gICAgICAgICAgICAgICAgICBzdHJhdGVneTogU3RhY2tTZWxlY3Rpb25TdHJhdGVneS5QQVRURVJOX01VU1RfTUFUQ0hfU0lOR0xFLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3JwaGFuRmFpbGVkUmVzb3VyY2VzOiBvcHRpb25zLm9ycGhhbkZhaWxlZFJlc291cmNlc0R1cmluZ1JvbGxiYWNrLFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAvLyBHbyBhcm91bmQgdGhyb3VnaCB0aGUgJ3doaWxlJyBsb29wIGFnYWluIGJ1dCBzd2l0Y2ggcm9sbGJhY2sgdG8gdHJ1ZS5cbiAgICAgICAgICAgICAgcm9sbGJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAncmVwbGFjZW1lbnQtcmVxdWlyZXMtcm9sbGJhY2snOiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1vdGl2YXRpb24gPSAnQ2hhbmdlIGluY2x1ZGVzIGEgcmVwbGFjZW1lbnQgd2hpY2ggY2Fubm90IGJlIGRlcGxveWVkIHdpdGggXCItLW5vLXJvbGxiYWNrXCInO1xuICAgICAgICAgICAgICBjb25zdCBxdWVzdGlvbiA9IGAke21vdGl2YXRpb259LiBQZXJmb3JtIGEgcmVndWxhciBkZXBsb3ltZW50YDtcblxuICAgICAgICAgICAgICBjb25zdCBjb25maXJtZWQgPSBhd2FpdCBpb0hlbHBlci5yZXF1ZXN0UmVzcG9uc2UoSU8uQ0RLX1RPT0xLSVRfSTUwNTAucmVxKHF1ZXN0aW9uLCB7XG4gICAgICAgICAgICAgICAgbW90aXZhdGlvbixcbiAgICAgICAgICAgICAgICBjb25jdXJyZW5jeSxcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICBpZiAoIWNvbmZpcm1lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ0Fib3J0ZWQgYnkgdXNlcicpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gR28gYXJvdW5kIHRocm91Z2ggdGhlICd3aGlsZScgbG9vcCBhZ2FpbiBidXQgc3dpdGNoIHJvbGxiYWNrIHRvIHRydWUuXG4gICAgICAgICAgICAgIHJvbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYFVuZXhwZWN0ZWQgcmVzdWx0IHR5cGUgZnJvbSBkZXBsb3lTdGFjazogJHtKU09OLnN0cmluZ2lmeShyKX0uIElmIHlvdSBhcmUgc2VlaW5nIHRoaXMgZXJyb3IsIHBsZWFzZSByZXBvcnQgaXQgYXQgaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrL2lzc3Vlcy9uZXcvY2hvb3NlYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGRlcGxveVJlc3VsdC5ub09wXG4gICAgICAgICAgPyBgIOKchSAgJHtzdGFjay5kaXNwbGF5TmFtZX0gKG5vIGNoYW5nZXMpYFxuICAgICAgICAgIDogYCDinIUgICR7c3RhY2suZGlzcGxheU5hbWV9YDtcblxuICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTU5MDAubXNnKGNoYWxrLmdyZWVuKCdcXG4nICsgbWVzc2FnZSksIGRlcGxveVJlc3VsdCkpO1xuICAgICAgICBkZXBsb3lEdXJhdGlvbiA9IGF3YWl0IGRlcGxveVNwYW4udGltaW5nKElPLkNES19UT09MS0lUX0k1MDAwKTtcblxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGVwbG95UmVzdWx0Lm91dHB1dHMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBidWZmZXIgPSBbJ091dHB1dHM6J107XG4gICAgICAgICAgc3RhY2tPdXRwdXRzW3N0YWNrLnN0YWNrTmFtZV0gPSBkZXBsb3lSZXN1bHQub3V0cHV0cztcblxuICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhkZXBsb3lSZXN1bHQub3V0cHV0cykuc29ydCgpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRlcGxveVJlc3VsdC5vdXRwdXRzW25hbWVdO1xuICAgICAgICAgICAgYnVmZmVyLnB1c2goYCR7Y2hhbGsuY3lhbihzdGFjay5pZCl9LiR7Y2hhbGsuY3lhbihuYW1lKX0gPSAke2NoYWxrLnVuZGVybGluZShjaGFsay5jeWFuKHZhbHVlKSl9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9JNTkwMS5tc2coYnVmZmVyLmpvaW4oJ1xcbicpKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0k1OTAxLm1zZyhgU3RhY2sgQVJOOlxcbiR7ZGVwbG95UmVzdWx0LnN0YWNrQXJufWApKTtcblxuICAgICAgICByZXQuc3RhY2tzLnB1c2goe1xuICAgICAgICAgIHN0YWNrTmFtZTogc3RhY2suc3RhY2tOYW1lLFxuICAgICAgICAgIGVudmlyb25tZW50OiB7XG4gICAgICAgICAgICBhY2NvdW50OiBzdGFjay5lbnZpcm9ubWVudC5hY2NvdW50LFxuICAgICAgICAgICAgcmVnaW9uOiBzdGFjay5lbnZpcm9ubWVudC5yZWdpb24sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdGFja0FybjogZGVwbG95UmVzdWx0LnN0YWNrQXJuLFxuICAgICAgICAgIG91dHB1dHM6IGRlcGxveVJlc3VsdC5vdXRwdXRzLFxuICAgICAgICAgIGhpZXJhcmNoaWNhbElkOiBzdGFjay5oaWVyYXJjaGljYWxJZCxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgLy8gSXQgaGFzIHRvIGJlIGV4YWN0bHkgdGhpcyBzdHJpbmcgYmVjYXVzZSBhbiBpbnRlZ3JhdGlvbiB0ZXN0IHRlc3RzIGZvclxuICAgICAgICAvLyBcImJvbGQoc3RhY2tuYW1lKSBmYWlsZWQ6IFJlc291cmNlTm90UmVhZHk6IDxlcnJvcj5cIlxuICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKFxuICAgICAgICAgIFtg4p2MICAke2NoYWxrLmJvbGQoc3RhY2suc3RhY2tOYW1lKX0gZmFpbGVkOmAsIC4uLihlLm5hbWUgPyBbYCR7ZS5uYW1lfTpgXSA6IFtdKSwgZS5tZXNzYWdlXS5qb2luKCcgJyksXG4gICAgICAgICk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAob3B0aW9ucy50cmFjZUxvZ3MpIHtcbiAgICAgICAgICAvLyBkZXBsb3kgY2FsbHMgdGhhdCBvcmlnaW5hdGUgZnJvbSB3YXRjaCB3aWxsIGNvbWUgd2l0aCB0aGVpciBvd24gY2xvdWRXYXRjaExvZ01vbml0b3JcbiAgICAgICAgICBjb25zdCBjbG91ZFdhdGNoTG9nTW9uaXRvciA9IG9wdGlvbnMuY2xvdWRXYXRjaExvZ01vbml0b3IgPz8gbmV3IENsb3VkV2F0Y2hMb2dFdmVudE1vbml0b3IoeyBpb0hlbHBlciB9KTtcbiAgICAgICAgICBjb25zdCBmb3VuZExvZ0dyb3Vwc1Jlc3VsdCA9IGF3YWl0IGZpbmRDbG91ZFdhdGNoTG9nR3JvdXBzKGF3YWl0IHRoaXMuc2RrUHJvdmlkZXIoJ2RlcGxveScpLCBpb0hlbHBlciwgc3RhY2spO1xuICAgICAgICAgIGNsb3VkV2F0Y2hMb2dNb25pdG9yLmFkZExvZ0dyb3VwcyhcbiAgICAgICAgICAgIGZvdW5kTG9nR3JvdXBzUmVzdWx0LmVudixcbiAgICAgICAgICAgIGZvdW5kTG9nR3JvdXBzUmVzdWx0LnNkayxcbiAgICAgICAgICAgIGZvdW5kTG9nR3JvdXBzUmVzdWx0LmxvZ0dyb3VwTmFtZXMsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTUwMzEubXNnKGBUaGUgZm9sbG93aW5nIGxvZyBncm91cHMgYXJlIGFkZGVkOiAke2ZvdW5kTG9nR3JvdXBzUmVzdWx0LmxvZ0dyb3VwTmFtZXN9YCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYW4gb3V0cHV0cyBmaWxlIGhhcyBiZWVuIHNwZWNpZmllZCwgY3JlYXRlIHRoZSBmaWxlIHBhdGggYW5kIHdyaXRlIHN0YWNrIG91dHB1dHMgdG8gaXQgb25jZS5cbiAgICAgICAgLy8gT3V0cHV0cyBhcmUgd3JpdHRlbiBhZnRlciBhbGwgc3RhY2tzIGhhdmUgYmVlbiBkZXBsb3llZC4gSWYgYSBzdGFjayBkZXBsb3ltZW50IGZhaWxzLFxuICAgICAgICAvLyBhbGwgb2YgdGhlIG91dHB1dHMgZnJvbSBzdWNjZXNzZnVsbHkgZGVwbG95ZWQgc3RhY2tzIGJlZm9yZSB0aGUgZmFpbHVyZSB3aWxsIHN0aWxsIGJlIHdyaXR0ZW4uXG4gICAgICAgIGlmIChvdXRwdXRzRmlsZSkge1xuICAgICAgICAgIGZzLmVuc3VyZUZpbGVTeW5jKG91dHB1dHNGaWxlKTtcbiAgICAgICAgICBhd2FpdCBmcy53cml0ZUpzb24ob3V0cHV0c0ZpbGUsIHN0YWNrT3V0cHV0cywge1xuICAgICAgICAgICAgc3BhY2VzOiAyLFxuICAgICAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgZHVyYXRpb24gPSBzeW50aER1cmF0aW9uLmFzTXMgKyAoZGVwbG95RHVyYXRpb24/LmFzTXMgPz8gMCk7XG4gICAgICBhd2FpdCBkZXBsb3lTcGFuLmVuZChgXFxu4pyoICBUb3RhbCB0aW1lOiAke2Zvcm1hdFRpbWUoZHVyYXRpb24pfXNcXG5gLCB7IGR1cmF0aW9uIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBhc3NldEJ1aWxkVGltZSA9IG9wdGlvbnMuYXNzZXRCdWlsZFRpbWUgPz8gQXNzZXRCdWlsZFRpbWUuQUxMX0JFRk9SRV9ERVBMT1k7XG4gICAgY29uc3QgcHJlYnVpbGRBc3NldHMgPSBhc3NldEJ1aWxkVGltZSA9PT0gQXNzZXRCdWlsZFRpbWUuQUxMX0JFRk9SRV9ERVBMT1k7XG4gICAgY29uc3QgY29uY3VycmVuY3kgPSBvcHRpb25zLmNvbmN1cnJlbmN5IHx8IDE7XG5cbiAgICBjb25zdCBzdGFja3NBbmRUaGVpckFzc2V0TWFuaWZlc3RzID0gc3RhY2tzLmZsYXRNYXAoKHN0YWNrKSA9PiBbXG4gICAgICBzdGFjayxcbiAgICAgIC4uLnN0YWNrLmRlcGVuZGVuY2llcy5maWx0ZXIoeCA9PiBjeGFwaS5Bc3NldE1hbmlmZXN0QXJ0aWZhY3QuaXNBc3NldE1hbmlmZXN0QXJ0aWZhY3QoeCkpLFxuICAgIF0pO1xuICAgIGNvbnN0IHdvcmtHcmFwaCA9IG5ldyBXb3JrR3JhcGhCdWlsZGVyKGlvSGVscGVyLCBwcmVidWlsZEFzc2V0cykuYnVpbGQoc3RhY2tzQW5kVGhlaXJBc3NldE1hbmlmZXN0cyk7XG5cbiAgICAvLyBVbmxlc3Mgd2UgYXJlIHJ1bm5pbmcgd2l0aCAnLS1mb3JjZScsIHNraXAgYWxyZWFkeSBwdWJsaXNoZWQgYXNzZXRzXG4gICAgaWYgKCFvcHRpb25zLmZvcmNlQXNzZXRQdWJsaXNoaW5nKSB7XG4gICAgICBhd2FpdCByZW1vdmVQdWJsaXNoZWRBc3NldHNGcm9tV29ya0dyYXBoKHdvcmtHcmFwaCwgZGVwbG95bWVudHMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGNvbnN0IGdyYXBoQ29uY3VycmVuY3k6IENvbmN1cnJlbmN5ID0ge1xuICAgICAgJ3N0YWNrJzogY29uY3VycmVuY3ksXG4gICAgICAnYXNzZXQtYnVpbGQnOiAxLCAvLyBUaGlzIHdpbGwgYmUgQ1BVLWJvdW5kL21lbW9yeSBib3VuZCwgbW9zdGx5IG1hdHRlcnMgZm9yIERvY2tlciBidWlsZHNcbiAgICAgICdhc3NldC1wdWJsaXNoJzogKG9wdGlvbnMuYXNzZXRQYXJhbGxlbGlzbSA/PyB0cnVlKSA/IDggOiAxLCAvLyBUaGlzIHdpbGwgYmUgSS9PLWJvdW5kLCA4IGluIHBhcmFsbGVsIHNlZW1zIHJlYXNvbmFibGVcbiAgICB9O1xuXG4gICAgYXdhaXQgd29ya0dyYXBoLmRvUGFyYWxsZWwoZ3JhcGhDb25jdXJyZW5jeSwge1xuICAgICAgZGVwbG95U3RhY2ssXG4gICAgICBidWlsZEFzc2V0LFxuICAgICAgcHVibGlzaEFzc2V0LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXYXRjaCBBY3Rpb25cbiAgICpcbiAgICogQ29udGludW91c2x5IG9ic2VydmUgcHJvamVjdCBmaWxlcyBhbmQgZGVwbG95IHRoZSBzZWxlY3RlZCBzdGFja3NcbiAgICogYXV0b21hdGljYWxseSB3aGVuIGNoYW5nZXMgYXJlIGRldGVjdGVkLiBEZWZhdWx0cyB0byBob3Rzd2FwIGRlcGxveW1lbnRzLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgaW1tZWRpYXRlbHksIHN0YXJ0aW5nIGEgd2F0Y2hlciBpbiB0aGUgYmFja2dyb3VuZC5cbiAgICovXG4gIHB1YmxpYyBhc3luYyB3YXRjaChjeDogSUNsb3VkQXNzZW1ibHlTb3VyY2UsIG9wdGlvbnM6IFdhdGNoT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxJV2F0Y2hlcj4ge1xuICAgIGNvbnN0IGlvSGVscGVyID0gYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgJ3dhdGNoJyk7XG4gICAgYXdhaXQgdXNpbmcgYXNzZW1ibHkgPSBhd2FpdCBhc3NlbWJseUZyb21Tb3VyY2UoaW9IZWxwZXIsIGN4LCBmYWxzZSk7XG4gICAgY29uc3Qgcm9vdERpciA9IG9wdGlvbnMud2F0Y2hEaXIgPz8gcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIEZvciB0aGUgXCJpbmNsdWRlXCIgc2V0dGluZywgdGhlIGJlaGF2aW9yIGlzOlxuICAgIC8vIDEuIFwid2F0Y2hcIiBzZXR0aW5nIHdpdGhvdXQgYW4gXCJpbmNsdWRlXCIga2V5PyBXZSBkZWZhdWx0IHRvIG9ic2VydmluZyBcIioqXCIuXG4gICAgLy8gMi4gXCJ3YXRjaFwiIHNldHRpbmcgd2l0aCBhbiBlbXB0eSBcImluY2x1ZGVcIiBrZXk/IFdlIGRlZmF1bHQgdG8gb2JzZXJ2aW5nIFwiKipcIi5cbiAgICAvLyAzLiBOb24tZW1wdHkgXCJpbmNsdWRlXCIga2V5PyBKdXN0IHVzZSB0aGUgXCJpbmNsdWRlXCIga2V5LlxuICAgIGNvbnN0IHdhdGNoSW5jbHVkZXMgPSBvcHRpb25zLmluY2x1ZGUgPz8gW107XG4gICAgaWYgKHdhdGNoSW5jbHVkZXMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHdhdGNoSW5jbHVkZXMucHVzaCgnKionKTtcbiAgICB9XG5cbiAgICAvLyBGb3IgdGhlIFwiZXhjbHVkZVwiIHNldHRpbmcsIHRoZSBiZWhhdmlvciBpcyB0byBhZGQgc29tZSBkZWZhdWx0IGV4Y2x1ZGVzIGluIGFkZGl0aW9uIHRvXG4gICAgLy8gcGF0dGVybnMgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyIHNlbnNpYmxlIGRlZmF1bHQgcGF0dGVybnM6XG4gICAgY29uc3Qgd2F0Y2hFeGNsdWRlcyA9IG9wdGlvbnMuZXhjbHVkZSA/PyBbLi4uV0FUQ0hfRVhDTFVERV9ERUZBVUxUU107XG4gICAgLy8gMS4gVGhlIENESyBvdXRwdXQgZGlyZWN0b3J5LCBpZiBpdCBpcyB1bmRlciB0aGUgcm9vdERpclxuICAgIGNvbnN0IHJlbGF0aXZlT3V0RGlyID0gcGF0aC5yZWxhdGl2ZShyb290RGlyLCBhc3NlbWJseS5kaXJlY3RvcnkpO1xuICAgIGlmIChCb29sZWFuKHJlbGF0aXZlT3V0RGlyICYmICFyZWxhdGl2ZU91dERpci5zdGFydHNXaXRoKCcuLicgKyBwYXRoLnNlcCkgJiYgIXBhdGguaXNBYnNvbHV0ZShyZWxhdGl2ZU91dERpcikpKSB7XG4gICAgICB3YXRjaEV4Y2x1ZGVzLnB1c2goYCR7cmVsYXRpdmVPdXREaXJ9LyoqYCk7XG4gICAgfVxuICAgIC8vIDIuIEFueSBmaWxlIHdob3NlIG5hbWUgc3RhcnRzIHdpdGggYSBkb3QuXG4gICAgd2F0Y2hFeGNsdWRlcy5wdXNoKCcuKicsICcqKi8uKicpO1xuICAgIC8vIDMuIEFueSBkaXJlY3RvcnkncyBjb250ZW50IHdob3NlIG5hbWUgc3RhcnRzIHdpdGggYSBkb3QuXG4gICAgd2F0Y2hFeGNsdWRlcy5wdXNoKCcqKi8uKi8qKicpO1xuICAgIC8vIDQuIEFueSBub2RlX21vZHVsZXMgYW5kIGl0cyBjb250ZW50IChldmVuIGlmIGl0J3Mgbm90IGEgSlMvVFMgcHJvamVjdCwgeW91IG1pZ2h0IGJlIHVzaW5nIGEgbG9jYWwgYXdzLWNsaSBwYWNrYWdlKVxuICAgIHdhdGNoRXhjbHVkZXMucHVzaCgnKiovbm9kZV9tb2R1bGVzLyoqJyk7XG5cbiAgICAvLyBQcmludCBzb21lIGRlYnVnIGluZm9ybWF0aW9uIG9uIGNvbXB1dGVkIHNldHRpbmdzXG4gICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0k1MzEwLm1zZyhbXG4gICAgICBgcm9vdCBkaXJlY3RvcnkgdXNlZCBmb3IgJ3dhdGNoJyBpczogJHtyb290RGlyfWAsXG4gICAgICBgJ2luY2x1ZGUnIHBhdHRlcm5zIGZvciAnd2F0Y2gnOiAke0pTT04uc3RyaW5naWZ5KHdhdGNoSW5jbHVkZXMpfWAsXG4gICAgICBgJ2V4Y2x1ZGUnIHBhdHRlcm5zIGZvciAnd2F0Y2gnOiAke0pTT04uc3RyaW5naWZ5KHdhdGNoRXhjbHVkZXMpfWAsXG4gICAgXS5qb2luKCdcXG4nKSwge1xuICAgICAgd2F0Y2hEaXI6IHJvb3REaXIsXG4gICAgICBpbmNsdWRlczogd2F0Y2hJbmNsdWRlcyxcbiAgICAgIGV4Y2x1ZGVzOiB3YXRjaEV4Y2x1ZGVzLFxuICAgIH0pKTtcblxuICAgIC8vIFNpbmNlICdjZGsgZGVwbG95JyBpcyBhIHJlbGF0aXZlbHkgc2xvdyBvcGVyYXRpb24gZm9yIGEgJ3dhdGNoJyBwcm9jZXNzLFxuICAgIC8vIGludHJvZHVjZSBhIGNvbmN1cnJlbmN5IGxhdGNoIHRoYXQgdHJhY2tzIHRoZSBzdGF0ZS5cbiAgICAvLyBUaGlzIHdheSwgaWYgZmlsZSBjaGFuZ2UgZXZlbnRzIGFycml2ZSB3aGVuIGEgJ2NkayBkZXBsb3knIGlzIHN0aWxsIGV4ZWN1dGluZyxcbiAgICAvLyB3ZSB3aWxsIGJhdGNoIHRoZW0sIGFuZCB0cmlnZ2VyIGFub3RoZXIgJ2NkayBkZXBsb3knIGFmdGVyIHRoZSBjdXJyZW50IG9uZSBmaW5pc2hlcyxcbiAgICAvLyBtYWtpbmcgc3VyZSAnY2RrIGRlcGxveSdzICBhbHdheXMgZXhlY3V0ZSBvbmUgYXQgYSB0aW1lLlxuICAgIC8vIEhlcmUncyBhIGRpYWdyYW0gc2hvd2luZyB0aGUgc3RhdGUgdHJhbnNpdGlvbnM6XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0gICAgICAgICAgICAgICAgLS0tLS0tLS0gICAgZmlsZSBjaGFuZ2VkICAgICAtLS0tLS0tLS0tLS0tLSAgICBmaWxlIGNoYW5nZWQgICAgIC0tLS0tLS0tLS0tLS0tICBmaWxlIGNoYW5nZWRcbiAgICAvLyB8ICAgICAgICAgICAgfCAgcmVhZHkgZXZlbnQgICB8ICAgICAgfCAtLS0tLS0tLS0tLS0tLS0tLS0+IHwgICAgICAgICAgICB8IC0tLS0tLS0tLS0tLS0tLS0tLT4gfCAgICAgICAgICAgIHwgLS0tLS0tLS0tLS0tLS18XG4gICAgLy8gfCBwcmUtcmVhZHkgIHwgLS0tLS0tLS0tLS0tLT4gfCBvcGVuIHwgICAgICAgICAgICAgICAgICAgICB8IGRlcGxveWluZyAgfCAgICAgICAgICAgICAgICAgICAgIHwgICBxdWV1ZWQgICB8ICAgICAgICAgICAgICAgfFxuICAgIC8vIHwgICAgICAgICAgICB8ICAgICAgICAgICAgICAgIHwgICAgICB8IDwtLS0tLS0tLS0tLS0tLS0tLS0gfCAgICAgICAgICAgIHwgPC0tLS0tLS0tLS0tLS0tLS0tLSB8ICAgICAgICAgICAgfCA8LS0tLS0tLS0tLS0tLXxcbiAgICAvLyAtLS0tLS0tLS0tLS0tLSAgICAgICAgICAgICAgICAtLS0tLS0tLSAgJ2NkayBkZXBsb3knIGRvbmUgIC0tLS0tLS0tLS0tLS0tICAnY2RrIGRlcGxveScgZG9uZSAgLS0tLS0tLS0tLS0tLS1cbiAgICB0eXBlIExhdGNoU3RhdGUgPSAncHJlLXJlYWR5JyB8ICdvcGVuJyB8ICdkZXBsb3lpbmcnIHwgJ3F1ZXVlZCc7XG4gICAgbGV0IGxhdGNoOiBMYXRjaFN0YXRlID0gJ3ByZS1yZWFkeSc7XG5cbiAgICBjb25zdCBjbG91ZFdhdGNoTG9nTW9uaXRvciA9IG9wdGlvbnMudHJhY2VMb2dzID8gbmV3IENsb3VkV2F0Y2hMb2dFdmVudE1vbml0b3IoeyBpb0hlbHBlciB9KSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBkZXBsb3lBbmRXYXRjaCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGxhdGNoID0gJ2RlcGxveWluZycgYXMgTGF0Y2hTdGF0ZTtcbiAgICAgIGF3YWl0IGNsb3VkV2F0Y2hMb2dNb25pdG9yPy5kZWFjdGl2YXRlKCk7XG5cbiAgICAgIGF3YWl0IHRoaXMuaW52b2tlRGVwbG95RnJvbVdhdGNoKGFzc2VtYmx5LCBvcHRpb25zLCBjbG91ZFdhdGNoTG9nTW9uaXRvcik7XG5cbiAgICAgIC8vIElmIGxhdGNoIGlzIHN0aWxsICdkZXBsb3lpbmcnIGFmdGVyIHRoZSAnYXdhaXQnLCB0aGF0J3MgZmluZSxcbiAgICAgIC8vIGJ1dCBpZiBpdCdzICdxdWV1ZWQnLCB0aGF0IG1lYW5zIHdlIG5lZWQgdG8gZGVwbG95IGFnYWluXG4gICAgICB3aGlsZSAobGF0Y2ggPT09ICdxdWV1ZWQnKSB7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgZG9lc24ndCByZWFsaXplIGxhdGNoIGNhbiBjaGFuZ2UgYmV0d2VlbiAnYXdhaXRzJyxcbiAgICAgICAgLy8gYW5kIHRoaW5rcyB0aGUgYWJvdmUgJ3doaWxlJyBjb25kaXRpb24gaXMgYWx3YXlzICdmYWxzZScgd2l0aG91dCB0aGUgY2FzdFxuICAgICAgICBsYXRjaCA9ICdkZXBsb3lpbmcnO1xuICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTUzMTUubXNnKFwiRGV0ZWN0ZWQgZmlsZSBjaGFuZ2VzIGR1cmluZyBkZXBsb3ltZW50LiBJbnZva2luZyAnY2RrIGRlcGxveScgYWdhaW5cIikpO1xuICAgICAgICBhd2FpdCB0aGlzLmludm9rZURlcGxveUZyb21XYXRjaChhc3NlbWJseSwgb3B0aW9ucywgY2xvdWRXYXRjaExvZ01vbml0b3IpO1xuICAgICAgfVxuICAgICAgbGF0Y2ggPSAnb3Blbic7XG4gICAgICBhd2FpdCBjbG91ZFdhdGNoTG9nTW9uaXRvcj8uYWN0aXZhdGUoKTtcbiAgICB9O1xuXG4gICAgY29uc3Qgd2F0Y2hlciA9IGNob2tpZGFyXG4gICAgICAud2F0Y2god2F0Y2hJbmNsdWRlcywge1xuICAgICAgICBpZ25vcmVkOiB3YXRjaEV4Y2x1ZGVzLFxuICAgICAgICBjd2Q6IHJvb3REaXIsXG4gICAgICB9KVxuICAgICAgLm9uKCdyZWFkeScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbGF0Y2ggPSAnb3Blbic7XG4gICAgICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLmRlYnVnKFwiJ3dhdGNoJyByZWNlaXZlZCB0aGUgJ3JlYWR5JyBldmVudC4gRnJvbSBub3cgb24sIGFsbCBmaWxlIGNoYW5nZXMgd2lsbCB0cmlnZ2VyIGEgZGVwbG95bWVudFwiKTtcbiAgICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0k1MzE0Lm1zZyhcIlRyaWdnZXJpbmcgaW5pdGlhbCAnY2RrIGRlcGxveSdcIikpO1xuICAgICAgICBhd2FpdCBkZXBsb3lBbmRXYXRjaCgpO1xuICAgICAgfSlcbiAgICAgIC5vbignYWxsJywgYXN5bmMgKGV2ZW50OiAnYWRkJyB8ICdhZGREaXInIHwgJ2NoYW5nZScgfCAndW5saW5rJyB8ICd1bmxpbmtEaXInLCBmaWxlUGF0aDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHdhdGNoRXZlbnQgPSB7XG4gICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgcGF0aDogZmlsZVBhdGgsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChsYXRjaCA9PT0gJ3ByZS1yZWFkeScpIHtcbiAgICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTUzMTEubXNnKGAnd2F0Y2gnIGlzIG9ic2VydmluZyAke2V2ZW50ID09PSAnYWRkRGlyJyA/ICdkaXJlY3RvcnknIDogJ3RoZSBmaWxlJ30gJyR7ZmlsZVBhdGh9JyBmb3IgY2hhbmdlc2AsIHdhdGNoRXZlbnQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXRjaCA9PT0gJ29wZW4nKSB7XG4gICAgICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0k1MzEyLm1zZyhgRGV0ZWN0ZWQgY2hhbmdlIHRvICcke2ZpbGVQYXRofScgKHR5cGU6ICR7ZXZlbnR9KS4gVHJpZ2dlcmluZyAnY2RrIGRlcGxveSdgLCB3YXRjaEV2ZW50KSk7XG4gICAgICAgICAgYXdhaXQgZGVwbG95QW5kV2F0Y2goKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0aGlzIG1lYW5zIGxhdGNoIGlzIGVpdGhlciAnZGVwbG95aW5nJyBvciAncXVldWVkJ1xuICAgICAgICAgIGxhdGNoID0gJ3F1ZXVlZCc7XG4gICAgICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0k1MzEzLm1zZyhcbiAgICAgICAgICAgIGBEZXRlY3RlZCBjaGFuZ2UgdG8gJyR7ZmlsZVBhdGh9JyAodHlwZTogJHtldmVudH0pIHdoaWxlICdjZGsgZGVwbG95JyBpcyBzdGlsbCBydW5uaW5nLiBXaWxsIHF1ZXVlIGZvciBhbm90aGVyIGRlcGxveW1lbnQgYWZ0ZXIgdGhpcyBvbmUgZmluaXNoZXMnYCxcbiAgICAgICAgICAgIHdhdGNoRXZlbnQsXG4gICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgY29uc3Qgc3RvcHBlZFByb21pc2UgPSBwcm9taXNlV2l0aFJlc29sdmVyczx2b2lkPigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFzeW5jIGRpc3Bvc2UoKSB7XG4gICAgICAgIC8vIHN0b3AgdGhlIGxvZ3MgbW9uaXRvciwgaWYgaXQgZXhpc3RzXG4gICAgICAgIGF3YWl0IGNsb3VkV2F0Y2hMb2dNb25pdG9yPy5kZWFjdGl2YXRlKCk7XG4gICAgICAgIC8vIGNsb3NlIHRoZSB3YXRjaGVyIGl0c2VsZlxuICAgICAgICBhd2FpdCB3YXRjaGVyLmNsb3NlKCk7XG4gICAgICAgIC8vIFByZXZlbnRzIE5vZGUgZnJvbSBzdGF5aW5nIGFsaXZlLiBUaGVyZSBpcyBubyAnZW5kJyBldmVudCB0aGF0IHRoZSB3YXRjaGVyIGVtaXRzXG4gICAgICAgIC8vIHRoYXQgd2UgY2FuIGtub3cgaXQncyBkZWZpbml0ZWx5IGRvbmUsIHNvIGJlc3Qgd2UgY2FuIGRvIGlzIHRlbGwgaXQgdG8gc3RvcCB3YXRjaGluZyxcbiAgICAgICAgLy8gc3RvcCBrZWVwaW5nIE5vZGUgYWxpdmUsIGFuZCB0aGVuIHByZXRlbmQgdGhhdCdzIGV2ZXJ5dGhpbmcgd2UgbmVlZGVkIHRvIGRvLlxuICAgICAgICB3YXRjaGVyLnVucmVmKCk7XG4gICAgICAgIHN0b3BwZWRQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgcmV0dXJuIHN0b3BwZWRQcm9taXNlLnByb21pc2U7XG4gICAgICB9LFxuICAgICAgYXN5bmMgd2FpdEZvckVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHN0b3BwZWRQcm9taXNlLnByb21pc2U7XG4gICAgICB9LFxuICAgICAgYXN5bmMgW1N5bWJvbC5hc3luY0Rpc3Bvc2VdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNwb3NlKCk7XG4gICAgICB9LFxuICAgIH0gc2F0aXNmaWVzIElXYXRjaGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJvbGxiYWNrIEFjdGlvblxuICAgKlxuICAgKiBSb2xscyBiYWNrIHRoZSBzZWxlY3RlZCBzdGFja3MuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcm9sbGJhY2soY3g6IElDbG91ZEFzc2VtYmx5U291cmNlLCBvcHRpb25zOiBSb2xsYmFja09wdGlvbnMgPSB7fSk6IFByb21pc2U8Um9sbGJhY2tSZXN1bHQ+IHtcbiAgICBjb25zdCBpb0hlbHBlciA9IGFzSW9IZWxwZXIodGhpcy5pb0hvc3QsICdyb2xsYmFjaycpO1xuICAgIGF3YWl0IHVzaW5nIGFzc2VtYmx5ID0gYXdhaXQgYXNzZW1ibHlGcm9tU291cmNlKGlvSGVscGVyLCBjeCk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3JvbGxiYWNrKGFzc2VtYmx5LCAncm9sbGJhY2snLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gYWxsb3cgcm9sbGJhY2sgYmVpbmcgY2FsbGVkIGFzIHBhcnQgb2YgdGhlIGRlcGxveSBvciB3YXRjaCBhY3Rpb24uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9yb2xsYmFjayhhc3NlbWJseTogU3RhY2tBc3NlbWJseSwgYWN0aW9uOiAncm9sbGJhY2snIHwgJ2RlcGxveScgfCAnd2F0Y2gnLCBvcHRpb25zOiBSb2xsYmFja09wdGlvbnMpOiBQcm9taXNlPFJvbGxiYWNrUmVzdWx0PiB7XG4gICAgY29uc3Qgc2VsZWN0U3RhY2tzID0gb3B0aW9ucy5zdGFja3MgPz8gQUxMX1NUQUNLUztcbiAgICBjb25zdCBpb0hlbHBlciA9IGFzSW9IZWxwZXIodGhpcy5pb0hvc3QsIGFjdGlvbik7XG4gICAgY29uc3Qgc3ludGhTcGFuID0gYXdhaXQgaW9IZWxwZXIuc3BhbihTUEFOLlNZTlRIX0FTU0VNQkxZKS5iZWdpbih7IHN0YWNrczogc2VsZWN0U3RhY2tzIH0pO1xuICAgIGNvbnN0IHN0YWNrcyA9IGF3YWl0IGFzc2VtYmx5LnNlbGVjdFN0YWNrc1YyKHNlbGVjdFN0YWNrcyk7XG4gICAgYXdhaXQgdGhpcy52YWxpZGF0ZVN0YWNrc01ldGFkYXRhKHN0YWNrcywgaW9IZWxwZXIpO1xuICAgIGF3YWl0IHN5bnRoU3Bhbi5lbmQoKTtcblxuICAgIGNvbnN0IHJldDogUm9sbGJhY2tSZXN1bHQgPSB7XG4gICAgICBzdGFja3M6IFtdLFxuICAgIH07XG5cbiAgICBpZiAoc3RhY2tzLnN0YWNrQ291bnQgPT09IDApIHtcbiAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9FNjAwMS5tc2coJ05vIHN0YWNrcyBzZWxlY3RlZCcpKTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgbGV0IGFueVJvbGxiYWNrYWJsZSA9IGZhbHNlO1xuXG4gICAgZm9yIChjb25zdCBbaW5kZXgsIHN0YWNrXSBvZiBzdGFja3Muc3RhY2tBcnRpZmFjdHMuZW50cmllcygpKSB7XG4gICAgICBjb25zdCByb2xsYmFja1NwYW4gPSBhd2FpdCBpb0hlbHBlci5zcGFuKFNQQU4uUk9MTEJBQ0tfU1RBQ0spLmJlZ2luKGBSb2xsaW5nIGJhY2sgJHtjaGFsay5ib2xkKHN0YWNrLmRpc3BsYXlOYW1lKX1gLCB7XG4gICAgICAgIHRvdGFsOiBzdGFja3Muc3RhY2tDb3VudCxcbiAgICAgICAgY3VycmVudDogaW5kZXggKyAxLFxuICAgICAgICBzdGFjayxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZGVwbG95bWVudHMgPSBhd2FpdCB0aGlzLmRlcGxveW1lbnRzRm9yQWN0aW9uKCdyb2xsYmFjaycpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RhY2tSZXN1bHQgPSBhd2FpdCBkZXBsb3ltZW50cy5yb2xsYmFja1N0YWNrKHtcbiAgICAgICAgICBzdGFjayxcbiAgICAgICAgICByb2xlQXJuOiBvcHRpb25zLnJvbGVBcm4sXG4gICAgICAgICAgdG9vbGtpdFN0YWNrTmFtZTogdGhpcy50b29sa2l0U3RhY2tOYW1lLFxuICAgICAgICAgIG9ycGhhbkZhaWxlZFJlc291cmNlczogb3B0aW9ucy5vcnBoYW5GYWlsZWRSZXNvdXJjZXMsXG4gICAgICAgICAgdmFsaWRhdGVCb290c3RyYXBTdGFja1ZlcnNpb246IG9wdGlvbnMudmFsaWRhdGVCb290c3RyYXBTdGFja1ZlcnNpb24sXG4gICAgICAgICAgb3JwaGFuTG9naWNhbElkczogb3B0aW9ucy5vcnBoYW5Mb2dpY2FsSWRzLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFzdGFja1Jlc3VsdC5ub3RJblJvbGxiYWNrYWJsZVN0YXRlKSB7XG4gICAgICAgICAgYW55Um9sbGJhY2thYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCByb2xsYmFja1NwYW4uZW5kKCk7XG5cbiAgICAgICAgcmV0LnN0YWNrcy5wdXNoKHtcbiAgICAgICAgICBlbnZpcm9ubWVudDoge1xuICAgICAgICAgICAgYWNjb3VudDogc3RhY2suZW52aXJvbm1lbnQuYWNjb3VudCxcbiAgICAgICAgICAgIHJlZ2lvbjogc3RhY2suZW52aXJvbm1lbnQucmVnaW9uLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RhY2tOYW1lOiBzdGFjay5zdGFja05hbWUsXG4gICAgICAgICAgc3RhY2tBcm46IHN0YWNrUmVzdWx0LnN0YWNrQXJuLFxuICAgICAgICAgIHJlc3VsdDogc3RhY2tSZXN1bHQubm90SW5Sb2xsYmFja2FibGVTdGF0ZSA/ICdhbHJlYWR5LXN0YWJsZScgOiAncm9sbGVkLWJhY2snLFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfRTY5MDAubXNnKGBcXG4g4p2MICAke2NoYWxrLmJvbGQoc3RhY2suZGlzcGxheU5hbWUpfSBmYWlsZWQ6ICR7Zm9ybWF0RXJyb3JNZXNzYWdlKGUpfWAsIHsgZXJyb3I6IGUgfSkpO1xuICAgICAgICB0aHJvdyBUb29sa2l0RXJyb3Iud2l0aENhdXNlKCdSb2xsYmFjayBmYWlsZWQgKHVzZSAtLWZvcmNlIHRvIG9ycGhhbiBmYWlsaW5nIHJlc291cmNlcyknLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFhbnlSb2xsYmFja2FibGUpIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ05vIHN0YWNrcyB3ZXJlIGluIGEgc3RhdGUgdGhhdCBjb3VsZCBiZSByb2xsZWQgYmFjaycpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvKipcbiAgICogUmVmYWN0b3IgQWN0aW9uLiBNb3ZlcyByZXNvdXJjZXMgZnJvbSBvbmUgbG9jYXRpb24gKHN0YWNrICsgbG9naWNhbCBJRCkgdG8gYW5vdGhlci5cbiAgICovXG4gIHB1YmxpYyBhc3luYyByZWZhY3RvcihjeDogSUNsb3VkQXNzZW1ibHlTb3VyY2UsIG9wdGlvbnM6IFJlZmFjdG9yT3B0aW9ucyA9IHt9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5yZXF1aXJlVW5zdGFibGVGZWF0dXJlKCdyZWZhY3RvcicpO1xuXG4gICAgY29uc3QgaW9IZWxwZXIgPSBhc0lvSGVscGVyKHRoaXMuaW9Ib3N0LCAncmVmYWN0b3InKTtcbiAgICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IGFzc2VtYmx5RnJvbVNvdXJjZShpb0hlbHBlciwgY3gpO1xuICAgIHJldHVybiB0aGlzLl9yZWZhY3Rvcihhc3NlbWJseSwgaW9IZWxwZXIsIG9wdGlvbnMpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfcmVmYWN0b3IoYXNzZW1ibHk6IFN0YWNrQXNzZW1ibHksIGlvSGVscGVyOiBJb0hlbHBlciwgb3B0aW9uczogUmVmYWN0b3JPcHRpb25zID0ge30pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIW9wdGlvbnMuZHJ5UnVuKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKCdSZWZhY3RvciBpcyBub3QgYXZhaWxhYmxlIHlldC4gVG9vIHNlZSB0aGUgcHJvcG9zZWQgY2hhbmdlcywgdXNlIHRoZSAtLWRyeS1ydW4gZmxhZy4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZGtQcm92aWRlciA9IGF3YWl0IHRoaXMuc2RrUHJvdmlkZXIoJ3JlZmFjdG9yJyk7XG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgYXNzZW1ibHkuc2VsZWN0U3RhY2tzVjIoQUxMX1NUQUNLUyk7XG4gICAgY29uc3QgbWFwcGluZ1NvdXJjZSA9IG9wdGlvbnMubWFwcGluZ1NvdXJjZSA/PyBNYXBwaW5nU291cmNlLmF1dG8oKTtcbiAgICBjb25zdCBleGNsdWRlID0gbWFwcGluZ1NvdXJjZS5leGNsdWRlLnVuaW9uKG5ldyBNYW5pZmVzdEV4Y2x1ZGVMaXN0KGFzc2VtYmx5LmNsb3VkQXNzZW1ibHkubWFuaWZlc3QpKTtcbiAgICBjb25zdCBmaWx0ZXJlZFN0YWNrcyA9IGF3YWl0IGFzc2VtYmx5LnNlbGVjdFN0YWNrc1YyKG9wdGlvbnMuc3RhY2tzID8/IEFMTF9TVEFDS1MpO1xuXG4gICAgY29uc3QgcmVmYWN0b3JpbmdDb250ZXh0czogUmVmYWN0b3JpbmdDb250ZXh0W10gPSBbXTtcbiAgICBmb3IgKGxldCB7IGVudmlyb25tZW50LCBsb2NhbFN0YWNrcywgZGVwbG95ZWRTdGFja3MgfSBvZiBhd2FpdCBncm91cFN0YWNrc0J5RW52aXJvbm1lbnQoKSkge1xuICAgICAgcmVmYWN0b3JpbmdDb250ZXh0cy5wdXNoKG5ldyBSZWZhY3RvcmluZ0NvbnRleHQoe1xuICAgICAgICBlbnZpcm9ubWVudCxcbiAgICAgICAgZGVwbG95ZWRTdGFja3MsXG4gICAgICAgIGxvY2FsU3RhY2tzLFxuICAgICAgICBmaWx0ZXJlZFN0YWNrczogZmlsdGVyZWRTdGFja3Muc3RhY2tBcnRpZmFjdHMsXG4gICAgICAgIG1hcHBpbmdzOiBhd2FpdCBnZXRVc2VyUHJvdmlkZWRNYXBwaW5ncyhlbnZpcm9ubWVudCksXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9uQW1iaWd1b3VzQ29udGV4dHMgPSByZWZhY3RvcmluZ0NvbnRleHRzLmZpbHRlcihjID0+ICFjLmlzQW1iaWd1b3VzKTtcbiAgICBpZiAobm9uQW1iaWd1b3VzQ29udGV4dHMubGVuZ3RoID4gMCkge1xuICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0k4OTAwLm1zZyhmb3JtYXRNYXBwaW5nc0hlYWRlcigpLCB7fSkpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNvbnRleHQgb2Ygbm9uQW1iaWd1b3VzQ29udGV4dHMpIHtcbiAgICAgIGNvbnN0IG1hcHBpbmdzID0gY29udGV4dC5tYXBwaW5ncy5maWx0ZXIoKG0pID0+ICFleGNsdWRlLmlzRXhjbHVkZWQobS5kZXN0aW5hdGlvbikpO1xuICAgICAgY29uc3QgdHlwZWRNYXBwaW5ncyA9IG1hcHBpbmdzLm1hcChtID0+IG0udG9UeXBlZE1hcHBpbmcoKSk7XG4gICAgICBjb25zdCBlbnZpcm9ubWVudCA9IGNvbnRleHQuZW52aXJvbm1lbnQ7XG4gICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTg5MDAubXNnKGZvcm1hdFR5cGVkTWFwcGluZ3MoZW52aXJvbm1lbnQsIHR5cGVkTWFwcGluZ3MpLCB7XG4gICAgICAgIHR5cGVkTWFwcGluZ3MsXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgY29uc3QgYW1iaWd1b3VzQ29udGV4dHMgPSByZWZhY3RvcmluZ0NvbnRleHRzLmZpbHRlcihjID0+IGMuaXNBbWJpZ3VvdXMpO1xuICAgIGlmIChhbWJpZ3VvdXNDb250ZXh0cy5sZW5ndGggPiAwKSB7XG4gICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTg5MDAubXNnKGZvcm1hdEFtYmlndWl0eVNlY3Rpb25IZWFkZXIoKSwge30pKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjb250ZXh0IG9mIGFtYmlndW91c0NvbnRleHRzKSB7XG4gICAgICBjb25zdCBwYXRocyA9IGNvbnRleHQuYW1iaWd1b3VzUGF0aHM7XG4gICAgICBjb25zdCBlbnZpcm9ubWVudCA9IGNvbnRleHQuZW52aXJvbm1lbnQ7XG4gICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTg5MDAubXNnKGZvcm1hdEFtYmlndW91c01hcHBpbmdzKGVudmlyb25tZW50LCBwYXRocyksIHtcbiAgICAgICAgYW1iaWd1b3VzUGF0aHM6IHBhdGhzLFxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdyb3VwU3RhY2tzQnlFbnZpcm9ubWVudCgpOiBQcm9taXNlPFN0YWNrR3JvdXBbXT4ge1xuICAgICAgY29uc3Qgc3RhY2tHcm91cHM6IE1hcDxzdHJpbmcsIFtDbG91ZEZvcm1hdGlvblN0YWNrW10sIENsb3VkRm9ybWF0aW9uU3RhY2tbXV0+ID0gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgZW52aXJvbm1lbnRzOiBNYXA8c3RyaW5nLCBjeGFwaS5FbnZpcm9ubWVudD4gPSBuZXcgTWFwKCk7XG5cbiAgICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzLnN0YWNrQXJ0aWZhY3RzKSB7XG4gICAgICAgIGNvbnN0IGVudmlyb25tZW50ID0gYXdhaXQgc2RrUHJvdmlkZXIucmVzb2x2ZUVudmlyb25tZW50KHN0YWNrLmVudmlyb25tZW50KTtcbiAgICAgICAgY29uc3Qga2V5ID0gaGFzaE9iamVjdChlbnZpcm9ubWVudCk7XG4gICAgICAgIGVudmlyb25tZW50cy5zZXQoa2V5LCBlbnZpcm9ubWVudCk7XG4gICAgICAgIGlmIChzdGFja0dyb3Vwcy5oYXMoa2V5KSkge1xuICAgICAgICAgIHN0YWNrR3JvdXBzLmdldChrZXkpIVsxXS5wdXNoKHN0YWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGUgZmlyc3QgdGltZSB3ZSBzZWUgYW4gZW52aXJvbm1lbnQsIHdlIG5lZWQgdG8gZmV0Y2ggYWxsIHN0YWNrcyBkZXBsb3llZCB0byBpdC5cbiAgICAgICAgICBjb25zdCBiZWZvcmUgPSBhd2FpdCBnZXREZXBsb3llZFN0YWNrcyhzZGtQcm92aWRlciwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgIHN0YWNrR3JvdXBzLnNldChrZXksIFtiZWZvcmUsIFtzdGFja11dKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQ6IFN0YWNrR3JvdXBbXSA9IFtdO1xuICAgICAgZm9yIChjb25zdCBbaGFzaCwgW2RlcGxveWVkU3RhY2tzLCBsb2NhbFN0YWNrc11dIG9mIHN0YWNrR3JvdXBzKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICBlbnZpcm9ubWVudDogZW52aXJvbm1lbnRzLmdldChoYXNoKSEsXG4gICAgICAgICAgbG9jYWxTdGFja3MsXG4gICAgICAgICAgZGVwbG95ZWRTdGFja3MsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRVc2VyUHJvdmlkZWRNYXBwaW5ncyhlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQpOiBQcm9taXNlPFJlc291cmNlTWFwcGluZ1tdIHwgdW5kZWZpbmVkPiB7XG4gICAgICByZXR1cm4gbWFwcGluZ1NvdXJjZS5zb3VyY2UgPT0gJ2V4cGxpY2l0J1xuICAgICAgICA/IHVzZVByZXNjcmliZWRNYXBwaW5ncyhtYXBwaW5nU291cmNlLmdyb3Vwcy5maWx0ZXIobWF0Y2hlc0Vudmlyb25tZW50KSwgc2RrUHJvdmlkZXIpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICBmdW5jdGlvbiBtYXRjaGVzRW52aXJvbm1lbnQoZzogTWFwcGluZ0dyb3VwKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBnLmFjY291bnQgPT09IGVudmlyb25tZW50LmFjY291bnQgJiYgZy5yZWdpb24gPT09IGVudmlyb25tZW50LnJlZ2lvbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveSBBY3Rpb25cbiAgICpcbiAgICogRGVzdHJveXMgdGhlIHNlbGVjdGVkIFN0YWNrcy5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBkZXN0cm95KGN4OiBJQ2xvdWRBc3NlbWJseVNvdXJjZSwgb3B0aW9uczogRGVzdHJveU9wdGlvbnMgPSB7fSk6IFByb21pc2U8RGVzdHJveVJlc3VsdD4ge1xuICAgIGNvbnN0IGlvSGVscGVyID0gYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgJ2Rlc3Ryb3knKTtcbiAgICBhd2FpdCB1c2luZyBhc3NlbWJseSA9IGF3YWl0IGFzc2VtYmx5RnJvbVNvdXJjZShpb0hlbHBlciwgY3gpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9kZXN0cm95KGFzc2VtYmx5LCAnZGVzdHJveScsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byBhbGxvdyBkZXN0cm95IGJlaW5nIGNhbGxlZCBhcyBwYXJ0IG9mIHRoZSBkZXBsb3kgYWN0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfZGVzdHJveShhc3NlbWJseTogU3RhY2tBc3NlbWJseSwgYWN0aW9uOiAnZGVwbG95JyB8ICdkZXN0cm95Jywgb3B0aW9uczogRGVzdHJveU9wdGlvbnMpOiBQcm9taXNlPERlc3Ryb3lSZXN1bHQ+IHtcbiAgICBjb25zdCBzZWxlY3RTdGFja3MgPSBvcHRpb25zLnN0YWNrcyA/PyBBTExfU1RBQ0tTO1xuICAgIGNvbnN0IGlvSGVscGVyID0gYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgYWN0aW9uKTtcbiAgICBjb25zdCBzeW50aFNwYW4gPSBhd2FpdCBpb0hlbHBlci5zcGFuKFNQQU4uU1lOVEhfQVNTRU1CTFkpLmJlZ2luKHsgc3RhY2tzOiBzZWxlY3RTdGFja3MgfSk7XG4gICAgLy8gVGhlIHN0YWNrcyB3aWxsIGhhdmUgYmVlbiBvcmRlcmVkIGZvciBkZXBsb3ltZW50LCBzbyByZXZlcnNlIHRoZW0gZm9yIGRlbGV0aW9uLlxuICAgIGNvbnN0IHN0YWNrcyA9IChhd2FpdCBhc3NlbWJseS5zZWxlY3RTdGFja3NWMihzZWxlY3RTdGFja3MpKS5yZXZlcnNlZCgpO1xuICAgIGF3YWl0IHN5bnRoU3Bhbi5lbmQoKTtcblxuICAgIGNvbnN0IHJldDogRGVzdHJveVJlc3VsdCA9IHtcbiAgICAgIHN0YWNrczogW10sXG4gICAgfTtcblxuICAgIGNvbnN0IG1vdGl2YXRpb24gPSAnRGVzdHJveWluZyBzdGFja3MgaXMgYW4gaXJyZXZlcnNpYmxlIGFjdGlvbic7XG4gICAgY29uc3QgcXVlc3Rpb24gPSBgQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZTogJHtjaGFsay5yZWQoc3RhY2tzLmhpZXJhcmNoaWNhbElkcy5qb2luKCcsICcpKX1gO1xuICAgIGNvbnN0IGNvbmZpcm1lZCA9IGF3YWl0IGlvSGVscGVyLnJlcXVlc3RSZXNwb25zZShJTy5DREtfVE9PTEtJVF9JNzAxMC5yZXEocXVlc3Rpb24sIHsgbW90aXZhdGlvbiB9KSk7XG4gICAgaWYgKCFjb25maXJtZWQpIHtcbiAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9FNzAxMC5tc2coJ0Fib3J0ZWQgYnkgdXNlcicpKTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgY29uc3QgZGVzdHJveVNwYW4gPSBhd2FpdCBpb0hlbHBlci5zcGFuKFNQQU4uREVTVFJPWV9BQ1RJT04pLmJlZ2luKHtcbiAgICAgIHN0YWNrczogc3RhY2tzLnN0YWNrQXJ0aWZhY3RzLFxuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKGNvbnN0IFtpbmRleCwgc3RhY2tdIG9mIHN0YWNrcy5zdGFja0FydGlmYWN0cy5lbnRyaWVzKCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBzaW5nbGVEZXN0cm95U3BhbiA9IGF3YWl0IGlvSGVscGVyLnNwYW4oU1BBTi5ERVNUUk9ZX1NUQUNLKVxuICAgICAgICAgICAgLmJlZ2luKGNoYWxrLmdyZWVuKGAke2NoYWxrLmJsdWUoc3RhY2suZGlzcGxheU5hbWUpfTogZGVzdHJveWluZy4uLiBbJHtpbmRleCArIDF9LyR7c3RhY2tzLnN0YWNrQ291bnR9XWApLCB7XG4gICAgICAgICAgICAgIHRvdGFsOiBzdGFja3Muc3RhY2tDb3VudCxcbiAgICAgICAgICAgICAgY3VycmVudDogaW5kZXggKyAxLFxuICAgICAgICAgICAgICBzdGFjayxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGRlcGxveW1lbnRzID0gYXdhaXQgdGhpcy5kZXBsb3ltZW50c0ZvckFjdGlvbihhY3Rpb24pO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRlcGxveW1lbnRzLmRlc3Ryb3lTdGFjayh7XG4gICAgICAgICAgICBzdGFjayxcbiAgICAgICAgICAgIGRlcGxveU5hbWU6IHN0YWNrLnN0YWNrTmFtZSxcbiAgICAgICAgICAgIHJvbGVBcm46IG9wdGlvbnMucm9sZUFybixcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldC5zdGFja3MucHVzaCh7XG4gICAgICAgICAgICBlbnZpcm9ubWVudDoge1xuICAgICAgICAgICAgICBhY2NvdW50OiBzdGFjay5lbnZpcm9ubWVudC5hY2NvdW50LFxuICAgICAgICAgICAgICByZWdpb246IHN0YWNrLmVudmlyb25tZW50LnJlZ2lvbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGFja05hbWU6IHN0YWNrLnN0YWNrTmFtZSxcbiAgICAgICAgICAgIHN0YWNrQXJuOiByZXN1bHQuc3RhY2tBcm4sXG4gICAgICAgICAgICBzdGFja0V4aXN0ZWQ6IHJlc3VsdC5zdGFja0FybiAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0k3OTAwLm1zZyhjaGFsay5ncmVlbihgXFxuIOKchSAgJHtjaGFsay5ibHVlKHN0YWNrLmRpc3BsYXlOYW1lKX06ICR7YWN0aW9ufWVkYCksIHN0YWNrKSk7XG4gICAgICAgICAgYXdhaXQgc2luZ2xlRGVzdHJveVNwYW4uZW5kKCk7XG4gICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9FNzkwMC5tc2coYFxcbiDinYwgICR7Y2hhbGsuYmx1ZShzdGFjay5kaXNwbGF5TmFtZSl9OiAke2FjdGlvbn0gZmFpbGVkICR7ZX1gLCB7IGVycm9yOiBlIH0pKTtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGF3YWl0IGRlc3Ryb3lTcGFuLmVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB0aGUgc3RhY2tzIGZvciBlcnJvcnMgYW5kIHdhcm5pbmdzIGFjY29yZGluZyB0byB0aGUgQ0xJJ3MgY3VycmVudCBzZXR0aW5nc1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyB2YWxpZGF0ZVN0YWNrc01ldGFkYXRhKHN0YWNrczogU3RhY2tDb2xsZWN0aW9uLCBpb0hvc3Q6IElvSGVscGVyKSB7XG4gICAgY29uc3QgYnVpbGRlciA9IChsZXZlbDogSW9NZXNzYWdlTGV2ZWwpID0+IHtcbiAgICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgIHJldHVybiBJTy5DREtfQVNTRU1CTFlfRTk5OTk7XG4gICAgICAgIGNhc2UgJ3dhcm4nOlxuICAgICAgICAgIHJldHVybiBJTy5DREtfQVNTRU1CTFlfVzk5OTk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIElPLkNES19BU1NFTUJMWV9JOTk5OTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGF3YWl0IHN0YWNrcy52YWxpZGF0ZU1ldGFkYXRhKFxuICAgICAgdGhpcy5wcm9wcy5hc3NlbWJseUZhaWx1cmVBdCxcbiAgICAgIGFzeW5jIChsZXZlbCwgbXNnKSA9PiBpb0hvc3Qubm90aWZ5KGJ1aWxkZXIobGV2ZWwpLm1zZyhgWyR7bGV2ZWx9IGF0ICR7bXNnLmlkfV0gJHttc2cuZW50cnkuZGF0YX1gLCBtc2cpKSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGRlcGxveW1lbnRzIGNsYXNzXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGRlcGxveW1lbnRzRm9yQWN0aW9uKGFjdGlvbjogVG9vbGtpdEFjdGlvbik6IFByb21pc2U8RGVwbG95bWVudHM+IHtcbiAgICByZXR1cm4gbmV3IERlcGxveW1lbnRzKHtcbiAgICAgIHNka1Byb3ZpZGVyOiBhd2FpdCB0aGlzLnNka1Byb3ZpZGVyKGFjdGlvbiksXG4gICAgICB0b29sa2l0U3RhY2tOYW1lOiB0aGlzLnRvb2xraXRTdGFja05hbWUsXG4gICAgICBpb0hlbHBlcjogYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgYWN0aW9uKSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaW52b2tlRGVwbG95RnJvbVdhdGNoKFxuICAgIGFzc2VtYmx5OiBTdGFja0Fzc2VtYmx5LFxuICAgIG9wdGlvbnM6IFdhdGNoT3B0aW9ucyxcbiAgICBjbG91ZFdhdGNoTG9nTW9uaXRvcj86IENsb3VkV2F0Y2hMb2dFdmVudE1vbml0b3IsXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIHdhdGNoIGRlZmF1bHRzIHRvIGhvdHN3YXAgZGVwbG95bWVudFxuICAgIGNvbnN0IGRlcGxveW1lbnRNZXRob2QgPSBvcHRpb25zLmRlcGxveW1lbnRNZXRob2QgPz8geyBtZXRob2Q6ICdob3Rzd2FwJyB9O1xuICAgIGNvbnN0IGRlcGxveU9wdGlvbnM6IFByaXZhdGVEZXBsb3lPcHRpb25zID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGNsb3VkV2F0Y2hMb2dNb25pdG9yLFxuICAgICAgZGVwbG95bWVudE1ldGhvZCxcbiAgICAgIGV4dHJhVXNlckFnZW50OiBgY2RrLXdhdGNoL2hvdHN3YXAtJHtkZXBsb3ltZW50TWV0aG9kLm1ldGhvZCA9PT0gJ2hvdHN3YXAnID8gJ29uJyA6ICdvZmYnfWAsXG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLl9kZXBsb3koYXNzZW1ibHksICd3YXRjaCcsIGRlcGxveU9wdGlvbnMpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgLy8ganVzdCBjb250aW51ZSAtIGRlcGxveSB3aWxsIHNob3cgdGhlIGVycm9yXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZXF1aXJlVW5zdGFibGVGZWF0dXJlKHJlcXVlc3RlZEZlYXR1cmU6IFVuc3RhYmxlRmVhdHVyZSkge1xuICAgIGlmICghdGhpcy51bnN0YWJsZUZlYXR1cmVzLmluY2x1ZGVzKHJlcXVlc3RlZEZlYXR1cmUpKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBVbnN0YWJsZSBmZWF0dXJlICcke3JlcXVlc3RlZEZlYXR1cmV9JyBpcyBub3QgZW5hYmxlZC4gUGxlYXNlIGVuYWJsZSBpdCB1bmRlciAndW5zdGFibGVGZWF0dXJlcydgKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==