"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.zipDirectory = zipDirectory;
const fs_1 = require("fs");
const path = require("path");
const glob = require("glob");
// namespace object imports won't work in the bundle for function exports
// eslint-disable-next-line @typescript-eslint/no-require-imports
const archiver = require('archiver');
async function zipDirectory(directory, outputFile, eventEmitter) {
    // We write to a temporary file and rename at the last moment. This is so that if we are
    // interrupted during this process, we don't leave a half-finished file in the target location.
    const temporaryOutputFile = `${outputFile}.${randomString()}._tmp`;
    await writeZipFile(directory, temporaryOutputFile);
    await moveIntoPlace(temporaryOutputFile, outputFile, eventEmitter);
}
function writeZipFile(directory, outputFile) {
    return new Promise(async (ok, fail) => {
        // The below options are needed to support following symlinks when building zip files:
        // - nodir: This will prevent symlinks themselves from being copied into the zip.
        // - follow: This will follow symlinks and copy the files within.
        const globOptions = {
            dot: true,
            nodir: true,
            follow: true,
            cwd: directory,
        };
        const files = glob.sync('**', globOptions); // The output here is already sorted
        const output = (0, fs_1.createWriteStream)(outputFile);
        const archive = archiver('zip');
        archive.on('warning', fail);
        archive.on('error', fail);
        // archive has been finalized and the output file descriptor has closed, resolve promise
        // this has to be done before calling `finalize` since the events may fire immediately after.
        // see https://www.npmjs.com/package/archiver
        output.once('close', ok);
        archive.pipe(output);
        // Append files serially to ensure file order
        for (const file of files) {
            const fullPath = path.resolve(directory, file);
            // There are exactly 2 promises
            // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
            const [data, stat] = await Promise.all([fs_1.promises.readFile(fullPath), fs_1.promises.stat(fullPath)]);
            archive.append(data, {
                name: file,
                date: new Date('1980-01-01T00:00:00.000Z'), // reset dates to get the same hash for the same content
                mode: stat.mode,
            });
        }
        await archive.finalize();
    });
}
/**
 * Rename the file to the target location, taking into account:
 *
 * - That we may see EPERM on Windows while an Antivirus scanner still has the
 *   file open, so retry a couple of times.
 * - This same function may be called in parallel and be interrupted at any point.
 */
async function moveIntoPlace(source, target, eventEmitter) {
    let delay = 100;
    let attempts = 5;
    while (true) {
        try {
            // 'rename' is guaranteed to overwrite an existing target, as long as it is a file (not a directory)
            await fs_1.promises.rename(source, target);
            return;
        }
        catch (e) {
            if (e.code !== 'EPERM' || attempts-- <= 0) {
                throw e;
            }
            eventEmitter(e.message);
            await sleep(Math.floor(Math.random() * delay));
            delay *= 2;
        }
    }
}
function sleep(ms) {
    return new Promise((ok) => setTimeout(ok, ms));
}
function randomString() {
    return Math.random()
        .toString(36)
        .replace(/[^a-z0-9]+/g, '');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJjaGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImFyY2hpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFVQSxvQ0FVQztBQXBCRCwyQkFBdUQ7QUFDdkQsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUU3Qix5RUFBeUU7QUFDekUsaUVBQWlFO0FBQ2pFLE1BQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUk5QixLQUFLLFVBQVUsWUFBWSxDQUNoQyxTQUFpQixFQUNqQixVQUFrQixFQUNsQixZQUEwQjtJQUUxQix3RkFBd0Y7SUFDeEYsK0ZBQStGO0lBQy9GLE1BQU0sbUJBQW1CLEdBQUcsR0FBRyxVQUFVLElBQUksWUFBWSxFQUFFLE9BQU8sQ0FBQztJQUNuRSxNQUFNLFlBQVksQ0FBQyxTQUFTLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztJQUNuRCxNQUFNLGFBQWEsQ0FBQyxtQkFBbUIsRUFBRSxVQUFVLEVBQUUsWUFBWSxDQUFDLENBQUM7QUFDckUsQ0FBQztBQUVELFNBQVMsWUFBWSxDQUFDLFNBQWlCLEVBQUUsVUFBa0I7SUFDekQsT0FBTyxJQUFJLE9BQU8sQ0FBQyxLQUFLLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxFQUFFO1FBQ3BDLHNGQUFzRjtRQUN0RixpRkFBaUY7UUFDakYsaUVBQWlFO1FBQ2pFLE1BQU0sV0FBVyxHQUFHO1lBQ2xCLEdBQUcsRUFBRSxJQUFJO1lBQ1QsS0FBSyxFQUFFLElBQUk7WUFDWCxNQUFNLEVBQUUsSUFBSTtZQUNaLEdBQUcsRUFBRSxTQUFTO1NBQ2YsQ0FBQztRQUNGLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUMsb0NBQW9DO1FBRWhGLE1BQU0sTUFBTSxHQUFHLElBQUEsc0JBQWlCLEVBQUMsVUFBVSxDQUFDLENBQUM7UUFFN0MsTUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2hDLE9BQU8sQ0FBQyxFQUFFLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzVCLE9BQU8sQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRTFCLHdGQUF3RjtRQUN4Riw2RkFBNkY7UUFDN0YsNkNBQTZDO1FBQzdDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRXpCLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFckIsNkNBQTZDO1FBQzdDLEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxFQUFFLENBQUM7WUFDekIsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDL0MsK0JBQStCO1lBQy9CLHdFQUF3RTtZQUN4RSxNQUFNLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxHQUFHLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLGFBQUUsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEVBQUUsYUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbkYsT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUU7Z0JBQ25CLElBQUksRUFBRSxJQUFJO2dCQUNWLElBQUksRUFBRSxJQUFJLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxFQUFFLHdEQUF3RDtnQkFDcEcsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO2FBQ2hCLENBQUMsQ0FBQztRQUNMLENBQUM7UUFFRCxNQUFNLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUMzQixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxLQUFLLFVBQVUsYUFBYSxDQUFDLE1BQWMsRUFBRSxNQUFjLEVBQUUsWUFBMEI7SUFDckYsSUFBSSxLQUFLLEdBQUcsR0FBRyxDQUFDO0lBQ2hCLElBQUksUUFBUSxHQUFHLENBQUMsQ0FBQztJQUNqQixPQUFPLElBQUksRUFBRSxDQUFDO1FBQ1osSUFBSSxDQUFDO1lBQ0gsb0dBQW9HO1lBQ3BHLE1BQU0sYUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFDaEMsT0FBTztRQUNULENBQUM7UUFBQyxPQUFPLENBQU0sRUFBRSxDQUFDO1lBQ2hCLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxPQUFPLElBQUksUUFBUSxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUM7Z0JBQzFDLE1BQU0sQ0FBQyxDQUFDO1lBQ1YsQ0FBQztZQUNELFlBQVksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDeEIsTUFBTSxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUMvQyxLQUFLLElBQUksQ0FBQyxDQUFDO1FBQ2IsQ0FBQztJQUNILENBQUM7QUFDSCxDQUFDO0FBRUQsU0FBUyxLQUFLLENBQUMsRUFBVTtJQUN2QixPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDakQsQ0FBQztBQUVELFNBQVMsWUFBWTtJQUNuQixPQUFPLElBQUksQ0FBQyxNQUFNLEVBQUU7U0FDakIsUUFBUSxDQUFDLEVBQUUsQ0FBQztTQUNaLE9BQU8sQ0FBQyxhQUFhLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDaEMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVdyaXRlU3RyZWFtLCBwcm9taXNlcyBhcyBmcyB9IGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBnbG9iIGZyb20gJ2dsb2InO1xuXG4vLyBuYW1lc3BhY2Ugb2JqZWN0IGltcG9ydHMgd29uJ3Qgd29yayBpbiB0aGUgYnVuZGxlIGZvciBmdW5jdGlvbiBleHBvcnRzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuY29uc3QgYXJjaGl2ZXIgPSByZXF1aXJlKCdhcmNoaXZlcicpO1xuXG50eXBlIEV2ZW50RW1pdHRlciA9ICh4OiBzdHJpbmcpID0+IHZvaWQ7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB6aXBEaXJlY3RvcnkoXG4gIGRpcmVjdG9yeTogc3RyaW5nLFxuICBvdXRwdXRGaWxlOiBzdHJpbmcsXG4gIGV2ZW50RW1pdHRlcjogRXZlbnRFbWl0dGVyLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIC8vIFdlIHdyaXRlIHRvIGEgdGVtcG9yYXJ5IGZpbGUgYW5kIHJlbmFtZSBhdCB0aGUgbGFzdCBtb21lbnQuIFRoaXMgaXMgc28gdGhhdCBpZiB3ZSBhcmVcbiAgLy8gaW50ZXJydXB0ZWQgZHVyaW5nIHRoaXMgcHJvY2Vzcywgd2UgZG9uJ3QgbGVhdmUgYSBoYWxmLWZpbmlzaGVkIGZpbGUgaW4gdGhlIHRhcmdldCBsb2NhdGlvbi5cbiAgY29uc3QgdGVtcG9yYXJ5T3V0cHV0RmlsZSA9IGAke291dHB1dEZpbGV9LiR7cmFuZG9tU3RyaW5nKCl9Ll90bXBgO1xuICBhd2FpdCB3cml0ZVppcEZpbGUoZGlyZWN0b3J5LCB0ZW1wb3JhcnlPdXRwdXRGaWxlKTtcbiAgYXdhaXQgbW92ZUludG9QbGFjZSh0ZW1wb3JhcnlPdXRwdXRGaWxlLCBvdXRwdXRGaWxlLCBldmVudEVtaXR0ZXIpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVppcEZpbGUoZGlyZWN0b3J5OiBzdHJpbmcsIG91dHB1dEZpbGU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKG9rLCBmYWlsKSA9PiB7XG4gICAgLy8gVGhlIGJlbG93IG9wdGlvbnMgYXJlIG5lZWRlZCB0byBzdXBwb3J0IGZvbGxvd2luZyBzeW1saW5rcyB3aGVuIGJ1aWxkaW5nIHppcCBmaWxlczpcbiAgICAvLyAtIG5vZGlyOiBUaGlzIHdpbGwgcHJldmVudCBzeW1saW5rcyB0aGVtc2VsdmVzIGZyb20gYmVpbmcgY29waWVkIGludG8gdGhlIHppcC5cbiAgICAvLyAtIGZvbGxvdzogVGhpcyB3aWxsIGZvbGxvdyBzeW1saW5rcyBhbmQgY29weSB0aGUgZmlsZXMgd2l0aGluLlxuICAgIGNvbnN0IGdsb2JPcHRpb25zID0ge1xuICAgICAgZG90OiB0cnVlLFxuICAgICAgbm9kaXI6IHRydWUsXG4gICAgICBmb2xsb3c6IHRydWUsXG4gICAgICBjd2Q6IGRpcmVjdG9yeSxcbiAgICB9O1xuICAgIGNvbnN0IGZpbGVzID0gZ2xvYi5zeW5jKCcqKicsIGdsb2JPcHRpb25zKTsgLy8gVGhlIG91dHB1dCBoZXJlIGlzIGFscmVhZHkgc29ydGVkXG5cbiAgICBjb25zdCBvdXRwdXQgPSBjcmVhdGVXcml0ZVN0cmVhbShvdXRwdXRGaWxlKTtcblxuICAgIGNvbnN0IGFyY2hpdmUgPSBhcmNoaXZlcignemlwJyk7XG4gICAgYXJjaGl2ZS5vbignd2FybmluZycsIGZhaWwpO1xuICAgIGFyY2hpdmUub24oJ2Vycm9yJywgZmFpbCk7XG5cbiAgICAvLyBhcmNoaXZlIGhhcyBiZWVuIGZpbmFsaXplZCBhbmQgdGhlIG91dHB1dCBmaWxlIGRlc2NyaXB0b3IgaGFzIGNsb3NlZCwgcmVzb2x2ZSBwcm9taXNlXG4gICAgLy8gdGhpcyBoYXMgdG8gYmUgZG9uZSBiZWZvcmUgY2FsbGluZyBgZmluYWxpemVgIHNpbmNlIHRoZSBldmVudHMgbWF5IGZpcmUgaW1tZWRpYXRlbHkgYWZ0ZXIuXG4gICAgLy8gc2VlIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2FyY2hpdmVyXG4gICAgb3V0cHV0Lm9uY2UoJ2Nsb3NlJywgb2spO1xuXG4gICAgYXJjaGl2ZS5waXBlKG91dHB1dCk7XG5cbiAgICAvLyBBcHBlbmQgZmlsZXMgc2VyaWFsbHkgdG8gZW5zdXJlIGZpbGUgb3JkZXJcbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5yZXNvbHZlKGRpcmVjdG9yeSwgZmlsZSk7XG4gICAgICAvLyBUaGVyZSBhcmUgZXhhY3RseSAyIHByb21pc2VzXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGNka2xhYnMvcHJvbWlzZWFsbC1uby11bmJvdW5kZWQtcGFyYWxsZWxpc21cbiAgICAgIGNvbnN0IFtkYXRhLCBzdGF0XSA9IGF3YWl0IFByb21pc2UuYWxsKFtmcy5yZWFkRmlsZShmdWxsUGF0aCksIGZzLnN0YXQoZnVsbFBhdGgpXSk7XG4gICAgICBhcmNoaXZlLmFwcGVuZChkYXRhLCB7XG4gICAgICAgIG5hbWU6IGZpbGUsXG4gICAgICAgIGRhdGU6IG5ldyBEYXRlKCcxOTgwLTAxLTAxVDAwOjAwOjAwLjAwMFonKSwgLy8gcmVzZXQgZGF0ZXMgdG8gZ2V0IHRoZSBzYW1lIGhhc2ggZm9yIHRoZSBzYW1lIGNvbnRlbnRcbiAgICAgICAgbW9kZTogc3RhdC5tb2RlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXdhaXQgYXJjaGl2ZS5maW5hbGl6ZSgpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZW5hbWUgdGhlIGZpbGUgdG8gdGhlIHRhcmdldCBsb2NhdGlvbiwgdGFraW5nIGludG8gYWNjb3VudDpcbiAqXG4gKiAtIFRoYXQgd2UgbWF5IHNlZSBFUEVSTSBvbiBXaW5kb3dzIHdoaWxlIGFuIEFudGl2aXJ1cyBzY2FubmVyIHN0aWxsIGhhcyB0aGVcbiAqICAgZmlsZSBvcGVuLCBzbyByZXRyeSBhIGNvdXBsZSBvZiB0aW1lcy5cbiAqIC0gVGhpcyBzYW1lIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgaW4gcGFyYWxsZWwgYW5kIGJlIGludGVycnVwdGVkIGF0IGFueSBwb2ludC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbW92ZUludG9QbGFjZShzb3VyY2U6IHN0cmluZywgdGFyZ2V0OiBzdHJpbmcsIGV2ZW50RW1pdHRlcjogRXZlbnRFbWl0dGVyKSB7XG4gIGxldCBkZWxheSA9IDEwMDtcbiAgbGV0IGF0dGVtcHRzID0gNTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB0cnkge1xuICAgICAgLy8gJ3JlbmFtZScgaXMgZ3VhcmFudGVlZCB0byBvdmVyd3JpdGUgYW4gZXhpc3RpbmcgdGFyZ2V0LCBhcyBsb25nIGFzIGl0IGlzIGEgZmlsZSAobm90IGEgZGlyZWN0b3J5KVxuICAgICAgYXdhaXQgZnMucmVuYW1lKHNvdXJjZSwgdGFyZ2V0KTtcbiAgICAgIHJldHVybjtcbiAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgIGlmIChlLmNvZGUgIT09ICdFUEVSTScgfHwgYXR0ZW1wdHMtLSA8PSAwKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICBldmVudEVtaXR0ZXIoZS5tZXNzYWdlKTtcbiAgICAgIGF3YWl0IHNsZWVwKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGRlbGF5KSk7XG4gICAgICBkZWxheSAqPSAyO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzbGVlcChtczogbnVtYmVyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgob2spID0+IHNldFRpbWVvdXQob2ssIG1zKSk7XG59XG5cbmZ1bmN0aW9uIHJhbmRvbVN0cmluZygpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKClcbiAgICAudG9TdHJpbmcoMzYpXG4gICAgLnJlcGxhY2UoL1teYS16MC05XSsvZywgJycpO1xufVxuIl19