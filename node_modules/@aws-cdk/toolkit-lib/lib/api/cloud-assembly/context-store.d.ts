/**
 * A storage place for context used in synthesis
 */
export interface IContextStore {
    /**
     * Read the context from the context store, plus all updates we have made so far.
     */
    read(): Promise<Record<string, unknown>>;
    /**
     * Commit the given updates to the context store
     *
     * `undefined` is used as a value to indicate that the key needs to be removed.
     *
     * If a context value is an object that is a superset of `{ [TRANSIENT_CONTEXT_KEY]: true }`
     * it *should* be returned by subsequent `read()` operations on this object,
     * but it *should not* be persisted to permanent storage.
     *
     * You can use the `persistableContext()` function to filter a context dictionary
     * down to remove all values that shouldn't be persisted.
     */
    update(updates: Record<string, unknown>): Promise<void>;
}
/**
 * A context store as used by a CDK app.
 *
 * Will source context from the following locations:
 *
 * - Any context values passed to the constructor (expected
 *   to come from the command line, treated as ephemeral).
 * - The `context` key in `<appDirectory>/cdk.json`.
 * - `<appDirectory>/cdk.context.json`.
 * - The `context` key in `~/.cdk.json`.
 *
 * Updates will be written to `<appDirectory>/cdk.context.json`.
 */
export declare class CdkAppMultiContext implements IContextStore {
    private readonly commandlineContext?;
    private _context?;
    private configContextFile;
    private projectContextFile;
    private userConfigFile;
    constructor(appDirectory: string, commandlineContext?: Record<string, unknown> | undefined);
    read(): Promise<Record<string, unknown>>;
    update(updates: Record<string, unknown>): Promise<void>;
    /**
     * Initialize the `Context` object
     *
     * This code all exists to reuse code that's already there, to minimize
     * the chances of the new code behaving subtly differently than the
     * old code.
     *
     * It might be most of this is unnecessary now...
     */
    private asyncInitialize;
}
/**
 * On-disk context stored in a single file
 */
export declare class FileContext implements IContextStore {
    private readonly fileName;
    private _cache?;
    constructor(fileName: string);
    read(): Promise<Record<string, unknown>>;
    update(updates: Record<string, unknown>): Promise<void>;
}
/**
 * An in-memory context store
 */
export declare class MemoryContext implements IContextStore {
    private context;
    constructor(initialContext?: Record<string, unknown>);
    read(): Promise<Record<string, unknown>>;
    update(updates: Record<string, unknown>): Promise<void>;
}
/**
 * Filter the given context, leaving only entries that should be persisted
 */
export declare function persistableContext(context: Record<string, unknown>): Record<string, unknown>;
