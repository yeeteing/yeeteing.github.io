"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegionInfo = void 0;
const jsiiDeprecationWarnings = require("../.warnings.jsii.js");
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const aws_entities_1 = require("./aws-entities");
const fact_1 = require("./fact");
/**
 * Information pertaining to an AWS region.
 */
class RegionInfo {
    /**
     * @returns the list of names of AWS regions for which there is at least one registered fact. This
     *          may not be an exaustive list of all available AWS regions.
     */
    static get regions() {
        return fact_1.Fact.regions.map(x => RegionInfo.get(x));
    }
    /**
     * Retrieves a collection of all fact values for all regions that fact is defined in.
     *
     * @param factName the name of the fact to retrieve values for.
     *   For a list of common fact names, see the FactName class
     * @returns a mapping with AWS region codes as the keys,
     *   and the fact in the given region as the value for that key
     */
    static regionMap(factName) {
        const ret = {};
        for (const regionInfo of RegionInfo.regions) {
            const fact = fact_1.Fact.find(regionInfo.name, factName);
            if (fact) {
                ret[regionInfo.name] = fact;
            }
        }
        return ret;
    }
    /**
     * Retrieves a collection of all fact values for all regions, limited to some partitions
     *
     * @param factName the name of the fact to retrieve values for.
     *   For a list of common fact names, see the FactName class
     * @param partitions list of partitions to retrieve facts for. Defaults
     *   to `['aws', 'aws-cn']`.
     * @returns a mapping with AWS region codes as the keys,
     *   and the fact in the given region as the value for that key
     */
    static limitedRegionMap(factName, partitions) {
        const ret = {};
        for (const [region, value] of Object.entries(RegionInfo.regionMap(factName))) {
            if (partitions.includes((0, aws_entities_1.partitionInformation)(region).partition)) {
                ret[region] = value;
            }
        }
        return ret;
    }
    /**
     * Obtain region info for a given region name.
     *
     * @param name the name of the region (e.g: us-east-1)
     */
    static get(name) {
        return new RegionInfo(name);
    }
    constructor(name) {
        this.name = name;
    }
    /**
     * Whether the `AWS::CDK::Metadata` CloudFormation Resource is available in this region or not.
     */
    get cdkMetadataResourceAvailable() {
        return fact_1.Fact.find(this.name, fact_1.FactName.CDK_METADATA_RESOURCE_AVAILABLE) === 'YES';
    }
    /**
     * Whether the given region is an opt-in region
     */
    get isOptInRegion() {
        return fact_1.Fact.find(this.name, fact_1.FactName.IS_OPT_IN_REGION) === 'YES';
    }
    /**
     * The domain name suffix (e.g: amazonaws.com) for this region.
     */
    get domainSuffix() {
        return fact_1.Fact.find(this.name, fact_1.FactName.DOMAIN_SUFFIX);
    }
    /**
     * The name of the ARN partition for this region (e.g: aws).
     */
    get partition() {
        return fact_1.Fact.find(this.name, fact_1.FactName.PARTITION);
    }
    /**
     * The endpoint used by S3 static website hosting in this region (e.g: s3-static-website-us-east-1.amazonaws.com)
     */
    get s3StaticWebsiteEndpoint() {
        return fact_1.Fact.find(this.name, fact_1.FactName.S3_STATIC_WEBSITE_ENDPOINT);
    }
    /**
     * The hosted zone ID used by Route 53 to alias a S3 static website in this region (e.g: Z2O1EMRO9K5GLX)
     */
    get s3StaticWebsiteHostedZoneId() {
        return fact_1.Fact.find(this.name, fact_1.FactName.S3_STATIC_WEBSITE_ZONE_53_HOSTED_ZONE_ID);
    }
    /**
     * The hosted zone ID used by Route 53 to alias a EBS environment endpoint in this region (e.g: Z2O1EMRO9K5GLX)
     */
    get ebsEnvEndpointHostedZoneId() {
        return fact_1.Fact.find(this.name, fact_1.FactName.EBS_ENV_ENDPOINT_HOSTED_ZONE_ID);
    }
    /**
     * The prefix for VPC Endpoint Service names,
     * cn.com.amazonaws.vpce for China regions,
     * com.amazonaws.vpce otherwise.
     */
    get vpcEndpointServiceNamePrefix() {
        return fact_1.Fact.find(this.name, fact_1.FactName.VPC_ENDPOINT_SERVICE_NAME_PREFIX);
    }
    /**
     * The name of the service principal for a given service in this region.
     * @param service the service name (e.g: s3.amazonaws.com)
     *
     * @deprecated - Use `iam.ServicePrincipal.servicePrincipalName()` instead.
     */
    servicePrincipal(service) {
        try {
            jsiiDeprecationWarnings.print("@aws-cdk/region-info.RegionInfo#servicePrincipal", "- Use `iam.ServicePrincipal.servicePrincipalName()` instead.");
        }
        catch (error) {
            if (process.env.JSII_DEBUG !== "1" && error.name === "DeprecationError") {
                Error.captureStackTrace(error, this.servicePrincipal);
            }
            throw error;
        }
        return `${service.replace(/\.amazonaws\.com(\.cn)?$/, '')}.amazonaws.com`;
    }
    /**
     * The account ID for ELBv2 in this region
     */
    get elbv2Account() {
        return fact_1.Fact.find(this.name, fact_1.FactName.ELBV2_ACCOUNT);
    }
    /**
     * The ID of the AWS account that owns the public ECR repository containing the
     * AWS Deep Learning Containers images in this region.
     */
    get dlcRepositoryAccount() {
        return fact_1.Fact.find(this.name, fact_1.FactName.DLC_REPOSITORY_ACCOUNT);
    }
    /**
     * The ARN of the CloudWatch Lambda Insights extension, for the given version.
     * @param insightsVersion the version (e.g. 1.0.98.0)
     * @param architecture the Lambda Function architecture (e.g. 'x86_64' or 'arm64')
     */
    cloudwatchLambdaInsightsArn(insightsVersion, architecture) {
        return fact_1.Fact.find(this.name, fact_1.FactName.cloudwatchLambdaInsightsVersion(insightsVersion, architecture));
    }
    /**
     * The ARN of the AppConfig Lambda Layer, for the given version.
     * @param layerVersion The layer version (e.g. 2.0.181)
     * @param architecture The Lambda Function architecture (e.g. 'x86_64' or 'arm64'), defaults to x86_64
     */
    appConfigLambdaArn(layerVersion, architecture) {
        return fact_1.Fact.find(this.name, fact_1.FactName.appConfigLambdaLayerVersion(layerVersion, architecture));
    }
    /**
     * The ID of the AWS account that owns the public ECR repository that contains the
     * AWS App Mesh Envoy Proxy images in a given region.
     */
    get appMeshRepositoryAccount() {
        return fact_1.Fact.find(this.name, fact_1.FactName.APPMESH_ECR_ACCOUNT);
    }
    /**
     * The CIDR block used by Amazon Data Firehose servers.
     */
    get firehoseCidrBlock() {
        return fact_1.Fact.find(this.name, fact_1.FactName.FIREHOSE_CIDR_BLOCK);
    }
    /**
     * The ARN of the ADOT Lambda layer, for the given layer type, version and architecture.
     *
     * @param type the type of the ADOT lambda layer
     * @param version the layer version.
     * @param architecture the Lambda Function architecture (e.g. 'x86_64' or 'arm64')
     */
    adotLambdaLayerArn(type, version, architecture) {
        return fact_1.Fact.find(this.name, fact_1.FactName.adotLambdaLayer(type, version, architecture));
    }
    /**
     * The ARN of the Parameters and Secrets Lambda layer for the given lambda architecture.
     *
     * @param version the layer version
     * @param architecture the Lambda Function architecture (e.g. 'x86_64' or 'arm64')
     */
    paramsAndSecretsLambdaLayerArn(version, architecture) {
        return fact_1.Fact.find(this.name, fact_1.FactName.paramsAndSecretsLambdaLayer(version, architecture));
    }
    /**
     * SAML Sign On URL used by IAM SAML Principals.
     */
    get samlSignOnUrl() {
        return fact_1.Fact.find(this.name, fact_1.FactName.SAML_SIGN_ON_URL);
    }
}
exports.RegionInfo = RegionInfo;
_a = JSII_RTTI_SYMBOL_1;
RegionInfo[_a] = { fqn: "@aws-cdk/region-info.RegionInfo", version: "2.214.0" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVnaW9uLWluZm8uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJyZWdpb24taW5mby50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxpREFBc0Q7QUFDdEQsaUNBQXdDO0FBRXhDOztHQUVHO0FBQ0gsTUFBYSxVQUFVO0lBQ3JCOzs7T0FHRztJQUNJLE1BQU0sS0FBSyxPQUFPO1FBQ3ZCLE9BQU8sV0FBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDakQ7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksTUFBTSxDQUFDLFNBQVMsQ0FBQyxRQUFnQjtRQUN0QyxNQUFNLEdBQUcsR0FBaUMsRUFBRSxDQUFDO1FBQzdDLEtBQUssTUFBTSxVQUFVLElBQUksVUFBVSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQzVDLE1BQU0sSUFBSSxHQUFHLFdBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztZQUNsRCxJQUFJLElBQUksRUFBRSxDQUFDO2dCQUNULEdBQUcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDO1lBQzlCLENBQUM7UUFDSCxDQUFDO1FBQ0QsT0FBTyxHQUFHLENBQUM7S0FDWjtJQUVEOzs7Ozs7Ozs7T0FTRztJQUNJLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFnQixFQUFFLFVBQW9CO1FBQ25FLE1BQU0sR0FBRyxHQUEyQixFQUFFLENBQUM7UUFDdkMsS0FBSyxNQUFNLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDN0UsSUFBSSxVQUFVLENBQUMsUUFBUSxDQUFDLElBQUEsbUNBQW9CLEVBQUMsTUFBTSxDQUFDLENBQUMs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O0tBQy9GO0lBRUQ7OztPQUdHO0lBQ0gsSUFBVyx3QkFBd0I7UUFDakMsT0FBTyxXQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsZUFBUSxDQUFDLG1CQUFtQixDQUFDLENBQUM7S0FDM0Q7SUFFRDs7T0FFRztJQUNILElBQVcsaUJBQWlCO1FBQzFCLE9BQU8sV0FBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLGVBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0tBQzNEO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksa0JBQWtCLENBQUMsSUFBWSxFQUFFLE9BQWUsRUFBRSxZQUFvQjtRQUMzRSxPQUFPLFdBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxlQUFRLENBQUMsZUFBZSxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQztLQUNwRjtJQUVEOzs7OztPQUtHO0lBQ0ksOEJBQThCLENBQUMsT0FBZSxFQUFFLFlBQW9CO1FBQ3pFLE9BQU8sV0FBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLGVBQVEsQ0FBQywyQkFBMkIsQ0FBQyxPQUFPLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQztLQUMxRjtJQUVEOztPQUVHO0lBQ0gsSUFBVyxhQUFhO1FBQ3RCLE9BQU8sV0FBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLGVBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0tBQ3hEOztBQXpNSCxnQ0EwTUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJ0aXRpb25JbmZvcm1hdGlvbiB9IGZyb20gJy4vYXdzLWVudGl0aWVzJztcbmltcG9ydCB7IEZhY3QsIEZhY3ROYW1lIH0gZnJvbSAnLi9mYWN0JztcblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBwZXJ0YWluaW5nIHRvIGFuIEFXUyByZWdpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWdpb25JbmZvIHtcbiAgLyoqXG4gICAqIEByZXR1cm5zIHRoZSBsaXN0IG9mIG5hbWVzIG9mIEFXUyByZWdpb25zIGZvciB3aGljaCB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgcmVnaXN0ZXJlZCBmYWN0LiBUaGlzXG4gICAqICAgICAgICAgIG1heSBub3QgYmUgYW4gZXhhdXN0aXZlIGxpc3Qgb2YgYWxsIGF2YWlsYWJsZSBBV1MgcmVnaW9ucy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZ2V0IHJlZ2lvbnMoKTogUmVnaW9uSW5mb1tdIHtcbiAgICByZXR1cm4gRmFjdC5yZWdpb25zLm1hcCh4ID0+IFJlZ2lvbkluZm8uZ2V0KHgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBjb2xsZWN0aW9uIG9mIGFsbCBmYWN0IHZhbHVlcyBmb3IgYWxsIHJlZ2lvbnMgdGhhdCBmYWN0IGlzIGRlZmluZWQgaW4uXG4gICAqXG4gICAqIEBwYXJhbSBmYWN0TmFtZSB0aGUgbmFtZSBvZiB0aGUgZmFjdCB0byByZXRyaWV2ZSB2YWx1ZXMgZm9yLlxuICAgKiAgIEZvciBhIGxpc3Qgb2YgY29tbW9uIGZhY3QgbmFtZXMsIHNlZSB0aGUgRmFjdE5hbWUgY2xhc3NcbiAgICogQHJldHVybnMgYSBtYXBwaW5nIHdpdGggQVdTIHJlZ2lvbiBjb2RlcyBhcyB0aGUga2V5cyxcbiAgICogICBhbmQgdGhlIGZhY3QgaW4gdGhlIGdpdmVuIHJlZ2lvbiBhcyB0aGUgdmFsdWUgZm9yIHRoYXQga2V5XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlZ2lvbk1hcChmYWN0TmFtZTogc3RyaW5nKTogeyBbcmVnaW9uOiBzdHJpbmddOiBzdHJpbmcgfSB7XG4gICAgY29uc3QgcmV0OiB7IFtyZWdpb246IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gICAgZm9yIChjb25zdCByZWdpb25JbmZvIG9mIFJlZ2lvbkluZm8ucmVnaW9ucykge1xuICAgICAgY29uc3QgZmFjdCA9IEZhY3QuZmluZChyZWdpb25JbmZvLm5hbWUsIGZhY3ROYW1lKTtcbiAgICAgIGlmIChmYWN0KSB7XG4gICAgICAgIHJldFtyZWdpb25JbmZvLm5hbWVdID0gZmFjdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBjb2xsZWN0aW9uIG9mIGFsbCBmYWN0IHZhbHVlcyBmb3IgYWxsIHJlZ2lvbnMsIGxpbWl0ZWQgdG8gc29tZSBwYXJ0aXRpb25zXG4gICAqXG4gICAqIEBwYXJhbSBmYWN0TmFtZSB0aGUgbmFtZSBvZiB0aGUgZmFjdCB0byByZXRyaWV2ZSB2YWx1ZXMgZm9yLlxuICAgKiAgIEZvciBhIGxpc3Qgb2YgY29tbW9uIGZhY3QgbmFtZXMsIHNlZSB0aGUgRmFjdE5hbWUgY2xhc3NcbiAgICogQHBhcmFtIHBhcnRpdGlvbnMgbGlzdCBvZiBwYXJ0aXRpb25zIHRvIHJldHJpZXZlIGZhY3RzIGZvci4gRGVmYXVsdHNcbiAgICogICB0byBgWydhd3MnLCAnYXdzLWNuJ11gLlxuICAgKiBAcmV0dXJucyBhIG1hcHBpbmcgd2l0aCBBV1MgcmVnaW9uIGNvZGVzIGFzIHRoZSBrZXlzLFxuICAgKiAgIGFuZCB0aGUgZmFjdCBpbiB0aGUgZ2l2ZW4gcmVnaW9uIGFzIHRoZSB2YWx1ZSBmb3IgdGhhdCBrZXlcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbGltaXRlZFJlZ2lvbk1hcChmYWN0TmFtZTogc3RyaW5nLCBwYXJ0aXRpb25zOiBzdHJpbmdbXSk6IHsgW3JlZ2lvbjogc3RyaW5nXTogc3RyaW5nIH0ge1xuICAgIGNvbnN0IHJldDogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICAgIGZvciAoY29uc3QgW3JlZ2lvbiwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKFJlZ2lvbkluZm8ucmVnaW9uTWFwKGZhY3ROYW1lKSkpIHtcbiAgICAgIGlmIChwYXJ0aXRpb25zLmluY2x1ZGVzKHBhcnRpdGlvbkluZm9ybWF0aW9uKHJlZ2lvbikucGFydGl0aW9uKSkge1xuICAgICAgICByZXRbcmVnaW9uXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIE9idGFpbiByZWdpb24gaW5mbyBmb3IgYSBnaXZlbiByZWdpb24gbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgb2YgdGhlIHJlZ2lvbiAoZS5nOiB1cy1lYXN0LTEpXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdldChuYW1lOiBzdHJpbmcpOiBSZWdpb25JbmZvIHtcbiAgICByZXR1cm4gbmV3IFJlZ2lvbkluZm8obmFtZSk7XG4gIH1cblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBuYW1lOiBzdHJpbmcpIHt9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGBBV1M6OkNESzo6TWV0YWRhdGFgIENsb3VkRm9ybWF0aW9uIFJlc291cmNlIGlzIGF2YWlsYWJsZSBpbiB0aGlzIHJlZ2lvbiBvciBub3QuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGNka01ldGFkYXRhUmVzb3VyY2VBdmFpbGFibGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIEZhY3QuZmluZCh0aGlzLm5hbWUsIEZhY3ROYW1lLkNES19NRVRBREFUQV9SRVNPVVJDRV9BVkFJTEFCTEUpID09PSAnWUVTJztcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBnaXZlbiByZWdpb24gaXMgYW4gb3B0LWluIHJlZ2lvblxuICAgKi9cbiAgcHVibGljIGdldCBpc09wdEluUmVnaW9uKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBGYWN0LmZpbmQodGhpcy5uYW1lLCBGYWN0TmFtZS5JU19PUFRfSU5fUkVHSU9OKSA9PT0gJ1lFUyc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRvbWFpbiBuYW1lIHN1ZmZpeCAoZS5nOiBhbWF6b25hd3MuY29tKSBmb3IgdGhpcyByZWdpb24uXG4gICAqL1xuICBwdWJsaWMgZ2V0IGRvbWFpblN1ZmZpeCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBGYWN0LmZpbmQodGhpcy5uYW1lLCBGYWN0TmFtZS5ET01BSU5fU1VGRklYKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgQVJOIHBhcnRpdGlvbiBmb3IgdGhpcyByZWdpb24gKGUuZzogYXdzKS5cbiAgICovXG4gIHB1YmxpYyBnZXQgcGFydGl0aW9uKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIEZhY3QuZmluZCh0aGlzLm5hbWUsIEZhY3ROYW1lLlBBUlRJVElPTik7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGVuZHBvaW50IHVzZWQgYnkgUzMgc3RhdGljIHdlYnNpdGUgaG9zdGluZyBpbiB0aGlzIHJlZ2lvbiAoZS5nOiBzMy1zdGF0aWMtd2Vic2l0ZS11cy1lYXN0LTEuYW1hem9uYXdzLmNvbSlcbiAgICovXG4gIHB1YmxpYyBnZXQgczNTdGF0aWNXZWJzaXRlRW5kcG9pbnQoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gRmFjdC5maW5kKHRoaXMubmFtZSwgRmFjdE5hbWUuUzNfU1RBVElDX1dFQlNJVEVfRU5EUE9JTlQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBob3N0ZWQgem9uZSBJRCB1c2VkIGJ5IFJvdXRlIDUzIHRvIGFsaWFzIGEgUzMgc3RhdGljIHdlYnNpdGUgaW4gdGhpcyByZWdpb24gKGUuZzogWjJPMUVNUk85SzVHTFgpXG4gICAqL1xuICBwdWJsaWMgZ2V0IHMzU3RhdGljV2Vic2l0ZUhvc3RlZFpvbmVJZCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBGYWN0LmZpbmQodGhpcy5uYW1lLCBGYWN0TmFtZS5TM19TVEFUSUNfV0VCU0lURV9aT05FXzUzX0hPU1RFRF9aT05FX0lEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaG9zdGVkIHpvbmUgSUQgdXNlZCBieSBSb3V0ZSA1MyB0byBhbGlhcyBhIEVCUyBlbnZpcm9ubWVudCBlbmRwb2ludCBpbiB0aGlzIHJlZ2lvbiAoZS5nOiBaMk8xRU1STzlLNUdMWClcbiAgICovXG4gIHB1YmxpYyBnZXQgZWJzRW52RW5kcG9pbnRIb3N0ZWRab25lSWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gRmFjdC5maW5kKHRoaXMubmFtZSwgRmFjdE5hbWUuRUJTX0VOVl9FTkRQT0lOVF9IT1NURURfWk9ORV9JRCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHByZWZpeCBmb3IgVlBDIEVuZHBvaW50IFNlcnZpY2UgbmFtZXMsXG4gICAqIGNuLmNvbS5hbWF6b25hd3MudnBjZSBmb3IgQ2hpbmEgcmVnaW9ucyxcbiAgICogY29tLmFtYXpvbmF3cy52cGNlIG90aGVyd2lzZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgdnBjRW5kcG9pbnRTZXJ2aWNlTmFtZVByZWZpeCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBGYWN0LmZpbmQodGhpcy5uYW1lLCBGYWN0TmFtZS5WUENfRU5EUE9JTlRfU0VSVklDRV9OQU1FX1BSRUZJWCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHNlcnZpY2UgcHJpbmNpcGFsIGZvciBhIGdpdmVuIHNlcnZpY2UgaW4gdGhpcyByZWdpb24uXG4gICAqIEBwYXJhbSBzZXJ2aWNlIHRoZSBzZXJ2aWNlIG5hbWUgKGUuZzogczMuYW1hem9uYXdzLmNvbSlcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgLSBVc2UgYGlhbS5TZXJ2aWNlUHJpbmNpcGFsLnNlcnZpY2VQcmluY2lwYWxOYW1lKClgIGluc3RlYWQuXG4gICAqL1xuICBwdWJsaWMgc2VydmljZVByaW5jaXBhbChzZXJ2aWNlOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBgJHtzZXJ2aWNlLnJlcGxhY2UoL1xcLmFtYXpvbmF3c1xcLmNvbShcXC5jbik/JC8sICcnKX0uYW1hem9uYXdzLmNvbWA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGFjY291bnQgSUQgZm9yIEVMQnYyIGluIHRoaXMgcmVnaW9uXG4gICAqL1xuICBwdWJsaWMgZ2V0IGVsYnYyQWNjb3VudCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBGYWN0LmZpbmQodGhpcy5uYW1lLCBGYWN0TmFtZS5FTEJWMl9BQ0NPVU5UKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIEFXUyBhY2NvdW50IHRoYXQgb3ducyB0aGUgcHVibGljIEVDUiByZXBvc2l0b3J5IGNvbnRhaW5pbmcgdGhlXG4gICAqIEFXUyBEZWVwIExlYXJuaW5nIENvbnRhaW5lcnMgaW1hZ2VzIGluIHRoaXMgcmVnaW9uLlxuICAgKi9cbiAgcHVibGljIGdldCBkbGNSZXBvc2l0b3J5QWNjb3VudCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBGYWN0LmZpbmQodGhpcy5uYW1lLCBGYWN0TmFtZS5ETENfUkVQT1NJVE9SWV9BQ0NPVU5UKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgQVJOIG9mIHRoZSBDbG91ZFdhdGNoIExhbWJkYSBJbnNpZ2h0cyBleHRlbnNpb24sIGZvciB0aGUgZ2l2ZW4gdmVyc2lvbi5cbiAgICogQHBhcmFtIGluc2lnaHRzVmVyc2lvbiB0aGUgdmVyc2lvbiAoZS5nLiAxLjAuOTguMClcbiAgICogQHBhcmFtIGFyY2hpdGVjdHVyZSB0aGUgTGFtYmRhIEZ1bmN0aW9uIGFyY2hpdGVjdHVyZSAoZS5nLiAneDg2XzY0JyBvciAnYXJtNjQnKVxuICAgKi9cbiAgcHVibGljIGNsb3Vkd2F0Y2hMYW1iZGFJbnNpZ2h0c0FybihpbnNpZ2h0c1ZlcnNpb246IHN0cmluZywgYXJjaGl0ZWN0dXJlPzogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gRmFjdC5maW5kKHRoaXMubmFtZSwgRmFjdE5hbWUuY2xvdWR3YXRjaExhbWJkYUluc2lnaHRzVmVyc2lvbihpbnNpZ2h0c1ZlcnNpb24sIGFyY2hpdGVjdHVyZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBBUk4gb2YgdGhlIEFwcENvbmZpZyBMYW1iZGEgTGF5ZXIsIGZvciB0aGUgZ2l2ZW4gdmVyc2lvbi5cbiAgICogQHBhcmFtIGxheWVyVmVyc2lvbiBUaGUgbGF5ZXIgdmVyc2lvbiAoZS5nLiAyLjAuMTgxKVxuICAgKiBAcGFyYW0gYXJjaGl0ZWN0dXJlIFRoZSBMYW1iZGEgRnVuY3Rpb24gYXJjaGl0ZWN0dXJlIChlLmcuICd4ODZfNjQnIG9yICdhcm02NCcpLCBkZWZhdWx0cyB0byB4ODZfNjRcbiAgICovXG4gIHB1YmxpYyBhcHBDb25maWdMYW1iZGFBcm4obGF5ZXJWZXJzaW9uOiBzdHJpbmcsIGFyY2hpdGVjdHVyZT86IHN0cmluZykgOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBGYWN0LmZpbmQodGhpcy5uYW1lLCBGYWN0TmFtZS5hcHBDb25maWdMYW1iZGFMYXllclZlcnNpb24obGF5ZXJWZXJzaW9uLCBhcmNoaXRlY3R1cmUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIEFXUyBhY2NvdW50IHRoYXQgb3ducyB0aGUgcHVibGljIEVDUiByZXBvc2l0b3J5IHRoYXQgY29udGFpbnMgdGhlXG4gICAqIEFXUyBBcHAgTWVzaCBFbnZveSBQcm94eSBpbWFnZXMgaW4gYSBnaXZlbiByZWdpb24uXG4gICAqL1xuICBwdWJsaWMgZ2V0IGFwcE1lc2hSZXBvc2l0b3J5QWNjb3VudCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBGYWN0LmZpbmQodGhpcy5uYW1lLCBGYWN0TmFtZS5BUFBNRVNIX0VDUl9BQ0NPVU5UKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgQ0lEUiBibG9jayB1c2VkIGJ5IEFtYXpvbiBEYXRhIEZpcmVob3NlIHNlcnZlcnMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGZpcmVob3NlQ2lkckJsb2NrKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIEZhY3QuZmluZCh0aGlzLm5hbWUsIEZhY3ROYW1lLkZJUkVIT1NFX0NJRFJfQkxPQ0spO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBBUk4gb2YgdGhlIEFET1QgTGFtYmRhIGxheWVyLCBmb3IgdGhlIGdpdmVuIGxheWVyIHR5cGUsIHZlcnNpb24gYW5kIGFyY2hpdGVjdHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgdGhlIHR5cGUgb2YgdGhlIEFET1QgbGFtYmRhIGxheWVyXG4gICAqIEBwYXJhbSB2ZXJzaW9uIHRoZSBsYXllciB2ZXJzaW9uLlxuICAgKiBAcGFyYW0gYXJjaGl0ZWN0dXJlIHRoZSBMYW1iZGEgRnVuY3Rpb24gYXJjaGl0ZWN0dXJlIChlLmcuICd4ODZfNjQnIG9yICdhcm02NCcpXG4gICAqL1xuICBwdWJsaWMgYWRvdExhbWJkYUxheWVyQXJuKHR5cGU6IHN0cmluZywgdmVyc2lvbjogc3RyaW5nLCBhcmNoaXRlY3R1cmU6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIEZhY3QuZmluZCh0aGlzLm5hbWUsIEZhY3ROYW1lLmFkb3RMYW1iZGFMYXllcih0eXBlLCB2ZXJzaW9uLCBhcmNoaXRlY3R1cmUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgQVJOIG9mIHRoZSBQYXJhbWV0ZXJzIGFuZCBTZWNyZXRzIExhbWJkYSBsYXllciBmb3IgdGhlIGdpdmVuIGxhbWJkYSBhcmNoaXRlY3R1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB2ZXJzaW9uIHRoZSBsYXllciB2ZXJzaW9uXG4gICAqIEBwYXJhbSBhcmNoaXRlY3R1cmUgdGhlIExhbWJkYSBGdW5jdGlvbiBhcmNoaXRlY3R1cmUgKGUuZy4gJ3g4Nl82NCcgb3IgJ2FybTY0JylcbiAgICovXG4gIHB1YmxpYyBwYXJhbXNBbmRTZWNyZXRzTGFtYmRhTGF5ZXJBcm4odmVyc2lvbjogc3RyaW5nLCBhcmNoaXRlY3R1cmU6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIEZhY3QuZmluZCh0aGlzLm5hbWUsIEZhY3ROYW1lLnBhcmFtc0FuZFNlY3JldHNMYW1iZGFMYXllcih2ZXJzaW9uLCBhcmNoaXRlY3R1cmUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTQU1MIFNpZ24gT24gVVJMIHVzZWQgYnkgSUFNIFNBTUwgUHJpbmNpcGFscy5cbiAgICovXG4gIHB1YmxpYyBnZXQgc2FtbFNpZ25PblVybCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBGYWN0LmZpbmQodGhpcy5uYW1lLCBGYWN0TmFtZS5TQU1MX1NJR05fT05fVVJMKTtcbiAgfVxufVxuIl19