declare const errorSym: unique symbol;
export type Result<A> = A | Failure;
export interface Failure {
    readonly [errorSym]: string;
}
export interface Fail {
    (error: string): Failure;
    in(prefix: string): Fail;
    locate<A>(x: Result<A>): Result<A>;
}
export interface failure extends Fail {
}
export declare function failure(error: string): Failure;
export declare namespace failure {
    var _a: (prefix: string) => Fail;
    export var locate: <A>(x: Result<A>) => Result<A>;
    export { _a as in };
}
export declare function isFailure<A>(x: Result<A>): x is Failure;
export declare function isSuccess<A>(x: Result<A>): x is A;
export declare function unpack<A>(x: Result<A>): A;
export declare function unpackOr<A, B>(x: Result<A>, def: B): B extends A ? A : A | B;
export declare function errorMessage(x: Failure): string;
export declare function errorFrom(x: Failure): Error;
export declare function assertSuccess<A>(x: Result<A>): asserts x is A;
export declare function assertSuccess(x: Failure): never;
export declare function tryCatch<A>(block: () => A): Result<A>;
export declare function tryCatch<A>(failFn: Fail, block: () => A): Result<A>;
export declare function using<A, B>(value: Result<A>, block: (x: A) => Result<B>): Result<B>;
/**
 * Like 'using', but can take any number of functions
 */
export declare function chain<A, B>(value: Result<A>, b0: (x: A) => Result<B>): Result<B>;
export declare function chain<A, B, C>(value: Result<A>, b0: (x: A) => Result<B>, b1: (x: B) => Result<C>): Result<C>;
export declare function chain<A, B, C, D>(value: Result<A>, b0: (x: A) => Result<B>, b1: (x: B) => Result<C>, b2: (x: C) => Result<D>): Result<D>;
export declare function chain<A, B, C, D, E>(value: Result<A>, b0: (x: A) => Result<B>, b1: (x: B) => Result<C>, b2: (x: C) => Result<D>, b3: (x: D) => Result<E>): Result<E>;
export declare function chain<A, B, C, D, E, F>(value: Result<A>, b0: (x: A) => Result<B>, b1: (x: B) => Result<C>, b2: (x: C) => Result<D>, b3: (x: D) => Result<E>, b4: (x: E) => Result<F>): Result<F>;
export declare function chain<A, B, C, D, E, F, G>(value: Result<A>, b0: (x: A) => Result<B>, b1: (x: B) => Result<C>, b2: (x: C) => Result<D>, b3: (x: D) => Result<E>, b4: (x: E) => Result<F>, b5: (x: F) => Result<G>): Result<G>;
/**
 * Make a function that will prepend a prefix to error messages
 *
 * This is one way to be specific about the location where errors originate, by prefixing
 * errors as the call stack unwinds.
 *
 * A different method is to pass in a modified failure function using `failure.in(...)`,
 * to build the error message as the call stack deepens.
 */
export declare function locateFailure(prefix: string): <A>(x: Result<A>) => Result<A>;
export type Failures = Array<Failure>;
export declare function liftResult<A>(xs: Record<string, Result<A>>): Result<Record<string, A>>;
export declare function liftResult<A>(xs: Array<Result<A>>): Result<Array<A>>;
/**
 * Lift a value that can be 'undefined' to a result, or a function that can return undefined.
 */
export declare function liftUndefined<A>(v: A | undefined): Result<NonNullable<A>>;
export declare function liftUndefined<A, F extends (...args: any[]) => A>(v: F): (x: Parameters<F>) => Result<NonNullable<A>>;
export {};
