"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParameterValues = exports.TemplateParameters = void 0;
exports.waitForChangeSet = waitForChangeSet;
exports.createDiffChangeSet = createDiffChangeSet;
exports.uploadStackTemplateAssets = uploadStackTemplateAssets;
exports.createChangeSet = createChangeSet;
exports.changeSetHasNoChanges = changeSetHasNoChanges;
exports.waitForStackDelete = waitForStackDelete;
exports.waitForStackDeploy = waitForStackDeploy;
exports.stabilizeStack = stabilizeStack;
const util_1 = require("util");
const cxapi = require("@aws-cdk/cx-api");
const cx_api_1 = require("@aws-cdk/cx-api");
const client_cloudformation_1 = require("@aws-sdk/client-cloudformation");
const cdk_assets_1 = require("cdk-assets");
const asset_manifest_builder_1 = require("./asset-manifest-builder");
const toolkit_error_1 = require("../../toolkit/toolkit-error");
const cloudformation_1 = require("../cloudformation");
/**
 * Describe a changeset in CloudFormation, regardless of its current state.
 *
 * @param cfn           - a CloudFormation client
 * @param stackName     - the name of the Stack the ChangeSet belongs to
 * @param changeSetName - the name of the ChangeSet
 * @param fetchAll      - if true, fetches all pages of the change set description.
 *
 * @returns       CloudFormation information about the ChangeSet
 */
async function describeChangeSet(cfn, stackName, changeSetName, { fetchAll }) {
    const response = await cfn.describeChangeSet({
        StackName: stackName,
        ChangeSetName: changeSetName,
    });
    // If fetchAll is true, traverse all pages from the change set description.
    while (fetchAll && response.NextToken != null) {
        const nextPage = await cfn.describeChangeSet({
            StackName: stackName,
            ChangeSetName: response.ChangeSetId ?? changeSetName,
            NextToken: response.NextToken,
        });
        // Consolidate the changes
        if (nextPage.Changes != null) {
            response.Changes = response.Changes != null ? response.Changes.concat(nextPage.Changes) : nextPage.Changes;
        }
        // Forward the new NextToken
        response.NextToken = nextPage.NextToken;
    }
    return response;
}
/**
 * Waits for a function to return non-+undefined+ before returning.
 *
 * @param valueProvider - a function that will return a value that is not +undefined+ once the wait should be over
 * @param timeout     - the time to wait between two calls to +valueProvider+
 *
 * @returns       the value that was returned by +valueProvider+
 */
async function waitFor(valueProvider, timeout = 5000) {
    while (true) {
        const result = await valueProvider();
        if (result === null) {
            return undefined;
        }
        else if (result !== undefined) {
            return result;
        }
        await new Promise((cb) => setTimeout(cb, timeout));
    }
}
/**
 * Waits for a ChangeSet to be available for triggering a StackUpdate.
 *
 * Will return a changeset that is either ready to be executed or has no changes.
 * Will throw in other cases.
 *
 * @param cfn           - a CloudFormation client
 * @param stackName     - the name of the Stack that the ChangeSet belongs to
 * @param changeSetName - the name of the ChangeSet
 * @param fetchAll      - if true, fetches all pages of the ChangeSet before returning.
 *
 * @returns       the CloudFormation description of the ChangeSet
 */
async function waitForChangeSet(cfn, ioHelper, stackName, changeSetName, { fetchAll }) {
    await ioHelper.defaults.debug((0, util_1.format)('Waiting for changeset %s on stack %s to finish creating...', changeSetName, stackName));
    const ret = await waitFor(async () => {
        const description = await describeChangeSet(cfn, stackName, changeSetName, {
            fetchAll,
        });
        // The following doesn't use a switch because tsc will not allow fall-through, UNLESS it is allows
        // EVERYWHERE that uses this library directly or indirectly, which is undesirable.
        if (description.Status === 'CREATE_PENDING' || description.Status === 'CREATE_IN_PROGRESS') {
            await ioHelper.defaults.debug((0, util_1.format)('Changeset %s on stack %s is still creating', changeSetName, stackName));
            return undefined;
        }
        if (description.Status === client_cloudformation_1.ChangeSetStatus.CREATE_COMPLETE || changeSetHasNoChanges(description)) {
            return description;
        }
        // eslint-disable-next-line @stylistic/max-len
        throw new toolkit_error_1.ToolkitError(`Failed to create ChangeSet ${changeSetName} on ${stackName}: ${description.Status || 'NO_STATUS'}, ${description.StatusReason || 'no reason provided'}`);
    });
    if (!ret) {
        throw new toolkit_error_1.ToolkitError('Change set took too long to be created; aborting');
    }
    return ret;
}
/**
 * Create a changeset for a diff operation
 */
async function createDiffChangeSet(ioHelper, options) {
    // `options.stack` has been modified to include any nested stack templates directly inline with its own template, under a special `NestedTemplate` property.
    // Thus the parent template's Resources section contains the nested template's CDK metadata check, which uses Fn::Equals.
    // This causes CreateChangeSet to fail with `Template Error: Fn::Equals cannot be partially collapsed`.
    for (const resource of Object.values(options.stack.template.Resources ?? {})) {
        if (resource.Type === 'AWS::CloudFormation::Stack') {
            await ioHelper.defaults.debug('This stack contains one or more nested stacks, falling back to template-only diff...');
            return undefined;
        }
    }
    return uploadBodyParameterAndCreateChangeSet(ioHelper, options);
}
/**
 * Returns all file entries from an AssetManifestArtifact that look like templates.
 *
 * This is used in the `uploadBodyParameterAndCreateChangeSet` function to find
 * all template asset files to build and publish.
 *
 * Returns a tuple of [AssetManifest, FileManifestEntry[]]
 */
function templatesFromAssetManifestArtifact(artifact) {
    const assets = [];
    const fileName = artifact.file;
    const assetManifest = cdk_assets_1.AssetManifest.fromFile(fileName);
    assetManifest.entries.forEach((entry) => {
        if (entry.type === 'file') {
            const source = entry.source;
            if (source.path && source.path.endsWith('.template.json')) {
                assets.push(entry);
            }
        }
    });
    return [assetManifest, assets];
}
async function uploadBodyParameterAndCreateChangeSet(ioHelper, options) {
    try {
        await uploadStackTemplateAssets(options.stack, options.deployments);
        const env = await options.deployments.envs.accessStackForMutableStackOperations(options.stack);
        const bodyParameter = await (0, cloudformation_1.makeBodyParameter)(ioHelper, options.stack, env.resolvedEnvironment, new asset_manifest_builder_1.AssetManifestBuilder(), env.resources);
        const cfn = env.sdk.cloudFormation();
        const exists = (await cloudformation_1.CloudFormationStack.lookup(cfn, options.stack.stackName, false)).exists;
        const executionRoleArn = await env.replacePlaceholders(options.stack.cloudFormationExecutionRoleArn);
        await ioHelper.defaults.info('Hold on while we create a read-only change set to get a diff with accurate replacement information (use --no-change-set to use a less accurate but faster template-only diff)\n');
        return await createChangeSet(ioHelper, {
            cfn,
            changeSetName: 'cdk-diff-change-set',
            stack: options.stack,
            exists,
            uuid: options.uuid,
            willExecute: options.willExecute,
            bodyParameter,
            parameters: options.parameters,
            resourcesToImport: options.resourcesToImport,
            importExistingResources: options.importExistingResources,
            role: executionRoleArn,
        });
    }
    catch (e) {
        // This function is currently only used by diff so these messages are diff-specific
        if (!options.failOnError) {
            await ioHelper.defaults.debug(String(e));
            await ioHelper.defaults.info('Could not create a change set, will base the diff on template differences (run again with -v to see the reason)\n');
            return undefined;
        }
        throw new toolkit_error_1.ToolkitError('Could not create a change set and failOnError is set. (run again with failOnError off to base the diff on template differences)\n', e);
    }
}
/**
 * Uploads the assets that look like templates for this CloudFormation stack
 *
 * This is necessary for any CloudFormation call that needs the template, it may need
 * to be uploaded to an S3 bucket first. We have to follow the instructions in the
 * asset manifest, because technically that is the only place that knows about
 * bucket and assumed roles and such.
 */
async function uploadStackTemplateAssets(stack, deployments) {
    for (const artifact of stack.dependencies) {
        // Skip artifact if it is not an Asset Manifest Artifact
        if (!cxapi.AssetManifestArtifact.isAssetManifestArtifact(artifact)) {
            continue;
        }
        const [assetManifest, file_entries] = templatesFromAssetManifestArtifact(artifact);
        for (const entry of file_entries) {
            await deployments.buildSingleAsset(artifact, assetManifest, entry, {
                stack,
            });
            await deployments.publishSingleAsset(assetManifest, entry, {
                stack,
            });
        }
    }
}
async function createChangeSet(ioHelper, options) {
    await cleanupOldChangeset(options.cfn, ioHelper, options.changeSetName, options.stack.stackName);
    await ioHelper.defaults.debug(`Attempting to create ChangeSet with name ${options.changeSetName} for stack ${options.stack.stackName}`);
    const templateParams = TemplateParameters.fromTemplate(options.stack.template);
    const stackParams = templateParams.supplyAll(options.parameters);
    const changeSet = await options.cfn.createChangeSet({
        StackName: options.stack.stackName,
        ChangeSetName: options.changeSetName,
        ChangeSetType: options.resourcesToImport ? 'IMPORT' : options.exists ? 'UPDATE' : 'CREATE',
        Description: `CDK Changeset for diff ${options.uuid}`,
        ClientToken: `diff${options.uuid}`,
        TemplateURL: options.bodyParameter.TemplateURL,
        TemplateBody: options.bodyParameter.TemplateBody,
        Parameters: stackParams.apiParameters,
        ResourcesToImport: options.resourcesToImport,
        ImportExistingResources: options.importExistingResources,
        RoleARN: options.role,
        Tags: toCfnTags(options.stack.tags),
        Capabilities: ['CAPABILITY_IAM', 'CAPABILITY_NAMED_IAM', 'CAPABILITY_AUTO_EXPAND'],
    });
    await ioHelper.defaults.debug((0, util_1.format)('Initiated creation of changeset: %s; waiting for it to finish creating...', changeSet.Id));
    // Fetching all pages if we'll execute, so we can have the correct change count when monitoring.
    const createdChangeSet = await waitForChangeSet(options.cfn, ioHelper, options.stack.stackName, options.changeSetName, {
        fetchAll: options.willExecute,
    });
    await cleanupOldChangeset(options.cfn, ioHelper, options.changeSetName, options.stack.stackName);
    return createdChangeSet;
}
function toCfnTags(tags) {
    return Object.entries(tags).map(([k, v]) => ({
        Key: k,
        Value: v,
    }));
}
async function cleanupOldChangeset(cfn, ioHelper, changeSetName, stackName) {
    // Delete any existing change sets generated by CDK since change set names must be unique.
    // The delete request is successful as long as the stack exists (even if the change set does not exist).
    await ioHelper.defaults.debug(`Removing existing change set with name ${changeSetName} if it exists`);
    await cfn.deleteChangeSet({
        StackName: stackName,
        ChangeSetName: changeSetName,
    });
}
/**
 * Return true if the given change set has no changes
 *
 * This must be determined from the status, not the 'Changes' array on the
 * object; the latter can be empty because no resources were changed, but if
 * there are changes to Outputs, the change set can still be executed.
 */
function changeSetHasNoChanges(description) {
    const noChangeErrorPrefixes = [
        // Error message for a regular template
        "The submitted information didn't contain changes.",
        // Error message when a Transform is involved (see #10650)
        'No updates are to be performed.',
    ];
    return (description.Status === 'FAILED' && noChangeErrorPrefixes.some((p) => (description.StatusReason ?? '').startsWith(p)));
}
/**
 * Waits for a CloudFormation stack to stabilize in a complete/available state
 * after a delete operation is issued.
 *
 * Fails if the stack is in a FAILED state. Will not fail if the stack was
 * already deleted.
 *
 * @param cfn        - a CloudFormation client
 * @param stackName      - the name of the stack to wait for after a delete
 *
 * @returns     the CloudFormation description of the stabilized stack after the delete attempt
 */
async function waitForStackDelete(cfn, ioHelper, stackName) {
    const stack = await stabilizeStack(cfn, ioHelper, stackName);
    if (!stack) {
        return undefined;
    }
    const status = stack.stackStatus;
    if (status.isFailure) {
        throw new toolkit_error_1.ToolkitError(`The stack named ${stackName} is in a failed state. You may need to delete it from the AWS console : ${status}`);
    }
    else if (status.isDeleted) {
        return undefined;
    }
    return stack;
}
/**
 * Waits for a CloudFormation stack to stabilize in a complete/available state
 * after an update/create operation is issued.
 *
 * Fails if the stack is in a FAILED state, ROLLBACK state, or DELETED state.
 *
 * @param cfn        - a CloudFormation client
 * @param stackName      - the name of the stack to wait for after an update
 *
 * @returns     the CloudFormation description of the stabilized stack after the update attempt
 */
async function waitForStackDeploy(cfn, ioHelper, stackName) {
    const stack = await stabilizeStack(cfn, ioHelper, stackName);
    if (!stack) {
        return undefined;
    }
    const status = stack.stackStatus;
    if (status.isCreationFailure) {
        throw new toolkit_error_1.ToolkitError(`The stack named ${stackName} failed creation, it may need to be manually deleted from the AWS console: ${status}`);
    }
    else if (!status.isDeploySuccess) {
        throw new toolkit_error_1.ToolkitError(`The stack named ${stackName} failed to deploy: ${status}`);
    }
    return stack;
}
/**
 * Wait for a stack to become stable (no longer _IN_PROGRESS), returning it
 */
async function stabilizeStack(cfn, ioHelper, stackName) {
    await ioHelper.defaults.debug((0, util_1.format)('Waiting for stack %s to finish creating or updating...', stackName));
    return waitFor(async () => {
        const stack = await cloudformation_1.CloudFormationStack.lookup(cfn, stackName);
        if (!stack.exists) {
            await ioHelper.defaults.debug((0, util_1.format)('Stack %s does not exist', stackName));
            return null;
        }
        const status = stack.stackStatus;
        if (status.isInProgress) {
            await ioHelper.defaults.debug((0, util_1.format)('Stack %s has an ongoing operation in progress and is not stable (%s)', stackName, status));
            return undefined;
        }
        else if (status.isReviewInProgress) {
            // This may happen if a stack creation operation is interrupted before the ChangeSet execution starts. Recovering
            // from this would requiring manual intervention (deleting or executing the pending ChangeSet), and failing to do
            // so will result in an endless wait here (the ChangeSet wont delete or execute itself). Instead of blocking
            // "forever" we proceed as if the stack was existing and stable. If there is a concurrent operation that just
            // hasn't finished proceeding just yet, either this operation or the concurrent one may fail due to the other one
            // having made progress. Which is fine. I guess.
            await ioHelper.defaults.debug((0, util_1.format)('Stack %s is in REVIEW_IN_PROGRESS state. Considering this is a stable status (%s)', stackName, status));
        }
        return stack;
    });
}
/**
 * The set of (formal) parameters that have been declared in a template
 */
class TemplateParameters {
    params;
    static fromTemplate(template) {
        return new TemplateParameters(template.Parameters || {});
    }
    constructor(params) {
        this.params = params;
    }
    /**
     * Calculate stack parameters to pass from the given desired parameter values
     *
     * Will throw if parameters without a Default value or a Previous value are not
     * supplied.
     */
    supplyAll(updates) {
        return new ParameterValues(this.params, updates);
    }
    /**
     * From the template, the given desired values and the current values, calculate the changes to the stack parameters
     *
     * Will take into account parameters already set on the template (will emit
     * 'UsePreviousValue: true' for those unless the value is changed), and will
     * throw if parameters without a Default value or a Previous value are not
     * supplied.
     */
    updateExisting(updates, previousValues) {
        return new ParameterValues(this.params, updates, previousValues);
    }
}
exports.TemplateParameters = TemplateParameters;
/**
 * The set of parameters we're going to pass to a Stack
 */
class ParameterValues {
    formalParams;
    values = {};
    apiParameters = [];
    constructor(formalParams, updates, previousValues = {}) {
        this.formalParams = formalParams;
        const missingRequired = new Array();
        for (const [key, formalParam] of Object.entries(this.formalParams)) {
            // Check updates first, then use the previous value (if available), then use
            // the default (if available).
            //
            // If we don't find a parameter value using any of these methods, then that's an error.
            const updatedValue = updates[key];
            if (updatedValue !== undefined) {
                this.values[key] = updatedValue;
                this.apiParameters.push({
                    ParameterKey: key,
                    ParameterValue: updates[key],
                });
                continue;
            }
            if (key in previousValues) {
                this.values[key] = previousValues[key];
                this.apiParameters.push({ ParameterKey: key, UsePreviousValue: true });
                continue;
            }
            if (formalParam.Default !== undefined) {
                this.values[key] = formalParam.Default;
                continue;
            }
            // Oh no
            missingRequired.push(key);
        }
        if (missingRequired.length > 0) {
            throw new toolkit_error_1.ToolkitError(`The following CloudFormation Parameters are missing a value: ${missingRequired.join(', ')}`);
        }
        // Just append all supplied overrides that aren't really expected (this
        // will fail CFN but maybe people made typos that they want to be notified
        // of)
        const unknownParam = ([key, _]) => this.formalParams[key] === undefined;
        const hasValue = ([_, value]) => !!value;
        for (const [key, value] of Object.entries(updates).filter(unknownParam).filter(hasValue)) {
            this.values[key] = value;
            this.apiParameters.push({ ParameterKey: key, ParameterValue: value });
        }
    }
    /**
     * Whether this set of parameter updates will change the actual stack values
     */
    hasChanges(currentValues) {
        // If any of the parameters are SSM parameters, deploying must always happen
        // because we can't predict what the values will be. We will allow some
        // parameters to opt out of this check by having a magic string in their description.
        if (Object.values(this.formalParams).some((p) => p.Type.startsWith('AWS::SSM::Parameter::') && !p.Description?.includes(cx_api_1.SSMPARAM_NO_INVALIDATE))) {
            return 'ssm';
        }
        // Otherwise we're dirty if:
        // - any of the existing values are removed, or changed
        if (Object.entries(currentValues).some(([key, value]) => !(key in this.values) || value !== this.values[key])) {
            return true;
        }
        // - any of the values we're setting are new
        if (Object.keys(this.values).some((key) => !(key in currentValues))) {
            return true;
        }
        return false;
    }
}
exports.ParameterValues = ParameterValues;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2ZuLWFwaS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNmbi1hcGkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBb0dBLDRDQWtDQztBQXFDRCxrREFnQkM7QUF1RkQsOERBaUJDO0FBRUQsMENBbUNDO0FBK0JELHNEQVdDO0FBY0QsZ0RBbUJDO0FBYUQsZ0RBcUJDO0FBS0Qsd0NBNEJDO0FBdGRELCtCQUE4QjtBQUM5Qix5Q0FBeUM7QUFDekMsNENBQXlEO0FBT3pELDBFQUV3QztBQUV4QywyQ0FBMkM7QUFDM0MscUVBQWdFO0FBRWhFLCtEQUEyRDtBQUczRCxzREFBMkU7QUFJM0U7Ozs7Ozs7OztHQVNHO0FBQ0gsS0FBSyxVQUFVLGlCQUFpQixDQUM5QixHQUEwQixFQUMxQixTQUFpQixFQUNqQixhQUFxQixFQUNyQixFQUFFLFFBQVEsRUFBeUI7SUFFbkMsTUFBTSxRQUFRLEdBQUcsTUFBTSxHQUFHLENBQUMsaUJBQWlCLENBQUM7UUFDM0MsU0FBUyxFQUFFLFNBQVM7UUFDcEIsYUFBYSxFQUFFLGFBQWE7S0FDN0IsQ0FBQyxDQUFDO0lBRUgsMkVBQTJFO0lBQzNFLE9BQU8sUUFBUSxJQUFJLFFBQVEsQ0FBQyxTQUFTLElBQUksSUFBSSxFQUFFLENBQUM7UUFDOUMsTUFBTSxRQUFRLEdBQUcsTUFBTSxHQUFHLENBQUMsaUJBQWlCLENBQUM7WUFDM0MsU0FBUyxFQUFFLFNBQVM7WUFDcEIsYUFBYSxFQUFFLFFBQVEsQ0FBQyxXQUFXLElBQUksYUFBYTtZQUNwRCxTQUFTLEVBQUUsUUFBUSxDQUFDLFNBQVM7U0FDOUIsQ0FBQyxDQUFDO1FBRUgsMEJBQTBCO1FBQzFCLElBQUksUUFBUSxDQUFDLE9BQU8sSUFBSSxJQUFJLEVBQUUsQ0FBQztZQUM3QixRQUFRLENBQUMsT0FBTyxHQUFHLFFBQVEsQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FB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QUFDLHVCQUF1QixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLFFBQVEsQ0FBQywrQkFBc0IsQ0FBQyxDQUN0RyxFQUNELENBQUM7WUFDRCxPQUFPLEtBQUssQ0FBQztRQUNmLENBQUM7UUFFRCw0QkFBNEI7UUFDNUIsdURBQXVEO1FBQ3ZELElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksS0FBSyxLQUFLLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQzlHLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVELDRDQUE0QztRQUM1QyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxhQUFhLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDcEUsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0NBQ0Y7QUFwRkQsMENBb0ZDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAndXRpbCc7XG5pbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHsgU1NNUEFSQU1fTk9fSU5WQUxJREFURSB9IGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgdHlwZSB7XG4gIERlc2NyaWJlQ2hhbmdlU2V0Q29tbWFuZE91dHB1dCxcbiAgUGFyYW1ldGVyLFxuICBSZXNvdXJjZVRvSW1wb3J0LFxuICBUYWcsXG59IGZyb20gJ0Bhd3Mtc2RrL2NsaWVudC1jbG91ZGZvcm1hdGlvbic7XG5pbXBvcnQge1xuICBDaGFuZ2VTZXRTdGF0dXMsXG59IGZyb20gJ0Bhd3Mtc2RrL2NsaWVudC1jbG91ZGZvcm1hdGlvbic7XG5pbXBvcnQgdHlwZSB7IEZpbGVNYW5pZmVzdEVudHJ5IH0gZnJvbSAnY2RrLWFzc2V0cyc7XG5pbXBvcnQgeyBBc3NldE1hbmlmZXN0IH0gZnJvbSAnY2RrLWFzc2V0cyc7XG5pbXBvcnQgeyBBc3NldE1hbmlmZXN0QnVpbGRlciB9IGZyb20gJy4vYXNzZXQtbWFuaWZlc3QtYnVpbGRlcic7XG5pbXBvcnQgdHlwZSB7IERlcGxveW1lbnRzIH0gZnJvbSAnLi9kZXBsb3ltZW50cyc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuLi8uLi90b29sa2l0L3Rvb2xraXQtZXJyb3InO1xuaW1wb3J0IHR5cGUgeyBJQ2xvdWRGb3JtYXRpb25DbGllbnQsIFNka1Byb3ZpZGVyIH0gZnJvbSAnLi4vYXdzLWF1dGgvcHJpdmF0ZSc7XG5pbXBvcnQgdHlwZSB7IFRlbXBsYXRlLCBUZW1wbGF0ZUJvZHlQYXJhbWV0ZXIsIFRlbXBsYXRlUGFyYW1ldGVyIH0gZnJvbSAnLi4vY2xvdWRmb3JtYXRpb24nO1xuaW1wb3J0IHsgQ2xvdWRGb3JtYXRpb25TdGFjaywgbWFrZUJvZHlQYXJhbWV0ZXIgfSBmcm9tICcuLi9jbG91ZGZvcm1hdGlvbic7XG5pbXBvcnQgdHlwZSB7IElvSGVscGVyIH0gZnJvbSAnLi4vaW8vcHJpdmF0ZSc7XG5pbXBvcnQgdHlwZSB7IFJlc291cmNlc1RvSW1wb3J0IH0gZnJvbSAnLi4vcmVzb3VyY2UtaW1wb3J0JztcblxuLyoqXG4gKiBEZXNjcmliZSBhIGNoYW5nZXNldCBpbiBDbG91ZEZvcm1hdGlvbiwgcmVnYXJkbGVzcyBvZiBpdHMgY3VycmVudCBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0gY2ZuICAgICAgICAgICAtIGEgQ2xvdWRGb3JtYXRpb24gY2xpZW50XG4gKiBAcGFyYW0gc3RhY2tOYW1lICAgICAtIHRoZSBuYW1lIG9mIHRoZSBTdGFjayB0aGUgQ2hhbmdlU2V0IGJlbG9uZ3MgdG9cbiAqIEBwYXJhbSBjaGFuZ2VTZXROYW1lIC0gdGhlIG5hbWUgb2YgdGhlIENoYW5nZVNldFxuICogQHBhcmFtIGZldGNoQWxsICAgICAgLSBpZiB0cnVlLCBmZXRjaGVzIGFsbCBwYWdlcyBvZiB0aGUgY2hhbmdlIHNldCBkZXNjcmlwdGlvbi5cbiAqXG4gKiBAcmV0dXJucyAgICAgICBDbG91ZEZvcm1hdGlvbiBpbmZvcm1hdGlvbiBhYm91dCB0aGUgQ2hhbmdlU2V0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlc2NyaWJlQ2hhbmdlU2V0KFxuICBjZm46IElDbG91ZEZvcm1hdGlvbkNsaWVudCxcbiAgc3RhY2tOYW1lOiBzdHJpbmcsXG4gIGNoYW5nZVNldE5hbWU6IHN0cmluZyxcbiAgeyBmZXRjaEFsbCB9OiB7IGZldGNoQWxsOiBib29sZWFuIH0sXG4pOiBQcm9taXNlPERlc2NyaWJlQ2hhbmdlU2V0Q29tbWFuZE91dHB1dD4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNmbi5kZXNjcmliZUNoYW5nZVNldCh7XG4gICAgU3RhY2tOYW1lOiBzdGFja05hbWUsXG4gICAgQ2hhbmdlU2V0TmFtZTogY2hhbmdlU2V0TmFtZSxcbiAgfSk7XG5cbiAgLy8gSWYgZmV0Y2hBbGwgaXMgdHJ1ZSwgdHJhdmVyc2UgYWxsIHBhZ2VzIGZyb20gdGhlIGNoYW5nZSBzZXQgZGVzY3JpcHRpb24uXG4gIHdoaWxlIChmZXRjaEFsbCAmJiByZXNwb25zZS5OZXh0VG9rZW4gIT0gbnVsbCkge1xuICAgIGNvbnN0IG5leHRQYWdlID0gYXdhaXQgY2ZuLmRlc2NyaWJlQ2hhbmdlU2V0KHtcbiAgICAgIFN0YWNrTmFtZTogc3RhY2tOYW1lLFxuICAgICAgQ2hhbmdlU2V0TmFtZTogcmVzcG9uc2UuQ2hhbmdlU2V0SWQgPz8gY2hhbmdlU2V0TmFtZSxcbiAgICAgIE5leHRUb2tlbjogcmVzcG9uc2UuTmV4dFRva2VuLFxuICAgIH0pO1xuXG4gICAgLy8gQ29uc29saWRhdGUgdGhlIGNoYW5nZXNcbiAgICBpZiAobmV4dFBhZ2UuQ2hhbmdlcyAhPSBudWxsKSB7XG4gICAgICByZXNwb25zZS5DaGFuZ2VzID0gcmVzcG9uc2UuQ2hhbmdlcyAhPSBudWxsID8gcmVzcG9uc2UuQ2hhbmdlcy5jb25jYXQobmV4dFBhZ2UuQ2hhbmdlcykgOiBuZXh0UGFnZS5DaGFuZ2VzO1xuICAgIH1cblxuICAgIC8vIEZvcndhcmQgdGhlIG5ldyBOZXh0VG9rZW5cbiAgICByZXNwb25zZS5OZXh0VG9rZW4gPSBuZXh0UGFnZS5OZXh0VG9rZW47XG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2U7XG59XG5cbi8qKlxuICogV2FpdHMgZm9yIGEgZnVuY3Rpb24gdG8gcmV0dXJuIG5vbi0rdW5kZWZpbmVkKyBiZWZvcmUgcmV0dXJuaW5nLlxuICpcbiAqIEBwYXJhbSB2YWx1ZVByb3ZpZGVyIC0gYSBmdW5jdGlvbiB0aGF0IHdpbGwgcmV0dXJuIGEgdmFsdWUgdGhhdCBpcyBub3QgK3VuZGVmaW5lZCsgb25jZSB0aGUgd2FpdCBzaG91bGQgYmUgb3ZlclxuICogQHBhcmFtIHRpbWVvdXQgICAgIC0gdGhlIHRpbWUgdG8gd2FpdCBiZXR3ZWVuIHR3byBjYWxscyB0byArdmFsdWVQcm92aWRlcitcbiAqXG4gKiBAcmV0dXJucyAgICAgICB0aGUgdmFsdWUgdGhhdCB3YXMgcmV0dXJuZWQgYnkgK3ZhbHVlUHJvdmlkZXIrXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHdhaXRGb3I8VD4oXG4gIHZhbHVlUHJvdmlkZXI6ICgpID0+IFByb21pc2U8VCB8IG51bGwgfCB1bmRlZmluZWQ+LFxuICB0aW1lb3V0OiBudW1iZXIgPSA1MDAwLFxuKTogUHJvbWlzZTxUIHwgdW5kZWZpbmVkPiB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsdWVQcm92aWRlcigpO1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKGNiKSA9PiBzZXRUaW1lb3V0KGNiLCB0aW1lb3V0KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXYWl0cyBmb3IgYSBDaGFuZ2VTZXQgdG8gYmUgYXZhaWxhYmxlIGZvciB0cmlnZ2VyaW5nIGEgU3RhY2tVcGRhdGUuXG4gKlxuICogV2lsbCByZXR1cm4gYSBjaGFuZ2VzZXQgdGhhdCBpcyBlaXRoZXIgcmVhZHkgdG8gYmUgZXhlY3V0ZWQgb3IgaGFzIG5vIGNoYW5nZXMuXG4gKiBXaWxsIHRocm93IGluIG90aGVyIGNhc2VzLlxuICpcbiAqIEBwYXJhbSBjZm4gICAgICAgICAgIC0gYSBDbG91ZEZvcm1hdGlvbiBjbGllbnRcbiAqIEBwYXJhbSBzdGFja05hbWUgICAgIC0gdGhlIG5hbWUgb2YgdGhlIFN0YWNrIHRoYXQgdGhlIENoYW5nZVNldCBiZWxvbmdzIHRvXG4gKiBAcGFyYW0gY2hhbmdlU2V0TmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBDaGFuZ2VTZXRcbiAqIEBwYXJhbSBmZXRjaEFsbCAgICAgIC0gaWYgdHJ1ZSwgZmV0Y2hlcyBhbGwgcGFnZXMgb2YgdGhlIENoYW5nZVNldCBiZWZvcmUgcmV0dXJuaW5nLlxuICpcbiAqIEByZXR1cm5zICAgICAgIHRoZSBDbG91ZEZvcm1hdGlvbiBkZXNjcmlwdGlvbiBvZiB0aGUgQ2hhbmdlU2V0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3YWl0Rm9yQ2hhbmdlU2V0KFxuICBjZm46IElDbG91ZEZvcm1hdGlvbkNsaWVudCxcbiAgaW9IZWxwZXI6IElvSGVscGVyLFxuICBzdGFja05hbWU6IHN0cmluZyxcbiAgY2hhbmdlU2V0TmFtZTogc3RyaW5nLFxuICB7IGZldGNoQWxsIH06IHsgZmV0Y2hBbGw6IGJvb2xlYW4gfSxcbik6IFByb21pc2U8RGVzY3JpYmVDaGFuZ2VTZXRDb21tYW5kT3V0cHV0PiB7XG4gIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLmRlYnVnKGZvcm1hdCgnV2FpdGluZyBmb3IgY2hhbmdlc2V0ICVzIG9uIHN0YWNrICVzIHRvIGZpbmlzaCBjcmVhdGluZy4uLicsIGNoYW5nZVNldE5hbWUsIHN0YWNrTmFtZSkpO1xuICBjb25zdCByZXQgPSBhd2FpdCB3YWl0Rm9yKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGF3YWl0IGRlc2NyaWJlQ2hhbmdlU2V0KGNmbiwgc3RhY2tOYW1lLCBjaGFuZ2VTZXROYW1lLCB7XG4gICAgICBmZXRjaEFsbCxcbiAgICB9KTtcbiAgICAvLyBUaGUgZm9sbG93aW5nIGRvZXNuJ3QgdXNlIGEgc3dpdGNoIGJlY2F1c2UgdHNjIHdpbGwgbm90IGFsbG93IGZhbGwtdGhyb3VnaCwgVU5MRVNTIGl0IGlzIGFsbG93c1xuICAgIC8vIEVWRVJZV0hFUkUgdGhhdCB1c2VzIHRoaXMgbGlicmFyeSBkaXJlY3RseSBvciBpbmRpcmVjdGx5LCB3aGljaCBpcyB1bmRlc2lyYWJsZS5cbiAgICBpZiAoZGVzY3JpcHRpb24uU3RhdHVzID09PSAnQ1JFQVRFX1BFTkRJTkcnIHx8IGRlc2NyaXB0aW9uLlN0YXR1cyA9PT0gJ0NSRUFURV9JTl9QUk9HUkVTUycpIHtcbiAgICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLmRlYnVnKGZvcm1hdCgnQ2hhbmdlc2V0ICVzIG9uIHN0YWNrICVzIGlzIHN0aWxsIGNyZWF0aW5nJywgY2hhbmdlU2V0TmFtZSwgc3RhY2tOYW1lKSk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChkZXNjcmlwdGlvbi5TdGF0dXMgPT09IENoYW5nZVNldFN0YXR1cy5DUkVBVEVfQ09NUExFVEUgfHwgY2hhbmdlU2V0SGFzTm9DaGFuZ2VzKGRlc2NyaXB0aW9uKSkge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAc3R5bGlzdGljL21heC1sZW5cbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKFxuICAgICAgYEZhaWxlZCB0byBjcmVhdGUgQ2hhbmdlU2V0ICR7Y2hhbmdlU2V0TmFtZX0gb24gJHtzdGFja05hbWV9OiAke2Rlc2NyaXB0aW9uLlN0YXR1cyB8fCAnTk9fU1RBVFVTJ30sICR7ZGVzY3JpcHRpb24uU3RhdHVzUmVhc29uIHx8ICdubyByZWFzb24gcHJvdmlkZWQnfWAsXG4gICAgKTtcbiAgfSk7XG5cbiAgaWYgKCFyZXQpIHtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKCdDaGFuZ2Ugc2V0IHRvb2sgdG9vIGxvbmcgdG8gYmUgY3JlYXRlZDsgYWJvcnRpbmcnKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmV4cG9ydCB0eXBlIFByZXBhcmVDaGFuZ2VTZXRPcHRpb25zID0ge1xuICBzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0O1xuICBkZXBsb3ltZW50czogRGVwbG95bWVudHM7XG4gIHV1aWQ6IHN0cmluZztcbiAgd2lsbEV4ZWN1dGU6IGJvb2xlYW47XG4gIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcjtcbiAgcGFyYW1ldGVyczogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH07XG4gIHJlc291cmNlc1RvSW1wb3J0PzogUmVzb3VyY2VzVG9JbXBvcnQ7XG4gIGltcG9ydEV4aXN0aW5nUmVzb3VyY2VzPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIERlZmF1bHQgYmVoYXZpb3IgaXMgdG8gbG9nIEFXUyBDbG91ZEZvcm1hdGlvbiBlcnJvcnMgYW5kIG1vdmUgb24uIFNldCB0aGlzIHByb3BlcnR5IHRvIHRydWUgdG8gaW5zdGVhZFxuICAgKiBmYWlsIG9uIGVycm9ycyByZWNlaXZlZCBieSBBV1MgQ2xvdWRGb3JtYXRpb24uXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBmYWlsT25FcnJvcj86IGJvb2xlYW47XG59O1xuXG5leHBvcnQgdHlwZSBDcmVhdGVDaGFuZ2VTZXRPcHRpb25zID0ge1xuICBjZm46IElDbG91ZEZvcm1hdGlvbkNsaWVudDtcbiAgY2hhbmdlU2V0TmFtZTogc3RyaW5nO1xuICB3aWxsRXhlY3V0ZTogYm9vbGVhbjtcbiAgZXhpc3RzOiBib29sZWFuO1xuICB1dWlkOiBzdHJpbmc7XG4gIHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q7XG4gIGJvZHlQYXJhbWV0ZXI6IFRlbXBsYXRlQm9keVBhcmFtZXRlcjtcbiAgcGFyYW1ldGVyczogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH07XG4gIHJlc291cmNlc1RvSW1wb3J0PzogUmVzb3VyY2VUb0ltcG9ydFtdO1xuICBpbXBvcnRFeGlzdGluZ1Jlc291cmNlcz86IGJvb2xlYW47XG4gIHJvbGU/OiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGNoYW5nZXNldCBmb3IgYSBkaWZmIG9wZXJhdGlvblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlRGlmZkNoYW5nZVNldChcbiAgaW9IZWxwZXI6IElvSGVscGVyLFxuICBvcHRpb25zOiBQcmVwYXJlQ2hhbmdlU2V0T3B0aW9ucyxcbik6IFByb21pc2U8RGVzY3JpYmVDaGFuZ2VTZXRDb21tYW5kT3V0cHV0IHwgdW5kZWZpbmVkPiB7XG4gIC8vIGBvcHRpb25zLnN0YWNrYCBoYXMgYmVlbiBtb2RpZmllZCB0byBpbmNsdWRlIGFueSBuZXN0ZWQgc3RhY2sgdGVtcGxhdGVzIGRpcmVjdGx5IGlubGluZSB3aXRoIGl0cyBvd24gdGVtcGxhdGUsIHVuZGVyIGEgc3BlY2lhbCBgTmVzdGVkVGVtcGxhdGVgIHByb3BlcnR5LlxuICAvLyBUaHVzIHRoZSBwYXJlbnQgdGVtcGxhdGUncyBSZXNvdXJjZXMgc2VjdGlvbiBjb250YWlucyB0aGUgbmVzdGVkIHRlbXBsYXRlJ3MgQ0RLIG1ldGFkYXRhIGNoZWNrLCB3aGljaCB1c2VzIEZuOjpFcXVhbHMuXG4gIC8vIFRoaXMgY2F1c2VzIENyZWF0ZUNoYW5nZVNldCB0byBmYWlsIHdpdGggYFRlbXBsYXRlIEVycm9yOiBGbjo6RXF1YWxzIGNhbm5vdCBiZSBwYXJ0aWFsbHkgY29sbGFwc2VkYC5cbiAgZm9yIChjb25zdCByZXNvdXJjZSBvZiBPYmplY3QudmFsdWVzKG9wdGlvbnMuc3RhY2sudGVtcGxhdGUuUmVzb3VyY2VzID8/IHt9KSkge1xuICAgIGlmICgocmVzb3VyY2UgYXMgYW55KS5UeXBlID09PSAnQVdTOjpDbG91ZEZvcm1hdGlvbjo6U3RhY2snKSB7XG4gICAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy5kZWJ1ZygnVGhpcyBzdGFjayBjb250YWlucyBvbmUgb3IgbW9yZSBuZXN0ZWQgc3RhY2tzLCBmYWxsaW5nIGJhY2sgdG8gdGVtcGxhdGUtb25seSBkaWZmLi4uJyk7XG5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVwbG9hZEJvZHlQYXJhbWV0ZXJBbmRDcmVhdGVDaGFuZ2VTZXQoaW9IZWxwZXIsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYWxsIGZpbGUgZW50cmllcyBmcm9tIGFuIEFzc2V0TWFuaWZlc3RBcnRpZmFjdCB0aGF0IGxvb2sgbGlrZSB0ZW1wbGF0ZXMuXG4gKlxuICogVGhpcyBpcyB1c2VkIGluIHRoZSBgdXBsb2FkQm9keVBhcmFtZXRlckFuZENyZWF0ZUNoYW5nZVNldGAgZnVuY3Rpb24gdG8gZmluZFxuICogYWxsIHRlbXBsYXRlIGFzc2V0IGZpbGVzIHRvIGJ1aWxkIGFuZCBwdWJsaXNoLlxuICpcbiAqIFJldHVybnMgYSB0dXBsZSBvZiBbQXNzZXRNYW5pZmVzdCwgRmlsZU1hbmlmZXN0RW50cnlbXV1cbiAqL1xuZnVuY3Rpb24gdGVtcGxhdGVzRnJvbUFzc2V0TWFuaWZlc3RBcnRpZmFjdChcbiAgYXJ0aWZhY3Q6IGN4YXBpLkFzc2V0TWFuaWZlc3RBcnRpZmFjdCxcbik6IFtBc3NldE1hbmlmZXN0LCBGaWxlTWFuaWZlc3RFbnRyeVtdXSB7XG4gIGNvbnN0IGFzc2V0czogRmlsZU1hbmlmZXN0RW50cnlbXSA9IFtdO1xuICBjb25zdCBmaWxlTmFtZSA9IGFydGlmYWN0LmZpbGU7XG4gIGNvbnN0IGFzc2V0TWFuaWZlc3QgPSBBc3NldE1hbmlmZXN0LmZyb21GaWxlKGZpbGVOYW1lKTtcblxuICBhc3NldE1hbmlmZXN0LmVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICBpZiAoZW50cnkudHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSAoZW50cnkgYXMgRmlsZU1hbmlmZXN0RW50cnkpLnNvdXJjZTtcbiAgICAgIGlmIChzb3VyY2UucGF0aCAmJiBzb3VyY2UucGF0aC5lbmRzV2l0aCgnLnRlbXBsYXRlLmpzb24nKSkge1xuICAgICAgICBhc3NldHMucHVzaChlbnRyeSBhcyBGaWxlTWFuaWZlc3RFbnRyeSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFthc3NldE1hbmlmZXN0LCBhc3NldHNdO1xufVxuXG5hc3luYyBmdW5jdGlvbiB1cGxvYWRCb2R5UGFyYW1ldGVyQW5kQ3JlYXRlQ2hhbmdlU2V0KFxuICBpb0hlbHBlcjogSW9IZWxwZXIsXG4gIG9wdGlvbnM6IFByZXBhcmVDaGFuZ2VTZXRPcHRpb25zLFxuKTogUHJvbWlzZTxEZXNjcmliZUNoYW5nZVNldENvbW1hbmRPdXRwdXQgfCB1bmRlZmluZWQ+IHtcbiAgdHJ5IHtcbiAgICBhd2FpdCB1cGxvYWRTdGFja1RlbXBsYXRlQXNzZXRzKG9wdGlvbnMuc3RhY2ssIG9wdGlvbnMuZGVwbG95bWVudHMpO1xuICAgIGNvbnN0IGVudiA9IGF3YWl0IG9wdGlvbnMuZGVwbG95bWVudHMuZW52cy5hY2Nlc3NTdGFja0Zvck11dGFibGVTdGFja09wZXJhdGlvbnMob3B0aW9ucy5zdGFjayk7XG5cbiAgICBjb25zdCBib2R5UGFyYW1ldGVyID0gYXdhaXQgbWFrZUJvZHlQYXJhbWV0ZXIoXG4gICAgICBpb0hlbHBlcixcbiAgICAgIG9wdGlvbnMuc3RhY2ssXG4gICAgICBlbnYucmVzb2x2ZWRFbnZpcm9ubWVudCxcbiAgICAgIG5ldyBBc3NldE1hbmlmZXN0QnVpbGRlcigpLFxuICAgICAgZW52LnJlc291cmNlcyxcbiAgICApO1xuICAgIGNvbnN0IGNmbiA9IGVudi5zZGsuY2xvdWRGb3JtYXRpb24oKTtcbiAgICBjb25zdCBleGlzdHMgPSAoYXdhaXQgQ2xvdWRGb3JtYXRpb25TdGFjay5sb29rdXAoY2ZuLCBvcHRpb25zLnN0YWNrLnN0YWNrTmFtZSwgZmFsc2UpKS5leGlzdHM7XG5cbiAgICBjb25zdCBleGVjdXRpb25Sb2xlQXJuID0gYXdhaXQgZW52LnJlcGxhY2VQbGFjZWhvbGRlcnMob3B0aW9ucy5zdGFjay5jbG91ZEZvcm1hdGlvbkV4ZWN1dGlvblJvbGVBcm4pO1xuICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLmluZm8oXG4gICAgICAnSG9sZCBvbiB3aGlsZSB3ZSBjcmVhdGUgYSByZWFkLW9ubHkgY2hhbmdlIHNldCB0byBnZXQgYSBkaWZmIHdpdGggYWNjdXJhdGUgcmVwbGFjZW1lbnQgaW5mb3JtYXRpb24gKHVzZSAtLW5vLWNoYW5nZS1zZXQgdG8gdXNlIGEgbGVzcyBhY2N1cmF0ZSBidXQgZmFzdGVyIHRlbXBsYXRlLW9ubHkgZGlmZilcXG4nLFxuICAgICk7XG5cbiAgICByZXR1cm4gYXdhaXQgY3JlYXRlQ2hhbmdlU2V0KGlvSGVscGVyLCB7XG4gICAgICBjZm4sXG4gICAgICBjaGFuZ2VTZXROYW1lOiAnY2RrLWRpZmYtY2hhbmdlLXNldCcsXG4gICAgICBzdGFjazogb3B0aW9ucy5zdGFjayxcbiAgICAgIGV4aXN0cyxcbiAgICAgIHV1aWQ6IG9wdGlvbnMudXVpZCxcbiAgICAgIHdpbGxFeGVjdXRlOiBvcHRpb25zLndpbGxFeGVjdXRlLFxuICAgICAgYm9keVBhcmFtZXRlcixcbiAgICAgIHBhcmFtZXRlcnM6IG9wdGlvbnMucGFyYW1ldGVycyxcbiAgICAgIHJlc291cmNlc1RvSW1wb3J0OiBvcHRpb25zLnJlc291cmNlc1RvSW1wb3J0LFxuICAgICAgaW1wb3J0RXhpc3RpbmdSZXNvdXJjZXM6IG9wdGlvbnMuaW1wb3J0RXhpc3RpbmdSZXNvdXJjZXMsXG4gICAgICByb2xlOiBleGVjdXRpb25Sb2xlQXJuLFxuICAgIH0pO1xuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGN1cnJlbnRseSBvbmx5IHVzZWQgYnkgZGlmZiBzbyB0aGVzZSBtZXNzYWdlcyBhcmUgZGlmZi1zcGVjaWZpY1xuICAgIGlmICghb3B0aW9ucy5mYWlsT25FcnJvcikge1xuICAgICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMuZGVidWcoU3RyaW5nKGUpKTtcbiAgICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLmluZm8oXG4gICAgICAgICdDb3VsZCBub3QgY3JlYXRlIGEgY2hhbmdlIHNldCwgd2lsbCBiYXNlIHRoZSBkaWZmIG9uIHRlbXBsYXRlIGRpZmZlcmVuY2VzIChydW4gYWdhaW4gd2l0aCAtdiB0byBzZWUgdGhlIHJlYXNvbilcXG4nLFxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKCdDb3VsZCBub3QgY3JlYXRlIGEgY2hhbmdlIHNldCBhbmQgZmFpbE9uRXJyb3IgaXMgc2V0LiAocnVuIGFnYWluIHdpdGggZmFpbE9uRXJyb3Igb2ZmIHRvIGJhc2UgdGhlIGRpZmYgb24gdGVtcGxhdGUgZGlmZmVyZW5jZXMpXFxuJywgZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBVcGxvYWRzIHRoZSBhc3NldHMgdGhhdCBsb29rIGxpa2UgdGVtcGxhdGVzIGZvciB0aGlzIENsb3VkRm9ybWF0aW9uIHN0YWNrXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgZm9yIGFueSBDbG91ZEZvcm1hdGlvbiBjYWxsIHRoYXQgbmVlZHMgdGhlIHRlbXBsYXRlLCBpdCBtYXkgbmVlZFxuICogdG8gYmUgdXBsb2FkZWQgdG8gYW4gUzMgYnVja2V0IGZpcnN0LiBXZSBoYXZlIHRvIGZvbGxvdyB0aGUgaW5zdHJ1Y3Rpb25zIGluIHRoZVxuICogYXNzZXQgbWFuaWZlc3QsIGJlY2F1c2UgdGVjaG5pY2FsbHkgdGhhdCBpcyB0aGUgb25seSBwbGFjZSB0aGF0IGtub3dzIGFib3V0XG4gKiBidWNrZXQgYW5kIGFzc3VtZWQgcm9sZXMgYW5kIHN1Y2guXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGxvYWRTdGFja1RlbXBsYXRlQXNzZXRzKHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QsIGRlcGxveW1lbnRzOiBEZXBsb3ltZW50cykge1xuICBmb3IgKGNvbnN0IGFydGlmYWN0IG9mIHN0YWNrLmRlcGVuZGVuY2llcykge1xuICAgIC8vIFNraXAgYXJ0aWZhY3QgaWYgaXQgaXMgbm90IGFuIEFzc2V0IE1hbmlmZXN0IEFydGlmYWN0XG4gICAgaWYgKCFjeGFwaS5Bc3NldE1hbmlmZXN0QXJ0aWZhY3QuaXNBc3NldE1hbmlmZXN0QXJ0aWZhY3QoYXJ0aWZhY3QpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBbYXNzZXRNYW5pZmVzdCwgZmlsZV9lbnRyaWVzXSA9IHRlbXBsYXRlc0Zyb21Bc3NldE1hbmlmZXN0QXJ0aWZhY3QoYXJ0aWZhY3QpO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZmlsZV9lbnRyaWVzKSB7XG4gICAgICBhd2FpdCBkZXBsb3ltZW50cy5idWlsZFNpbmdsZUFzc2V0KGFydGlmYWN0LCBhc3NldE1hbmlmZXN0LCBlbnRyeSwge1xuICAgICAgICBzdGFjayxcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgZGVwbG95bWVudHMucHVibGlzaFNpbmdsZUFzc2V0KGFzc2V0TWFuaWZlc3QsIGVudHJ5LCB7XG4gICAgICAgIHN0YWNrLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVDaGFuZ2VTZXQoXG4gIGlvSGVscGVyOiBJb0hlbHBlcixcbiAgb3B0aW9uczogQ3JlYXRlQ2hhbmdlU2V0T3B0aW9ucyxcbik6IFByb21pc2U8RGVzY3JpYmVDaGFuZ2VTZXRDb21tYW5kT3V0cHV0PiB7XG4gIGF3YWl0IGNsZWFudXBPbGRDaGFuZ2VzZXQob3B0aW9ucy5jZm4sIGlvSGVscGVyLCBvcHRpb25zLmNoYW5nZVNldE5hbWUsIG9wdGlvbnMuc3RhY2suc3RhY2tOYW1lKTtcblxuICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy5kZWJ1ZyhgQXR0ZW1wdGluZyB0byBjcmVhdGUgQ2hhbmdlU2V0IHdpdGggbmFtZSAke29wdGlvbnMuY2hhbmdlU2V0TmFtZX0gZm9yIHN0YWNrICR7b3B0aW9ucy5zdGFjay5zdGFja05hbWV9YCk7XG5cbiAgY29uc3QgdGVtcGxhdGVQYXJhbXMgPSBUZW1wbGF0ZVBhcmFtZXRlcnMuZnJvbVRlbXBsYXRlKG9wdGlvbnMuc3RhY2sudGVtcGxhdGUpO1xuICBjb25zdCBzdGFja1BhcmFtcyA9IHRlbXBsYXRlUGFyYW1zLnN1cHBseUFsbChvcHRpb25zLnBhcmFtZXRlcnMpO1xuXG4gIGNvbnN0IGNoYW5nZVNldCA9IGF3YWl0IG9wdGlvbnMuY2ZuLmNyZWF0ZUNoYW5nZVNldCh7XG4gICAgU3RhY2tOYW1lOiBvcHRpb25zLnN0YWNrLnN0YWNrTmFtZSxcbiAgICBDaGFuZ2VTZXROYW1lOiBvcHRpb25zLmNoYW5nZVNldE5hbWUsXG4gICAgQ2hhbmdlU2V0VHlwZTogb3B0aW9ucy5yZXNvdXJjZXNUb0ltcG9ydCA/ICdJTVBPUlQnIDogb3B0aW9ucy5leGlzdHMgPyAnVVBEQVRFJyA6ICdDUkVBVEUnLFxuICAgIERlc2NyaXB0aW9uOiBgQ0RLIENoYW5nZXNldCBmb3IgZGlmZiAke29wdGlvbnMudXVpZH1gLFxuICAgIENsaWVudFRva2VuOiBgZGlmZiR7b3B0aW9ucy51dWlkfWAsXG4gICAgVGVtcGxhdGVVUkw6IG9wdGlvbnMuYm9keVBhcmFtZXRlci5UZW1wbGF0ZVVSTCxcbiAgICBUZW1wbGF0ZUJvZHk6IG9wdGlvbnMuYm9keVBhcmFtZXRlci5UZW1wbGF0ZUJvZHksXG4gICAgUGFyYW1ldGVyczogc3RhY2tQYXJhbXMuYXBpUGFyYW1ldGVycyxcbiAgICBSZXNvdXJjZXNUb0ltcG9ydDogb3B0aW9ucy5yZXNvdXJjZXNUb0ltcG9ydCxcbiAgICBJbXBvcnRFeGlzdGluZ1Jlc291cmNlczogb3B0aW9ucy5pbXBvcnRFeGlzdGluZ1Jlc291cmNlcyxcbiAgICBSb2xlQVJOOiBvcHRpb25zLnJvbGUsXG4gICAgVGFnczogdG9DZm5UYWdzKG9wdGlvbnMuc3RhY2sudGFncyksXG4gICAgQ2FwYWJpbGl0aWVzOiBbJ0NBUEFCSUxJVFlfSUFNJywgJ0NBUEFCSUxJVFlfTkFNRURfSUFNJywgJ0NBUEFCSUxJVFlfQVVUT19FWFBBTkQnXSxcbiAgfSk7XG5cbiAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMuZGVidWcoZm9ybWF0KCdJbml0aWF0ZWQgY3JlYXRpb24gb2YgY2hhbmdlc2V0OiAlczsgd2FpdGluZyBmb3IgaXQgdG8gZmluaXNoIGNyZWF0aW5nLi4uJywgY2hhbmdlU2V0LklkKSk7XG4gIC8vIEZldGNoaW5nIGFsbCBwYWdlcyBpZiB3ZSdsbCBleGVjdXRlLCBzbyB3ZSBjYW4gaGF2ZSB0aGUgY29ycmVjdCBjaGFuZ2UgY291bnQgd2hlbiBtb25pdG9yaW5nLlxuICBjb25zdCBjcmVhdGVkQ2hhbmdlU2V0ID0gYXdhaXQgd2FpdEZvckNoYW5nZVNldChvcHRpb25zLmNmbiwgaW9IZWxwZXIsIG9wdGlvbnMuc3RhY2suc3RhY2tOYW1lLCBvcHRpb25zLmNoYW5nZVNldE5hbWUsIHtcbiAgICBmZXRjaEFsbDogb3B0aW9ucy53aWxsRXhlY3V0ZSxcbiAgfSk7XG4gIGF3YWl0IGNsZWFudXBPbGRDaGFuZ2VzZXQob3B0aW9ucy5jZm4sIGlvSGVscGVyLCBvcHRpb25zLmNoYW5nZVNldE5hbWUsIG9wdGlvbnMuc3RhY2suc3RhY2tOYW1lKTtcblxuICByZXR1cm4gY3JlYXRlZENoYW5nZVNldDtcbn1cblxuZnVuY3Rpb24gdG9DZm5UYWdzKHRhZ3M6IHsgW2lkOiBzdHJpbmddOiBzdHJpbmcgfSk6IFRhZ1tdIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRhZ3MpLm1hcCgoW2ssIHZdKSA9PiAoe1xuICAgIEtleTogayxcbiAgICBWYWx1ZTogdixcbiAgfSkpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjbGVhbnVwT2xkQ2hhbmdlc2V0KFxuICBjZm46IElDbG91ZEZvcm1hdGlvbkNsaWVudCxcbiAgaW9IZWxwZXI6IElvSGVscGVyLFxuICBjaGFuZ2VTZXROYW1lOiBzdHJpbmcsXG4gIHN0YWNrTmFtZTogc3RyaW5nLFxuKSB7XG4gIC8vIERlbGV0ZSBhbnkgZXhpc3RpbmcgY2hhbmdlIHNldHMgZ2VuZXJhdGVkIGJ5IENESyBzaW5jZSBjaGFuZ2Ugc2V0IG5hbWVzIG11c3QgYmUgdW5pcXVlLlxuICAvLyBUaGUgZGVsZXRlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bCBhcyBsb25nIGFzIHRoZSBzdGFjayBleGlzdHMgKGV2ZW4gaWYgdGhlIGNoYW5nZSBzZXQgZG9lcyBub3QgZXhpc3QpLlxuICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy5kZWJ1ZyhgUmVtb3ZpbmcgZXhpc3RpbmcgY2hhbmdlIHNldCB3aXRoIG5hbWUgJHtjaGFuZ2VTZXROYW1lfSBpZiBpdCBleGlzdHNgKTtcbiAgYXdhaXQgY2ZuLmRlbGV0ZUNoYW5nZVNldCh7XG4gICAgU3RhY2tOYW1lOiBzdGFja05hbWUsXG4gICAgQ2hhbmdlU2V0TmFtZTogY2hhbmdlU2V0TmFtZSxcbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIGdpdmVuIGNoYW5nZSBzZXQgaGFzIG5vIGNoYW5nZXNcbiAqXG4gKiBUaGlzIG11c3QgYmUgZGV0ZXJtaW5lZCBmcm9tIHRoZSBzdGF0dXMsIG5vdCB0aGUgJ0NoYW5nZXMnIGFycmF5IG9uIHRoZVxuICogb2JqZWN0OyB0aGUgbGF0dGVyIGNhbiBiZSBlbXB0eSBiZWNhdXNlIG5vIHJlc291cmNlcyB3ZXJlIGNoYW5nZWQsIGJ1dCBpZlxuICogdGhlcmUgYXJlIGNoYW5nZXMgdG8gT3V0cHV0cywgdGhlIGNoYW5nZSBzZXQgY2FuIHN0aWxsIGJlIGV4ZWN1dGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hhbmdlU2V0SGFzTm9DaGFuZ2VzKGRlc2NyaXB0aW9uOiBEZXNjcmliZUNoYW5nZVNldENvbW1hbmRPdXRwdXQpIHtcbiAgY29uc3Qgbm9DaGFuZ2VFcnJvclByZWZpeGVzID0gW1xuICAgIC8vIEVycm9yIG1lc3NhZ2UgZm9yIGEgcmVndWxhciB0ZW1wbGF0ZVxuICAgIFwiVGhlIHN1Ym1pdHRlZCBpbmZvcm1hdGlvbiBkaWRuJ3QgY29udGFpbiBjaGFuZ2VzLlwiLFxuICAgIC8vIEVycm9yIG1lc3NhZ2Ugd2hlbiBhIFRyYW5zZm9ybSBpcyBpbnZvbHZlZCAoc2VlICMxMDY1MClcbiAgICAnTm8gdXBkYXRlcyBhcmUgdG8gYmUgcGVyZm9ybWVkLicsXG4gIF07XG5cbiAgcmV0dXJuIChcbiAgICBkZXNjcmlwdGlvbi5TdGF0dXMgPT09ICdGQUlMRUQnICYmIG5vQ2hhbmdlRXJyb3JQcmVmaXhlcy5zb21lKChwKSA9PiAoZGVzY3JpcHRpb24uU3RhdHVzUmVhc29uID8/ICcnKS5zdGFydHNXaXRoKHApKVxuICApO1xufVxuXG4vKipcbiAqIFdhaXRzIGZvciBhIENsb3VkRm9ybWF0aW9uIHN0YWNrIHRvIHN0YWJpbGl6ZSBpbiBhIGNvbXBsZXRlL2F2YWlsYWJsZSBzdGF0ZVxuICogYWZ0ZXIgYSBkZWxldGUgb3BlcmF0aW9uIGlzIGlzc3VlZC5cbiAqXG4gKiBGYWlscyBpZiB0aGUgc3RhY2sgaXMgaW4gYSBGQUlMRUQgc3RhdGUuIFdpbGwgbm90IGZhaWwgaWYgdGhlIHN0YWNrIHdhc1xuICogYWxyZWFkeSBkZWxldGVkLlxuICpcbiAqIEBwYXJhbSBjZm4gICAgICAgIC0gYSBDbG91ZEZvcm1hdGlvbiBjbGllbnRcbiAqIEBwYXJhbSBzdGFja05hbWUgICAgICAtIHRoZSBuYW1lIG9mIHRoZSBzdGFjayB0byB3YWl0IGZvciBhZnRlciBhIGRlbGV0ZVxuICpcbiAqIEByZXR1cm5zICAgICB0aGUgQ2xvdWRGb3JtYXRpb24gZGVzY3JpcHRpb24gb2YgdGhlIHN0YWJpbGl6ZWQgc3RhY2sgYWZ0ZXIgdGhlIGRlbGV0ZSBhdHRlbXB0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3YWl0Rm9yU3RhY2tEZWxldGUoXG4gIGNmbjogSUNsb3VkRm9ybWF0aW9uQ2xpZW50LFxuICBpb0hlbHBlcjogSW9IZWxwZXIsXG4gIHN0YWNrTmFtZTogc3RyaW5nLFxuKTogUHJvbWlzZTxDbG91ZEZvcm1hdGlvblN0YWNrIHwgdW5kZWZpbmVkPiB7XG4gIGNvbnN0IHN0YWNrID0gYXdhaXQgc3RhYmlsaXplU3RhY2soY2ZuLCBpb0hlbHBlciwgc3RhY2tOYW1lKTtcbiAgaWYgKCFzdGFjaykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBzdGF0dXMgPSBzdGFjay5zdGFja1N0YXR1cztcbiAgaWYgKHN0YXR1cy5pc0ZhaWx1cmUpIHtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKFxuICAgICAgYFRoZSBzdGFjayBuYW1lZCAke3N0YWNrTmFtZX0gaXMgaW4gYSBmYWlsZWQgc3RhdGUuIFlvdSBtYXkgbmVlZCB0byBkZWxldGUgaXQgZnJvbSB0aGUgQVdTIGNvbnNvbGUgOiAke3N0YXR1c31gLFxuICAgICk7XG4gIH0gZWxzZSBpZiAoc3RhdHVzLmlzRGVsZXRlZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHN0YWNrO1xufVxuXG4vKipcbiAqIFdhaXRzIGZvciBhIENsb3VkRm9ybWF0aW9uIHN0YWNrIHRvIHN0YWJpbGl6ZSBpbiBhIGNvbXBsZXRlL2F2YWlsYWJsZSBzdGF0ZVxuICogYWZ0ZXIgYW4gdXBkYXRlL2NyZWF0ZSBvcGVyYXRpb24gaXMgaXNzdWVkLlxuICpcbiAqIEZhaWxzIGlmIHRoZSBzdGFjayBpcyBpbiBhIEZBSUxFRCBzdGF0ZSwgUk9MTEJBQ0sgc3RhdGUsIG9yIERFTEVURUQgc3RhdGUuXG4gKlxuICogQHBhcmFtIGNmbiAgICAgICAgLSBhIENsb3VkRm9ybWF0aW9uIGNsaWVudFxuICogQHBhcmFtIHN0YWNrTmFtZSAgICAgIC0gdGhlIG5hbWUgb2YgdGhlIHN0YWNrIHRvIHdhaXQgZm9yIGFmdGVyIGFuIHVwZGF0ZVxuICpcbiAqIEByZXR1cm5zICAgICB0aGUgQ2xvdWRGb3JtYXRpb24gZGVzY3JpcHRpb24gb2YgdGhlIHN0YWJpbGl6ZWQgc3RhY2sgYWZ0ZXIgdGhlIHVwZGF0ZSBhdHRlbXB0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3YWl0Rm9yU3RhY2tEZXBsb3koXG4gIGNmbjogSUNsb3VkRm9ybWF0aW9uQ2xpZW50LFxuICBpb0hlbHBlcjogSW9IZWxwZXIsXG4gIHN0YWNrTmFtZTogc3RyaW5nLFxuKTogUHJvbWlzZTxDbG91ZEZvcm1hdGlvblN0YWNrIHwgdW5kZWZpbmVkPiB7XG4gIGNvbnN0IHN0YWNrID0gYXdhaXQgc3RhYmlsaXplU3RhY2soY2ZuLCBpb0hlbHBlciwgc3RhY2tOYW1lKTtcbiAgaWYgKCFzdGFjaykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBzdGF0dXMgPSBzdGFjay5zdGFja1N0YXR1cztcblxuICBpZiAoc3RhdHVzLmlzQ3JlYXRpb25GYWlsdXJlKSB7XG4gICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihcbiAgICAgIGBUaGUgc3RhY2sgbmFtZWQgJHtzdGFja05hbWV9IGZhaWxlZCBjcmVhdGlvbiwgaXQgbWF5IG5lZWQgdG8gYmUgbWFudWFsbHkgZGVsZXRlZCBmcm9tIHRoZSBBV1MgY29uc29sZTogJHtzdGF0dXN9YCxcbiAgICApO1xuICB9IGVsc2UgaWYgKCFzdGF0dXMuaXNEZXBsb3lTdWNjZXNzKSB7XG4gICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgVGhlIHN0YWNrIG5hbWVkICR7c3RhY2tOYW1lfSBmYWlsZWQgdG8gZGVwbG95OiAke3N0YXR1c31gKTtcbiAgfVxuXG4gIHJldHVybiBzdGFjaztcbn1cblxuLyoqXG4gKiBXYWl0IGZvciBhIHN0YWNrIHRvIGJlY29tZSBzdGFibGUgKG5vIGxvbmdlciBfSU5fUFJPR1JFU1MpLCByZXR1cm5pbmcgaXRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0YWJpbGl6ZVN0YWNrKFxuICBjZm46IElDbG91ZEZvcm1hdGlvbkNsaWVudCxcbiAgaW9IZWxwZXI6IElvSGVscGVyLFxuICBzdGFja05hbWU6IHN0cmluZyxcbikge1xuICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy5kZWJ1Zyhmb3JtYXQoJ1dhaXRpbmcgZm9yIHN0YWNrICVzIHRvIGZpbmlzaCBjcmVhdGluZyBvciB1cGRhdGluZy4uLicsIHN0YWNrTmFtZSkpO1xuICByZXR1cm4gd2FpdEZvcihhc3luYyAoKSA9PiB7XG4gICAgY29uc3Qgc3RhY2sgPSBhd2FpdCBDbG91ZEZvcm1hdGlvblN0YWNrLmxvb2t1cChjZm4sIHN0YWNrTmFtZSk7XG4gICAgaWYgKCFzdGFjay5leGlzdHMpIHtcbiAgICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLmRlYnVnKGZvcm1hdCgnU3RhY2sgJXMgZG9lcyBub3QgZXhpc3QnLCBzdGFja05hbWUpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzdGF0dXMgPSBzdGFjay5zdGFja1N0YXR1cztcbiAgICBpZiAoc3RhdHVzLmlzSW5Qcm9ncmVzcykge1xuICAgICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMuZGVidWcoZm9ybWF0KCdTdGFjayAlcyBoYXMgYW4gb25nb2luZyBvcGVyYXRpb24gaW4gcHJvZ3Jlc3MgYW5kIGlzIG5vdCBzdGFibGUgKCVzKScsIHN0YWNrTmFtZSwgc3RhdHVzKSk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAoc3RhdHVzLmlzUmV2aWV3SW5Qcm9ncmVzcykge1xuICAgICAgLy8gVGhpcyBtYXkgaGFwcGVuIGlmIGEgc3RhY2sgY3JlYXRpb24gb3BlcmF0aW9uIGlzIGludGVycnVwdGVkIGJlZm9yZSB0aGUgQ2hhbmdlU2V0IGV4ZWN1dGlvbiBzdGFydHMuIFJlY292ZXJpbmdcbiAgICAgIC8vIGZyb20gdGhpcyB3b3VsZCByZXF1aXJpbmcgbWFudWFsIGludGVydmVudGlvbiAoZGVsZXRpbmcgb3IgZXhlY3V0aW5nIHRoZSBwZW5kaW5nIENoYW5nZVNldCksIGFuZCBmYWlsaW5nIHRvIGRvXG4gICAgICAvLyBzbyB3aWxsIHJlc3VsdCBpbiBhbiBlbmRsZXNzIHdhaXQgaGVyZSAodGhlIENoYW5nZVNldCB3b250IGRlbGV0ZSBvciBleGVjdXRlIGl0c2VsZikuIEluc3RlYWQgb2YgYmxvY2tpbmdcbiAgICAgIC8vIFwiZm9yZXZlclwiIHdlIHByb2NlZWQgYXMgaWYgdGhlIHN0YWNrIHdhcyBleGlzdGluZyBhbmQgc3RhYmxlLiBJZiB0aGVyZSBpcyBhIGNvbmN1cnJlbnQgb3BlcmF0aW9uIHRoYXQganVzdFxuICAgICAgLy8gaGFzbid0IGZpbmlzaGVkIHByb2NlZWRpbmcganVzdCB5ZXQsIGVpdGhlciB0aGlzIG9wZXJhdGlvbiBvciB0aGUgY29uY3VycmVudCBvbmUgbWF5IGZhaWwgZHVlIHRvIHRoZSBvdGhlciBvbmVcbiAgICAgIC8vIGhhdmluZyBtYWRlIHByb2dyZXNzLiBXaGljaCBpcyBmaW5lLiBJIGd1ZXNzLlxuICAgICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMuZGVidWcoZm9ybWF0KCdTdGFjayAlcyBpcyBpbiBSRVZJRVdfSU5fUFJPR1JFU1Mgc3RhdGUuIENvbnNpZGVyaW5nIHRoaXMgaXMgYSBzdGFibGUgc3RhdHVzICglcyknLCBzdGFja05hbWUsIHN0YXR1cykpO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFjaztcbiAgfSk7XG59XG5cbi8qKlxuICogVGhlIHNldCBvZiAoZm9ybWFsKSBwYXJhbWV0ZXJzIHRoYXQgaGF2ZSBiZWVuIGRlY2xhcmVkIGluIGEgdGVtcGxhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIFRlbXBsYXRlUGFyYW1ldGVycyB7XG4gIHB1YmxpYyBzdGF0aWMgZnJvbVRlbXBsYXRlKHRlbXBsYXRlOiBUZW1wbGF0ZSkge1xuICAgIHJldHVybiBuZXcgVGVtcGxhdGVQYXJhbWV0ZXJzKHRlbXBsYXRlLlBhcmFtZXRlcnMgfHwge30pO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIFRlbXBsYXRlUGFyYW1ldGVyPikge1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBzdGFjayBwYXJhbWV0ZXJzIHRvIHBhc3MgZnJvbSB0aGUgZ2l2ZW4gZGVzaXJlZCBwYXJhbWV0ZXIgdmFsdWVzXG4gICAqXG4gICAqIFdpbGwgdGhyb3cgaWYgcGFyYW1ldGVycyB3aXRob3V0IGEgRGVmYXVsdCB2YWx1ZSBvciBhIFByZXZpb3VzIHZhbHVlIGFyZSBub3RcbiAgICogc3VwcGxpZWQuXG4gICAqL1xuICBwdWJsaWMgc3VwcGx5QWxsKHVwZGF0ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD4pOiBQYXJhbWV0ZXJWYWx1ZXMge1xuICAgIHJldHVybiBuZXcgUGFyYW1ldGVyVmFsdWVzKHRoaXMucGFyYW1zLCB1cGRhdGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGcm9tIHRoZSB0ZW1wbGF0ZSwgdGhlIGdpdmVuIGRlc2lyZWQgdmFsdWVzIGFuZCB0aGUgY3VycmVudCB2YWx1ZXMsIGNhbGN1bGF0ZSB0aGUgY2hhbmdlcyB0byB0aGUgc3RhY2sgcGFyYW1ldGVyc1xuICAgKlxuICAgKiBXaWxsIHRha2UgaW50byBhY2NvdW50IHBhcmFtZXRlcnMgYWxyZWFkeSBzZXQgb24gdGhlIHRlbXBsYXRlICh3aWxsIGVtaXRcbiAgICogJ1VzZVByZXZpb3VzVmFsdWU6IHRydWUnIGZvciB0aG9zZSB1bmxlc3MgdGhlIHZhbHVlIGlzIGNoYW5nZWQpLCBhbmQgd2lsbFxuICAgKiB0aHJvdyBpZiBwYXJhbWV0ZXJzIHdpdGhvdXQgYSBEZWZhdWx0IHZhbHVlIG9yIGEgUHJldmlvdXMgdmFsdWUgYXJlIG5vdFxuICAgKiBzdXBwbGllZC5cbiAgICovXG4gIHB1YmxpYyB1cGRhdGVFeGlzdGluZyhcbiAgICB1cGRhdGVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+LFxuICAgIHByZXZpb3VzVmFsdWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICApOiBQYXJhbWV0ZXJWYWx1ZXMge1xuICAgIHJldHVybiBuZXcgUGFyYW1ldGVyVmFsdWVzKHRoaXMucGFyYW1zLCB1cGRhdGVzLCBwcmV2aW91c1ZhbHVlcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgc2V0IG9mIHBhcmFtZXRlcnMgd2UncmUgZ29pbmcgdG8gcGFzcyB0byBhIFN0YWNrXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJhbWV0ZXJWYWx1ZXMge1xuICBwdWJsaWMgcmVhZG9ubHkgdmFsdWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gIHB1YmxpYyByZWFkb25seSBhcGlQYXJhbWV0ZXJzOiBQYXJhbWV0ZXJbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZm9ybWFsUGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBUZW1wbGF0ZVBhcmFtZXRlcj4sXG4gICAgdXBkYXRlczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPixcbiAgICBwcmV2aW91c1ZhbHVlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9LFxuICApIHtcbiAgICBjb25zdCBtaXNzaW5nUmVxdWlyZWQgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuXG4gICAgZm9yIChjb25zdCBba2V5LCBmb3JtYWxQYXJhbV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5mb3JtYWxQYXJhbXMpKSB7XG4gICAgICAvLyBDaGVjayB1cGRhdGVzIGZpcnN0LCB0aGVuIHVzZSB0aGUgcHJldmlvdXMgdmFsdWUgKGlmIGF2YWlsYWJsZSksIHRoZW4gdXNlXG4gICAgICAvLyB0aGUgZGVmYXVsdCAoaWYgYXZhaWxhYmxlKS5cbiAgICAgIC8vXG4gICAgICAvLyBJZiB3ZSBkb24ndCBmaW5kIGEgcGFyYW1ldGVyIHZhbHVlIHVzaW5nIGFueSBvZiB0aGVzZSBtZXRob2RzLCB0aGVuIHRoYXQncyBhbiBlcnJvci5cbiAgICAgIGNvbnN0IHVwZGF0ZWRWYWx1ZSA9IHVwZGF0ZXNba2V5XTtcbiAgICAgIGlmICh1cGRhdGVkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnZhbHVlc1trZXldID0gdXBkYXRlZFZhbHVlO1xuICAgICAgICB0aGlzLmFwaVBhcmFtZXRlcnMucHVzaCh7XG4gICAgICAgICAgUGFyYW1ldGVyS2V5OiBrZXksXG4gICAgICAgICAgUGFyYW1ldGVyVmFsdWU6IHVwZGF0ZXNba2V5XSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5IGluIHByZXZpb3VzVmFsdWVzKSB7XG4gICAgICAgIHRoaXMudmFsdWVzW2tleV0gPSBwcmV2aW91c1ZhbHVlc1trZXldO1xuICAgICAgICB0aGlzLmFwaVBhcmFtZXRlcnMucHVzaCh7IFBhcmFtZXRlcktleToga2V5LCBVc2VQcmV2aW91c1ZhbHVlOiB0cnVlIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvcm1hbFBhcmFtLkRlZmF1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnZhbHVlc1trZXldID0gZm9ybWFsUGFyYW0uRGVmYXVsdDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIE9oIG5vXG4gICAgICBtaXNzaW5nUmVxdWlyZWQucHVzaChrZXkpO1xuICAgIH1cblxuICAgIGlmIChtaXNzaW5nUmVxdWlyZWQubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgVGhlIGZvbGxvd2luZyBDbG91ZEZvcm1hdGlvbiBQYXJhbWV0ZXJzIGFyZSBtaXNzaW5nIGEgdmFsdWU6ICR7bWlzc2luZ1JlcXVpcmVkLmpvaW4oJywgJyl9YCk7XG4gICAgfVxuXG4gICAgLy8gSnVzdCBhcHBlbmQgYWxsIHN1cHBsaWVkIG92ZXJyaWRlcyB0aGF0IGFyZW4ndCByZWFsbHkgZXhwZWN0ZWQgKHRoaXNcbiAgICAvLyB3aWxsIGZhaWwgQ0ZOIGJ1dCBtYXliZSBwZW9wbGUgbWFkZSB0eXBvcyB0aGF0IHRoZXkgd2FudCB0byBiZSBub3RpZmllZFxuICAgIC8vIG9mKVxuICAgIGNvbnN0IHVua25vd25QYXJhbSA9IChba2V5LCBfXTogW3N0cmluZywgYW55XSkgPT4gdGhpcy5mb3JtYWxQYXJhbXNba2V5XSA9PT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGhhc1ZhbHVlID0gKFtfLCB2YWx1ZV06IFtzdHJpbmcsIGFueV0pID0+ICEhdmFsdWU7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModXBkYXRlcykuZmlsdGVyKHVua25vd25QYXJhbSkuZmlsdGVyKGhhc1ZhbHVlKSkge1xuICAgICAgdGhpcy52YWx1ZXNba2V5XSA9IHZhbHVlITtcbiAgICAgIHRoaXMuYXBpUGFyYW1ldGVycy5wdXNoKHsgUGFyYW1ldGVyS2V5OiBrZXksIFBhcmFtZXRlclZhbHVlOiB2YWx1ZSB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIHNldCBvZiBwYXJhbWV0ZXIgdXBkYXRlcyB3aWxsIGNoYW5nZSB0aGUgYWN0dWFsIHN0YWNrIHZhbHVlc1xuICAgKi9cbiAgcHVibGljIGhhc0NoYW5nZXMoY3VycmVudFZhbHVlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPik6IFBhcmFtZXRlckNoYW5nZXMge1xuICAgIC8vIElmIGFueSBvZiB0aGUgcGFyYW1ldGVycyBhcmUgU1NNIHBhcmFtZXRlcnMsIGRlcGxveWluZyBtdXN0IGFsd2F5cyBoYXBwZW5cbiAgICAvLyBiZWNhdXNlIHdlIGNhbid0IHByZWRpY3Qgd2hhdCB0aGUgdmFsdWVzIHdpbGwgYmUuIFdlIHdpbGwgYWxsb3cgc29tZVxuICAgIC8vIHBhcmFtZXRlcnMgdG8gb3B0IG91dCBvZiB0aGlzIGNoZWNrIGJ5IGhhdmluZyBhIG1hZ2ljIHN0cmluZyBpbiB0aGVpciBkZXNjcmlwdGlvbi5cbiAgICBpZiAoXG4gICAgICBPYmplY3QudmFsdWVzKHRoaXMuZm9ybWFsUGFyYW1zKS5zb21lKFxuICAgICAgICAocCkgPT4gcC5UeXBlLnN0YXJ0c1dpdGgoJ0FXUzo6U1NNOjpQYXJhbWV0ZXI6OicpICYmICFwLkRlc2NyaXB0aW9uPy5pbmNsdWRlcyhTU01QQVJBTV9OT19JTlZBTElEQVRFKSxcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHJldHVybiAnc3NtJztcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2Ugd2UncmUgZGlydHkgaWY6XG4gICAgLy8gLSBhbnkgb2YgdGhlIGV4aXN0aW5nIHZhbHVlcyBhcmUgcmVtb3ZlZCwgb3IgY2hhbmdlZFxuICAgIGlmIChPYmplY3QuZW50cmllcyhjdXJyZW50VmFsdWVzKS5zb21lKChba2V5LCB2YWx1ZV0pID0+ICEoa2V5IGluIHRoaXMudmFsdWVzKSB8fCB2YWx1ZSAhPT0gdGhpcy52YWx1ZXNba2V5XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIC0gYW55IG9mIHRoZSB2YWx1ZXMgd2UncmUgc2V0dGluZyBhcmUgbmV3XG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMudmFsdWVzKS5zb21lKChrZXkpID0+ICEoa2V5IGluIGN1cnJlbnRWYWx1ZXMpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIFBhcmFtZXRlckNoYW5nZXMgPSBib29sZWFuIHwgJ3NzbSc7XG4iXX0=