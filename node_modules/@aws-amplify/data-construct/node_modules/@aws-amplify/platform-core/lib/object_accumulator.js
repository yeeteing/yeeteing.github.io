"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectAccumulator = exports.ObjectAccumulatorVersionMismatchError = exports.ObjectAccumulatorPropertyAlreadyExistsError = void 0;
const lodash_mergewith_1 = __importDefault(require("lodash.mergewith"));
const semver_1 = __importDefault(require("semver"));
/**
 * This error is thrown when there's a collision in the object keys
 */
class ObjectAccumulatorPropertyAlreadyExistsError extends Error {
    key;
    existingValue;
    incomingValue;
    /**
     * Creates property already exists error.
     */
    constructor(key, existingValue, incomingValue) {
        super(`Property ${key} already exists`);
        this.key = key;
        this.existingValue = existingValue;
        this.incomingValue = incomingValue;
    }
}
exports.ObjectAccumulatorPropertyAlreadyExistsError = ObjectAccumulatorPropertyAlreadyExistsError;
/**
 * This error is thrown when partial objects with different versions are being accumulated
 */
class ObjectAccumulatorVersionMismatchError extends Error {
    existingVersion;
    newVersion;
    /**
     * Creates property already exists error.
     */
    constructor(existingVersion, newVersion) {
        super(`Version mismatch: Cannot accumulate new objects with version ${newVersion} with existing accumulated object with version ${existingVersion}`);
        this.existingVersion = existingVersion;
        this.newVersion = newVersion;
    }
}
exports.ObjectAccumulatorVersionMismatchError = ObjectAccumulatorVersionMismatchError;
/**
 * A class that can accumulate (squash merge) objects into single instance.
 */
class ObjectAccumulator {
    accumulator;
    versionKey;
    /**
     * creates object accumulator.
     */
    constructor(accumulator, versionKey = 'version') {
        this.accumulator = accumulator;
        this.versionKey = versionKey;
    }
    /**
     * Accumulate a new object part with accumulator.
     * This method throws if there is any intersection between the object parts
     * except for the versionKey, which should be the same across all object parts (nested objects included)
     * @param part a new object part to accumulate
     * @returns the accumulator object for easy chaining
     */
    accumulate = (part) => {
        (0, lodash_mergewith_1.default)(this.accumulator, part, (existingValue, incomingValue, key) => {
            if (Array.isArray(existingValue)) {
                return existingValue.concat(incomingValue);
            }
            if (existingValue && typeof existingValue !== 'object') {
                if (key === this.versionKey) {
                    const incomingVersion = semver_1.default.coerce(incomingValue);
                    const existingVersion = semver_1.default.coerce(existingValue);
                    if (incomingVersion && existingVersion) {
                        // Only throw if the major version is not equal
                        if (incomingVersion.major !== existingVersion.major) {
                            throw new ObjectAccumulatorVersionMismatchError(existingValue, incomingValue);
                        }
                        else {
                            // We always get the max version to persist in the accumulated object
                            return semver_1.default.gte(incomingVersion, existingVersion)
                                ? incomingValue
                                : existingValue;
                        }
                    }
                }
                else if (key !== this.versionKey) {
                    throw new ObjectAccumulatorPropertyAlreadyExistsError(key, existingValue, incomingValue);
                }
            }
            // returning undefined falls back to default merge algorithm
            return undefined;
        });
        return this;
    };
    getAccumulatedObject = () => {
        return this.accumulator;
    };
}
exports.ObjectAccumulator = ObjectAccumulator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2JqZWN0X2FjY3VtdWxhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL29iamVjdF9hY2N1bXVsYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQSx3RUFBeUM7QUFDekMsb0RBQTRCO0FBQzVCOztHQUVHO0FBQ0gsTUFBYSwyQ0FBNEMsU0FBUSxLQUFLO0lBS3pEO0lBQ0E7SUFDQTtJQU5YOztPQUVHO0lBQ0gsWUFDVyxHQUFXLEVBQ1gsYUFBc0IsRUFDdEIsYUFBc0I7UUFFL0IsS0FBSyxDQUFDLFlBQVksR0FBRyxpQkFBaUIsQ0FBQyxDQUFDO1FBSi9CLFFBQUcsR0FBSCxHQUFHLENBQVE7UUFDWCxrQkFBYSxHQUFiLGFBQWEsQ0FBUztRQUN0QixrQkFBYSxHQUFiLGFBQWEsQ0FBUztJQUdqQyxDQUFDO0NBQ0Y7QUFYRCxrR0FXQztBQUVEOztHQUVHO0FBQ0gsTUFBYSxxQ0FBc0MsU0FBUSxLQUFLO0lBS25EO0lBQ0E7SUFMWDs7T0FFRztJQUNILFlBQ1csZUFBdUIsRUFDdkIsVUFBa0I7UUFFM0IsS0FBSyxDQUNILGdFQUFnRSxVQUFVLGtEQUFrRCxlQUFlLEVBQUUsQ0FDOUksQ0FBQztRQUxPLG9CQUFlLEdBQWYsZUFBZSxDQUFRO1FBQ3ZCLGVBQVUsR0FBVixVQUFVLENBQVE7SUFLN0IsQ0FBQztDQUNGO0FBWkQsc0ZBWUM7QUFFRDs7R0FFRztBQUNILE1BQWEsaUJBQWlCO0lBS1Q7SUFDQTtJQUxuQjs7T0FFRztJQUNILFlBQ21CLFdBQWtELEVBQ2xELGFBQWEsU0FBUztRQUR0QixnQkFBVyxHQUFYLFdBQVcsQ0FBdUM7UUFDbEQsZUFBVSxHQUFWLFVBQVUsQ0FBWTtJQUN0QyxDQUFDO0lBRUo7Ozs7OztPQU1HO0lBQ0gsVUFBVSxHQUFHLENBQ1gsSUFBMkMsRUFDckIsRUFBRTtRQUN4QixJQUFBLDBCQUFTLEVBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxhQUFhLEVBQUUsYUFBYSxFQUFFLEdBQUcsRUFBRSxFQUFFO1lBQ3RFLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsRUFBRTtnQkFDaEMsT0FBTyxhQUFhLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDO2FBQzVDO1lBQ0QsSUFBSSxhQUFhLElBQUksT0FBTyxhQUFhLEtBQUssUUFBUSxFQUFFO2dCQUN0RCxJQUFJLEdBQUcsS0FBSyxJQUFJLENBQUMsVUFBVSxFQUFFO29CQUMzQixNQUFNLGVBQWUsR0FBRyxnQkFBTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQztvQkFDckQsTUFBTSxlQUFlLEdBQUcsZ0JBQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUM7b0JBQ3JELElBQUksZUFBZSxJQUFJLGVBQWUsRUFBRTt3QkFDdEMsK0NBQStDO3dCQUMvQyxJQUFJLGVBQWUsQ0FBQyxLQUFLLEtBQUssZUFBZSxDQUFDLEtBQUssRUFBRTs0QkFDbkQsTUFBTSxJQUFJLHFDQUFxQyxDQUM3QyxhQUFhLEVBQ2IsYUFBYSxDQUNkLENBQUM7eUJBQ0g7NkJBQU07NEJBQ0wscUVBQXFFOzRCQUNyRSxPQUFPLGdCQUFNLENBQUMsR0FBRyxDQUFDLGVBQWUsRUFBRSxlQUFlLENBQUM7Z0NBQ2pELENBQUMsQ0FBQyxhQUFhO2dDQUNmLENBQUMsQ0FBQyxhQUFhLENBQUM7eUJBQ25CO3FCQUNGO2lCQUNGO3FCQUFNLElBQUksR0FBRyxLQUFLLElBQUksQ0FBQyxVQUFVLEVBQUU7b0JBQ2xDLE1BQU0sSUFBSSwyQ0FBMkMsQ0FDbkQsR0FBRyxFQUNILGFBQWEsRUFDYixhQUFhLENBQ2QsQ0FBQztpQkFDSDthQUNGO1lBRUQsNERBQTREO1lBQzVELE9BQU8sU0FBUyxDQUFDO1FBQ25CLENBQUMsQ0FBQyxDQUFDO1FBQ0gsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDLENBQUM7SUFFRixvQkFBb0IsR0FBRyxHQUFHLEVBQUU7UUFDMUIsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDO0lBQzFCLENBQUMsQ0FBQztDQUNIO0FBM0RELDhDQTJEQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERlZXBQYXJ0aWFsQW1wbGlmeUdlbmVyYXRlZENvbmZpZ3MgfSBmcm9tICdAYXdzLWFtcGxpZnkvcGx1Z2luLXR5cGVzJztcbmltcG9ydCBtZXJnZVdpdGggZnJvbSAnbG9kYXNoLm1lcmdld2l0aCc7XG5pbXBvcnQgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG4vKipcbiAqIFRoaXMgZXJyb3IgaXMgdGhyb3duIHdoZW4gdGhlcmUncyBhIGNvbGxpc2lvbiBpbiB0aGUgb2JqZWN0IGtleXNcbiAqL1xuZXhwb3J0IGNsYXNzIE9iamVjdEFjY3VtdWxhdG9yUHJvcGVydHlBbHJlYWR5RXhpc3RzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIHByb3BlcnR5IGFscmVhZHkgZXhpc3RzIGVycm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcmVhZG9ubHkga2V5OiBzdHJpbmcsXG4gICAgcmVhZG9ubHkgZXhpc3RpbmdWYWx1ZTogdW5rbm93bixcbiAgICByZWFkb25seSBpbmNvbWluZ1ZhbHVlOiB1bmtub3duLFxuICApIHtcbiAgICBzdXBlcihgUHJvcGVydHkgJHtrZXl9IGFscmVhZHkgZXhpc3RzYCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGVycm9yIGlzIHRocm93biB3aGVuIHBhcnRpYWwgb2JqZWN0cyB3aXRoIGRpZmZlcmVudCB2ZXJzaW9ucyBhcmUgYmVpbmcgYWNjdW11bGF0ZWRcbiAqL1xuZXhwb3J0IGNsYXNzIE9iamVjdEFjY3VtdWxhdG9yVmVyc2lvbk1pc21hdGNoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIHByb3BlcnR5IGFscmVhZHkgZXhpc3RzIGVycm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcmVhZG9ubHkgZXhpc3RpbmdWZXJzaW9uOiBzdHJpbmcsXG4gICAgcmVhZG9ubHkgbmV3VmVyc2lvbjogc3RyaW5nLFxuICApIHtcbiAgICBzdXBlcihcbiAgICAgIGBWZXJzaW9uIG1pc21hdGNoOiBDYW5ub3QgYWNjdW11bGF0ZSBuZXcgb2JqZWN0cyB3aXRoIHZlcnNpb24gJHtuZXdWZXJzaW9ufSB3aXRoIGV4aXN0aW5nIGFjY3VtdWxhdGVkIG9iamVjdCB3aXRoIHZlcnNpb24gJHtleGlzdGluZ1ZlcnNpb259YCxcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogQSBjbGFzcyB0aGF0IGNhbiBhY2N1bXVsYXRlIChzcXVhc2ggbWVyZ2UpIG9iamVjdHMgaW50byBzaW5nbGUgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBPYmplY3RBY2N1bXVsYXRvcjxUPiB7XG4gIC8qKlxuICAgKiBjcmVhdGVzIG9iamVjdCBhY2N1bXVsYXRvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYWNjdW11bGF0b3I6IERlZXBQYXJ0aWFsQW1wbGlmeUdlbmVyYXRlZENvbmZpZ3M8VD4sXG4gICAgcHJpdmF0ZSByZWFkb25seSB2ZXJzaW9uS2V5ID0gJ3ZlcnNpb24nLFxuICApIHt9XG5cbiAgLyoqXG4gICAqIEFjY3VtdWxhdGUgYSBuZXcgb2JqZWN0IHBhcnQgd2l0aCBhY2N1bXVsYXRvci5cbiAgICogVGhpcyBtZXRob2QgdGhyb3dzIGlmIHRoZXJlIGlzIGFueSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0aGUgb2JqZWN0IHBhcnRzXG4gICAqIGV4Y2VwdCBmb3IgdGhlIHZlcnNpb25LZXksIHdoaWNoIHNob3VsZCBiZSB0aGUgc2FtZSBhY3Jvc3MgYWxsIG9iamVjdCBwYXJ0cyAobmVzdGVkIG9iamVjdHMgaW5jbHVkZWQpXG4gICAqIEBwYXJhbSBwYXJ0IGEgbmV3IG9iamVjdCBwYXJ0IHRvIGFjY3VtdWxhdGVcbiAgICogQHJldHVybnMgdGhlIGFjY3VtdWxhdG9yIG9iamVjdCBmb3IgZWFzeSBjaGFpbmluZ1xuICAgKi9cbiAgYWNjdW11bGF0ZSA9IChcbiAgICBwYXJ0OiBEZWVwUGFydGlhbEFtcGxpZnlHZW5lcmF0ZWRDb25maWdzPFQ+LFxuICApOiBPYmplY3RBY2N1bXVsYXRvcjxUPiA9PiB7XG4gICAgbWVyZ2VXaXRoKHRoaXMuYWNjdW11bGF0b3IsIHBhcnQsIChleGlzdGluZ1ZhbHVlLCBpbmNvbWluZ1ZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGV4aXN0aW5nVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1ZhbHVlLmNvbmNhdChpbmNvbWluZ1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChleGlzdGluZ1ZhbHVlICYmIHR5cGVvZiBleGlzdGluZ1ZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoa2V5ID09PSB0aGlzLnZlcnNpb25LZXkpIHtcbiAgICAgICAgICBjb25zdCBpbmNvbWluZ1ZlcnNpb24gPSBzZW12ZXIuY29lcmNlKGluY29taW5nVmFsdWUpO1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVmVyc2lvbiA9IHNlbXZlci5jb2VyY2UoZXhpc3RpbmdWYWx1ZSk7XG4gICAgICAgICAgaWYgKGluY29taW5nVmVyc2lvbiAmJiBleGlzdGluZ1ZlcnNpb24pIHtcbiAgICAgICAgICAgIC8vIE9ubHkgdGhyb3cgaWYgdGhlIG1ham9yIHZlcnNpb24gaXMgbm90IGVxdWFsXG4gICAgICAgICAgICBpZiAoaW5jb21pbmdWZXJzaW9uLm1ham9yICE9PSBleGlzdGluZ1ZlcnNpb24ubWFqb3IpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdEFjY3VtdWxhdG9yVmVyc2lvbk1pc21hdGNoRXJyb3IoXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdWYWx1ZSxcbiAgICAgICAgICAgICAgICBpbmNvbWluZ1ZhbHVlLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gV2UgYWx3YXlzIGdldCB0aGUgbWF4IHZlcnNpb24gdG8gcGVyc2lzdCBpbiB0aGUgYWNjdW11bGF0ZWQgb2JqZWN0XG4gICAgICAgICAgICAgIHJldHVybiBzZW12ZXIuZ3RlKGluY29taW5nVmVyc2lvbiwgZXhpc3RpbmdWZXJzaW9uKVxuICAgICAgICAgICAgICAgID8gaW5jb21pbmdWYWx1ZVxuICAgICAgICAgICAgICAgIDogZXhpc3RpbmdWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ICE9PSB0aGlzLnZlcnNpb25LZXkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0QWNjdW11bGF0b3JQcm9wZXJ0eUFscmVhZHlFeGlzdHNFcnJvcihcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGV4aXN0aW5nVmFsdWUsXG4gICAgICAgICAgICBpbmNvbWluZ1ZhbHVlLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcmV0dXJuaW5nIHVuZGVmaW5lZCBmYWxscyBiYWNrIHRvIGRlZmF1bHQgbWVyZ2UgYWxnb3JpdGhtXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGdldEFjY3VtdWxhdGVkT2JqZWN0ID0gKCkgPT4ge1xuICAgIHJldHVybiB0aGlzLmFjY3VtdWxhdG9yO1xuICB9O1xufVxuIl19