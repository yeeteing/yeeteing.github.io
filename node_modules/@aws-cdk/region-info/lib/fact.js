"use strict";
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.FactName = exports.Fact = void 0;
const jsiiDeprecationWarnings = require("../.warnings.jsii.js");
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const aws_entities_1 = require("./aws-entities");
const errors_1 = require("aws-cdk-lib/core/lib/errors");
/**
 * A database of regional information.
 */
class Fact {
    /**
     * @returns the list of names of AWS Regions for which there is at least one registered fact. This
     *          includes Regions defined in AWS_REGIONS plus custom defined regions.
     */
    static get regions() {
        // Return the union of regions in AWS_REGIONS and custom defined regions.
        return [...new Set([...aws_entities_1.AWS_REGIONS, ...Object.keys(this.database)])];
    }
    /**
     * Returns the list of names of registered facts.
     *
     * All facts will be present in at least one region.
     */
    static get names() {
        return [...new Set(Object.values(this.database).flatMap(regionFacts => Object.keys(regionFacts)))];
    }
    /**
     * Return all pairs of (region, factName) that are defined
     */
    static definedFacts() {
        return Object.entries(this.database)
            .flatMap(([regionName, regionFacts]) => Object.keys(regionFacts).map((factName) => [regionName, factName]));
    }
    /**
     * Retrieves a fact from this Fact database.
     *
     * @param region the name of the region (e.g: `us-east-1`)
     * @param name   the name of the fact being looked up (see the `FactName` class for details)
     *
     * @returns the fact value if it is known, and `undefined` otherwise.
     */
    static find(region, name) {
        const regionFacts = this.database[region];
        return regionFacts && regionFacts[name];
    }
    /**
     * Retrieve a fact from the Fact database. (retrieval will fail if the specified region or
     * fact name does not exist.)
     *
     * @param region the name of the region (e.g: `us-east-1`)
     * @param name the name of the fact being looked up (see the `FactName` class for details)
     */
    static requireFact(region, name) {
        const foundFact = this.find(region, name);
        if (!foundFact) {
            throw new errors_1.UnscopedValidationError(`No fact ${name} could be found for region: ${region} and name: ${name}.`);
        }
        return foundFact;
    }
    /**
     * Registers a new fact in this Fact database.
     *
     * @param fact           the new fact to be registered.
     * @param allowReplacing whether new facts can replace existing facts or not.
     */
    static register(fact, allowReplacing = false) {
        try {
            jsiiDeprecationWarnings._aws_cdk_region_info_IFact(fact);
        }
        catch (error) {
            if (process.env.JSII_DEBUG !== "1" && error.name === "DeprecationError") {
                Error.captureStackTrace(error, this.register);
            }
            throw error;
        }
        const regionFacts = this.database[fact.region] || (this.database[fact.region] = {});
        if (fact.name in regionFacts && regionFacts[fact.name] !== fact.value && !allowReplacing) {
            throw new errors_1.UnscopedValidationError(`Region ${fact.region} already has a fact ${fact.name}, with value ${regionFacts[fact.name]}`);
        }
        if (fact.value !== undefined) {
            regionFacts[fact.name] = fact.value;
        }
    }
    /**
     * Removes a fact from the database.
     * @param region the region for which the fact is to be removed.
     * @param name   the name of the fact to remove.
     * @param value  the value that should be removed (removal will fail if the value is specified, but does not match the
     *               current stored value).
     */
    static unregister(region, name, value) {
        const regionFacts = this.database[region] || {};
        if (name in regionFacts && value && regionFacts[name] !== value) {
            throw new errors_1.UnscopedValidationError(`Attempted to remove ${name} from ${region} with value ${value}, but the fact's value is ${regionFacts[name]}`);
        }
        delete regionFacts[name];
    }
    constructor() {
        throw new errors_1.UnscopedValidationError('Use the static methods of Fact instead!');
    }
}
exports.Fact = Fact;
_a = JSII_RTTI_SYMBOL_1;
Fact[_a] = { fqn: "@aws-cdk/region-info.Fact", version: "2.214.0" };
Fact.database = {};
/**
 * All standardized fact names.
 */
class FactName {
    /**
     * The ARN of CloudWatch Lambda Insights for a version (e.g. 1.0.98.0)
     */
    static cloudwatchLambdaInsightsVersion(version, arch) {
        // if we are provided an architecture use that, otherwise
        // default to x86_64 for backwards compatibility
        const suffix = version.split('.').join('_') + `_${arch ?? 'x86_64'}`;
        return `cloudwatch-lambda-insights-version:${suffix}`;
    }
    /**
     * The ARN of AppConfig Lambda Layer for a given version (e.g. 2.0.181)
     * @param version The layer version.
     * @param arch The architecture (optional), defaults to x86_64.
     */
    static appConfigLambdaLayerVersion(version, arch) {
        const suffix = version.split('.').join('_') + `_${arch ?? 'x86_64'}`;
        return `appconfig-lambda-layer:${suffix}`;
    }
    /**
     * The name of the regional service principal for a given service.
     *
     * @param service the service name, either simple (e.g: `s3`, `codedeploy`) or qualified (e.g: `s3.amazonaws.com`).
     *                The `.amazonaws.com` and `.amazonaws.com.cn` domains are stripped from service names, so they are
     *                canonicalized in that respect.
     *
     * @deprecated - Use `iam.ServicePrincipal.servicePrincipalName()` instead.
     */
    static servicePrincipal(service) {
        try {
            jsiiDeprecationWarnings.print("@aws-cdk/region-info.FactName#servicePrincipal", "- Use `iam.ServicePrincipal.servicePrincipalName()` instead.");
        }
        catch (error) {
            if (process.env.JSII_DEBUG !== "1" && error.name === "DeprecationError") {
                Error.captureStackTrace(error, this.servicePrincipal);
            }
            throw error;
        }
        return `${service.replace(/\.amazonaws\.com(\.cn)?$/, '')}.amazonaws.com`;
    }
    /**
     * The ARN of Amazon Distro for OpenTelemetry (ADOT) Lambda layer for a given lambda type, version and architecture.
     *
     * @param type the type of the ADOT lambda layer
     * @param version the layer version.
     * @param architecture the Lambda Function architecture (e.g. 'x86_64' or 'arm64')
     */
    static adotLambdaLayer(type, version, architecture) {
        const suffix = type + '_' + version.split('.').join('_') + '_' + architecture;
        return `adot-lambda-layer:${suffix}`;
    }
    /**
     * The ARN of Parameters and Secrets Lambda layer for a given lambda architecture.
     *
     * @param version the layer version
     * @param architecture the Lambda Function architecture (e.g. 'x86_64' or 'arm64')
     */
    static paramsAndSecretsLambdaLayer(version, architecture) {
        const suffix = version.split('.').join('_') + `_${architecture}`;
        return `params-and-secrets-layer:${suffix}`;
    }
}
exports.FactName = FactName;
_b = JSII_RTTI_SYMBOL_1;
FactName[_b] = { fqn: "@aws-cdk/region-info.FactName", version: "2.214.0" };
/**
 * The name of the partition for a region (e.g: 'aws', 'aws-cn', ...)
 */
FactName.PARTITION = 'partition';
/**
 * The domain suffix for a region (e.g: 'amazonaws.com`)
 */
FactName.DOMAIN_SUFFIX = 'domainSuffix';
/**
 * Whether the AWS::CDK::Metadata CloudFormation Resource is available in-region or not. The value is a boolean
 * modelled as `YES` or `NO`.
 */
FactName.CDK_METADATA_RESOURCE_AVAILABLE = 'cdk:metadata-resource:available';
/**
 * Whether the given region is an opt-in region or not. The value is a boolean
 * modelled as `YES` or `NO`.
 */
FactName.IS_OPT_IN_REGION = 'aws:is-opt-in-region';
/**
 * The endpoint used for hosting S3 static websites
 */
FactName.S3_STATIC_WEBSITE_ENDPOINT = 's3-static-website:endpoint';
/**
 * The endpoint used for aliasing S3 static websites in Route 53
 */
FactName.S3_STATIC_WEBSITE_ZONE_53_HOSTED_ZONE_ID = 's3-static-website:route-53-hosted-zone-id';
/**
 * The hosted zone ID used by Route 53 to alias a EBS environment endpoint in this region (e.g: Z2O1EMRO9K5GLX)
 */
FactName.EBS_ENV_ENDPOINT_HOSTED_ZONE_ID = 'ebs-environment:route-53-hosted-zone-id';
/**
 * The prefix for VPC Endpoint Service names,
 * cn.com.amazonaws.vpce for China regions,
 * com.amazonaws.vpce otherwise.
 */
FactName.VPC_ENDPOINT_SERVICE_NAME_PREFIX = 'vpcEndpointServiceNamePrefix';
/**
 * The account for ELBv2 in this region
 */
FactName.ELBV2_ACCOUNT = 'elbv2Account';
/**
 * The ID of the AWS account that owns the public ECR repository that contains the
 * AWS Deep Learning Containers images in a given region.
 */
FactName.DLC_REPOSITORY_ACCOUNT = 'dlcRepositoryAccount';
/**
 * The ID of the AWS account that owns the public ECR repository that contains the
 * AWS App Mesh Envoy Proxy images in a given region.
 */
FactName.APPMESH_ECR_ACCOUNT = 'appMeshRepositoryAccount';
/**
 * The CIDR block used by Amazon Data Firehose servers.
 */
FactName.FIREHOSE_CIDR_BLOCK = 'firehoseCidrBlock';
/**
 * The SAML Sign On URL for partition used by IAM SAML Principal
 */
FactName.SAML_SIGN_ON_URL = 'samlSignOnUrl';
/**
 * The latest Lambda NodeJS runtime available in a given region.
 */
FactName.LATEST_NODE_RUNTIME = 'latestNodeRuntime';
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmFjdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImZhY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsaURBQTZDO0FBQzdDLHdEQUFzRTtBQUV0RTs7R0FFRztBQUNILE1BQWEsSUFBSTtJQUNmOzs7T0FHRztJQUNJLE1BQU0sS0FBSyxPQUFPO1FBQ3ZCLHlFQUF5RTtRQUN6RSxPQUFPLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEdBQUcsMEJBQVcsRUFBRSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3RFO0lBRUQ7Ozs7T0FJRztJQUNJLE1BQU0sS0FBSyxLQUFLO1FBQ3JCLE9BQU8sQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDcEc7SUFFRDs7T0FFRztJQUNJLE1BQU0sQ0FBQyxZQUFZO1FBQ3hCLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO2FBQ2pDLE9BQU8sQ0FBQyxDQUFDLENBQUMsVUFBVSxFQUFFLFdBQVcsQ0FBQyxFQUFFLEVBQUUsQ0FDckMsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUN4QyxDQUFDLFVBQVUsRUFBRSxRQUFRLENBQTRCLENBQUMsQ0FBQyxDQUFDO0tBQzNEO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBYyxFQUFFLElBQVk7UUFDN0MsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUMx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QWdDLEdBQUcsOEJBQThCLENBQUM7QUFFekY7O0dBRUc7QUFDb0Isc0JBQWEsR0FBRyxjQUFjLENBQUM7QUFFdEQ7OztHQUdHO0FBQ29CLCtCQUFzQixHQUFHLHNCQUFzQixDQUFDO0FBRXZFOzs7R0FHRztBQUNvQiw0QkFBbUIsR0FBRywwQkFBMEIsQ0FBQztBQUV4RTs7R0FFRztBQUNvQiw0QkFBbUIsR0FBRyxtQkFBbUIsQ0FBQztBQUVqRTs7R0FFRztBQUNvQix5QkFBZ0IsR0FBRyxlQUFlLENBQUM7QUFFMUQ7O0dBRUc7QUFDb0IsNEJBQW1CLEdBQUcsbUJBQW1CLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBV1NfUkVHSU9OUyB9IGZyb20gJy4vYXdzLWVudGl0aWVzJztcbmltcG9ydCB7IFVuc2NvcGVkVmFsaWRhdGlvbkVycm9yIH0gZnJvbSAnYXdzLWNkay1saWIvY29yZS9saWIvZXJyb3JzJztcblxuLyoqXG4gKiBBIGRhdGFiYXNlIG9mIHJlZ2lvbmFsIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgRmFjdCB7XG4gIC8qKlxuICAgKiBAcmV0dXJucyB0aGUgbGlzdCBvZiBuYW1lcyBvZiBBV1MgUmVnaW9ucyBmb3Igd2hpY2ggdGhlcmUgaXMgYXQgbGVhc3Qgb25lIHJlZ2lzdGVyZWQgZmFjdC4gVGhpc1xuICAgKiAgICAgICAgICBpbmNsdWRlcyBSZWdpb25zIGRlZmluZWQgaW4gQVdTX1JFR0lPTlMgcGx1cyBjdXN0b20gZGVmaW5lZCByZWdpb25zLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXQgcmVnaW9ucygpOiBzdHJpbmdbXSB7XG4gICAgLy8gUmV0dXJuIHRoZSB1bmlvbiBvZiByZWdpb25zIGluIEFXU19SRUdJT05TIGFuZCBjdXN0b20gZGVmaW5lZCByZWdpb25zLlxuICAgIHJldHVybiBbLi4ubmV3IFNldChbLi4uQVdTX1JFR0lPTlMsIC4uLk9iamVjdC5rZXlzKHRoaXMuZGF0YWJhc2UpXSldO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgbmFtZXMgb2YgcmVnaXN0ZXJlZCBmYWN0cy5cbiAgICpcbiAgICogQWxsIGZhY3RzIHdpbGwgYmUgcHJlc2VudCBpbiBhdCBsZWFzdCBvbmUgcmVnaW9uLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXQgbmFtZXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbLi4ubmV3IFNldChPYmplY3QudmFsdWVzKHRoaXMuZGF0YWJhc2UpLmZsYXRNYXAocmVnaW9uRmFjdHMgPT4gT2JqZWN0LmtleXMocmVnaW9uRmFjdHMpKSldO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgcGFpcnMgb2YgKHJlZ2lvbiwgZmFjdE5hbWUpIHRoYXQgYXJlIGRlZmluZWRcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZGVmaW5lZEZhY3RzKCk6IEFycmF5PHN0cmluZ1tdPiB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMuZGF0YWJhc2UpXG4gICAgICAuZmxhdE1hcCgoW3JlZ2lvbk5hbWUsIHJlZ2lvbkZhY3RzXSkgPT5cbiAgICAgICAgT2JqZWN0LmtleXMocmVnaW9uRmFjdHMpLm1hcCgoZmFjdE5hbWUpID0+XG4gICAgICAgICAgW3JlZ2lvbk5hbWUsIGZhY3ROYW1lXSBzYXRpc2ZpZXMgW3N0cmluZywgc3RyaW5nXSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIGZhY3QgZnJvbSB0aGlzIEZhY3QgZGF0YWJhc2UuXG4gICAqXG4gICAqIEBwYXJhbSByZWdpb24gdGhlIG5hbWUgb2YgdGhlIHJlZ2lvbiAoZS5nOiBgdXMtZWFzdC0xYClcbiAgICogQHBhcmFtIG5hbWUgICB0aGUgbmFtZSBvZiB0aGUgZmFjdCBiZWluZyBsb29rZWQgdXAgKHNlZSB0aGUgYEZhY3ROYW1lYCBjbGFzcyBmb3IgZGV0YWlscylcbiAgICpcbiAgICogQHJldHVybnMgdGhlIGZhY3QgdmFsdWUgaWYgaXQgaXMga25vd24sIGFuZCBgdW5kZWZpbmVkYCBvdGhlcndpc2UuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZpbmQocmVnaW9uOiBzdHJpbmcsIG5hbWU6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgcmVnaW9uRmFjdHMgPSB0aGlzLmRhdGFiYXNlW3JlZ2lvbl07XG4gICAgcmV0dXJuIHJlZ2lvbkZhY3RzICYmIHJlZ2lvbkZhY3RzW25hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGEgZmFjdCBmcm9tIHRoZSBGYWN0IGRhdGFiYXNlLiAocmV0cmlldmFsIHdpbGwgZmFpbCBpZiB0aGUgc3BlY2lmaWVkIHJlZ2lvbiBvclxuICAgKiBmYWN0IG5hbWUgZG9lcyBub3QgZXhpc3QuKVxuICAgKlxuICAgKiBAcGFyYW0gcmVnaW9uIHRoZSBuYW1lIG9mIHRoZSByZWdpb24gKGUuZzogYHVzLWVhc3QtMWApXG4gICAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBmYWN0IGJlaW5nIGxvb2tlZCB1cCAoc2VlIHRoZSBgRmFjdE5hbWVgIGNsYXNzIGZvciBkZXRhaWxzKVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZXF1aXJlRmFjdChyZWdpb246IHN0cmluZywgbmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBmb3VuZEZhY3QgPSB0aGlzLmZpbmQocmVnaW9uLCBuYW1lKTtcblxuICAgIGlmICghZm91bmRGYWN0KSB7XG4gICAgICB0aHJvdyBuZXcgVW5zY29wZWRWYWxpZGF0aW9uRXJyb3IoYE5vIGZhY3QgJHtuYW1lfSBjb3VsZCBiZSBmb3VuZCBmb3IgcmVnaW9uOiAke3JlZ2lvbn0gYW5kIG5hbWU6ICR7bmFtZX0uYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvdW5kRmFjdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBuZXcgZmFjdCBpbiB0aGlzIEZhY3QgZGF0YWJhc2UuXG4gICAqXG4gICAqIEBwYXJhbSBmYWN0ICAgICAgICAgICB0aGUgbmV3IGZhY3QgdG8gYmUgcmVnaXN0ZXJlZC5cbiAgICogQHBhcmFtIGFsbG93UmVwbGFjaW5nIHdoZXRoZXIgbmV3IGZhY3RzIGNhbiByZXBsYWNlIGV4aXN0aW5nIGZhY3RzIG9yIG5vdC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVnaXN0ZXIoZmFjdDogSUZhY3QsIGFsbG93UmVwbGFjaW5nID0gZmFsc2UpOiB2b2lkIHtcbiAgICBjb25zdCByZWdpb25GYWN0cyA9IHRoaXMuZGF0YWJhc2VbZmFjdC5yZWdpb25dIHx8ICh0aGlzLmRhdGFiYXNlW2ZhY3QucmVnaW9uXSA9IHt9KTtcbiAgICBpZiAoZmFjdC5uYW1lIGluIHJlZ2lvbkZhY3RzICYmIHJlZ2lvbkZhY3RzW2ZhY3QubmFtZV0gIT09IGZhY3QudmFsdWUgJiYgIWFsbG93UmVwbGFjaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zY29wZWRWYWxpZGF0aW9uRXJyb3IoYFJlZ2lvbiAke2ZhY3QucmVnaW9ufSBhbHJlYWR5IGhhcyBhIGZhY3QgJHtmYWN0Lm5hbWV9LCB3aXRoIHZhbHVlICR7cmVnaW9uRmFjdHNbZmFjdC5uYW1lXX1gKTtcbiAgICB9XG4gICAgaWYgKGZhY3QudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVnaW9uRmFjdHNbZmFjdC5uYW1lXSA9IGZhY3QudmFsdWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBmYWN0IGZyb20gdGhlIGRhdGFiYXNlLlxuICAgKiBAcGFyYW0gcmVnaW9uIHRoZSByZWdpb24gZm9yIHdoaWNoIHRoZSBmYWN0IGlzIHRvIGJlIHJlbW92ZWQuXG4gICAqIEBwYXJhbSBuYW1lICAgdGhlIG5hbWUgb2YgdGhlIGZhY3QgdG8gcmVtb3ZlLlxuICAgKiBAcGFyYW0gdmFsdWUgIHRoZSB2YWx1ZSB0aGF0IHNob3VsZCBiZSByZW1vdmVkIChyZW1vdmFsIHdpbGwgZmFpbCBpZiB0aGUgdmFsdWUgaXMgc3BlY2lmaWVkLCBidXQgZG9lcyBub3QgbWF0Y2ggdGhlXG4gICAqICAgICAgICAgICAgICAgY3VycmVudCBzdG9yZWQgdmFsdWUpLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyB1bnJlZ2lzdGVyKHJlZ2lvbjogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIHZhbHVlPzogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgcmVnaW9uRmFjdHMgPSB0aGlzLmRhdGFiYXNlW3JlZ2lvbl0gfHwge307XG4gICAgaWYgKG5hbWUgaW4gcmVnaW9uRmFjdHMgJiYgdmFsdWUgJiYgcmVnaW9uRmFjdHNbbmFtZV0gIT09IHZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zY29wZWRWYWxpZGF0aW9uRXJyb3IoYEF0dGVtcHRlZCB0byByZW1vdmUgJHtuYW1lfSBmcm9tICR7cmVnaW9ufSB3aXRoIHZhbHVlICR7dmFsdWV9LCBidXQgdGhlIGZhY3QncyB2YWx1ZSBpcyAke3JlZ2lvbkZhY3RzW25hbWVdfWApO1xuICAgIH1cbiAgICBkZWxldGUgcmVnaW9uRmFjdHNbbmFtZV07XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBkYXRhYmFzZTogeyBbcmVnaW9uOiBzdHJpbmddOiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfSB9ID0ge307XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aHJvdyBuZXcgVW5zY29wZWRWYWxpZGF0aW9uRXJyb3IoJ1VzZSB0aGUgc3RhdGljIG1ldGhvZHMgb2YgRmFjdCBpbnN0ZWFkIScpO1xuICB9XG59XG5cbi8qKlxuICogQSBmYWN0IHRoYXQgY2FuIGJlIHJlZ2lzdGVyZWQgYWJvdXQgYSBwYXJ0aWN1bGFyIHJlZ2lvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJRmFjdCB7XG4gIC8qKlxuICAgKiBUaGUgcmVnaW9uIGZvciB3aGljaCB0aGlzIGZhY3QgYXBwbGllcy5cbiAgICovXG4gIHJlYWRvbmx5IHJlZ2lvbjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGlzIGZhY3QuIFN0YW5kYXJkaXplZCB2YWx1ZXMgYXJlIHByb3ZpZGVkIGJ5IHRoZSBgRmFjdHNgIGNsYXNzLlxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgb2YgdGhpcyBmYWN0LlxuICAgKi9cbiAgcmVhZG9ubHkgdmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBbGwgc3RhbmRhcmRpemVkIGZhY3QgbmFtZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBGYWN0TmFtZSB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgcGFydGl0aW9uIGZvciBhIHJlZ2lvbiAoZS5nOiAnYXdzJywgJ2F3cy1jbicsIC4uLilcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUEFSVElUSU9OID0gJ3BhcnRpdGlvbic7XG5cbiAgLyoqXG4gICAqIFRoZSBkb21haW4gc3VmZml4IGZvciBhIHJlZ2lvbiAoZS5nOiAnYW1hem9uYXdzLmNvbWApXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERPTUFJTl9TVUZGSVggPSAnZG9tYWluU3VmZml4JztcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgQVdTOjpDREs6Ok1ldGFkYXRhIENsb3VkRm9ybWF0aW9uIFJlc291cmNlIGlzIGF2YWlsYWJsZSBpbi1yZWdpb24gb3Igbm90LiBUaGUgdmFsdWUgaXMgYSBib29sZWFuXG4gICAqIG1vZGVsbGVkIGFzIGBZRVNgIG9yIGBOT2AuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IENES19NRVRBREFUQV9SRVNPVVJDRV9BVkFJTEFCTEUgPSAnY2RrOm1ldGFkYXRhLXJlc291cmNlOmF2YWlsYWJsZSc7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGdpdmVuIHJlZ2lvbiBpcyBhbiBvcHQtaW4gcmVnaW9uIG9yIG5vdC4gVGhlIHZhbHVlIGlzIGEgYm9vbGVhblxuICAgKiBtb2RlbGxlZCBhcyBgWUVTYCBvciBgTk9gLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBJU19PUFRfSU5fUkVHSU9OID0gJ2F3czppcy1vcHQtaW4tcmVnaW9uJztcblxuICAvKipcbiAgICogVGhlIGVuZHBvaW50IHVzZWQgZm9yIGhvc3RpbmcgUzMgc3RhdGljIHdlYnNpdGVzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFMzX1NUQVRJQ19XRUJTSVRFX0VORFBPSU5UID0gJ3MzLXN0YXRpYy13ZWJzaXRlOmVuZHBvaW50JztcblxuICAvKipcbiAgICogVGhlIGVuZHBvaW50IHVzZWQgZm9yIGFsaWFzaW5nIFMzIHN0YXRpYyB3ZWJzaXRlcyBpbiBSb3V0ZSA1M1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBTM19TVEFUSUNfV0VCU0lURV9aT05FXzUzX0hPU1RFRF9aT05FX0lEID0gJ3MzLXN0YXRpYy13ZWJzaXRlOnJvdXRlLTUzLWhvc3RlZC16b25lLWlkJztcblxuICAvKipcbiAgICogVGhlIGhvc3RlZCB6b25lIElEIHVzZWQgYnkgUm91dGUgNTMgdG8gYWxpYXMgYSBFQlMgZW52aXJvbm1lbnQgZW5kcG9pbnQgaW4gdGhpcyByZWdpb24gKGUuZzogWjJPMUVNUk85SzVHTFgpXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEVCU19FTlZfRU5EUE9JTlRfSE9TVEVEX1pPTkVfSUQgPSAnZWJzLWVudmlyb25tZW50OnJvdXRlLTUzLWhvc3RlZC16b25lLWlkJztcblxuICAvKipcbiAgICogVGhlIHByZWZpeCBmb3IgVlBDIEVuZHBvaW50IFNlcnZpY2UgbmFtZXMsXG4gICAqIGNuLmNvbS5hbWF6b25hd3MudnBjZSBmb3IgQ2hpbmEgcmVnaW9ucyxcbiAgICogY29tLmFtYXpvbmF3cy52cGNlIG90aGVyd2lzZS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgVlBDX0VORFBPSU5UX1NFUlZJQ0VfTkFNRV9QUkVGSVggPSAndnBjRW5kcG9pbnRTZXJ2aWNlTmFtZVByZWZpeCc7XG5cbiAgLyoqXG4gICAqIFRoZSBhY2NvdW50IGZvciBFTEJ2MiBpbiB0aGlzIHJlZ2lvblxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBFTEJWMl9BQ0NPVU5UID0gJ2VsYnYyQWNjb3VudCc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgQVdTIGFjY291bnQgdGhhdCBvd25zIHRoZSBwdWJsaWMgRUNSIHJlcG9zaXRvcnkgdGhhdCBjb250YWlucyB0aGVcbiAgICogQVdTIERlZXAgTGVhcm5pbmcgQ29udGFpbmVycyBpbWFnZXMgaW4gYSBnaXZlbiByZWdpb24uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERMQ19SRVBPU0lUT1JZX0FDQ09VTlQgPSAnZGxjUmVwb3NpdG9yeUFjY291bnQnO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIEFXUyBhY2NvdW50IHRoYXQgb3ducyB0aGUgcHVibGljIEVDUiByZXBvc2l0b3J5IHRoYXQgY29udGFpbnMgdGhlXG4gICAqIEFXUyBBcHAgTWVzaCBFbnZveSBQcm94eSBpbWFnZXMgaW4gYSBnaXZlbiByZWdpb24uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEFQUE1FU0hfRUNSX0FDQ09VTlQgPSAnYXBwTWVzaFJlcG9zaXRvcnlBY2NvdW50JztcblxuICAvKipcbiAgICogVGhlIENJRFIgYmxvY2sgdXNlZCBieSBBbWF6b24gRGF0YSBGaXJlaG9zZSBzZXJ2ZXJzLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBGSVJFSE9TRV9DSURSX0JMT0NLID0gJ2ZpcmVob3NlQ2lkckJsb2NrJztcblxuICAvKipcbiAgICogVGhlIFNBTUwgU2lnbiBPbiBVUkwgZm9yIHBhcnRpdGlvbiB1c2VkIGJ5IElBTSBTQU1MIFByaW5jaXBhbFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBTQU1MX1NJR05fT05fVVJMID0gJ3NhbWxTaWduT25VcmwnO1xuXG4gIC8qKlxuICAgKiBUaGUgbGF0ZXN0IExhbWJkYSBOb2RlSlMgcnVudGltZSBhdmFpbGFibGUgaW4gYSBnaXZlbiByZWdpb24uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IExBVEVTVF9OT0RFX1JVTlRJTUUgPSAnbGF0ZXN0Tm9kZVJ1bnRpbWUnO1xuXG4gIC8qKlxuICAgKiBUaGUgQVJOIG9mIENsb3VkV2F0Y2ggTGFtYmRhIEluc2lnaHRzIGZvciBhIHZlcnNpb24gKGUuZy4gMS4wLjk4LjApXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNsb3Vkd2F0Y2hMYW1iZGFJbnNpZ2h0c1ZlcnNpb24odmVyc2lvbjogc3RyaW5nLCBhcmNoPzogc3RyaW5nKSB7XG4gICAgLy8gaWYgd2UgYXJlIHByb3ZpZGVkIGFuIGFyY2hpdGVjdHVyZSB1c2UgdGhhdCwgb3RoZXJ3aXNlXG4gICAgLy8gZGVmYXVsdCB0byB4ODZfNjQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgY29uc3Qgc3VmZml4ID0gdmVyc2lvbi5zcGxpdCgnLicpLmpvaW4oJ18nKSArIGBfJHthcmNoID8/ICd4ODZfNjQnfWA7XG4gICAgcmV0dXJuIGBjbG91ZHdhdGNoLWxhbWJkYS1pbnNpZ2h0cy12ZXJzaW9uOiR7c3VmZml4fWA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIEFSTiBvZiBBcHBDb25maWcgTGFtYmRhIExheWVyIGZvciBhIGdpdmVuIHZlcnNpb24gKGUuZy4gMi4wLjE4MSlcbiAgICogQHBhcmFtIHZlcnNpb24gVGhlIGxheWVyIHZlcnNpb24uXG4gICAqIEBwYXJhbSBhcmNoIFRoZSBhcmNoaXRlY3R1cmUgKG9wdGlvbmFsKSwgZGVmYXVsdHMgdG8geDg2XzY0LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhcHBDb25maWdMYW1iZGFMYXllclZlcnNpb24odmVyc2lvbjogc3RyaW5nLCBhcmNoPzogc3RyaW5nKSB7XG4gICAgY29uc3Qgc3VmZml4ID0gdmVyc2lvbi5zcGxpdCgnLicpLmpvaW4oJ18nKSArIGBfJHthcmNoID8/ICd4ODZfNjQnfWA7XG4gICAgcmV0dXJuIGBhcHBjb25maWctbGFtYmRhLWxheWVyOiR7c3VmZml4fWA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHJlZ2lvbmFsIHNlcnZpY2UgcHJpbmNpcGFsIGZvciBhIGdpdmVuIHNlcnZpY2UuXG4gICAqXG4gICAqIEBwYXJhbSBzZXJ2aWNlIHRoZSBzZXJ2aWNlIG5hbWUsIGVpdGhlciBzaW1wbGUgKGUuZzogYHMzYCwgYGNvZGVkZXBsb3lgKSBvciBxdWFsaWZpZWQgKGUuZzogYHMzLmFtYXpvbmF3cy5jb21gKS5cbiAgICogICAgICAgICAgICAgICAgVGhlIGAuYW1hem9uYXdzLmNvbWAgYW5kIGAuYW1hem9uYXdzLmNvbS5jbmAgZG9tYWlucyBhcmUgc3RyaXBwZWQgZnJvbSBzZXJ2aWNlIG5hbWVzLCBzbyB0aGV5IGFyZVxuICAgKiAgICAgICAgICAgICAgICBjYW5vbmljYWxpemVkIGluIHRoYXQgcmVzcGVjdC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgLSBVc2UgYGlhbS5TZXJ2aWNlUHJpbmNpcGFsLnNlcnZpY2VQcmluY2lwYWxOYW1lKClgIGluc3RlYWQuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHNlcnZpY2VQcmluY2lwYWwoc2VydmljZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7c2VydmljZS5yZXBsYWNlKC9cXC5hbWF6b25hd3NcXC5jb20oXFwuY24pPyQvLCAnJyl9LmFtYXpvbmF3cy5jb21gO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBBUk4gb2YgQW1hem9uIERpc3RybyBmb3IgT3BlblRlbGVtZXRyeSAoQURPVCkgTGFtYmRhIGxheWVyIGZvciBhIGdpdmVuIGxhbWJkYSB0eXBlLCB2ZXJzaW9uIGFuZCBhcmNoaXRlY3R1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIHRoZSB0eXBlIG9mIHRoZSBBRE9UIGxhbWJkYSBsYXllclxuICAgKiBAcGFyYW0gdmVyc2lvbiB0aGUgbGF5ZXIgdmVyc2lvbi5cbiAgICogQHBhcmFtIGFyY2hpdGVjdHVyZSB0aGUgTGFtYmRhIEZ1bmN0aW9uIGFyY2hpdGVjdHVyZSAoZS5nLiAneDg2XzY0JyBvciAnYXJtNjQnKVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhZG90TGFtYmRhTGF5ZXIodHlwZTogc3RyaW5nLCB2ZXJzaW9uOiBzdHJpbmcsIGFyY2hpdGVjdHVyZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBzdWZmaXggPSB0eXBlICsgJ18nICsgdmVyc2lvbi5zcGxpdCgnLicpLmpvaW4oJ18nKSArICdfJyArIGFyY2hpdGVjdHVyZTtcbiAgICByZXR1cm4gYGFkb3QtbGFtYmRhLWxheWVyOiR7c3VmZml4fWA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIEFSTiBvZiBQYXJhbWV0ZXJzIGFuZCBTZWNyZXRzIExhbWJkYSBsYXllciBmb3IgYSBnaXZlbiBsYW1iZGEgYXJjaGl0ZWN0dXJlLlxuICAgKlxuICAgKiBAcGFyYW0gdmVyc2lvbiB0aGUgbGF5ZXIgdmVyc2lvblxuICAgKiBAcGFyYW0gYXJjaGl0ZWN0dXJlIHRoZSBMYW1iZGEgRnVuY3Rpb24gYXJjaGl0ZWN0dXJlIChlLmcuICd4ODZfNjQnIG9yICdhcm02NCcpXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHBhcmFtc0FuZFNlY3JldHNMYW1iZGFMYXllcih2ZXJzaW9uOiBzdHJpbmcsIGFyY2hpdGVjdHVyZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBzdWZmaXggPSB2ZXJzaW9uLnNwbGl0KCcuJykuam9pbignXycpICsgYF8ke2FyY2hpdGVjdHVyZX1gO1xuICAgIHJldHVybiBgcGFyYW1zLWFuZC1zZWNyZXRzLWxheWVyOiR7c3VmZml4fWA7XG4gIH1cbn1cbiJdfQ==