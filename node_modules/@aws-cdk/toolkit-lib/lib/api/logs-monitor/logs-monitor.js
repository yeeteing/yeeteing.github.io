"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloudWatchLogEventMonitor = void 0;
const util = require("util");
const chalk = require("chalk");
const uuid = require("uuid");
const util_1 = require("../../util");
const private_1 = require("../io/private");
class CloudWatchLogEventMonitor {
    /**
     * Determines which events not to display
     */
    startTime;
    /**
     * Map of environment (account:region) to LogGroupsAccessSettings
     */
    envsLogGroupsAccessSettings = new Map();
    /**
     * After reading events from all CloudWatch log groups
     * how long should we wait to read more events.
     *
     * If there is some error with reading events (i.e. Throttle)
     * then this is also how long we wait until we try again
     */
    pollingInterval = 2_000;
    monitorId;
    ioHelper;
    currentTick;
    constructor(props) {
        this.startTime = props.startTime?.getTime() ?? Date.now();
        this.ioHelper = props.ioHelper;
    }
    /**
     * resume reading/printing events
     */
    async activate() {
        this.monitorId = uuid.v4();
        await this.ioHelper.notify(private_1.IO.CDK_TOOLKIT_I5032.msg('Start monitoring log groups', {
            monitor: this.monitorId,
            logGroupNames: this.logGroupNames(),
        }));
        // tick schedules the next tick as well
        await this.tick();
    }
    /**
     * deactivates the monitor so no new events are read
     * use case for this is when we are in the middle of performing a deployment
     * and don't want to interweave all the logs together with the CFN
     * deployment logs
     *
     * Also resets the start time to be when the new deployment was triggered
     * and clears the list of tracked log groups
     */
    async deactivate() {
        const oldMonitorId = this.monitorId;
        this.monitorId = undefined;
        this.startTime = Date.now();
        clearTimeout(this.currentTick);
        await this.ioHelper.notify(private_1.IO.CDK_TOOLKIT_I5034.msg('Stopped monitoring log groups', {
            monitor: oldMonitorId,
            logGroupNames: this.logGroupNames(),
        }));
        this.envsLogGroupsAccessSettings.clear();
    }
    /**
     * Adds CloudWatch log groups to read log events from.
     * Since we could be watching multiple stacks that deploy to
     * multiple environments (account+region), we need to store a list of log groups
     * per env along with the SDK object that has access to read from
     * that environment.
     */
    addLogGroups(env, sdk, logGroupNames) {
        const awsEnv = `${env.account}:${env.region}`;
        const logGroupsStartTimes = logGroupNames.reduce((acc, groupName) => {
            acc[groupName] = this.startTime;
            return acc;
        }, {});
        this.envsLogGroupsAccessSettings.set(awsEnv, {
            sdk,
            logGroupsStartTimes: {
                ...this.envsLogGroupsAccessSettings.get(awsEnv)?.logGroupsStartTimes,
                ...logGroupsStartTimes,
            },
        });
    }
    logGroupNames() {
        return Array.from(this.envsLogGroupsAccessSettings.values()).flatMap((settings) => Object.keys(settings.logGroupsStartTimes));
    }
    scheduleNextTick() {
        if (!this.monitorId) {
            return;
        }
        this.currentTick = setTimeout(() => void this.tick(), this.pollingInterval);
    }
    async tick() {
        // excluding from codecoverage because this
        // doesn't always run (depends on timing)
        /* c8 ignore start */
        if (!this.monitorId) {
            return;
        }
        /* c8 ignore stop */
        try {
            const events = (0, util_1.flatten)(await this.readNewEvents());
            for (const event of events) {
                await this.print(event);
            }
            // We might have been stop()ped while the network call was in progress.
            if (!this.monitorId) {
                return;
            }
        }
        catch (e) {
            await this.ioHelper.notify(private_1.IO.CDK_TOOLKIT_E5035.msg(`Error occurred while monitoring logs: ${String(e)}`, { error: e }));
        }
        this.scheduleNextTick();
    }
    /**
     * Reads all new log events from a set of CloudWatch Log Groups
     * in parallel
     */
    async readNewEvents() {
        const promises = [];
        for (const settings of this.envsLogGroupsAccessSettings.values()) {
            for (const group of Object.keys(settings.logGroupsStartTimes)) {
                promises.push(this.readEventsFromLogGroup(settings, group));
            }
        }
        // Limited set of log groups
        // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
        return Promise.all(promises);
    }
    /**
     * Print out a cloudwatch event
     */
    async print(event) {
        await this.ioHelper.notify(private_1.IO.CDK_TOOLKIT_I5033.msg(util.format('[%s] %s %s', chalk.blue(event.logGroupName), chalk.yellow(event.timestamp.toLocaleTimeString()), event.message.trim()), event));
    }
    /**
     * Reads all new log events from a CloudWatch Log Group
     * starting at either the time the hotswap was triggered or
     * when the last event was read on the previous tick
     */
    async readEventsFromLogGroup(logGroupsAccessSettings, logGroupName) {
        const events = [];
        // log events from some service are ingested faster than others
        // so we need to track the start/end time for each log group individually
        // to make sure that we process all events from each log group
        const startTime = logGroupsAccessSettings.logGroupsStartTimes[logGroupName] ?? this.startTime;
        let endTime = startTime;
        try {
            const response = await logGroupsAccessSettings.sdk.cloudWatchLogs().filterLogEvents({
                logGroupName: logGroupName,
                limit: 100,
                startTime: startTime,
            });
            const filteredEvents = response.events ?? [];
            for (const event of filteredEvents) {
                if (event.message) {
                    events.push({
                        message: event.message,
                        logGroupName,
                        timestamp: event.timestamp ? new Date(event.timestamp) : new Date(),
                    });
                    if (event.timestamp && endTime < event.timestamp) {
                        endTime = event.timestamp;
                    }
                }
            }
            // As long as there are _any_ events in the log group `filterLogEvents` will return a nextToken.
            // This is true even if these events are before `startTime`. So if we have 100 events and a nextToken
            // then assume that we have hit the limit and let the user know some messages have been suppressed.
            // We are essentially showing them a sampling (10000 events printed out is not very useful)
            if (filteredEvents.length === 100 && response.nextToken) {
                events.push({
                    message: '>>> `watch` shows only the first 100 log messages - the rest have been truncated...',
                    logGroupName,
                    timestamp: new Date(endTime),
                });
            }
        }
        catch (e) {
            // with Lambda functions the CloudWatch is not created
            // until something is logged, so just keep polling until
            // there is somthing to find
            if (e.name === 'ResourceNotFoundException') {
                return [];
            }
            throw e;
        }
        logGroupsAccessSettings.logGroupsStartTimes[logGroupName] = endTime + 1;
        return events;
    }
}
exports.CloudWatchLogEventMonitor = CloudWatchLogEventMonitor;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9ncy1tb25pdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsibG9ncy1tb25pdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDZCQUE2QjtBQUU3QiwrQkFBK0I7QUFDL0IsNkJBQTZCO0FBRTdCLHFDQUFxQztBQUVyQywyQ0FBbUM7QUFvQ25DLE1BQWEseUJBQXlCO0lBQ3BDOztPQUVHO0lBQ0ssU0FBUyxDQUFTO0lBRTFCOztPQUVHO0lBQ2MsMkJBQTJCLEdBQUcsSUFBSSxHQUFHLEVBQW1DLENBQUM7SUFFMUY7Ozs7OztPQU1HO0lBQ2MsZUFBZSxHQUFXLEtBQUssQ0FBQztJQUUxQyxTQUFTLENBQVU7SUFFVCxRQUFRLENBQVc7SUFDNUIsV0FBVyxDQUFrQjtJQUVyQyxZQUFZLEtBQXFDO1FBQy9DLElBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUUsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDMUQsSUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDO0lBQ2pDLENBQUM7SUFFRDs7T0FFRztJQUNJLEtBQUssQ0FBQyxRQUFRO1FBQ25CLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBRTNCLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsWUFBRSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyw2QkFBNkIsRUFBRTtZQUNqRixPQUFPLEVBQUUsSUFBSSxDQUFDLFNBQVM7WUFDdkIsYUFBYSxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQUU7U0FDcEMsQ0FBQyxDQUFDLENBQUM7UUFFSix1Q0FBdUM7UUFDdkMsTUFBTSxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDcEIsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0ksS0FBSyxDQUFDLFVBQVU7UUFDckIsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLFNBQVUsQ0FBQztRQUNyQyxJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztRQUMzQixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUM1QixZQUFZLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRS9CLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsWUFBRSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQywrQkFBK0IsRUFBRTtZQUNuRixPQUFPLEVBQUUsWUFBWTtZQUNyQixhQUFhLEVBQUUsSUFBSSxDQUFDLGFBQWEsRUFBRTtTQUNwQyxDQUFDLENBQUMsQ0FBQztRQUVKLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUMzQyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksWUFBWSxDQUFDLEdBQXNCLEVBQUUsR0FBUSxFQUFFLGFBQXVCO1FBQzNFLE1BQU0sTUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDLE9BQU8sSUFBSSxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDOUMsTUFBTSxtQkFBbUIsR0FBRyxhQUFhLENBQUMsTUFBTSxDQUM5QyxDQUFDLEdBQUcsRUFBRSxTQUFTLEVBQUUsRUFBRTtZQUNqQixHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztZQUNoQyxPQUFPLEdBQUcsQ0FBQztRQUNiLENBQUMsRUFDRCxFQUF3QyxDQUN6QyxDQUFDO1FBQ0YsSUFBSSxDQUFDLDJCQUEyQixDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUU7WUFDM0MsR0FBRztZQUNILG1CQUFtQixFQUFFO2dCQUNuQixHQUFHLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUUsbUJBQW1CO2dCQUNwRSxHQUFHLG1CQUFtQjthQUN2QjtTQUNGLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFTyxhQUFhO1FBQ25CLE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsMkJBQTJCLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQztJQUNoSSxDQUFDO0lBRU8sZ0JBQWdCO1FBQ3RCLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDcEIsT0FBTztRQUNULENBQUM7UUFFRCxJQUFJLENBQUMsV0FBVyxHQUFHLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLLElBQUksQ0FBQyxJQUFJLEVBQUUsRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDOUUsQ0FBQztJQUVPLEtBQUssQ0FBQyxJQUFJO1FBQ2hCLDJDQUEyQztRQUMzQyx5Q0FBeUM7UUFDekMscUJBQXFCO1FBQ3JCLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDcEIsT0FBTztRQUNULENBQUM7UUFDRCxvQkFBb0I7UUFFcEIsSUFBSSxDQUFDO1lBQ0gsTUFBTSxNQUFNLEdBQUcsSUFBQSxjQUFPLEVBQUMsTUFBTSxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQztZQUNuRCxLQUFLLE1BQU0sS0FBSyxJQUFJLE1BQU0sRUFBRSxDQUFDO2dCQUMzQixNQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDMUIsQ0FBQztZQUVELHVFQUF1RTtZQUN2RSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO2dCQUNwQixPQUFPO1lBQ1QsQ0FBQztRQUNILENBQUM7UUFBQyxPQUFPLENBQU0sRUFBRSxDQUFDO1lBQ2hCLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsWUFBRSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyx5Q0FBeUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzNILENBQUM7UUFFRCxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztJQUMxQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssS0FBSyxDQUFDLGFBQWE7UUFDekIsTUFBTSxRQUFRLEdBQThDLEVBQUUsQ0FBQztRQUMvRCxLQUFLLE1BQU0sUUFBUSxJQUFJLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDO1lBQ2pFLEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsbUJBQW1CLENBQUMsRUFBRSxDQUFDO2dCQUM5RCxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUM5RCxDQUFDO1FBQ0gsQ0FBQztRQUNELDRCQUE0QjtRQUM1Qix3RUFBd0U7UUFDeEUsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFFRDs7T0FFRztJQUNLLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBeUI7UUFDM0MsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxZQUFFLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUNqRCxJQUFJLENBQUMsTUFBTSxDQUNULFlBQVksRUFDWixLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsRUFDOUIsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLGtCQUFrQixFQUFFLENBQUMsRUFDbEQsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FDckIsRUFDRCxLQUFLLENBQ04sQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyxLQUFLLENBQUMsc0JBQXNCLENBQ2xDLHVCQUFnRCxFQUNoRCxZQUFvQjtRQUVwQixNQUFNLE1BQU0sR0FBeUIsRUFBRSxDQUFDO1FBRXhDLCtEQUErRDtRQUMvRCx5RUFBeUU7UUFDekUsOERBQThEO1FBQzlELE1BQU0sU0FBUyxHQUFHLHVCQUF1QixDQUFDLG1CQUFtQixDQUFDLFlBQVksQ0FBQyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUM7UUFDOUYsSUFBSSxPQUFPLEdBQUcsU0FBUyxDQUFDO1FBQ3hCLElBQUksQ0FBQztZQUNILE1BQU0sUUFBUSxHQUFHLE1BQU0sdUJBQXVCLENBQUMsR0FBRyxDQUFDLGNBQWMsRUFBRSxDQUFDLGVBQWUsQ0FBQztnQkFDbEYsWUFBWSxFQUFFLFlBQVk7Z0JBQzFCLEtBQUssRUFBRSxHQUFHO2dCQUNWLFNBQVMsRUFBRSxTQUFTO2FBQ3JCLENBQUMsQ0FBQztZQUNILE1BQU0sY0FBYyxHQUFHLFFBQVEsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDO1lBRTdDLEtBQUssTUFBTSxLQUFLLElBQUksY0FBYyxFQUFFLENBQUM7Z0JBQ25DLElBQUksS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDO29CQUNsQixNQUFNLENBQUMsSUFBSSxDQUFDO3dCQUNWLE9BQU8sRUFBRSxLQUFLLENBQUMsT0FBTzt3QkFDdEIsWUFBWTt3QkFDWixTQUFTLEVBQUUsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksRUFBRTtxQkFDcEUsQ0FBQyxDQUFDO29CQUVILElBQUksS0FBSyxDQUFDLFNBQVMsSUFBSSxPQUFPLEdBQUcsS0FBSyxDQUFDLFNBQVMsRUFBRSxDQUFDO3dCQUNqRCxPQUFPLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQztvQkFDNUIsQ0FBQztnQkFDSCxDQUFDO1lBQ0gsQ0FBQztZQUNELGdHQUFnRztZQUNoRyxxR0FBcUc7WUFDckcsbUdBQW1HO1lBQ25HLDJGQUEyRjtZQUMzRixJQUFJLGNBQWMsQ0FBQyxNQUFNLEtBQUssR0FBRyxJQUFJLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQztnQkFDeEQsTUFBTSxDQUFDLElBQUksQ0FBQztvQkFDVixPQUFPLEVBQUUscUZBQXFGO29CQUM5RixZQUFZO29CQUNaLFNBQVMsRUFBRSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUM7aUJBQzdCLENBQUMsQ0FBQztZQUNMLENBQUM7UUFDSCxDQUFDO1FBQUMsT0FBTyxDQUFNLEVBQUUsQ0FBQztZQUNoQixzREFBc0Q7WUFDdEQsd0RBQXdEO1lBQ3hELDRCQUE0QjtZQUM1QixJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssMkJBQTJCLEVBQUUsQ0FBQztnQkFDM0MsT0FBTyxFQUFFLENBQUM7WUFDWixDQUFDO1lBQ0QsTUFBTSxDQUFDLENBQUM7UUFDVixDQUFDO1FBQ0QsdUJBQXVCLENBQUMsbUJBQW1CLENBQUMsWUFBWSxDQUFDLEdBQUcsT0FBTyxHQUFHLENBQUMsQ0FBQztRQUN4RSxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0NBQ0Y7QUE5TkQsOERBOE5DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdXRpbCBmcm9tICd1dGlsJztcbmltcG9ydCB0eXBlICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCAqIGFzIHV1aWQgZnJvbSAndXVpZCc7XG5pbXBvcnQgdHlwZSB7IENsb3VkV2F0Y2hMb2dFdmVudCB9IGZyb20gJy4uLy4uL3BheWxvYWRzL2xvZ3MtbW9uaXRvcic7XG5pbXBvcnQgeyBmbGF0dGVuIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgdHlwZSB7IFNESyB9IGZyb20gJy4uL2F3cy1hdXRoL3ByaXZhdGUnO1xuaW1wb3J0IHsgSU8gfSBmcm9tICcuLi9pby9wcml2YXRlJztcbmltcG9ydCB0eXBlIHsgSW9IZWxwZXIgfSBmcm9tICcuLi9pby9wcml2YXRlJztcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIHRyYWNraW5nIGluZm9ybWF0aW9uIG9uIHRoZSBsb2cgZ3JvdXBzIHRoYXQgYXJlXG4gKiBiZWluZyBtb25pdG9yZWRcbiAqL1xuaW50ZXJmYWNlIExvZ0dyb3Vwc0FjY2Vzc1NldHRpbmdzIHtcbiAgLyoqXG4gICAqIFRoZSBTREsgZm9yIGEgZ2l2ZW4gZW52aXJvbm1lbnQgKGFjY291bnQvcmVnaW9uKVxuICAgKi9cbiAgcmVhZG9ubHkgc2RrOiBTREs7XG5cbiAgLyoqXG4gICAqIEEgbWFwIG9mIGxvZyBncm91cHMgYW5kIGFzc29jaWF0ZWQgc3RhcnRUaW1lIGluIGEgZ2l2ZW4gYWNjb3VudC5cbiAgICpcbiAgICogVGhlIG1vbml0b3Igd2lsbCByZWFkIGV2ZW50cyBmcm9tIHRoZSBsb2cgZ3JvdXAgc3RhcnRpbmcgYXQgdGhlXG4gICAqIGFzc29jaWF0ZWQgc3RhcnRUaW1lXG4gICAqL1xuICByZWFkb25seSBsb2dHcm91cHNTdGFydFRpbWVzOiB7IFtsb2dHcm91cE5hbWU6IHN0cmluZ106IG51bWJlciB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENsb3VkV2F0Y2hMb2dFdmVudE1vbml0b3JQcm9wcyB7XG4gIC8qKlxuICAgKiBUaGUgSW9Ib3N0IHVzZWQgZm9yIG1lc3NhZ2luZ1xuICAgKi9cbiAgcmVhZG9ubHkgaW9IZWxwZXI6IElvSGVscGVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdGltZSBmcm9tIHdoaWNoIHdlIHN0YXJ0IHJlYWRpbmcgbG9nIG1lc3NhZ2VzXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm93XG4gICAqL1xuICByZWFkb25seSBzdGFydFRpbWU/OiBEYXRlO1xufVxuXG5leHBvcnQgY2xhc3MgQ2xvdWRXYXRjaExvZ0V2ZW50TW9uaXRvciB7XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoaWNoIGV2ZW50cyBub3QgdG8gZGlzcGxheVxuICAgKi9cbiAgcHJpdmF0ZSBzdGFydFRpbWU6IG51bWJlcjtcblxuICAvKipcbiAgICogTWFwIG9mIGVudmlyb25tZW50IChhY2NvdW50OnJlZ2lvbikgdG8gTG9nR3JvdXBzQWNjZXNzU2V0dGluZ3NcbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgZW52c0xvZ0dyb3Vwc0FjY2Vzc1NldHRpbmdzID0gbmV3IE1hcDxzdHJpbmcsIExvZ0dyb3Vwc0FjY2Vzc1NldHRpbmdzPigpO1xuXG4gIC8qKlxuICAgKiBBZnRlciByZWFkaW5nIGV2ZW50cyBmcm9tIGFsbCBDbG91ZFdhdGNoIGxvZyBncm91cHNcbiAgICogaG93IGxvbmcgc2hvdWxkIHdlIHdhaXQgdG8gcmVhZCBtb3JlIGV2ZW50cy5cbiAgICpcbiAgICogSWYgdGhlcmUgaXMgc29tZSBlcnJvciB3aXRoIHJlYWRpbmcgZXZlbnRzIChpLmUuIFRocm90dGxlKVxuICAgKiB0aGVuIHRoaXMgaXMgYWxzbyBob3cgbG9uZyB3ZSB3YWl0IHVudGlsIHdlIHRyeSBhZ2FpblxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBwb2xsaW5nSW50ZXJ2YWw6IG51bWJlciA9IDJfMDAwO1xuXG4gIHB1YmxpYyBtb25pdG9ySWQ/OiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBpb0hlbHBlcjogSW9IZWxwZXI7XG4gIHByaXZhdGUgY3VycmVudFRpY2s/OiBOb2RlSlMuVGltZW91dDtcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogQ2xvdWRXYXRjaExvZ0V2ZW50TW9uaXRvclByb3BzKSB7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBwcm9wcy5zdGFydFRpbWU/LmdldFRpbWUoKSA/PyBEYXRlLm5vdygpO1xuICAgIHRoaXMuaW9IZWxwZXIgPSBwcm9wcy5pb0hlbHBlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXN1bWUgcmVhZGluZy9wcmludGluZyBldmVudHNcbiAgICovXG4gIHB1YmxpYyBhc3luYyBhY3RpdmF0ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLm1vbml0b3JJZCA9IHV1aWQudjQoKTtcblxuICAgIGF3YWl0IHRoaXMuaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0k1MDMyLm1zZygnU3RhcnQgbW9uaXRvcmluZyBsb2cgZ3JvdXBzJywge1xuICAgICAgbW9uaXRvcjogdGhpcy5tb25pdG9ySWQsXG4gICAgICBsb2dHcm91cE5hbWVzOiB0aGlzLmxvZ0dyb3VwTmFtZXMoKSxcbiAgICB9KSk7XG5cbiAgICAvLyB0aWNrIHNjaGVkdWxlcyB0aGUgbmV4dCB0aWNrIGFzIHdlbGxcbiAgICBhd2FpdCB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkZWFjdGl2YXRlcyB0aGUgbW9uaXRvciBzbyBubyBuZXcgZXZlbnRzIGFyZSByZWFkXG4gICAqIHVzZSBjYXNlIGZvciB0aGlzIGlzIHdoZW4gd2UgYXJlIGluIHRoZSBtaWRkbGUgb2YgcGVyZm9ybWluZyBhIGRlcGxveW1lbnRcbiAgICogYW5kIGRvbid0IHdhbnQgdG8gaW50ZXJ3ZWF2ZSBhbGwgdGhlIGxvZ3MgdG9nZXRoZXIgd2l0aCB0aGUgQ0ZOXG4gICAqIGRlcGxveW1lbnQgbG9nc1xuICAgKlxuICAgKiBBbHNvIHJlc2V0cyB0aGUgc3RhcnQgdGltZSB0byBiZSB3aGVuIHRoZSBuZXcgZGVwbG95bWVudCB3YXMgdHJpZ2dlcmVkXG4gICAqIGFuZCBjbGVhcnMgdGhlIGxpc3Qgb2YgdHJhY2tlZCBsb2cgZ3JvdXBzXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGVhY3RpdmF0ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBvbGRNb25pdG9ySWQgPSB0aGlzLm1vbml0b3JJZCE7XG4gICAgdGhpcy5tb25pdG9ySWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmN1cnJlbnRUaWNrKTtcblxuICAgIGF3YWl0IHRoaXMuaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0k1MDM0Lm1zZygnU3RvcHBlZCBtb25pdG9yaW5nIGxvZyBncm91cHMnLCB7XG4gICAgICBtb25pdG9yOiBvbGRNb25pdG9ySWQsXG4gICAgICBsb2dHcm91cE5hbWVzOiB0aGlzLmxvZ0dyb3VwTmFtZXMoKSxcbiAgICB9KSk7XG5cbiAgICB0aGlzLmVudnNMb2dHcm91cHNBY2Nlc3NTZXR0aW5ncy5jbGVhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgQ2xvdWRXYXRjaCBsb2cgZ3JvdXBzIHRvIHJlYWQgbG9nIGV2ZW50cyBmcm9tLlxuICAgKiBTaW5jZSB3ZSBjb3VsZCBiZSB3YXRjaGluZyBtdWx0aXBsZSBzdGFja3MgdGhhdCBkZXBsb3kgdG9cbiAgICogbXVsdGlwbGUgZW52aXJvbm1lbnRzIChhY2NvdW50K3JlZ2lvbiksIHdlIG5lZWQgdG8gc3RvcmUgYSBsaXN0IG9mIGxvZyBncm91cHNcbiAgICogcGVyIGVudiBhbG9uZyB3aXRoIHRoZSBTREsgb2JqZWN0IHRoYXQgaGFzIGFjY2VzcyB0byByZWFkIGZyb21cbiAgICogdGhhdCBlbnZpcm9ubWVudC5cbiAgICovXG4gIHB1YmxpYyBhZGRMb2dHcm91cHMoZW52OiBjeGFwaS5FbnZpcm9ubWVudCwgc2RrOiBTREssIGxvZ0dyb3VwTmFtZXM6IHN0cmluZ1tdKTogdm9pZCB7XG4gICAgY29uc3QgYXdzRW52ID0gYCR7ZW52LmFjY291bnR9OiR7ZW52LnJlZ2lvbn1gO1xuICAgIGNvbnN0IGxvZ0dyb3Vwc1N0YXJ0VGltZXMgPSBsb2dHcm91cE5hbWVzLnJlZHVjZShcbiAgICAgIChhY2MsIGdyb3VwTmFtZSkgPT4ge1xuICAgICAgICBhY2NbZ3JvdXBOYW1lXSA9IHRoaXMuc3RhcnRUaW1lO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSxcbiAgICAgIHt9IGFzIHsgW2xvZ0dyb3VwTmFtZTogc3RyaW5nXTogbnVtYmVyIH0sXG4gICAgKTtcbiAgICB0aGlzLmVudnNMb2dHcm91cHNBY2Nlc3NTZXR0aW5ncy5zZXQoYXdzRW52LCB7XG4gICAgICBzZGssXG4gICAgICBsb2dHcm91cHNTdGFydFRpbWVzOiB7XG4gICAgICAgIC4uLnRoaXMuZW52c0xvZ0dyb3Vwc0FjY2Vzc1NldHRpbmdzLmdldChhd3NFbnYpPy5sb2dHcm91cHNTdGFydFRpbWVzLFxuICAgICAgICAuLi5sb2dHcm91cHNTdGFydFRpbWVzLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgbG9nR3JvdXBOYW1lcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5lbnZzTG9nR3JvdXBzQWNjZXNzU2V0dGluZ3MudmFsdWVzKCkpLmZsYXRNYXAoKHNldHRpbmdzKSA9PiBPYmplY3Qua2V5cyhzZXR0aW5ncy5sb2dHcm91cHNTdGFydFRpbWVzKSk7XG4gIH1cblxuICBwcml2YXRlIHNjaGVkdWxlTmV4dFRpY2soKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLm1vbml0b3JJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudFRpY2sgPSBzZXRUaW1lb3V0KCgpID0+IHZvaWQgdGhpcy50aWNrKCksIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgdGljaygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBleGNsdWRpbmcgZnJvbSBjb2RlY292ZXJhZ2UgYmVjYXVzZSB0aGlzXG4gICAgLy8gZG9lc24ndCBhbHdheXMgcnVuIChkZXBlbmRzIG9uIHRpbWluZylcbiAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICBpZiAoIXRoaXMubW9uaXRvcklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZXZlbnRzID0gZmxhdHRlbihhd2FpdCB0aGlzLnJlYWROZXdFdmVudHMoKSk7XG4gICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgICBhd2FpdCB0aGlzLnByaW50KGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgbWlnaHQgaGF2ZSBiZWVuIHN0b3AoKXBlZCB3aGlsZSB0aGUgbmV0d29yayBjYWxsIHdhcyBpbiBwcm9ncmVzcy5cbiAgICAgIGlmICghdGhpcy5tb25pdG9ySWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgYXdhaXQgdGhpcy5pb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfRTUwMzUubXNnKGBFcnJvciBvY2N1cnJlZCB3aGlsZSBtb25pdG9yaW5nIGxvZ3M6ICR7U3RyaW5nKGUpfWAsIHsgZXJyb3I6IGUgfSkpO1xuICAgIH1cblxuICAgIHRoaXMuc2NoZWR1bGVOZXh0VGljaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIGFsbCBuZXcgbG9nIGV2ZW50cyBmcm9tIGEgc2V0IG9mIENsb3VkV2F0Y2ggTG9nIEdyb3Vwc1xuICAgKiBpbiBwYXJhbGxlbFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyByZWFkTmV3RXZlbnRzKCk6IFByb21pc2U8QXJyYXk8QXJyYXk8Q2xvdWRXYXRjaExvZ0V2ZW50Pj4+IHtcbiAgICBjb25zdCBwcm9taXNlczogQXJyYXk8UHJvbWlzZTxBcnJheTxDbG91ZFdhdGNoTG9nRXZlbnQ+Pj4gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHNldHRpbmdzIG9mIHRoaXMuZW52c0xvZ0dyb3Vwc0FjY2Vzc1NldHRpbmdzLnZhbHVlcygpKSB7XG4gICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIE9iamVjdC5rZXlzKHNldHRpbmdzLmxvZ0dyb3Vwc1N0YXJ0VGltZXMpKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2godGhpcy5yZWFkRXZlbnRzRnJvbUxvZ0dyb3VwKHNldHRpbmdzLCBncm91cCkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBMaW1pdGVkIHNldCBvZiBsb2cgZ3JvdXBzXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBjZGtsYWJzL3Byb21pc2VhbGwtbm8tdW5ib3VuZGVkLXBhcmFsbGVsaXNtXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmludCBvdXQgYSBjbG91ZHdhdGNoIGV2ZW50XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHByaW50KGV2ZW50OiBDbG91ZFdhdGNoTG9nRXZlbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLmlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9JNTAzMy5tc2coXG4gICAgICB1dGlsLmZvcm1hdChcbiAgICAgICAgJ1slc10gJXMgJXMnLFxuICAgICAgICBjaGFsay5ibHVlKGV2ZW50LmxvZ0dyb3VwTmFtZSksXG4gICAgICAgIGNoYWxrLnllbGxvdyhldmVudC50aW1lc3RhbXAudG9Mb2NhbGVUaW1lU3RyaW5nKCkpLFxuICAgICAgICBldmVudC5tZXNzYWdlLnRyaW0oKSxcbiAgICAgICksXG4gICAgICBldmVudCxcbiAgICApKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBhbGwgbmV3IGxvZyBldmVudHMgZnJvbSBhIENsb3VkV2F0Y2ggTG9nIEdyb3VwXG4gICAqIHN0YXJ0aW5nIGF0IGVpdGhlciB0aGUgdGltZSB0aGUgaG90c3dhcCB3YXMgdHJpZ2dlcmVkIG9yXG4gICAqIHdoZW4gdGhlIGxhc3QgZXZlbnQgd2FzIHJlYWQgb24gdGhlIHByZXZpb3VzIHRpY2tcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcmVhZEV2ZW50c0Zyb21Mb2dHcm91cChcbiAgICBsb2dHcm91cHNBY2Nlc3NTZXR0aW5nczogTG9nR3JvdXBzQWNjZXNzU2V0dGluZ3MsXG4gICAgbG9nR3JvdXBOYW1lOiBzdHJpbmcsXG4gICk6IFByb21pc2U8QXJyYXk8Q2xvdWRXYXRjaExvZ0V2ZW50Pj4ge1xuICAgIGNvbnN0IGV2ZW50czogQ2xvdWRXYXRjaExvZ0V2ZW50W10gPSBbXTtcblxuICAgIC8vIGxvZyBldmVudHMgZnJvbSBzb21lIHNlcnZpY2UgYXJlIGluZ2VzdGVkIGZhc3RlciB0aGFuIG90aGVyc1xuICAgIC8vIHNvIHdlIG5lZWQgdG8gdHJhY2sgdGhlIHN0YXJ0L2VuZCB0aW1lIGZvciBlYWNoIGxvZyBncm91cCBpbmRpdmlkdWFsbHlcbiAgICAvLyB0byBtYWtlIHN1cmUgdGhhdCB3ZSBwcm9jZXNzIGFsbCBldmVudHMgZnJvbSBlYWNoIGxvZyBncm91cFxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IGxvZ0dyb3Vwc0FjY2Vzc1NldHRpbmdzLmxvZ0dyb3Vwc1N0YXJ0VGltZXNbbG9nR3JvdXBOYW1lXSA/PyB0aGlzLnN0YXJ0VGltZTtcbiAgICBsZXQgZW5kVGltZSA9IHN0YXJ0VGltZTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBsb2dHcm91cHNBY2Nlc3NTZXR0aW5ncy5zZGsuY2xvdWRXYXRjaExvZ3MoKS5maWx0ZXJMb2dFdmVudHMoe1xuICAgICAgICBsb2dHcm91cE5hbWU6IGxvZ0dyb3VwTmFtZSxcbiAgICAgICAgbGltaXQ6IDEwMCxcbiAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGZpbHRlcmVkRXZlbnRzID0gcmVzcG9uc2UuZXZlbnRzID8/IFtdO1xuXG4gICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGZpbHRlcmVkRXZlbnRzKSB7XG4gICAgICAgIGlmIChldmVudC5tZXNzYWdlKSB7XG4gICAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbWVzc2FnZTogZXZlbnQubWVzc2FnZSxcbiAgICAgICAgICAgIGxvZ0dyb3VwTmFtZSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogZXZlbnQudGltZXN0YW1wID8gbmV3IERhdGUoZXZlbnQudGltZXN0YW1wKSA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoZXZlbnQudGltZXN0YW1wICYmIGVuZFRpbWUgPCBldmVudC50aW1lc3RhbXApIHtcbiAgICAgICAgICAgIGVuZFRpbWUgPSBldmVudC50aW1lc3RhbXA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBcyBsb25nIGFzIHRoZXJlIGFyZSBfYW55XyBldmVudHMgaW4gdGhlIGxvZyBncm91cCBgZmlsdGVyTG9nRXZlbnRzYCB3aWxsIHJldHVybiBhIG5leHRUb2tlbi5cbiAgICAgIC8vIFRoaXMgaXMgdHJ1ZSBldmVuIGlmIHRoZXNlIGV2ZW50cyBhcmUgYmVmb3JlIGBzdGFydFRpbWVgLiBTbyBpZiB3ZSBoYXZlIDEwMCBldmVudHMgYW5kIGEgbmV4dFRva2VuXG4gICAgICAvLyB0aGVuIGFzc3VtZSB0aGF0IHdlIGhhdmUgaGl0IHRoZSBsaW1pdCBhbmQgbGV0IHRoZSB1c2VyIGtub3cgc29tZSBtZXNzYWdlcyBoYXZlIGJlZW4gc3VwcHJlc3NlZC5cbiAgICAgIC8vIFdlIGFyZSBlc3NlbnRpYWxseSBzaG93aW5nIHRoZW0gYSBzYW1wbGluZyAoMTAwMDAgZXZlbnRzIHByaW50ZWQgb3V0IGlzIG5vdCB2ZXJ5IHVzZWZ1bClcbiAgICAgIGlmIChmaWx0ZXJlZEV2ZW50cy5sZW5ndGggPT09IDEwMCAmJiByZXNwb25zZS5uZXh0VG9rZW4pIHtcbiAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgIG1lc3NhZ2U6ICc+Pj4gYHdhdGNoYCBzaG93cyBvbmx5IHRoZSBmaXJzdCAxMDAgbG9nIG1lc3NhZ2VzIC0gdGhlIHJlc3QgaGF2ZSBiZWVuIHRydW5jYXRlZC4uLicsXG4gICAgICAgICAgbG9nR3JvdXBOYW1lLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoZW5kVGltZSksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgLy8gd2l0aCBMYW1iZGEgZnVuY3Rpb25zIHRoZSBDbG91ZFdhdGNoIGlzIG5vdCBjcmVhdGVkXG4gICAgICAvLyB1bnRpbCBzb21ldGhpbmcgaXMgbG9nZ2VkLCBzbyBqdXN0IGtlZXAgcG9sbGluZyB1bnRpbFxuICAgICAgLy8gdGhlcmUgaXMgc29tdGhpbmcgdG8gZmluZFxuICAgICAgaWYgKGUubmFtZSA9PT0gJ1Jlc291cmNlTm90Rm91bmRFeGNlcHRpb24nKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGxvZ0dyb3Vwc0FjY2Vzc1NldHRpbmdzLmxvZ0dyb3Vwc1N0YXJ0VGltZXNbbG9nR3JvdXBOYW1lXSA9IGVuZFRpbWUgKyAxO1xuICAgIHJldHVybiBldmVudHM7XG4gIH1cbn1cbiJdfQ==