import { ConversationMessage, ConversationTurnEvent } from './types';
import { GraphqlRequestExecutor } from './graphql_request_executor';
export type ConversationHistoryMessageItem = ConversationMessage & {
    id: string;
    conversationId: string;
    associatedUserMessageId?: string;
    aiContext?: unknown;
};
export type GetQueryInput = {
    id: string;
};
export type GetQueryOutput = {
    data: Record<string, ConversationHistoryMessageItem>;
};
export type ListQueryInput = {
    filter: {
        conversationId: {
            eq: string;
        };
    };
    limit: number;
};
export type ListQueryOutput = {
    data: Record<string, {
        items: Array<ConversationHistoryMessageItem>;
    }>;
};
/**
 * This class is responsible for retrieving message history that belongs to conversation turn event.
 * It queries AppSync to list messages that belong to conversation.
 * Additionally, it looks up a current message in case it's missing in the list due to eventual consistency.
 */
export declare class ConversationMessageHistoryRetriever {
    private readonly event;
    private readonly graphqlRequestExecutor;
    /**
     * Creates conversation message history retriever.
     */
    constructor(event: ConversationTurnEvent, graphqlRequestExecutor?: GraphqlRequestExecutor);
    getMessageHistory: () => Promise<Array<ConversationMessage>>;
    /**
     * This function removes tool usage from non-current turns.
     * The tool usage and result blocks don't matter after a turn is completed,
     * but do cost extra tokens to process.
     * The algorithm is as follows:
     * 1. Find where current turn begins. I.e. last user message that isn't tool block.
     * 2. Remove toolUse and toolResult blocks before current turn.
     * 3. Squash continuous sequences of messages that belong to same 'message.role'.
     */
    private squashNonCurrentTurns;
    private getCurrentMessage;
    private listMessages;
}
//# sourceMappingURL=conversation_message_history_retriever.d.ts.map