"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cdkCredentialsConfigFile = cdkCredentialsConfigFile;
exports.cdkCredentialsConfig = cdkCredentialsConfig;
exports._clearCdkCredentialsConfigCache = _clearCdkCredentialsConfigCache;
exports.fetchDockerLoginCredentials = fetchDockerLoginCredentials;
exports.obtainEcrCredentials = obtainEcrCredentials;
const fs = require("fs");
const os = require("os");
const path = require("path");
const progress_1 = require("../progress");
/** Returns the presumed location of the CDK Docker credentials config file */
function cdkCredentialsConfigFile() {
    return (process.env.CDK_DOCKER_CREDS_FILE ??
        path.join((os.userInfo().homedir ?? os.homedir()).trim() || '/', '.cdk', 'cdk-docker-creds.json'));
}
let _cdkCredentials;
/** Loads and parses the CDK Docker credentials configuration, if it exists. */
function cdkCredentialsConfig() {
    if (!_cdkCredentials) {
        try {
            _cdkCredentials = JSON.parse(fs.readFileSync(cdkCredentialsConfigFile(), { encoding: 'utf-8' }));
        }
        catch {
        }
    }
    return _cdkCredentials;
}
/**
 * Just for testing
 */
function _clearCdkCredentialsConfigCache() {
    _cdkCredentials = undefined;
}
/** Fetches login credentials from the configured source (e.g., SecretsManager, ECR) */
async function fetchDockerLoginCredentials(aws, config, endpoint) {
    // Paranoid handling to ensure new URL() doesn't throw if the schema is missing
    // For official docker registry, docker will pass https://index.docker.io/v1/
    endpoint = endpoint.includes('://') ? endpoint : `https://${endpoint}`;
    const domain = new URL(endpoint).hostname;
    if (!Object.keys(config.domainCredentials).includes(domain) &&
        !Object.keys(config.domainCredentials).includes(endpoint)) {
        throw new Error(`unknown domain ${domain}`);
    }
    let domainConfig = config.domainCredentials[domain] ?? config.domainCredentials[endpoint];
    if (domainConfig.secretsManagerSecretId) {
        const sm = await aws.secretsManagerClient({ assumeRoleArn: domainConfig.assumeRoleArn });
        const secretValue = await sm.getSecretValue({
            SecretId: domainConfig.secretsManagerSecretId,
        });
        if (!secretValue.SecretString) {
            throw new Error(`unable to fetch SecretString from secret: ${domainConfig.secretsManagerSecretId}`);
        }
        const secret = JSON.parse(secretValue.SecretString);
        const usernameField = domainConfig.secretsUsernameField ?? 'username';
        const secretField = domainConfig.secretsPasswordField ?? 'secret';
        if (!secret[usernameField] || !secret[secretField]) {
            throw new Error(`malformed secret string ("${usernameField}" or "${secretField}" field missing)`);
        }
        return { Username: secret[usernameField], Secret: secret[secretField] };
    }
    else if (domainConfig.ecrRepository) {
        const ecr = await aws.ecrClient({ assumeRoleArn: domainConfig.assumeRoleArn });
        const ecrAuthData = await obtainEcrCredentials(ecr);
        return { Username: ecrAuthData.username, Secret: ecrAuthData.password };
    }
    else {
        throw new Error('unknown credential type: no secret ID or ECR repo');
    }
}
async function obtainEcrCredentials(ecr, eventEmitter) {
    if (eventEmitter) {
        eventEmitter(progress_1.EventType.DEBUG, 'Fetching ECR authorization token');
    }
    const authData = (await ecr.getAuthorizationToken()).authorizationData || [];
    if (authData.length === 0) {
        throw new Error('No authorization data received from ECR');
    }
    const token = Buffer.from(authData[0].authorizationToken, 'base64').toString('ascii');
    const [username, password] = token.split(':');
    if (!username || !password) {
        throw new Error('unexpected ECR authData format');
    }
    return {
        username,
        password,
        endpoint: authData[0].proxyEndpoint,
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG9ja2VyLWNyZWRlbnRpYWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZG9ja2VyLWNyZWRlbnRpYWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBMEJBLDREQVNDO0FBSUQsb0RBVUM7QUFLRCwwRUFFQztBQUdELGtFQWlEQztBQUVELG9EQW9CQztBQWxJRCx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUc3QiwwQ0FBd0M7QUFvQnhDLDhFQUE4RTtBQUM5RSxTQUFnQix3QkFBd0I7SUFDdEMsT0FBTyxDQUNMLE9BQU8sQ0FBQyxHQUFHLENBQUMscUJBQXFCO1FBQ2pDLElBQUksQ0FBQyxJQUFJLENBQ1AsQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLENBQUMsT0FBTyxJQUFJLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxJQUFJLEdBQUcsRUFDckQsTUFBTSxFQUNOLHVCQUF1QixDQUN4QixDQUNGLENBQUM7QUFDSixDQUFDO0FBRUQsSUFBSSxlQUFvRCxDQUFDO0FBQ3pELCtFQUErRTtBQUMvRSxTQUFnQixvQkFBb0I7SUFDbEMsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQ3JCLElBQUksQ0FBQztZQUNILGVBQWUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUMxQixFQUFFLENBQUMsWUFBWSxDQUFDLHdCQUF3QixFQUFFLEVBQUUsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FDeEMsQ0FBQztRQUMvQixDQUFDO1FBQUMsTUFBTSxDQUFDO1FBQ1QsQ0FBQztJQUNILENBQUM7SUFDRCxPQUFPLGVBQWUsQ0FBQztBQUN6QixDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQiwrQkFBK0I7SUFDN0MsZUFBZSxHQUFHLFNBQVMsQ0FBQztBQUM5QixDQUFDO0FBRUQsdUZBQXVGO0FBQ2hGLEtBQUssVUFBVSwyQkFBMkIsQ0FDL0MsR0FBUyxFQUNULE1BQStCLEVBQy9CLFFBQWdCO0lB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QkFBcUIsRUFBRSxDQUFDLENBQUMsaUJBQWlCLElBQUksRUFBRSxDQUFDO0lBQzdFLElBQUksUUFBUSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztRQUMxQixNQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7SUFDN0QsQ0FBQztJQUNELE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLGtCQUFtQixFQUFFLFFBQVEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN2RixNQUFNLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDOUMsSUFBSSxDQUFDLFFBQVEsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQzNCLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBRUQsT0FBTztRQUNMLFFBQVE7UUFDUixRQUFRO1FBQ1IsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFjO0tBQ3JDLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgb3MgZnJvbSAnb3MnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB0eXBlIHsgSUF3cywgSUVDUkNsaWVudCB9IGZyb20gJy4uL2F3cyc7XG5pbXBvcnQgdHlwZSB7IEV2ZW50RW1pdHRlciB9IGZyb20gJy4uL3Byb2dyZXNzJztcbmltcG9ydCB7IEV2ZW50VHlwZSB9IGZyb20gJy4uL3Byb2dyZXNzJztcblxuZXhwb3J0IGludGVyZmFjZSBEb2NrZXJDcmVkZW50aWFscyB7XG4gIHJlYWRvbmx5IFVzZXJuYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IFNlY3JldDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERvY2tlckNyZWRlbnRpYWxzQ29uZmlnIHtcbiAgcmVhZG9ubHkgdmVyc2lvbjogc3RyaW5nO1xuICByZWFkb25seSBkb21haW5DcmVkZW50aWFsczogUmVjb3JkPHN0cmluZywgRG9ja2VyRG9tYWluQ3JlZGVudGlhbFNvdXJjZT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRG9ja2VyRG9tYWluQ3JlZGVudGlhbFNvdXJjZSB7XG4gIHJlYWRvbmx5IHNlY3JldHNNYW5hZ2VyU2VjcmV0SWQ/OiBzdHJpbmc7XG4gIHJlYWRvbmx5IHNlY3JldHNVc2VybmFtZUZpZWxkPzogc3RyaW5nO1xuICByZWFkb25seSBzZWNyZXRzUGFzc3dvcmRGaWVsZD86IHN0cmluZztcbiAgcmVhZG9ubHkgZWNyUmVwb3NpdG9yeT86IGJvb2xlYW47XG4gIHJlYWRvbmx5IGFzc3VtZVJvbGVBcm4/OiBzdHJpbmc7XG59XG5cbi8qKiBSZXR1cm5zIHRoZSBwcmVzdW1lZCBsb2NhdGlvbiBvZiB0aGUgQ0RLIERvY2tlciBjcmVkZW50aWFscyBjb25maWcgZmlsZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNka0NyZWRlbnRpYWxzQ29uZmlnRmlsZSgpOiBzdHJpbmcge1xuICByZXR1cm4gKFxuICAgIHByb2Nlc3MuZW52LkNES19ET0NLRVJfQ1JFRFNfRklMRSA/P1xuICAgIHBhdGguam9pbihcbiAgICAgIChvcy51c2VySW5mbygpLmhvbWVkaXIgPz8gb3MuaG9tZWRpcigpKS50cmltKCkgfHwgJy8nLFxuICAgICAgJy5jZGsnLFxuICAgICAgJ2Nkay1kb2NrZXItY3JlZHMuanNvbicsXG4gICAgKVxuICApO1xufVxuXG5sZXQgX2Nka0NyZWRlbnRpYWxzOiBEb2NrZXJDcmVkZW50aWFsc0NvbmZpZyB8IHVuZGVmaW5lZDtcbi8qKiBMb2FkcyBhbmQgcGFyc2VzIHRoZSBDREsgRG9ja2VyIGNyZWRlbnRpYWxzIGNvbmZpZ3VyYXRpb24sIGlmIGl0IGV4aXN0cy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjZGtDcmVkZW50aWFsc0NvbmZpZygpOiBEb2NrZXJDcmVkZW50aWFsc0NvbmZpZyB8IHVuZGVmaW5lZCB7XG4gIGlmICghX2Nka0NyZWRlbnRpYWxzKSB7XG4gICAgdHJ5IHtcbiAgICAgIF9jZGtDcmVkZW50aWFscyA9IEpTT04ucGFyc2UoXG4gICAgICAgIGZzLnJlYWRGaWxlU3luYyhjZGtDcmVkZW50aWFsc0NvbmZpZ0ZpbGUoKSwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KSxcbiAgICAgICkgYXMgRG9ja2VyQ3JlZGVudGlhbHNDb25maWc7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG4gIHJldHVybiBfY2RrQ3JlZGVudGlhbHM7XG59XG5cbi8qKlxuICogSnVzdCBmb3IgdGVzdGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gX2NsZWFyQ2RrQ3JlZGVudGlhbHNDb25maWdDYWNoZSgpIHtcbiAgX2Nka0NyZWRlbnRpYWxzID0gdW5kZWZpbmVkO1xufVxuXG4vKiogRmV0Y2hlcyBsb2dpbiBjcmVkZW50aWFscyBmcm9tIHRoZSBjb25maWd1cmVkIHNvdXJjZSAoZS5nLiwgU2VjcmV0c01hbmFnZXIsIEVDUikgKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaERvY2tlckxvZ2luQ3JlZGVudGlhbHMoXG4gIGF3czogSUF3cyxcbiAgY29uZmlnOiBEb2NrZXJDcmVkZW50aWFsc0NvbmZpZyxcbiAgZW5kcG9pbnQ6IHN0cmluZyxcbikge1xuICAvLyBQYXJhbm9pZCBoYW5kbGluZyB0byBlbnN1cmUgbmV3IFVSTCgpIGRvZXNuJ3QgdGhyb3cgaWYgdGhlIHNjaGVtYSBpcyBtaXNzaW5nXG4gIC8vIEZvciBvZmZpY2lhbCBkb2NrZXIgcmVnaXN0cnksIGRvY2tlciB3aWxsIHBhc3MgaHR0cHM6Ly9pbmRleC5kb2NrZXIuaW8vdjEvXG4gIGVuZHBvaW50ID0gZW5kcG9pbnQuaW5jbHVkZXMoJzovLycpID8gZW5kcG9pbnQgOiBgaHR0cHM6Ly8ke2VuZHBvaW50fWA7XG4gIGNvbnN0IGRvbWFpbiA9IG5ldyBVUkwoZW5kcG9pbnQpLmhvc3RuYW1lO1xuXG4gIGlmIChcbiAgICAhT2JqZWN0LmtleXMoY29uZmlnLmRvbWFpbkNyZWRlbnRpYWxzKS5pbmNsdWRlcyhkb21haW4pICYmXG4gICAgIU9iamVjdC5rZXlzKGNvbmZpZy5kb21haW5DcmVkZW50aWFscykuaW5jbHVkZXMoZW5kcG9pbnQpXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBkb21haW4gJHtkb21haW59YCk7XG4gIH1cblxuICBsZXQgZG9tYWluQ29uZmlnID0gY29uZmlnLmRvbWFpbkNyZWRlbnRpYWxzW2RvbWFpbl0gPz8gY29uZmlnLmRvbWFpbkNyZWRlbnRpYWxzW2VuZHBvaW50XTtcblxuICBpZiAoZG9tYWluQ29uZmlnLnNlY3JldHNNYW5hZ2VyU2VjcmV0SWQpIHtcbiAgICBjb25zdCBzbSA9IGF3YWl0IGF3cy5zZWNyZXRzTWFuYWdlckNsaWVudCh7IGFzc3VtZVJvbGVBcm46IGRvbWFpbkNvbmZpZy5hc3N1bWVSb2xlQXJuIH0pO1xuICAgIGNvbnN0IHNlY3JldFZhbHVlID0gYXdhaXQgc20uZ2V0U2VjcmV0VmFsdWUoe1xuICAgICAgU2VjcmV0SWQ6IGRvbWFpbkNvbmZpZy5zZWNyZXRzTWFuYWdlclNlY3JldElkLFxuICAgIH0pO1xuICAgIGlmICghc2VjcmV0VmFsdWUuU2VjcmV0U3RyaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGB1bmFibGUgdG8gZmV0Y2ggU2VjcmV0U3RyaW5nIGZyb20gc2VjcmV0OiAke2RvbWFpbkNvbmZpZy5zZWNyZXRzTWFuYWdlclNlY3JldElkfWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHNlY3JldCA9IEpTT04ucGFyc2Uoc2VjcmV0VmFsdWUuU2VjcmV0U3RyaW5nKTtcblxuICAgIGNvbnN0IHVzZXJuYW1lRmllbGQgPSBkb21haW5Db25maWcuc2VjcmV0c1VzZXJuYW1lRmllbGQgPz8gJ3VzZXJuYW1lJztcbiAgICBjb25zdCBzZWNyZXRGaWVsZCA9IGRvbWFpbkNvbmZpZy5zZWNyZXRzUGFzc3dvcmRGaWVsZCA/PyAnc2VjcmV0JztcbiAgICBpZiAoIXNlY3JldFt1c2VybmFtZUZpZWxkXSB8fCAhc2VjcmV0W3NlY3JldEZpZWxkXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgbWFsZm9ybWVkIHNlY3JldCBzdHJpbmcgKFwiJHt1c2VybmFtZUZpZWxkfVwiIG9yIFwiJHtzZWNyZXRGaWVsZH1cIiBmaWVsZCBtaXNzaW5nKWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7IFVzZXJuYW1lOiBzZWNyZXRbdXNlcm5hbWVGaWVsZF0sIFNlY3JldDogc2VjcmV0W3NlY3JldEZpZWxkXSB9O1xuICB9IGVsc2UgaWYgKGRvbWFpbkNvbmZpZy5lY3JSZXBvc2l0b3J5KSB7XG4gICAgY29uc3QgZWNyID0gYXdhaXQgYXdzLmVjckNsaWVudCh7IGFzc3VtZVJvbGVBcm46IGRvbWFpbkNvbmZpZy5hc3N1bWVSb2xlQXJuIH0pO1xuICAgIGNvbnN0IGVjckF1dGhEYXRhID0gYXdhaXQgb2J0YWluRWNyQ3JlZGVudGlhbHMoZWNyKTtcblxuICAgIHJldHVybiB7IFVzZXJuYW1lOiBlY3JBdXRoRGF0YS51c2VybmFtZSwgU2VjcmV0OiBlY3JBdXRoRGF0YS5wYXNzd29yZCB9O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBjcmVkZW50aWFsIHR5cGU6IG5vIHNlY3JldCBJRCBvciBFQ1IgcmVwbycpO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBvYnRhaW5FY3JDcmVkZW50aWFscyhlY3I6IElFQ1JDbGllbnQsIGV2ZW50RW1pdHRlcj86IEV2ZW50RW1pdHRlcikge1xuICBpZiAoZXZlbnRFbWl0dGVyKSB7XG4gICAgZXZlbnRFbWl0dGVyKEV2ZW50VHlwZS5ERUJVRywgJ0ZldGNoaW5nIEVDUiBhdXRob3JpemF0aW9uIHRva2VuJyk7XG4gIH1cblxuICBjb25zdCBhdXRoRGF0YSA9IChhd2FpdCBlY3IuZ2V0QXV0aG9yaXphdGlvblRva2VuKCkpLmF1dGhvcml6YXRpb25EYXRhIHx8IFtdO1xuICBpZiAoYXV0aERhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBhdXRob3JpemF0aW9uIGRhdGEgcmVjZWl2ZWQgZnJvbSBFQ1InKTtcbiAgfVxuICBjb25zdCB0b2tlbiA9IEJ1ZmZlci5mcm9tKGF1dGhEYXRhWzBdLmF1dGhvcml6YXRpb25Ub2tlbiEsICdiYXNlNjQnKS50b1N0cmluZygnYXNjaWknKTtcbiAgY29uc3QgW3VzZXJuYW1lLCBwYXNzd29yZF0gPSB0b2tlbi5zcGxpdCgnOicpO1xuICBpZiAoIXVzZXJuYW1lIHx8ICFwYXNzd29yZCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBFQ1IgYXV0aERhdGEgZm9ybWF0Jyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHVzZXJuYW1lLFxuICAgIHBhc3N3b3JkLFxuICAgIGVuZHBvaW50OiBhdXRoRGF0YVswXS5wcm94eUVuZHBvaW50ISxcbiAgfTtcbn1cbiJdfQ==