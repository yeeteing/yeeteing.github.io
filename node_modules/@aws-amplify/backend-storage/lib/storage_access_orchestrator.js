import { entityIdPathToken, entityIdSubstitution } from './constants.js';
import { validateStorageAccessPaths as _validateStorageAccessPaths } from './validate_storage_access_paths.js';
import { roleAccessBuilder as _roleAccessBuilder } from './access_builder.js';
import { AmplifyUserError } from '@aws-amplify/platform-core';
/**
 * Orchestrates the process of converting customer-defined storage access rules into corresponding IAM policies
 * and attaching those policies to the corresponding IAM roles
 */
export class StorageAccessOrchestrator {
    storageAccessGenerator;
    getInstanceProps;
    ssmEnvironmentEntries;
    policyFactory;
    validateStorageAccessPaths;
    roleAccessBuilder;
    /**
     * Maintains a mapping from a resource access acceptor to all of the access grants it has been configured with
     * Each entry of this map is fed into the policy generator to create a single policy for each acceptor
     */
    acceptorAccessMap = new Map();
    /**
     * Maintains pointers to the "deny" StoragePath Set for each access entry in the map above
     * This map is used during a final pass over all the StoragePaths to deny access on any paths where explicit allow rules were not specified
     */
    prefixDenyMap = new Map();
    /**
     * Instantiate with the access generator and other dependencies necessary for evaluating and constructing access policies
     * @param storageAccessGenerator The access callback defined by the customer
     * @param getInstanceProps props for fetching construct instances from the construct container
     * @param ssmEnvironmentEntries SSM context that should be passed to the ResourceAccessAcceptors when configuring access
     * @param policyFactory factory that generates IAM policies for various access control definitions
     * @param validateStorageAccessPaths validator function for checking access definition paths
     * @param roleAccessBuilder builder instance that is injected into the storageAccessGenerator to evaluate the rules
     */
    constructor(storageAccessGenerator, getInstanceProps, ssmEnvironmentEntries, policyFactory, validateStorageAccessPaths = _validateStorageAccessPaths, roleAccessBuilder = _roleAccessBuilder) {
        this.storageAccessGenerator = storageAccessGenerator;
        this.getInstanceProps = getInstanceProps;
        this.ssmEnvironmentEntries = ssmEnvironmentEntries;
        this.policyFactory = policyFactory;
        this.validateStorageAccessPaths = validateStorageAccessPaths;
        this.roleAccessBuilder = roleAccessBuilder;
    }
    /**
     * Orchestrates the process of translating the customer-provided storage access rules into IAM policies and attaching those policies to the appropriate roles.
     *
     * The high level steps are:
     * 1. Invokes the storageAccessGenerator to produce a storageAccessDefinition
     * 2. Validates the paths in the storageAccessDefinition
     * 3. Organizes the storageAccessDefinition into internally managed maps to facilitate translation into allow / deny rules on IAM policies
     * 4. Invokes the policy generator to produce a policy with appropriate allow / deny rules
     * 5. Invokes the resourceAccessAcceptors for each entry in the storageAccessDefinition to accept the corresponding IAM policy
     */
    orchestrateStorageAccess = () => {
        // storageAccessGenerator is the access callback defined by the customer
        // here we inject the roleAccessBuilder into the callback and run it
        // this produces the access definition that will be used to create the storage policies
        const storageAccessDefinition = this.storageAccessGenerator(this.roleAccessBuilder);
        // verify that the paths in the access definition are valid
        this.validateStorageAccessPaths(Object.keys(storageAccessDefinition));
        const storageOutputAccessDefinition = {};
        // iterate over the access definition and group permissions by ResourceAccessAcceptor
        Object.entries(storageAccessDefinition).forEach(([s3Prefix, accessPermissions]) => {
            const uniqueDefinitionIdSet = new Set();
            // iterate over all of the access definitions for a given prefix
            accessPermissions.forEach((permission) => {
                const accessConfig = {};
                // replace "read" with "get" and "list" in actions
                const replaceReadWithGetAndList = permission.actions.flatMap((action) => (action === 'read' ? ['get', 'list'] : [action]));
                // ensure the actions list has no duplicates
                const noDuplicateActions = Array.from(new Set(replaceReadWithGetAndList));
                // iterate over all uniqueDefinitionIdValidations and ensure uniqueness within this path prefix
                permission.uniqueDefinitionIdValidations.forEach(({ uniqueDefinitionId, validationErrorOptions }) => {
                    if (uniqueDefinitionIdSet.has(uniqueDefinitionId)) {
                        throw new AmplifyUserError('InvalidStorageAccessDefinitionError', validationErrorOptions);
                    }
                    else {
                        uniqueDefinitionIdSet.add(uniqueDefinitionId);
                    }
                    accessConfig[uniqueDefinitionId] = noDuplicateActions;
                });
                // make the owner placeholder substitution in the s3 prefix
                const prefix = placeholderSubstitution(s3Prefix, permission.idSubstitution);
                storageOutputAccessDefinition[prefix] = {
                    ...storageOutputAccessDefinition[prefix],
                    ...accessConfig,
                };
                // set an entry that maps this permission to each resource acceptor
                permission.getResourceAccessAcceptors.forEach((getResourceAccessAcceptor) => {
                    this.addAccessDefinition(getResourceAccessAcceptor(this.getInstanceProps), noDuplicateActions, prefix);
                });
            });
        });
        // iterate over the access map entries and invoke each ResourceAccessAcceptor to accept the permissions
        this.attachPolicies(this.ssmEnvironmentEntries);
        return storageOutputAccessDefinition;
    };
    /**
     * Add an entry to the internal acceptorAccessMap and prefixDenyMap.
     * This entry defines a set of actions on a single s3 prefix that should be attached to a given ResourceAccessAcceptor
     */
    addAccessDefinition = (resourceAccessAcceptor, actions, s3Prefix) => {
        const acceptorToken = resourceAccessAcceptor.identifier;
        // if we haven't seen this token before, add it to the map
        if (!this.acceptorAccessMap.has(acceptorToken)) {
            this.acceptorAccessMap.set(acceptorToken, {
                accessMap: new Map(),
                acceptor: resourceAccessAcceptor,
            });
        }
        const accessMap = this.acceptorAccessMap.get(acceptorToken).accessMap;
        // add each action to the accessMap for this acceptorToken
        actions.forEach((action) => {
            if (!accessMap.has(action)) {
                // if we haven't seen this action for this acceptorToken before, add it to the map
                const allowSet = new Set([s3Prefix]);
                const denySet = new Set();
                accessMap.set(action, { allow: allowSet, deny: denySet });
                // this is where we create the reverse mapping that allows us to add entries to the denySet later by looking up the prefix
                this.setPrefixDenyMapEntry(s3Prefix, allowSet, denySet);
            }
            else {
                // otherwise add the prefix to the existing allow set
                const { allow: allowSet, deny: denySet } = accessMap.get(action);
                allowSet.add(s3Prefix);
                // add an entry in the prefixDenyMap for the existing allow and deny set
                this.setPrefixDenyMapEntry(s3Prefix, allowSet, denySet);
            }
        });
    };
    /**
     * Iterates over all of the access definitions that have been added to the orchestrator,
     * generates a policy for each accessMap,
     * and attaches the policy to the corresponding ResourceAccessAcceptor
     *
     * After this method is called, the existing access definition state is cleared.
     * This prevents multiple calls to this method from producing duplicate policies.
     * The class can continue to be used to build up state for a new set of policies if desired.
     * @param ssmEnvironmentEntries Additional SSM context that is passed to each ResourceAccessAcceptor
     */
    attachPolicies = (ssmEnvironmentEntries) => {
        const allPaths = Array.from(this.prefixDenyMap.keys());
        allPaths.forEach((storagePath) => {
            const parent = findParent(storagePath, allPaths);
            // do not add to prefix deny map if there is no parent or the path is a subpath with entity id
            if (!parent ||
                parent === storagePath.replaceAll(`${entityIdSubstitution}/`, '')) {
                return;
            }
            // if a parent path is defined, invoke the denyByDefault callback on this subpath for all policies that exist on the parent path
            this.prefixDenyMap
                .get(parent)
                ?.forEach((denyByDefaultCallback) => denyByDefaultCallback(storagePath));
        });
        this.acceptorAccessMap.forEach(({ acceptor, accessMap }) => {
            // removing subpaths from the allow set prevents unnecessary paths from being added to the policy
            // for example, if there are allow read rules for /foo/* and /foo/bar/* we only need to add /foo/* to the policy because that includes /foo/bar/*
            accessMap.forEach(({ allow }) => {
                removeSubPathsFromSet(allow);
            });
            acceptor.acceptResourceAccess(this.policyFactory.createPolicy(accessMap), ssmEnvironmentEntries);
        });
        this.acceptorAccessMap.clear();
        this.prefixDenyMap.clear();
    };
    setPrefixDenyMapEntry = (storagePath, allowPathSet, denyPathSet) => {
        // function that will add the denyPath to the denyPathSet unless the allowPathSet explicitly allows the path
        const setDenyByDefault = (denyPath) => {
            if (!allowPathSet.has(denyPath)) {
                denyPathSet.add(denyPath);
            }
        };
        if (!this.prefixDenyMap.has(storagePath)) {
            this.prefixDenyMap.set(storagePath, [setDenyByDefault]);
        }
        else {
            this.prefixDenyMap.get(storagePath)?.push(setDenyByDefault);
        }
    };
}
/**
 * This factory is really only necessary for allowing us to mock the StorageAccessOrchestrator in tests
 */
export class StorageAccessOrchestratorFactory {
    getInstance = (storageAccessGenerator, getInstanceProps, ssmEnvironmentEntries, policyFactory) => new StorageAccessOrchestrator(storageAccessGenerator, getInstanceProps, ssmEnvironmentEntries, policyFactory);
}
/**
 * Performs the owner placeholder substitution in the s3 prefix
 */
const placeholderSubstitution = (s3Prefix, idSubstitution) => {
    const prefix = s3Prefix.replaceAll(entityIdPathToken, idSubstitution);
    // for owner paths where prefix ends with '/*/*' remove the last wildcard
    if (prefix.endsWith('/*/*')) {
        return prefix.slice(0, -2);
    }
    return prefix;
};
/**
 * Returns the element in paths that is a prefix of path, if any
 * Note that there can only be one at this point because of upstream validation
 */
const findParent = (path, paths) => paths.find((p) => path !== p && path.startsWith(p.replaceAll('*', '')));
const removeSubPathsFromSet = (paths) => {
    paths.forEach((path) => {
        if (findParent(path, Array.from(paths))) {
            paths.delete(path);
        }
    });
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmFnZV9hY2Nlc3Nfb3JjaGVzdHJhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3N0b3JhZ2VfYWNjZXNzX29yY2hlc3RyYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFVQSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUV6RSxPQUFPLEVBQUUsMEJBQTBCLElBQUksMkJBQTJCLEVBQUUsTUFBTSxvQ0FBb0MsQ0FBQztBQUMvRyxPQUFPLEVBQUUsaUJBQWlCLElBQUksa0JBQWtCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQU05RSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQVU5RDs7O0dBR0c7QUFDSCxNQUFNLE9BQU8seUJBQXlCO0lBZ0NqQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFwQ25COzs7T0FHRztJQUNLLGlCQUFpQixHQUFHLElBQUksR0FBRyxFQVNoQyxDQUFDO0lBRUo7OztPQUdHO0lBQ0ssYUFBYSxHQUFHLElBQUksR0FBRyxFQUFtQyxDQUFDO0lBRW5FOzs7Ozs7OztPQVFHO0lBQ0gsWUFDbUIsc0JBQThDLEVBQzlDLGdCQUFrRCxFQUNsRCxxQkFBNEMsRUFDNUMsYUFBeUMsRUFDekMsNkJBQTZCLDJCQUEyQixFQUN4RCxvQkFBMEMsa0JBQWtCO1FBTDVELDJCQUFzQixHQUF0QixzQkFBc0IsQ0FBd0I7UUFDOUMscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQztRQUNsRCwwQkFBcUIsR0FBckIscUJBQXFCLENBQXVCO1FBQzVDLGtCQUFhLEdBQWIsYUFBYSxDQUE0QjtRQUN6QywrQkFBMEIsR0FBMUIsMEJBQTBCLENBQThCO1FBQ3hELHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBMkM7SUFDNUUsQ0FBQztJQUVKOzs7Ozs7Ozs7T0FTRztJQUNILHdCQUF3QixHQUFHLEdBQUcsRUFBRTtRQUM5Qix3RUFBd0U7UUFD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QUFVLENBQ2hDLGlCQUFpQixFQUNqQixjQUFjLENBQ0EsQ0FBQztJQUVqQix5RUFBeUU7SUFDekUsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7UUFDNUIsT0FBTyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBZ0IsQ0FBQztJQUM1QyxDQUFDO0lBRUQsT0FBTyxNQUFxQixDQUFDO0FBQy9CLENBQUMsQ0FBQztBQUVGOzs7R0FHRztBQUNILE1BQU0sVUFBVSxHQUFHLENBQUMsSUFBWSxFQUFFLEtBQWUsRUFBRSxFQUFFLENBQ25ELEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUV6RCxDQUFDO0FBRWhCLE1BQU0scUJBQXFCLEdBQUcsQ0FBQyxLQUF1QixFQUFFLEVBQUU7SUFDeEQsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO1FBQ3JCLElBQUksVUFBVSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUN4QyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JCLENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbnN0cnVjdEZhY3RvcnlHZXRJbnN0YW5jZVByb3BzLFxuICBSZXNvdXJjZUFjY2Vzc0FjY2VwdG9yLFxuICBTc21FbnZpcm9ubWVudEVudHJ5LFxufSBmcm9tICdAYXdzLWFtcGxpZnkvcGx1Z2luLXR5cGVzJztcbmltcG9ydCB7XG4gIFN0b3JhZ2VBY2Nlc3NCdWlsZGVyLFxuICBTdG9yYWdlQWNjZXNzR2VuZXJhdG9yLFxuICBTdG9yYWdlUGF0aCxcbn0gZnJvbSAnLi90eXBlcy5qcyc7XG5pbXBvcnQgeyBlbnRpdHlJZFBhdGhUb2tlbiwgZW50aXR5SWRTdWJzdGl0dXRpb24gfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBTdG9yYWdlQWNjZXNzUG9saWN5RmFjdG9yeSB9IGZyb20gJy4vc3RvcmFnZV9hY2Nlc3NfcG9saWN5X2ZhY3RvcnkuanMnO1xuaW1wb3J0IHsgdmFsaWRhdGVTdG9yYWdlQWNjZXNzUGF0aHMgYXMgX3ZhbGlkYXRlU3RvcmFnZUFjY2Vzc1BhdGhzIH0gZnJvbSAnLi92YWxpZGF0ZV9zdG9yYWdlX2FjY2Vzc19wYXRocy5qcyc7XG5pbXBvcnQgeyByb2xlQWNjZXNzQnVpbGRlciBhcyBfcm9sZUFjY2Vzc0J1aWxkZXIgfSBmcm9tICcuL2FjY2Vzc19idWlsZGVyLmpzJztcbmltcG9ydCB7XG4gIEludGVybmFsU3RvcmFnZUFjdGlvbixcbiAgU3RvcmFnZUFjY2Vzc0NvbmZpZyxcbiAgU3RvcmFnZUVycm9yLFxufSBmcm9tICcuL3ByaXZhdGVfdHlwZXMuanMnO1xuaW1wb3J0IHsgQW1wbGlmeVVzZXJFcnJvciB9IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbGF0Zm9ybS1jb3JlJztcblxuLyogc29tZSB0eXBlcyBpbnRlcm5hbCB0byB0aGlzIGZpbGUgdG8gaW1wcm92ZSByZWFkYWJpbGl0eSAqL1xuXG4vLyBBbGlhcyB0eXBlIGZvciBhIHN0cmluZyB0aGF0IGlzIGEgUmVzb3VyY2VBY2Nlc3NBY2NlcHRvciB0b2tlblxudHlwZSBBY2NlcHRvclRva2VuID0gc3RyaW5nO1xuXG4vLyBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IHBsYWNlcyBzdG9yYWdlUGF0aCBpbiB0aGUgZGVueSBsaXN0IGZvciBhbiBhY3Rpb24gaWYgaXQgaXMgbm90IGV4cGxpY2l0bHkgYWxsb3dlZCBieSBhbm90aGVyIHJ1bGVcbnR5cGUgU2V0RGVueUJ5RGVmYXVsdCA9IChzdG9yYWdlUGF0aDogU3RvcmFnZVBhdGgpID0+IHZvaWQ7XG5cbi8qKlxuICogT3JjaGVzdHJhdGVzIHRoZSBwcm9jZXNzIG9mIGNvbnZlcnRpbmcgY3VzdG9tZXItZGVmaW5lZCBzdG9yYWdlIGFjY2VzcyBydWxlcyBpbnRvIGNvcnJlc3BvbmRpbmcgSUFNIHBvbGljaWVzXG4gKiBhbmQgYXR0YWNoaW5nIHRob3NlIHBvbGljaWVzIHRvIHRoZSBjb3JyZXNwb25kaW5nIElBTSByb2xlc1xuICovXG5leHBvcnQgY2xhc3MgU3RvcmFnZUFjY2Vzc09yY2hlc3RyYXRvciB7XG4gIC8qKlxuICAgKiBNYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSByZXNvdXJjZSBhY2Nlc3MgYWNjZXB0b3IgdG8gYWxsIG9mIHRoZSBhY2Nlc3MgZ3JhbnRzIGl0IGhhcyBiZWVuIGNvbmZpZ3VyZWQgd2l0aFxuICAgKiBFYWNoIGVudHJ5IG9mIHRoaXMgbWFwIGlzIGZlZCBpbnRvIHRoZSBwb2xpY3kgZ2VuZXJhdG9yIHRvIGNyZWF0ZSBhIHNpbmdsZSBwb2xpY3kgZm9yIGVhY2ggYWNjZXB0b3JcbiAgICovXG4gIHByaXZhdGUgYWNjZXB0b3JBY2Nlc3NNYXAgPSBuZXcgTWFwPFxuICAgIEFjY2VwdG9yVG9rZW4sXG4gICAge1xuICAgICAgYWNjZXB0b3I6IFJlc291cmNlQWNjZXNzQWNjZXB0b3I7XG4gICAgICBhY2Nlc3NNYXA6IE1hcDxcbiAgICAgICAgSW50ZXJuYWxTdG9yYWdlQWN0aW9uLFxuICAgICAgICB7IGFsbG93OiBTZXQ8U3RvcmFnZVBhdGg+OyBkZW55OiBTZXQ8U3RvcmFnZVBhdGg+IH1cbiAgICAgID47XG4gICAgfVxuICA+KCk7XG5cbiAgLyoqXG4gICAqIE1haW50YWlucyBwb2ludGVycyB0byB0aGUgXCJkZW55XCIgU3RvcmFnZVBhdGggU2V0IGZvciBlYWNoIGFjY2VzcyBlbnRyeSBpbiB0aGUgbWFwIGFib3ZlXG4gICAqIFRoaXMgbWFwIGlzIHVzZWQgZHVyaW5nIGEgZmluYWwgcGFzcyBvdmVyIGFsbCB0aGUgU3RvcmFnZVBhdGhzIHRvIGRlbnkgYWNjZXNzIG9uIGFueSBwYXRocyB3aGVyZSBleHBsaWNpdCBhbGxvdyBydWxlcyB3ZXJlIG5vdCBzcGVjaWZpZWRcbiAgICovXG4gIHByaXZhdGUgcHJlZml4RGVueU1hcCA9IG5ldyBNYXA8U3RvcmFnZVBhdGgsIFNldERlbnlCeURlZmF1bHRbXT4oKTtcblxuICAvKipcbiAgICogSW5zdGFudGlhdGUgd2l0aCB0aGUgYWNjZXNzIGdlbmVyYXRvciBhbmQgb3RoZXIgZGVwZW5kZW5jaWVzIG5lY2Vzc2FyeSBmb3IgZXZhbHVhdGluZyBhbmQgY29uc3RydWN0aW5nIGFjY2VzcyBwb2xpY2llc1xuICAgKiBAcGFyYW0gc3RvcmFnZUFjY2Vzc0dlbmVyYXRvciBUaGUgYWNjZXNzIGNhbGxiYWNrIGRlZmluZWQgYnkgdGhlIGN1c3RvbWVyXG4gICAqIEBwYXJhbSBnZXRJbnN0YW5jZVByb3BzIHByb3BzIGZvciBmZXRjaGluZyBjb25zdHJ1Y3QgaW5zdGFuY2VzIGZyb20gdGhlIGNvbnN0cnVjdCBjb250YWluZXJcbiAgICogQHBhcmFtIHNzbUVudmlyb25tZW50RW50cmllcyBTU00gY29udGV4dCB0aGF0IHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIFJlc291cmNlQWNjZXNzQWNjZXB0b3JzIHdoZW4gY29uZmlndXJpbmcgYWNjZXNzXG4gICAqIEBwYXJhbSBwb2xpY3lGYWN0b3J5IGZhY3RvcnkgdGhhdCBnZW5lcmF0ZXMgSUFNIHBvbGljaWVzIGZvciB2YXJpb3VzIGFjY2VzcyBjb250cm9sIGRlZmluaXRpb25zXG4gICAqIEBwYXJhbSB2YWxpZGF0ZVN0b3JhZ2VBY2Nlc3NQYXRocyB2YWxpZGF0b3IgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGFjY2VzcyBkZWZpbml0aW9uIHBhdGhzXG4gICAqIEBwYXJhbSByb2xlQWNjZXNzQnVpbGRlciBidWlsZGVyIGluc3RhbmNlIHRoYXQgaXMgaW5qZWN0ZWQgaW50byB0aGUgc3RvcmFnZUFjY2Vzc0dlbmVyYXRvciB0byBldmFsdWF0ZSB0aGUgcnVsZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc3RvcmFnZUFjY2Vzc0dlbmVyYXRvcjogU3RvcmFnZUFjY2Vzc0dlbmVyYXRvcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IGdldEluc3RhbmNlUHJvcHM6IENvbnN0cnVjdEZhY3RvcnlHZXRJbnN0YW5jZVByb3BzLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc3NtRW52aXJvbm1lbnRFbnRyaWVzOiBTc21FbnZpcm9ubWVudEVudHJ5W10sXG4gICAgcHJpdmF0ZSByZWFkb25seSBwb2xpY3lGYWN0b3J5OiBTdG9yYWdlQWNjZXNzUG9saWN5RmFjdG9yeSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHZhbGlkYXRlU3RvcmFnZUFjY2Vzc1BhdGhzID0gX3ZhbGlkYXRlU3RvcmFnZUFjY2Vzc1BhdGhzLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcm9sZUFjY2Vzc0J1aWxkZXI6IFN0b3JhZ2VBY2Nlc3NCdWlsZGVyID0gX3JvbGVBY2Nlc3NCdWlsZGVyLFxuICApIHt9XG5cbiAgLyoqXG4gICAqIE9yY2hlc3RyYXRlcyB0aGUgcHJvY2VzcyBvZiB0cmFuc2xhdGluZyB0aGUgY3VzdG9tZXItcHJvdmlkZWQgc3RvcmFnZSBhY2Nlc3MgcnVsZXMgaW50byBJQU0gcG9saWNpZXMgYW5kIGF0dGFjaGluZyB0aG9zZSBwb2xpY2llcyB0byB0aGUgYXBwcm9wcmlhdGUgcm9sZXMuXG4gICAqXG4gICAqIFRoZSBoaWdoIGxldmVsIHN0ZXBzIGFyZTpcbiAgICogMS4gSW52b2tlcyB0aGUgc3RvcmFnZUFjY2Vzc0dlbmVyYXRvciB0byBwcm9kdWNlIGEgc3RvcmFnZUFjY2Vzc0RlZmluaXRpb25cbiAgICogMi4gVmFsaWRhdGVzIHRoZSBwYXRocyBpbiB0aGUgc3RvcmFnZUFjY2Vzc0RlZmluaXRpb25cbiAgICogMy4gT3JnYW5pemVzIHRoZSBzdG9yYWdlQWNjZXNzRGVmaW5pdGlvbiBpbnRvIGludGVybmFsbHkgbWFuYWdlZCBtYXBzIHRvIGZhY2lsaXRhdGUgdHJhbnNsYXRpb24gaW50byBhbGxvdyAvIGRlbnkgcnVsZXMgb24gSUFNIHBvbGljaWVzXG4gICAqIDQuIEludm9rZXMgdGhlIHBvbGljeSBnZW5lcmF0b3IgdG8gcHJvZHVjZSBhIHBvbGljeSB3aXRoIGFwcHJvcHJpYXRlIGFsbG93IC8gZGVueSBydWxlc1xuICAgKiA1LiBJbnZva2VzIHRoZSByZXNvdXJjZUFjY2Vzc0FjY2VwdG9ycyBmb3IgZWFjaCBlbnRyeSBpbiB0aGUgc3RvcmFnZUFjY2Vzc0RlZmluaXRpb24gdG8gYWNjZXB0IHRoZSBjb3JyZXNwb25kaW5nIElBTSBwb2xpY3lcbiAgICovXG4gIG9yY2hlc3RyYXRlU3RvcmFnZUFjY2VzcyA9ICgpID0+IHtcbiAgICAvLyBzdG9yYWdlQWNjZXNzR2VuZXJhdG9yIGlzIHRoZSBhY2Nlc3MgY2FsbGJhY2sgZGVmaW5lZCBieSB0aGUgY3VzdG9tZXJcbiAgICAvLyBoZXJlIHdlIGluamVjdCB0aGUgcm9sZUFjY2Vzc0J1aWxkZXIgaW50byB0aGUgY2FsbGJhY2sgYW5kIHJ1biBpdFxuICAgIC8vIHRoaXMgcHJvZHVjZXMgdGhlIGFjY2VzcyBkZWZpbml0aW9uIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RvcmFnZSBwb2xpY2llc1xuICAgIGNvbnN0IHN0b3JhZ2VBY2Nlc3NEZWZpbml0aW9uID0gdGhpcy5zdG9yYWdlQWNjZXNzR2VuZXJhdG9yKFxuICAgICAgdGhpcy5yb2xlQWNjZXNzQnVpbGRlcixcbiAgICApO1xuXG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhlIHBhdGhzIGluIHRoZSBhY2Nlc3MgZGVmaW5pdGlvbiBhcmUgdmFsaWRcbiAgICB0aGlzLnZhbGlkYXRlU3RvcmFnZUFjY2Vzc1BhdGhzKE9iamVjdC5rZXlzKHN0b3JhZ2VBY2Nlc3NEZWZpbml0aW9uKSk7XG5cbiAgICBjb25zdCBzdG9yYWdlT3V0cHV0QWNjZXNzRGVmaW5pdGlvbjogUmVjb3JkPHN0cmluZywgU3RvcmFnZUFjY2Vzc0NvbmZpZz4gPVxuICAgICAge307XG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgdGhlIGFjY2VzcyBkZWZpbml0aW9uIGFuZCBncm91cCBwZXJtaXNzaW9ucyBieSBSZXNvdXJjZUFjY2Vzc0FjY2VwdG9yXG4gICAgT2JqZWN0LmVudHJpZXMoc3RvcmFnZUFjY2Vzc0RlZmluaXRpb24pLmZvckVhY2goXG4gICAgICAoW3MzUHJlZml4LCBhY2Nlc3NQZXJtaXNzaW9uc10pID0+IHtcbiAgICAgICAgY29uc3QgdW5pcXVlRGVmaW5pdGlvbklkU2V0ID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgICAgIC8vIGl0ZXJhdGUgb3ZlciBhbGwgb2YgdGhlIGFjY2VzcyBkZWZpbml0aW9ucyBmb3IgYSBnaXZlbiBwcmVmaXhcbiAgICAgICAgYWNjZXNzUGVybWlzc2lvbnMuZm9yRWFjaCgocGVybWlzc2lvbikgPT4ge1xuICAgICAgICAgIGNvbnN0IGFjY2Vzc0NvbmZpZzogU3RvcmFnZUFjY2Vzc0NvbmZpZyA9IHt9O1xuICAgICAgICAgIC8vIHJlcGxhY2UgXCJyZWFkXCIgd2l0aCBcImdldFwiIGFuZCBcImxpc3RcIiBpbiBhY3Rpb25zXG4gICAgICAgICAgY29uc3QgcmVwbGFjZVJlYWRXaXRoR2V0QW5kTGlzdCA9IHBlcm1pc3Npb24uYWN0aW9ucy5mbGF0TWFwKFxuICAgICAgICAgICAgKGFjdGlvbikgPT4gKGFjdGlvbiA9PT0gJ3JlYWQnID8gWydnZXQnLCAnbGlzdCddIDogW2FjdGlvbl0pLFxuICAgICAgICAgICkgYXMgSW50ZXJuYWxTdG9yYWdlQWN0aW9uW107XG5cbiAgICAgICAgICAvLyBlbnN1cmUgdGhlIGFjdGlvbnMgbGlzdCBoYXMgbm8gZHVwbGljYXRlc1xuICAgICAgICAgIGNvbnN0IG5vRHVwbGljYXRlQWN0aW9ucyA9IEFycmF5LmZyb20oXG4gICAgICAgICAgICBuZXcgU2V0KHJlcGxhY2VSZWFkV2l0aEdldEFuZExpc3QpLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBpdGVyYXRlIG92ZXIgYWxsIHVuaXF1ZURlZmluaXRpb25JZFZhbGlkYXRpb25zIGFuZCBlbnN1cmUgdW5pcXVlbmVzcyB3aXRoaW4gdGhpcyBwYXRoIHByZWZpeFxuICAgICAgICAgIHBlcm1pc3Npb24udW5pcXVlRGVmaW5pdGlvbklkVmFsaWRhdGlvbnMuZm9yRWFjaChcbiAgICAgICAgICAgICh7IHVuaXF1ZURlZmluaXRpb25JZCwgdmFsaWRhdGlvbkVycm9yT3B0aW9ucyB9KSA9PiB7XG4gICAgICAgICAgICAgIGlmICh1bmlxdWVEZWZpbml0aW9uSWRTZXQuaGFzKHVuaXF1ZURlZmluaXRpb25JZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQW1wbGlmeVVzZXJFcnJvcjxTdG9yYWdlRXJyb3I+KFxuICAgICAgICAgICAgICAgICAgJ0ludmFsaWRTdG9yYWdlQWNjZXNzRGVmaW5pdGlvbkVycm9yJyxcbiAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25FcnJvck9wdGlvbnMsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1bmlxdWVEZWZpbml0aW9uSWRTZXQuYWRkKHVuaXF1ZURlZmluaXRpb25JZCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBhY2Nlc3NDb25maWdbdW5pcXVlRGVmaW5pdGlvbklkXSA9IG5vRHVwbGljYXRlQWN0aW9ucztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICAvLyBtYWtlIHRoZSBvd25lciBwbGFjZWhvbGRlciBzdWJzdGl0dXRpb24gaW4gdGhlIHMzIHByZWZpeFxuICAgICAgICAgIGNvbnN0IHByZWZpeCA9IHBsYWNlaG9sZGVyU3Vic3RpdHV0aW9uKFxuICAgICAgICAgICAgczNQcmVmaXgsXG4gICAgICAgICAgICBwZXJtaXNzaW9uLmlkU3Vic3RpdHV0aW9uLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBzdG9yYWdlT3V0cHV0QWNjZXNzRGVmaW5pdGlvbltwcmVmaXhdID0ge1xuICAgICAgICAgICAgLi4uc3RvcmFnZU91dHB1dEFjY2Vzc0RlZmluaXRpb25bcHJlZml4XSxcbiAgICAgICAgICAgIC4uLmFjY2Vzc0NvbmZpZyxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gc2V0IGFuIGVudHJ5IHRoYXQgbWFwcyB0aGlzIHBlcm1pc3Npb24gdG8gZWFjaCByZXNvdXJjZSBhY2NlcHRvclxuICAgICAgICAgIHBlcm1pc3Npb24uZ2V0UmVzb3VyY2VBY2Nlc3NBY2NlcHRvcnMuZm9yRWFjaChcbiAgICAgICAgICAgIChnZXRSZXNvdXJjZUFjY2Vzc0FjY2VwdG9yKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuYWRkQWNjZXNzRGVmaW5pdGlvbihcbiAgICAgICAgICAgICAgICBnZXRSZXNvdXJjZUFjY2Vzc0FjY2VwdG9yKHRoaXMuZ2V0SW5zdGFuY2VQcm9wcyksXG4gICAgICAgICAgICAgICAgbm9EdXBsaWNhdGVBY3Rpb25zLFxuICAgICAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICk7XG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgdGhlIGFjY2VzcyBtYXAgZW50cmllcyBhbmQgaW52b2tlIGVhY2ggUmVzb3VyY2VBY2Nlc3NBY2NlcHRvciB0byBhY2NlcHQgdGhlIHBlcm1pc3Npb25zXG4gICAgdGhpcy5hdHRhY2hQb2xpY2llcyh0aGlzLnNzbUVudmlyb25tZW50RW50cmllcyk7XG5cbiAgICByZXR1cm4gc3RvcmFnZU91dHB1dEFjY2Vzc0RlZmluaXRpb247XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBlbnRyeSB0byB0aGUgaW50ZXJuYWwgYWNjZXB0b3JBY2Nlc3NNYXAgYW5kIHByZWZpeERlbnlNYXAuXG4gICAqIFRoaXMgZW50cnkgZGVmaW5lcyBhIHNldCBvZiBhY3Rpb25zIG9uIGEgc2luZ2xlIHMzIHByZWZpeCB0aGF0IHNob3VsZCBiZSBhdHRhY2hlZCB0byBhIGdpdmVuIFJlc291cmNlQWNjZXNzQWNjZXB0b3JcbiAgICovXG4gIHByaXZhdGUgYWRkQWNjZXNzRGVmaW5pdGlvbiA9IChcbiAgICByZXNvdXJjZUFjY2Vzc0FjY2VwdG9yOiBSZXNvdXJjZUFjY2Vzc0FjY2VwdG9yLFxuICAgIGFjdGlvbnM6IEludGVybmFsU3RvcmFnZUFjdGlvbltdLFxuICAgIHMzUHJlZml4OiBTdG9yYWdlUGF0aCxcbiAgKSA9PiB7XG4gICAgY29uc3QgYWNjZXB0b3JUb2tlbiA9IHJlc291cmNlQWNjZXNzQWNjZXB0b3IuaWRlbnRpZmllcjtcblxuICAgIC8vIGlmIHdlIGhhdmVuJ3Qgc2VlbiB0aGlzIHRva2VuIGJlZm9yZSwgYWRkIGl0IHRvIHRoZSBtYXBcbiAgICBpZiAoIXRoaXMuYWNjZXB0b3JBY2Nlc3NNYXAuaGFzKGFjY2VwdG9yVG9rZW4pKSB7XG4gICAgICB0aGlzLmFjY2VwdG9yQWNjZXNzTWFwLnNldChhY2NlcHRvclRva2VuLCB7XG4gICAgICAgIGFjY2Vzc01hcDogbmV3IE1hcCgpLFxuICAgICAgICBhY2NlcHRvcjogcmVzb3VyY2VBY2Nlc3NBY2NlcHRvcixcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBhY2Nlc3NNYXAgPSB0aGlzLmFjY2VwdG9yQWNjZXNzTWFwLmdldChhY2NlcHRvclRva2VuKSEuYWNjZXNzTWFwO1xuICAgIC8vIGFkZCBlYWNoIGFjdGlvbiB0byB0aGUgYWNjZXNzTWFwIGZvciB0aGlzIGFjY2VwdG9yVG9rZW5cbiAgICBhY3Rpb25zLmZvckVhY2goKGFjdGlvbikgPT4ge1xuICAgICAgaWYgKCFhY2Nlc3NNYXAuaGFzKGFjdGlvbikpIHtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZW4ndCBzZWVuIHRoaXMgYWN0aW9uIGZvciB0aGlzIGFjY2VwdG9yVG9rZW4gYmVmb3JlLCBhZGQgaXQgdG8gdGhlIG1hcFxuICAgICAgICBjb25zdCBhbGxvd1NldCA9IG5ldyBTZXQ8U3RvcmFnZVBhdGg+KFtzM1ByZWZpeF0pO1xuICAgICAgICBjb25zdCBkZW55U2V0ID0gbmV3IFNldDxTdG9yYWdlUGF0aD4oKTtcbiAgICAgICAgYWNjZXNzTWFwLnNldChhY3Rpb24sIHsgYWxsb3c6IGFsbG93U2V0LCBkZW55OiBkZW55U2V0IH0pO1xuXG4gICAgICAgIC8vIHRoaXMgaXMgd2hlcmUgd2UgY3JlYXRlIHRoZSByZXZlcnNlIG1hcHBpbmcgdGhhdCBhbGxvd3MgdXMgdG8gYWRkIGVudHJpZXMgdG8gdGhlIGRlbnlTZXQgbGF0ZXIgYnkgbG9va2luZyB1cCB0aGUgcHJlZml4XG4gICAgICAgIHRoaXMuc2V0UHJlZml4RGVueU1hcEVudHJ5KHMzUHJlZml4LCBhbGxvd1NldCwgZGVueVNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvdGhlcndpc2UgYWRkIHRoZSBwcmVmaXggdG8gdGhlIGV4aXN0aW5nIGFsbG93IHNldFxuICAgICAgICBjb25zdCB7IGFsbG93OiBhbGxvd1NldCwgZGVueTogZGVueVNldCB9ID0gYWNjZXNzTWFwLmdldChhY3Rpb24pITtcbiAgICAgICAgYWxsb3dTZXQuYWRkKHMzUHJlZml4KTtcblxuICAgICAgICAvLyBhZGQgYW4gZW50cnkgaW4gdGhlIHByZWZpeERlbnlNYXAgZm9yIHRoZSBleGlzdGluZyBhbGxvdyBhbmQgZGVueSBzZXRcbiAgICAgICAgdGhpcy5zZXRQcmVmaXhEZW55TWFwRW50cnkoczNQcmVmaXgsIGFsbG93U2V0LCBkZW55U2V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogSXRlcmF0ZXMgb3ZlciBhbGwgb2YgdGhlIGFjY2VzcyBkZWZpbml0aW9ucyB0aGF0IGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgb3JjaGVzdHJhdG9yLFxuICAgKiBnZW5lcmF0ZXMgYSBwb2xpY3kgZm9yIGVhY2ggYWNjZXNzTWFwLFxuICAgKiBhbmQgYXR0YWNoZXMgdGhlIHBvbGljeSB0byB0aGUgY29ycmVzcG9uZGluZyBSZXNvdXJjZUFjY2Vzc0FjY2VwdG9yXG4gICAqXG4gICAqIEFmdGVyIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCwgdGhlIGV4aXN0aW5nIGFjY2VzcyBkZWZpbml0aW9uIHN0YXRlIGlzIGNsZWFyZWQuXG4gICAqIFRoaXMgcHJldmVudHMgbXVsdGlwbGUgY2FsbHMgdG8gdGhpcyBtZXRob2QgZnJvbSBwcm9kdWNpbmcgZHVwbGljYXRlIHBvbGljaWVzLlxuICAgKiBUaGUgY2xhc3MgY2FuIGNvbnRpbnVlIHRvIGJlIHVzZWQgdG8gYnVpbGQgdXAgc3RhdGUgZm9yIGEgbmV3IHNldCBvZiBwb2xpY2llcyBpZiBkZXNpcmVkLlxuICAgKiBAcGFyYW0gc3NtRW52aXJvbm1lbnRFbnRyaWVzIEFkZGl0aW9uYWwgU1NNIGNvbnRleHQgdGhhdCBpcyBwYXNzZWQgdG8gZWFjaCBSZXNvdXJjZUFjY2Vzc0FjY2VwdG9yXG4gICAqL1xuICBwcml2YXRlIGF0dGFjaFBvbGljaWVzID0gKHNzbUVudmlyb25tZW50RW50cmllczogU3NtRW52aXJvbm1lbnRFbnRyeVtdKSA9PiB7XG4gICAgY29uc3QgYWxsUGF0aHMgPSBBcnJheS5mcm9tKHRoaXMucHJlZml4RGVueU1hcC5rZXlzKCkpO1xuICAgIGFsbFBhdGhzLmZvckVhY2goKHN0b3JhZ2VQYXRoKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBmaW5kUGFyZW50KHN0b3JhZ2VQYXRoLCBhbGxQYXRocyk7XG4gICAgICAvLyBkbyBub3QgYWRkIHRvIHByZWZpeCBkZW55IG1hcCBpZiB0aGVyZSBpcyBubyBwYXJlbnQgb3IgdGhlIHBhdGggaXMgYSBzdWJwYXRoIHdpdGggZW50aXR5IGlkXG4gICAgICBpZiAoXG4gICAgICAgICFwYXJlbnQgfHxcbiAgICAgICAgcGFyZW50ID09PSBzdG9yYWdlUGF0aC5yZXBsYWNlQWxsKGAke2VudGl0eUlkU3Vic3RpdHV0aW9ufS9gLCAnJylcbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBpZiBhIHBhcmVudCBwYXRoIGlzIGRlZmluZWQsIGludm9rZSB0aGUgZGVueUJ5RGVmYXVsdCBjYWxsYmFjayBvbiB0aGlzIHN1YnBhdGggZm9yIGFsbCBwb2xpY2llcyB0aGF0IGV4aXN0IG9uIHRoZSBwYXJlbnQgcGF0aFxuICAgICAgdGhpcy5wcmVmaXhEZW55TWFwXG4gICAgICAgIC5nZXQocGFyZW50KVxuICAgICAgICA/LmZvckVhY2goKGRlbnlCeURlZmF1bHRDYWxsYmFjaykgPT5cbiAgICAgICAgICBkZW55QnlEZWZhdWx0Q2FsbGJhY2soc3RvcmFnZVBhdGgpLFxuICAgICAgICApO1xuICAgIH0pO1xuXG4gICAgdGhpcy5hY2NlcHRvckFjY2Vzc01hcC5mb3JFYWNoKCh7IGFjY2VwdG9yLCBhY2Nlc3NNYXAgfSkgPT4ge1xuICAgICAgLy8gcmVtb3Zpbmcgc3VicGF0aHMgZnJvbSB0aGUgYWxsb3cgc2V0IHByZXZlbnRzIHVubmVjZXNzYXJ5IHBhdGhzIGZyb20gYmVpbmcgYWRkZWQgdG8gdGhlIHBvbGljeVxuICAgICAgLy8gZm9yIGV4YW1wbGUsIGlmIHRoZXJlIGFyZSBhbGxvdyByZWFkIHJ1bGVzIGZvciAvZm9vLyogYW5kIC9mb28vYmFyLyogd2Ugb25seSBuZWVkIHRvIGFkZCAvZm9vLyogdG8gdGhlIHBvbGljeSBiZWNhdXNlIHRoYXQgaW5jbHVkZXMgL2Zvby9iYXIvKlxuICAgICAgYWNjZXNzTWFwLmZvckVhY2goKHsgYWxsb3cgfSkgPT4ge1xuICAgICAgICByZW1vdmVTdWJQYXRoc0Zyb21TZXQoYWxsb3cpO1xuICAgICAgfSk7XG4gICAgICBhY2NlcHRvci5hY2NlcHRSZXNvdXJjZUFjY2VzcyhcbiAgICAgICAgdGhpcy5wb2xpY3lGYWN0b3J5LmNyZWF0ZVBvbGljeShhY2Nlc3NNYXApLFxuICAgICAgICBzc21FbnZpcm9ubWVudEVudHJpZXMsXG4gICAgICApO1xuICAgIH0pO1xuICAgIHRoaXMuYWNjZXB0b3JBY2Nlc3NNYXAuY2xlYXIoKTtcbiAgICB0aGlzLnByZWZpeERlbnlNYXAuY2xlYXIoKTtcbiAgfTtcblxuICBwcml2YXRlIHNldFByZWZpeERlbnlNYXBFbnRyeSA9IChcbiAgICBzdG9yYWdlUGF0aDogU3RvcmFnZVBhdGgsXG4gICAgYWxsb3dQYXRoU2V0OiBTZXQ8U3RvcmFnZVBhdGg+LFxuICAgIGRlbnlQYXRoU2V0OiBTZXQ8U3RvcmFnZVBhdGg+LFxuICApID0+IHtcbiAgICAvLyBmdW5jdGlvbiB0aGF0IHdpbGwgYWRkIHRoZSBkZW55UGF0aCB0byB0aGUgZGVueVBhdGhTZXQgdW5sZXNzIHRoZSBhbGxvd1BhdGhTZXQgZXhwbGljaXRseSBhbGxvd3MgdGhlIHBhdGhcbiAgICBjb25zdCBzZXREZW55QnlEZWZhdWx0ID0gKGRlbnlQYXRoOiBTdG9yYWdlUGF0aCkgPT4ge1xuICAgICAgaWYgKCFhbGxvd1BhdGhTZXQuaGFzKGRlbnlQYXRoKSkge1xuICAgICAgICBkZW55UGF0aFNldC5hZGQoZGVueVBhdGgpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKCF0aGlzLnByZWZpeERlbnlNYXAuaGFzKHN0b3JhZ2VQYXRoKSkge1xuICAgICAgdGhpcy5wcmVmaXhEZW55TWFwLnNldChzdG9yYWdlUGF0aCwgW3NldERlbnlCeURlZmF1bHRdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmVmaXhEZW55TWFwLmdldChzdG9yYWdlUGF0aCk/LnB1c2goc2V0RGVueUJ5RGVmYXVsdCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZmFjdG9yeSBpcyByZWFsbHkgb25seSBuZWNlc3NhcnkgZm9yIGFsbG93aW5nIHVzIHRvIG1vY2sgdGhlIFN0b3JhZ2VBY2Nlc3NPcmNoZXN0cmF0b3IgaW4gdGVzdHNcbiAqL1xuZXhwb3J0IGNsYXNzIFN0b3JhZ2VBY2Nlc3NPcmNoZXN0cmF0b3JGYWN0b3J5IHtcbiAgZ2V0SW5zdGFuY2UgPSAoXG4gICAgc3RvcmFnZUFjY2Vzc0dlbmVyYXRvcjogU3RvcmFnZUFjY2Vzc0dlbmVyYXRvcixcbiAgICBnZXRJbnN0YW5jZVByb3BzOiBDb25zdHJ1Y3RGYWN0b3J5R2V0SW5zdGFuY2VQcm9wcyxcbiAgICBzc21FbnZpcm9ubWVudEVudHJpZXM6IFNzbUVudmlyb25tZW50RW50cnlbXSxcbiAgICBwb2xpY3lGYWN0b3J5OiBTdG9yYWdlQWNjZXNzUG9saWN5RmFjdG9yeSxcbiAgKSA9PlxuICAgIG5ldyBTdG9yYWdlQWNjZXNzT3JjaGVzdHJhdG9yKFxuICAgICAgc3RvcmFnZUFjY2Vzc0dlbmVyYXRvcixcbiAgICAgIGdldEluc3RhbmNlUHJvcHMsXG4gICAgICBzc21FbnZpcm9ubWVudEVudHJpZXMsXG4gICAgICBwb2xpY3lGYWN0b3J5LFxuICAgICk7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgdGhlIG93bmVyIHBsYWNlaG9sZGVyIHN1YnN0aXR1dGlvbiBpbiB0aGUgczMgcHJlZml4XG4gKi9cbmNvbnN0IHBsYWNlaG9sZGVyU3Vic3RpdHV0aW9uID0gKFxuICBzM1ByZWZpeDogc3RyaW5nLFxuICBpZFN1YnN0aXR1dGlvbjogc3RyaW5nLFxuKTogU3RvcmFnZVBhdGggPT4ge1xuICBjb25zdCBwcmVmaXggPSBzM1ByZWZpeC5yZXBsYWNlQWxsKFxuICAgIGVudGl0eUlkUGF0aFRva2VuLFxuICAgIGlkU3Vic3RpdHV0aW9uLFxuICApIGFzIFN0b3JhZ2VQYXRoO1xuXG4gIC8vIGZvciBvd25lciBwYXRocyB3aGVyZSBwcmVmaXggZW5kcyB3aXRoICcvKi8qJyByZW1vdmUgdGhlIGxhc3Qgd2lsZGNhcmRcbiAgaWYgKHByZWZpeC5lbmRzV2l0aCgnLyovKicpKSB7XG4gICAgcmV0dXJuIHByZWZpeC5zbGljZSgwLCAtMikgYXMgU3RvcmFnZVBhdGg7XG4gIH1cblxuICByZXR1cm4gcHJlZml4IGFzIFN0b3JhZ2VQYXRoO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50IGluIHBhdGhzIHRoYXQgaXMgYSBwcmVmaXggb2YgcGF0aCwgaWYgYW55XG4gKiBOb3RlIHRoYXQgdGhlcmUgY2FuIG9ubHkgYmUgb25lIGF0IHRoaXMgcG9pbnQgYmVjYXVzZSBvZiB1cHN0cmVhbSB2YWxpZGF0aW9uXG4gKi9cbmNvbnN0IGZpbmRQYXJlbnQgPSAocGF0aDogc3RyaW5nLCBwYXRoczogc3RyaW5nW10pID0+XG4gIHBhdGhzLmZpbmQoKHApID0+IHBhdGggIT09IHAgJiYgcGF0aC5zdGFydHNXaXRoKHAucmVwbGFjZUFsbCgnKicsICcnKSkpIGFzXG4gICAgfCBTdG9yYWdlUGF0aFxuICAgIHwgdW5kZWZpbmVkO1xuXG5jb25zdCByZW1vdmVTdWJQYXRoc0Zyb21TZXQgPSAocGF0aHM6IFNldDxTdG9yYWdlUGF0aD4pID0+IHtcbiAgcGF0aHMuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgIGlmIChmaW5kUGFyZW50KHBhdGgsIEFycmF5LmZyb20ocGF0aHMpKSkge1xuICAgICAgcGF0aHMuZGVsZXRlKHBhdGgpO1xuICAgIH1cbiAgfSk7XG59O1xuIl19