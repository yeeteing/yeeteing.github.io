"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversationMessageHistoryRetriever = void 0;
const graphql_request_executor_1 = require("./graphql_request_executor");
const user_agent_provider_1 = require("./user_agent_provider");
/**
 * These are all properties we have to pull.
 * Unfortunately, GQL doesn't support wildcards.
 * https://github.com/graphql/graphql-spec/issues/127
 */
const messageItemSelectionSet = `
                id
                conversationId
                associatedUserMessageId
                aiContext
                role
                content {
                  text
                  document {
                    source {
                      bytes
                    }
                    format
                    name
                  }
                  image {
                    format
                    source {
                      bytes
                    }
                  }
                  toolResult {
                    content {
                      document {
                        format
                        name
                        source {
                          bytes
                        }
                      }
                      image {
                        format
                        source {
                          bytes
                        }
                      }
                      json
                      text
                    }
                    status
                    toolUseId
                  }
                  toolUse {
                    input
                    name
                    toolUseId
                  }
                }
`;
/**
 * This class is responsible for retrieving message history that belongs to conversation turn event.
 * It queries AppSync to list messages that belong to conversation.
 * Additionally, it looks up a current message in case it's missing in the list due to eventual consistency.
 */
class ConversationMessageHistoryRetriever {
    /**
     * Creates conversation message history retriever.
     */
    constructor(event, graphqlRequestExecutor = new graphql_request_executor_1.GraphqlRequestExecutor(event.graphqlApiEndpoint, event.request.headers.authorization, new user_agent_provider_1.UserAgentProvider(event))) {
        this.event = event;
        this.graphqlRequestExecutor = graphqlRequestExecutor;
        this.getMessageHistory = async () => {
            const messages = await this.listMessages();
            let currentMessage = messages.find((m) => m.id === this.event.currentMessageId);
            // This is a fallback in case current message is not available in the message list.
            // I.e. in a situation when freshly written message is not yet visible in
            // eventually consistent reads.
            if (!currentMessage) {
                currentMessage = await this.getCurrentMessage();
                messages.push(currentMessage);
            }
            // Index assistant messages by corresponding user message.
            const assistantMessageByUserMessageId = new Map();
            messages.forEach((message) => {
                if (message.role === 'assistant' && message.associatedUserMessageId) {
                    assistantMessageByUserMessageId.set(message.associatedUserMessageId, message);
                }
            });
            // Reconcile history and inject aiContext
            const orderedMessages = messages.reduce((acc, current) => {
                // Bedrock expects that message history is user->assistant->user->assistant->... and so on.
                // The chronological order doesn't assure this ordering if there were any concurrent messages sent.
                // Therefore, conversation is ordered by user's messages only and corresponding assistant messages are inserted
                // into right place regardless of their createdAt value.
                // This algorithm assumes that GQL query returns messages sorted by createdAt.
                if (current.role === 'assistant') {
                    // Initially, skip assistant messages, these might be out of chronological order.
                    return acc;
                }
                if (current.role === 'user' &&
                    !assistantMessageByUserMessageId.has(current.id) &&
                    current.id !== this.event.currentMessageId) {
                    // Skip user messages that didn't get answer from assistant yet.
                    // These might be still "in-flight", i.e. assistant is still working on them in separate invocation.
                    // Except current message, we want to process that one.
                    return acc;
                }
                const aiContext = current.aiContext;
                const content = aiContext
                    ? [...current.content, { text: JSON.stringify(aiContext) }]
                    : current.content;
                acc.push({ role: current.role, content });
                // Find and insert corresponding assistant message.
                const correspondingAssistantMessage = assistantMessageByUserMessageId.get(current.id);
                if (correspondingAssistantMessage) {
                    acc.push({
                        role: correspondingAssistantMessage.role,
                        content: correspondingAssistantMessage.content,
                    });
                }
                return acc;
            }, []);
            // Remove tool usage from non-current turn and squash messages.
            return this.squashNonCurrentTurns(orderedMessages);
        };
        /**
         * This function removes tool usage from non-current turns.
         * The tool usage and result blocks don't matter after a turn is completed,
         * but do cost extra tokens to process.
         * The algorithm is as follows:
         * 1. Find where current turn begins. I.e. last user message that isn't tool block.
         * 2. Remove toolUse and toolResult blocks before current turn.
         * 3. Squash continuous sequences of messages that belong to same 'message.role'.
         */
        this.squashNonCurrentTurns = (messages) => {
            const isNonToolBlockPredicate = (contentBlock) => !contentBlock.toolUse && !contentBlock.toolResult;
            // find where current turn begins. I.e. last user message that is not related to tools
            const lastNonToolUseUserMessageIndex = messages.findLastIndex((message) => {
                return (message.role === 'user' && message.content.find(isNonToolBlockPredicate));
            });
            // No non-current turns, don't transform.
            if (lastNonToolUseUserMessageIndex <= 0) {
                return messages;
            }
            const squashedMessages = [];
            // Define a "buffer". I.e. a message we keep around and squash content on.
            let currentSquashedMessage = undefined;
            // Process messages before current turn begins
            // Remove tool usage blocks.
            // Combine content for consecutive message that have same role.
            for (let i = 0; i < lastNonToolUseUserMessageIndex; i++) {
                const currentMessage = messages[i];
                const currentMessageRole = currentMessage.role;
                const currentMessageNonToolContent = currentMessage.content.filter(isNonToolBlockPredicate);
                if (currentMessageNonToolContent.length === 0) {
                    // Tool only message. Nothing to squash, skip;
                    continue;
                }
                if (!currentSquashedMessage) {
                    // Nothing squashed yet, initialize the buffer.
                    currentSquashedMessage = {
                        role: currentMessageRole,
                        content: currentMessageNonToolContent,
                    };
                }
                else if (currentSquashedMessage.role === currentMessageRole) {
                    // if role is same append content.
                    currentSquashedMessage.content.push(...currentMessageNonToolContent);
                }
                else {
                    // if role flips push current squashed message and re-initialize the buffer.
                    squashedMessages.push(currentSquashedMessage);
                    currentSquashedMessage = {
                        role: currentMessageRole,
                        content: currentMessageNonToolContent,
                    };
                }
            }
            // flush the last buffer.
            if (currentSquashedMessage) {
                squashedMessages.push(currentSquashedMessage);
            }
            // Append current turn as is.
            squashedMessages.push(...messages.slice(lastNonToolUseUserMessageIndex));
            return squashedMessages;
        };
        this.getCurrentMessage = async () => {
            const query = `
        query GetMessage($id: ${this.event.messageHistoryQuery.getQueryInputTypeName}!) {
            ${this.event.messageHistoryQuery.getQueryName}(id: $id) {
              ${messageItemSelectionSet}
            }
        }
    `;
            const variables = {
                id: this.event.currentMessageId,
            };
            const response = await this.graphqlRequestExecutor.executeGraphql({
                query,
                variables,
            });
            return response.data[this.event.messageHistoryQuery.getQueryName];
        };
        this.listMessages = async () => {
            var _a;
            const query = `
        query ListMessages($filter: ${this.event.messageHistoryQuery.listQueryInputTypeName}!, $limit: Int) {
            ${this.event.messageHistoryQuery.listQueryName}(filter: $filter, limit: $limit) {
              items {
                ${messageItemSelectionSet}
              }
            }
        }
    `;
            const variables = {
                filter: {
                    conversationId: {
                        eq: this.event.conversationId,
                    },
                },
                limit: (_a = this.event.messageHistoryQuery.listQueryLimit) !== null && _a !== void 0 ? _a : 1000,
            };
            const response = await this.graphqlRequestExecutor.executeGraphql({
                query,
                variables,
            });
            const items = response.data[this.event.messageHistoryQuery.listQueryName].items;
            items.forEach((item) => {
                var _a;
                (_a = item.content) === null || _a === void 0 ? void 0 : _a.forEach((contentBlock) => {
                    var _a, _b;
                    let property;
                    for (property in contentBlock) {
                        // Deserialization of GraphQl query result sets these properties to 'null'
                        // This can trigger Bedrock SDK validation as it expects 'undefined' if properties are not set.
                        // We can't fix how GraphQl response is deserialized.
                        // Therefore, we apply this transformation to fix the data.
                        if (contentBlock[property] === null) {
                            contentBlock[property] = undefined;
                        }
                    }
                    if (typeof ((_a = contentBlock.toolUse) === null || _a === void 0 ? void 0 : _a.input) === 'string') {
                        // toolUse.input may come as serialized JSON for Client Tools.
                        // Parse it in that case.
                        contentBlock.toolUse.input = JSON.parse(contentBlock.toolUse.input);
                    }
                    if ((_b = contentBlock.toolResult) === null || _b === void 0 ? void 0 : _b.content) {
                        contentBlock.toolResult.content.forEach((toolResultContentBlock) => {
                            if (typeof toolResultContentBlock.json === 'string') {
                                // toolResult.content[].json may come as serialized JSON for Client Tools.
                                // Parse it in that case.
                                toolResultContentBlock.json = JSON.parse(toolResultContentBlock.json);
                            }
                        });
                    }
                });
            });
            return items;
        };
    }
}
exports.ConversationMessageHistoryRetriever = ConversationMessageHistoryRetriever;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udmVyc2F0aW9uX21lc3NhZ2VfaGlzdG9yeV9yZXRyaWV2ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29udmVyc2F0aW9uL3J1bnRpbWUvY29udmVyc2F0aW9uX21lc3NhZ2VfaGlzdG9yeV9yZXRyaWV2ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBS0EseUVBQW9FO0FBQ3BFLCtEQUEwRDtBQW1DMUQ7Ozs7R0FJRztBQUNILE1BQU0sdUJBQXVCLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWdEL0IsQ0FBQztBQUVGOzs7O0dBSUc7QUFDSCxNQUFhLG1DQUFtQztJQUM5Qzs7T0FFRztJQUNILFlBQ21CLEtBQTRCLEVBQzVCLHlCQUF5QixJQUFJLGlEQUFzQixDQUNsRSxLQUFLLENBQUMsa0JBQWtCLEVBQ3hCLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFDbkMsSUFBSSx1Q0FBaUIsQ0FBQyxLQUFLLENBQUMsQ0FDN0I7UUFMZ0IsVUFBSyxHQUFMLEtBQUssQ0FBdUI7UUFDNUIsMkJBQXNCLEdBQXRCLHNCQUFzQixDQUl0QztRQUdILHNCQUFpQixHQUFHLEtBQUssSUFBeUMsRUFBRTtZQUNsRSxNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztZQUUzQyxJQUFJLGNBQWMsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUNoQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUM1QyxDQUFDO1lBRUYsbUZBQW1GO1lBQ25GLHlFQUF5RTtZQUN6RSwrQkFBK0I7WUFDL0IsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO2dCQUNwQixjQUFjLEdBQUcsTUFBTSxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztnQkFDaEQsUUFBUSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUNoQyxDQUFDO1lBRUQsMERBQTBEO1lBQzFELE1BQU0sK0JBQStCLEdBR2pDLElBQUksR0FBRyxFQUFFLENBQUM7WUFDZCxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUU7Z0JBQzNCLElBQUksT0FBTyxDQUFDLElBQUksS0FBSyxXQUFXLElBQUksT0FBTyxDQUFDLHVCQUF1QixFQUFFLENBQUM7b0JBQ3BFLCtCQUErQixDQUFDLEdBQUcsQ0FDakMsT0FBTyxDQUFDLHVCQUF1QixFQUMvQixPQUFPLENBQ1IsQ0FBQztnQkFDSixDQUFDO1lBQ0gsQ0FBQyxDQUFDLENBQUM7WUFFSCx5Q0FBeUM7WUFDekMsTUFBTSxlQUFlLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxPQUFPLEVBQUUsRUFBRTtnQkFDdkQsMkZBQTJGO2dCQUMzRixtR0FBbUc7Z0JBQ25HLCtHQUErRztnQkFDL0csd0RBQXdEO2dCQUN4RCw4RUFBOEU7Z0JBQzlFLElBQUksT0FBTyxDQUFDLElBQUksS0FBSyxXQUFXLEVBQUUsQ0FBQztvQkFDakMsaUZBQWlGO29CQUNqRixPQUFPLEdBQUcsQ0FBQztnQkFDYixDQUFDO2dCQUNELElBQ0UsT0FBTyxDQUFDLElBQUksS0FBSyxNQUFNO29CQUN2QixDQUFDLCtCQUErQixDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDO29CQUNoRCxPQUFPLENBQUMsRUFBRSxLQUFLLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLEVBQzFDLENBQUM7b0JBQ0QsZ0VBQWdFO29CQUNoRSxvR0FBb0c7b0JBQ3BHLHVEQUF1RDtvQkFDdkQsT0FBTyxHQUFHLENBQUM7Z0JBQ2IsQ0FBQztnQkFDRCxNQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDO2dCQUNwQyxNQUFNLE9BQU8sR0FBRyxTQUFTO29CQUN2QixDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxPQUFPLEVBQUUsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDO29CQUMzRCxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQztnQkFFcEIsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksRUFBRSxPQUFPLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7Z0JBRTFDLG1EQUFtRDtnQkFDbkQsTUFBTSw2QkFBNkIsR0FBRywrQkFBK0IsQ0FBQyxHQUFHLENBQ3ZFLE9BQU8sQ0FBQyxFQUFFLENBQ1gsQ0FBQztnQkFDRixJQUFJLDZCQUE2QixFQUFFLENBQUM7b0JBQ2xDLEdBQUcsQ0FBQyxJQUFJLENBQUM7d0JBQ1AsSUFBSSxFQUFFLDZCQUE2QixDQUFDLElBQUk7d0JBQ3hDLE9BQU8sRUFBRSw2QkFBNkIsQ0FBQyxPQUFPO3FCQUMvQyxDQUFDLENBQUM7Z0JBQ0wsQ0FBQztnQkFDRCxPQUFPLEdBQUcsQ0FBQztZQUNiLENBQUMsRUFBRSxFQUFnQyxDQUFDLENBQUM7WUFFckMsK0RBQStEO1lBQy9ELE9BQU8sSUFBSSxDQUFDLHFCQUFxQixDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQ3JELENBQUMsQ0FBQztRQUVGOzs7Ozs7OztXQVFHO1FBQ0ssMEJBQXFCLEdBQUcsQ0FBQyxRQUFvQyxFQUFFLEVBQUU7WUFDdkUsTUFBTSx1QkFBdUIsR0FBRyxDQUM5QixZQUE2QyxFQUM3QyxFQUFFLENBQUMsQ0FBQyxZQUFZLENBQUMsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQztZQUV2RCxzRkFBc0Y7WUFDdEYsTUFBTSw4QkFBOEIsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUU7Z0JBQ3hFLE9BQU8sQ0FDTCxPQUFPLENBQUMsSUFBSSxLQUFLLE1BQU0sSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxDQUN6RSxDQUFDO1lBQ0osQ0FBQyxDQUFDLENBQUM7WUFFSCx5Q0FBeUM7WUFDekMsSUFBSSw4QkFBOEIsSUFBSSxDQUFDLEVBQUUsQ0FBQztnQkFDeEMsT0FBTyxRQUFRLENBQUM7WUFDbEIsQ0FBQztZQUVELE1BQU0sZ0JBQWdCLEdBQStCLEVBQUUsQ0FBQztZQUV4RCwwRUFBMEU7WUFDMUUsSUFBSSxzQkFBc0IsR0FBb0MsU0FBUyxDQUFDO1lBQ3hFLDhDQUE4QztZQUM5Qyw0QkFBNEI7WUFDNUIsK0RBQStEO1lBQy9ELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyw4QkFBOEIsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO2dCQUN4RCxNQUFNLGNBQWMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ25DLE1BQU0sa0JBQWtCLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQztnQkFDL0MsTUFBTSw0QkFBNEIsR0FBRyxjQUFjLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FDaEUsdUJBQXVCLENBQ3hCLENBQUM7Z0JBQ0YsSUFBSSw0QkFBNEIsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7b0JBQzlDLDhDQUE4QztvQkFDOUMsU0FBUztnQkFDWCxDQUFDO2dCQUVELElBQUksQ0FBQyxzQkFBc0IsRUFBRSxDQUFDO29CQUM1QiwrQ0FBK0M7b0JBQy9DLHNCQUFzQixHQUFHO3dCQUN2QixJQUFJLEVBQUUsa0JBQWtCO3dCQUN4QixPQUFPLEVBQUUsNEJBQTRCO3FCQUN0QyxDQUFDO2dCQUNKLENBQUM7cUJBQU0sSUFBSSxzQkFBc0IsQ0FBQyxJQUFJLEtBQUssa0JBQWtCLEVBQUUsQ0FBQztvQkFDOUQsa0NBQWtDO29CQUNsQyxzQkFBc0IsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsNEJBQTRCLENBQUMsQ0FBQztnQkFDdkUsQ0FBQztxQkFBTSxDQUFDO29CQUNOLDRFQUE0RTtvQkFDNUUsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLENBQUM7b0JBQzlDLHNCQUFzQixHQUFHO3dCQUN2QixJQUFJLEVBQUUsa0JBQWtCO3dCQUN4QixPQUFPLEVBQUUsNEJBQTRCO3FCQUN0QyxDQUFDO2dCQUNKLENBQUM7WUFDSCxDQUFDO1lBQ0QseUJBQXlCO1lBQ3pCLElBQUksc0JBQXNCLEVBQUUsQ0FBQztnQkFDM0IsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLENBQUM7WUFDaEQsQ0FBQztZQUVELDZCQUE2QjtZQUM3QixnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLDhCQUE4QixDQUFDLENBQUMsQ0FBQztZQUN6RSxPQUFPLGdCQUFnQixDQUFDO1FBQzFCLENBQUMsQ0FBQztRQUVNLHNCQUFpQixHQUN2QixLQUFLLElBQTZDLEVBQUU7WUFDbEQsTUFBTSxLQUFLLEdBQUc7Z0NBQ1ksSUFBSSxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxxQkFBcUI7Y0FDdEUsSUFBSSxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxZQUFZO2dCQUN6Qyx1QkFBdUI7OztLQUdsQyxDQUFDO1lBQ0EsTUFBTSxTQUFTLEdBQWtCO2dCQUMvQixFQUFFLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0I7YUFDaEMsQ0FBQztZQUVGLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLHNCQUFzQixDQUFDLGNBQWMsQ0FHL0Q7Z0JBQ0EsS0FBSztnQkFDTCxTQUFTO2FBQ1YsQ0FBQyxDQUFDO1lBRUgsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsbUJBQW1CLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDcEUsQ0FBQyxDQUFDO1FBRUksaUJBQVksR0FBRyxLQUFLLElBRTFCLEVBQUU7O1lBQ0YsTUFBTSxLQUFLLEdBQUc7c0NBQ29CLElBQUksQ0FBQyxLQUFLLENBQUMsbUJBQW1CLENBQUMsc0JBQXNCO2NBQzdFLElBQUksQ0FBQyxLQUFLLENBQUMsbUJBQW1CLENBQUMsYUFBYTs7a0JBRXhDLHVCQUF1Qjs7OztLQUlwQyxDQUFDO1lBQ0YsTUFBTSxTQUFTLEdBQW1CO2dCQUNoQyxNQUFNLEVBQUU7b0JBQ04sY0FBYyxFQUFFO3dCQUNkLEVBQUUsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLGNBQWM7cUJBQzlCO2lCQUNGO2dCQUNELEtBQUssRUFBRSxNQUFBLElBQUksQ0FBQyxLQUFLLENBQUMsbUJBQW1CLENBQUMsY0FBYyxtQ0FBSSxJQUFJO2FBQzdELENBQUM7WUFFRixNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxjQUFjLENBRy9EO2dCQUNBLEtBQUs7Z0JBQ0wsU0FBUzthQUNWLENBQUMsQ0FBQztZQUVILE1BQU0sS0FBSyxHQUNULFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxhQUFhLENBQUMsQ0FBQyxLQUFLLENBQUM7WUFFcEUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFOztnQkFDckIsTUFBQSxJQUFJLENBQUMsT0FBTywwQ0FBRSxPQUFPLENBQUMsQ0FBQyxZQUFZLEVBQUUsRUFBRTs7b0JBQ3JDLElBQUksUUFBbUMsQ0FBQztvQkFDeEMsS0FBSyxRQUFRLElBQUksWUFBWSxFQUFFLENBQUM7d0JBQzlCLDBFQUEwRTt3QkFDMUUsK0ZBQStGO3dCQUMvRixxREFBcUQ7d0JBQ3JELDJEQUEyRDt3QkFDM0QsSUFBSSxZQUFZLENBQUMsUUFBUSxDQUFDLEtBQUssSUFBSSxFQUFFLENBQUM7NEJBQ3BDLFlBQVksQ0FBQyxRQUFRLENBQUMsR0FBRyxTQUFTLENBQUM7d0JBQ3JDLENBQUM7b0JBQ0gsQ0FBQztvQkFFRCxJQUFJLE9BQU8sQ0FBQSxNQUFBLFlBQVksQ0FBQyxPQUFPLDBDQUFFLEtBQUssQ0FBQSxLQUFLLFFBQVEsRUFBRSxDQUFDO3dCQUNwRCw4REFBOEQ7d0JBQzlELHlCQUF5Qjt3QkFDekIsWUFBWSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUN0RSxDQUFDO29CQUNELElBQUksTUFBQSxZQUFZLENBQUMsVUFBVSwwQ0FBRSxPQUFPLEVBQUUsQ0FBQzt3QkFDckMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsc0JBQXNCLEVBQUUsRUFBRTs0QkFDakUsSUFBSSxPQUFPLHNCQUFzQixDQUFDLElBQUksS0FBSyxRQUFRLEVBQUUsQ0FBQztnQ0FDcEQsMEVBQTBFO2dDQUMxRSx5QkFBeUI7Z0NBQ3pCLHNCQUFzQixDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUN0QyxzQkFBc0IsQ0FBQyxJQUFJLENBQzVCLENBQUM7NEJBQ0osQ0FBQzt3QkFDSCxDQUFDLENBQUMsQ0FBQztvQkFDTCxDQUFDO2dCQUNILENBQUMsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDLENBQUM7WUFFSCxPQUFPLEtBQUssQ0FBQztRQUNmLENBQUMsQ0FBQztJQTdPQyxDQUFDO0NBOE9MO0FBelBELGtGQXlQQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbnZlcnNhdGlvbk1lc3NhZ2UsXG4gIENvbnZlcnNhdGlvbk1lc3NhZ2VDb250ZW50QmxvY2ssXG4gIENvbnZlcnNhdGlvblR1cm5FdmVudCxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBHcmFwaHFsUmVxdWVzdEV4ZWN1dG9yIH0gZnJvbSAnLi9ncmFwaHFsX3JlcXVlc3RfZXhlY3V0b3InO1xuaW1wb3J0IHsgVXNlckFnZW50UHJvdmlkZXIgfSBmcm9tICcuL3VzZXJfYWdlbnRfcHJvdmlkZXInO1xuXG5leHBvcnQgdHlwZSBDb252ZXJzYXRpb25IaXN0b3J5TWVzc2FnZUl0ZW0gPSBDb252ZXJzYXRpb25NZXNzYWdlICYge1xuICBpZDogc3RyaW5nO1xuICBjb252ZXJzYXRpb25JZDogc3RyaW5nO1xuICBhc3NvY2lhdGVkVXNlck1lc3NhZ2VJZD86IHN0cmluZztcbiAgYWlDb250ZXh0PzogdW5rbm93bjtcbn07XG5cbmV4cG9ydCB0eXBlIEdldFF1ZXJ5SW5wdXQgPSB7XG4gIGlkOiBzdHJpbmc7XG59O1xuXG5leHBvcnQgdHlwZSBHZXRRdWVyeU91dHB1dCA9IHtcbiAgZGF0YTogUmVjb3JkPHN0cmluZywgQ29udmVyc2F0aW9uSGlzdG9yeU1lc3NhZ2VJdGVtPjtcbn07XG5cbmV4cG9ydCB0eXBlIExpc3RRdWVyeUlucHV0ID0ge1xuICBmaWx0ZXI6IHtcbiAgICBjb252ZXJzYXRpb25JZDoge1xuICAgICAgZXE6IHN0cmluZztcbiAgICB9O1xuICB9O1xuICBsaW1pdDogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgTGlzdFF1ZXJ5T3V0cHV0ID0ge1xuICBkYXRhOiBSZWNvcmQ8XG4gICAgc3RyaW5nLFxuICAgIHtcbiAgICAgIGl0ZW1zOiBBcnJheTxDb252ZXJzYXRpb25IaXN0b3J5TWVzc2FnZUl0ZW0+O1xuICAgIH1cbiAgPjtcbn07XG5cbi8qKlxuICogVGhlc2UgYXJlIGFsbCBwcm9wZXJ0aWVzIHdlIGhhdmUgdG8gcHVsbC5cbiAqIFVuZm9ydHVuYXRlbHksIEdRTCBkb2Vzbid0IHN1cHBvcnQgd2lsZGNhcmRzLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dyYXBocWwvZ3JhcGhxbC1zcGVjL2lzc3Vlcy8xMjdcbiAqL1xuY29uc3QgbWVzc2FnZUl0ZW1TZWxlY3Rpb25TZXQgPSBgXG4gICAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgICAgICBjb252ZXJzYXRpb25JZFxuICAgICAgICAgICAgICAgIGFzc29jaWF0ZWRVc2VyTWVzc2FnZUlkXG4gICAgICAgICAgICAgICAgYWlDb250ZXh0XG4gICAgICAgICAgICAgICAgcm9sZVxuICAgICAgICAgICAgICAgIGNvbnRlbnQge1xuICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgZG9jdW1lbnQge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0XG4gICAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGltYWdlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSB7XG4gICAgICAgICAgICAgICAgICAgICAgYnl0ZXNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdG9vbFJlc3VsdCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQge1xuICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaW1hZ2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBqc29uXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c1xuICAgICAgICAgICAgICAgICAgICB0b29sVXNlSWRcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRvb2xVc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dFxuICAgICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgICAgIHRvb2xVc2VJZFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbmA7XG5cbi8qKlxuICogVGhpcyBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgcmV0cmlldmluZyBtZXNzYWdlIGhpc3RvcnkgdGhhdCBiZWxvbmdzIHRvIGNvbnZlcnNhdGlvbiB0dXJuIGV2ZW50LlxuICogSXQgcXVlcmllcyBBcHBTeW5jIHRvIGxpc3QgbWVzc2FnZXMgdGhhdCBiZWxvbmcgdG8gY29udmVyc2F0aW9uLlxuICogQWRkaXRpb25hbGx5LCBpdCBsb29rcyB1cCBhIGN1cnJlbnQgbWVzc2FnZSBpbiBjYXNlIGl0J3MgbWlzc2luZyBpbiB0aGUgbGlzdCBkdWUgdG8gZXZlbnR1YWwgY29uc2lzdGVuY3kuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb252ZXJzYXRpb25NZXNzYWdlSGlzdG9yeVJldHJpZXZlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGNvbnZlcnNhdGlvbiBtZXNzYWdlIGhpc3RvcnkgcmV0cmlldmVyLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBldmVudDogQ29udmVyc2F0aW9uVHVybkV2ZW50LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZ3JhcGhxbFJlcXVlc3RFeGVjdXRvciA9IG5ldyBHcmFwaHFsUmVxdWVzdEV4ZWN1dG9yKFxuICAgICAgZXZlbnQuZ3JhcGhxbEFwaUVuZHBvaW50LFxuICAgICAgZXZlbnQucmVxdWVzdC5oZWFkZXJzLmF1dGhvcml6YXRpb24sXG4gICAgICBuZXcgVXNlckFnZW50UHJvdmlkZXIoZXZlbnQpLFxuICAgICksXG4gICkge31cblxuICBnZXRNZXNzYWdlSGlzdG9yeSA9IGFzeW5jICgpOiBQcm9taXNlPEFycmF5PENvbnZlcnNhdGlvbk1lc3NhZ2U+PiA9PiB7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBhd2FpdCB0aGlzLmxpc3RNZXNzYWdlcygpO1xuXG4gICAgbGV0IGN1cnJlbnRNZXNzYWdlID0gbWVzc2FnZXMuZmluZChcbiAgICAgIChtKSA9PiBtLmlkID09PSB0aGlzLmV2ZW50LmN1cnJlbnRNZXNzYWdlSWQsXG4gICAgKTtcblxuICAgIC8vIFRoaXMgaXMgYSBmYWxsYmFjayBpbiBjYXNlIGN1cnJlbnQgbWVzc2FnZSBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBtZXNzYWdlIGxpc3QuXG4gICAgLy8gSS5lLiBpbiBhIHNpdHVhdGlvbiB3aGVuIGZyZXNobHkgd3JpdHRlbiBtZXNzYWdlIGlzIG5vdCB5ZXQgdmlzaWJsZSBpblxuICAgIC8vIGV2ZW50dWFsbHkgY29uc2lzdGVudCByZWFkcy5cbiAgICBpZiAoIWN1cnJlbnRNZXNzYWdlKSB7XG4gICAgICBjdXJyZW50TWVzc2FnZSA9IGF3YWl0IHRoaXMuZ2V0Q3VycmVudE1lc3NhZ2UoKTtcbiAgICAgIG1lc3NhZ2VzLnB1c2goY3VycmVudE1lc3NhZ2UpO1xuICAgIH1cblxuICAgIC8vIEluZGV4IGFzc2lzdGFudCBtZXNzYWdlcyBieSBjb3JyZXNwb25kaW5nIHVzZXIgbWVzc2FnZS5cbiAgICBjb25zdCBhc3Npc3RhbnRNZXNzYWdlQnlVc2VyTWVzc2FnZUlkOiBNYXA8XG4gICAgICBzdHJpbmcsXG4gICAgICBDb252ZXJzYXRpb25IaXN0b3J5TWVzc2FnZUl0ZW1cbiAgICA+ID0gbmV3IE1hcCgpO1xuICAgIG1lc3NhZ2VzLmZvckVhY2goKG1lc3NhZ2UpID0+IHtcbiAgICAgIGlmIChtZXNzYWdlLnJvbGUgPT09ICdhc3Npc3RhbnQnICYmIG1lc3NhZ2UuYXNzb2NpYXRlZFVzZXJNZXNzYWdlSWQpIHtcbiAgICAgICAgYXNzaXN0YW50TWVzc2FnZUJ5VXNlck1lc3NhZ2VJZC5zZXQoXG4gICAgICAgICAgbWVzc2FnZS5hc3NvY2lhdGVkVXNlck1lc3NhZ2VJZCxcbiAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmVjb25jaWxlIGhpc3RvcnkgYW5kIGluamVjdCBhaUNvbnRleHRcbiAgICBjb25zdCBvcmRlcmVkTWVzc2FnZXMgPSBtZXNzYWdlcy5yZWR1Y2UoKGFjYywgY3VycmVudCkgPT4ge1xuICAgICAgLy8gQmVkcm9jayBleHBlY3RzIHRoYXQgbWVzc2FnZSBoaXN0b3J5IGlzIHVzZXItPmFzc2lzdGFudC0+dXNlci0+YXNzaXN0YW50LT4uLi4gYW5kIHNvIG9uLlxuICAgICAgLy8gVGhlIGNocm9ub2xvZ2ljYWwgb3JkZXIgZG9lc24ndCBhc3N1cmUgdGhpcyBvcmRlcmluZyBpZiB0aGVyZSB3ZXJlIGFueSBjb25jdXJyZW50IG1lc3NhZ2VzIHNlbnQuXG4gICAgICAvLyBUaGVyZWZvcmUsIGNvbnZlcnNhdGlvbiBpcyBvcmRlcmVkIGJ5IHVzZXIncyBtZXNzYWdlcyBvbmx5IGFuZCBjb3JyZXNwb25kaW5nIGFzc2lzdGFudCBtZXNzYWdlcyBhcmUgaW5zZXJ0ZWRcbiAgICAgIC8vIGludG8gcmlnaHQgcGxhY2UgcmVnYXJkbGVzcyBvZiB0aGVpciBjcmVhdGVkQXQgdmFsdWUuXG4gICAgICAvLyBUaGlzIGFsZ29yaXRobSBhc3N1bWVzIHRoYXQgR1FMIHF1ZXJ5IHJldHVybnMgbWVzc2FnZXMgc29ydGVkIGJ5IGNyZWF0ZWRBdC5cbiAgICAgIGlmIChjdXJyZW50LnJvbGUgPT09ICdhc3Npc3RhbnQnKSB7XG4gICAgICAgIC8vIEluaXRpYWxseSwgc2tpcCBhc3Npc3RhbnQgbWVzc2FnZXMsIHRoZXNlIG1pZ2h0IGJlIG91dCBvZiBjaHJvbm9sb2dpY2FsIG9yZGVyLlxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBjdXJyZW50LnJvbGUgPT09ICd1c2VyJyAmJlxuICAgICAgICAhYXNzaXN0YW50TWVzc2FnZUJ5VXNlck1lc3NhZ2VJZC5oYXMoY3VycmVudC5pZCkgJiZcbiAgICAgICAgY3VycmVudC5pZCAhPT0gdGhpcy5ldmVudC5jdXJyZW50TWVzc2FnZUlkXG4gICAgICApIHtcbiAgICAgICAgLy8gU2tpcCB1c2VyIG1lc3NhZ2VzIHRoYXQgZGlkbid0IGdldCBhbnN3ZXIgZnJvbSBhc3Npc3RhbnQgeWV0LlxuICAgICAgICAvLyBUaGVzZSBtaWdodCBiZSBzdGlsbCBcImluLWZsaWdodFwiLCBpLmUuIGFzc2lzdGFudCBpcyBzdGlsbCB3b3JraW5nIG9uIHRoZW0gaW4gc2VwYXJhdGUgaW52b2NhdGlvbi5cbiAgICAgICAgLy8gRXhjZXB0IGN1cnJlbnQgbWVzc2FnZSwgd2Ugd2FudCB0byBwcm9jZXNzIHRoYXQgb25lLlxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgY29uc3QgYWlDb250ZXh0ID0gY3VycmVudC5haUNvbnRleHQ7XG4gICAgICBjb25zdCBjb250ZW50ID0gYWlDb250ZXh0XG4gICAgICAgID8gWy4uLmN1cnJlbnQuY29udGVudCwgeyB0ZXh0OiBKU09OLnN0cmluZ2lmeShhaUNvbnRleHQpIH1dXG4gICAgICAgIDogY3VycmVudC5jb250ZW50O1xuXG4gICAgICBhY2MucHVzaCh7IHJvbGU6IGN1cnJlbnQucm9sZSwgY29udGVudCB9KTtcblxuICAgICAgLy8gRmluZCBhbmQgaW5zZXJ0IGNvcnJlc3BvbmRpbmcgYXNzaXN0YW50IG1lc3NhZ2UuXG4gICAgICBjb25zdCBjb3JyZXNwb25kaW5nQXNzaXN0YW50TWVzc2FnZSA9IGFzc2lzdGFudE1lc3NhZ2VCeVVzZXJNZXNzYWdlSWQuZ2V0KFxuICAgICAgICBjdXJyZW50LmlkLFxuICAgICAgKTtcbiAgICAgIGlmIChjb3JyZXNwb25kaW5nQXNzaXN0YW50TWVzc2FnZSkge1xuICAgICAgICBhY2MucHVzaCh7XG4gICAgICAgICAgcm9sZTogY29ycmVzcG9uZGluZ0Fzc2lzdGFudE1lc3NhZ2Uucm9sZSxcbiAgICAgICAgICBjb250ZW50OiBjb3JyZXNwb25kaW5nQXNzaXN0YW50TWVzc2FnZS5jb250ZW50LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10gYXMgQXJyYXk8Q29udmVyc2F0aW9uTWVzc2FnZT4pO1xuXG4gICAgLy8gUmVtb3ZlIHRvb2wgdXNhZ2UgZnJvbSBub24tY3VycmVudCB0dXJuIGFuZCBzcXVhc2ggbWVzc2FnZXMuXG4gICAgcmV0dXJuIHRoaXMuc3F1YXNoTm9uQ3VycmVudFR1cm5zKG9yZGVyZWRNZXNzYWdlcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gcmVtb3ZlcyB0b29sIHVzYWdlIGZyb20gbm9uLWN1cnJlbnQgdHVybnMuXG4gICAqIFRoZSB0b29sIHVzYWdlIGFuZCByZXN1bHQgYmxvY2tzIGRvbid0IG1hdHRlciBhZnRlciBhIHR1cm4gaXMgY29tcGxldGVkLFxuICAgKiBidXQgZG8gY29zdCBleHRyYSB0b2tlbnMgdG8gcHJvY2Vzcy5cbiAgICogVGhlIGFsZ29yaXRobSBpcyBhcyBmb2xsb3dzOlxuICAgKiAxLiBGaW5kIHdoZXJlIGN1cnJlbnQgdHVybiBiZWdpbnMuIEkuZS4gbGFzdCB1c2VyIG1lc3NhZ2UgdGhhdCBpc24ndCB0b29sIGJsb2NrLlxuICAgKiAyLiBSZW1vdmUgdG9vbFVzZSBhbmQgdG9vbFJlc3VsdCBibG9ja3MgYmVmb3JlIGN1cnJlbnQgdHVybi5cbiAgICogMy4gU3F1YXNoIGNvbnRpbnVvdXMgc2VxdWVuY2VzIG9mIG1lc3NhZ2VzIHRoYXQgYmVsb25nIHRvIHNhbWUgJ21lc3NhZ2Uucm9sZScuXG4gICAqL1xuICBwcml2YXRlIHNxdWFzaE5vbkN1cnJlbnRUdXJucyA9IChtZXNzYWdlczogQXJyYXk8Q29udmVyc2F0aW9uTWVzc2FnZT4pID0+IHtcbiAgICBjb25zdCBpc05vblRvb2xCbG9ja1ByZWRpY2F0ZSA9IChcbiAgICAgIGNvbnRlbnRCbG9jazogQ29udmVyc2F0aW9uTWVzc2FnZUNvbnRlbnRCbG9jayxcbiAgICApID0+ICFjb250ZW50QmxvY2sudG9vbFVzZSAmJiAhY29udGVudEJsb2NrLnRvb2xSZXN1bHQ7XG5cbiAgICAvLyBmaW5kIHdoZXJlIGN1cnJlbnQgdHVybiBiZWdpbnMuIEkuZS4gbGFzdCB1c2VyIG1lc3NhZ2UgdGhhdCBpcyBub3QgcmVsYXRlZCB0byB0b29sc1xuICAgIGNvbnN0IGxhc3ROb25Ub29sVXNlVXNlck1lc3NhZ2VJbmRleCA9IG1lc3NhZ2VzLmZpbmRMYXN0SW5kZXgoKG1lc3NhZ2UpID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIG1lc3NhZ2Uucm9sZSA9PT0gJ3VzZXInICYmIG1lc3NhZ2UuY29udGVudC5maW5kKGlzTm9uVG9vbEJsb2NrUHJlZGljYXRlKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIC8vIE5vIG5vbi1jdXJyZW50IHR1cm5zLCBkb24ndCB0cmFuc2Zvcm0uXG4gICAgaWYgKGxhc3ROb25Ub29sVXNlVXNlck1lc3NhZ2VJbmRleCA8PSAwKSB7XG4gICAgICByZXR1cm4gbWVzc2FnZXM7XG4gICAgfVxuXG4gICAgY29uc3Qgc3F1YXNoZWRNZXNzYWdlczogQXJyYXk8Q29udmVyc2F0aW9uTWVzc2FnZT4gPSBbXTtcblxuICAgIC8vIERlZmluZSBhIFwiYnVmZmVyXCIuIEkuZS4gYSBtZXNzYWdlIHdlIGtlZXAgYXJvdW5kIGFuZCBzcXVhc2ggY29udGVudCBvbi5cbiAgICBsZXQgY3VycmVudFNxdWFzaGVkTWVzc2FnZTogQ29udmVyc2F0aW9uTWVzc2FnZSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAvLyBQcm9jZXNzIG1lc3NhZ2VzIGJlZm9yZSBjdXJyZW50IHR1cm4gYmVnaW5zXG4gICAgLy8gUmVtb3ZlIHRvb2wgdXNhZ2UgYmxvY2tzLlxuICAgIC8vIENvbWJpbmUgY29udGVudCBmb3IgY29uc2VjdXRpdmUgbWVzc2FnZSB0aGF0IGhhdmUgc2FtZSByb2xlLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGFzdE5vblRvb2xVc2VVc2VyTWVzc2FnZUluZGV4OyBpKyspIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRNZXNzYWdlID0gbWVzc2FnZXNbaV07XG4gICAgICBjb25zdCBjdXJyZW50TWVzc2FnZVJvbGUgPSBjdXJyZW50TWVzc2FnZS5yb2xlO1xuICAgICAgY29uc3QgY3VycmVudE1lc3NhZ2VOb25Ub29sQ29udGVudCA9IGN1cnJlbnRNZXNzYWdlLmNvbnRlbnQuZmlsdGVyKFxuICAgICAgICBpc05vblRvb2xCbG9ja1ByZWRpY2F0ZSxcbiAgICAgICk7XG4gICAgICBpZiAoY3VycmVudE1lc3NhZ2VOb25Ub29sQ29udGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gVG9vbCBvbmx5IG1lc3NhZ2UuIE5vdGhpbmcgdG8gc3F1YXNoLCBza2lwO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjdXJyZW50U3F1YXNoZWRNZXNzYWdlKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgc3F1YXNoZWQgeWV0LCBpbml0aWFsaXplIHRoZSBidWZmZXIuXG4gICAgICAgIGN1cnJlbnRTcXVhc2hlZE1lc3NhZ2UgPSB7XG4gICAgICAgICAgcm9sZTogY3VycmVudE1lc3NhZ2VSb2xlLFxuICAgICAgICAgIGNvbnRlbnQ6IGN1cnJlbnRNZXNzYWdlTm9uVG9vbENvbnRlbnQsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnRTcXVhc2hlZE1lc3NhZ2Uucm9sZSA9PT0gY3VycmVudE1lc3NhZ2VSb2xlKSB7XG4gICAgICAgIC8vIGlmIHJvbGUgaXMgc2FtZSBhcHBlbmQgY29udGVudC5cbiAgICAgICAgY3VycmVudFNxdWFzaGVkTWVzc2FnZS5jb250ZW50LnB1c2goLi4uY3VycmVudE1lc3NhZ2VOb25Ub29sQ29udGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiByb2xlIGZsaXBzIHB1c2ggY3VycmVudCBzcXVhc2hlZCBtZXNzYWdlIGFuZCByZS1pbml0aWFsaXplIHRoZSBidWZmZXIuXG4gICAgICAgIHNxdWFzaGVkTWVzc2FnZXMucHVzaChjdXJyZW50U3F1YXNoZWRNZXNzYWdlKTtcbiAgICAgICAgY3VycmVudFNxdWFzaGVkTWVzc2FnZSA9IHtcbiAgICAgICAgICByb2xlOiBjdXJyZW50TWVzc2FnZVJvbGUsXG4gICAgICAgICAgY29udGVudDogY3VycmVudE1lc3NhZ2VOb25Ub29sQ29udGVudCxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZmx1c2ggdGhlIGxhc3QgYnVmZmVyLlxuICAgIGlmIChjdXJyZW50U3F1YXNoZWRNZXNzYWdlKSB7XG4gICAgICBzcXVhc2hlZE1lc3NhZ2VzLnB1c2goY3VycmVudFNxdWFzaGVkTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLy8gQXBwZW5kIGN1cnJlbnQgdHVybiBhcyBpcy5cbiAgICBzcXVhc2hlZE1lc3NhZ2VzLnB1c2goLi4ubWVzc2FnZXMuc2xpY2UobGFzdE5vblRvb2xVc2VVc2VyTWVzc2FnZUluZGV4KSk7XG4gICAgcmV0dXJuIHNxdWFzaGVkTWVzc2FnZXM7XG4gIH07XG5cbiAgcHJpdmF0ZSBnZXRDdXJyZW50TWVzc2FnZSA9XG4gICAgYXN5bmMgKCk6IFByb21pc2U8Q29udmVyc2F0aW9uSGlzdG9yeU1lc3NhZ2VJdGVtPiA9PiB7XG4gICAgICBjb25zdCBxdWVyeSA9IGBcbiAgICAgICAgcXVlcnkgR2V0TWVzc2FnZSgkaWQ6ICR7dGhpcy5ldmVudC5tZXNzYWdlSGlzdG9yeVF1ZXJ5LmdldFF1ZXJ5SW5wdXRUeXBlTmFtZX0hKSB7XG4gICAgICAgICAgICAke3RoaXMuZXZlbnQubWVzc2FnZUhpc3RvcnlRdWVyeS5nZXRRdWVyeU5hbWV9KGlkOiAkaWQpIHtcbiAgICAgICAgICAgICAgJHttZXNzYWdlSXRlbVNlbGVjdGlvblNldH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIGA7XG4gICAgICBjb25zdCB2YXJpYWJsZXM6IEdldFF1ZXJ5SW5wdXQgPSB7XG4gICAgICAgIGlkOiB0aGlzLmV2ZW50LmN1cnJlbnRNZXNzYWdlSWQsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ3JhcGhxbFJlcXVlc3RFeGVjdXRvci5leGVjdXRlR3JhcGhxbDxcbiAgICAgICAgR2V0UXVlcnlJbnB1dCxcbiAgICAgICAgR2V0UXVlcnlPdXRwdXRcbiAgICAgID4oe1xuICAgICAgICBxdWVyeSxcbiAgICAgICAgdmFyaWFibGVzLFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhW3RoaXMuZXZlbnQubWVzc2FnZUhpc3RvcnlRdWVyeS5nZXRRdWVyeU5hbWVdO1xuICAgIH07XG5cbiAgcHJpdmF0ZSBsaXN0TWVzc2FnZXMgPSBhc3luYyAoKTogUHJvbWlzZTxcbiAgICBBcnJheTxDb252ZXJzYXRpb25IaXN0b3J5TWVzc2FnZUl0ZW0+XG4gID4gPT4ge1xuICAgIGNvbnN0IHF1ZXJ5ID0gYFxuICAgICAgICBxdWVyeSBMaXN0TWVzc2FnZXMoJGZpbHRlcjogJHt0aGlzLmV2ZW50Lm1lc3NhZ2VIaXN0b3J5UXVlcnkubGlzdFF1ZXJ5SW5wdXRUeXBlTmFtZX0hLCAkbGltaXQ6IEludCkge1xuICAgICAgICAgICAgJHt0aGlzLmV2ZW50Lm1lc3NhZ2VIaXN0b3J5UXVlcnkubGlzdFF1ZXJ5TmFtZX0oZmlsdGVyOiAkZmlsdGVyLCBsaW1pdDogJGxpbWl0KSB7XG4gICAgICAgICAgICAgIGl0ZW1zIHtcbiAgICAgICAgICAgICAgICAke21lc3NhZ2VJdGVtU2VsZWN0aW9uU2V0fVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBgO1xuICAgIGNvbnN0IHZhcmlhYmxlczogTGlzdFF1ZXJ5SW5wdXQgPSB7XG4gICAgICBmaWx0ZXI6IHtcbiAgICAgICAgY29udmVyc2F0aW9uSWQ6IHtcbiAgICAgICAgICBlcTogdGhpcy5ldmVudC5jb252ZXJzYXRpb25JZCxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBsaW1pdDogdGhpcy5ldmVudC5tZXNzYWdlSGlzdG9yeVF1ZXJ5Lmxpc3RRdWVyeUxpbWl0ID8/IDEwMDAsXG4gICAgfTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ncmFwaHFsUmVxdWVzdEV4ZWN1dG9yLmV4ZWN1dGVHcmFwaHFsPFxuICAgICAgTGlzdFF1ZXJ5SW5wdXQsXG4gICAgICBMaXN0UXVlcnlPdXRwdXRcbiAgICA+KHtcbiAgICAgIHF1ZXJ5LFxuICAgICAgdmFyaWFibGVzLFxuICAgIH0pO1xuXG4gICAgY29uc3QgaXRlbXMgPVxuICAgICAgcmVzcG9uc2UuZGF0YVt0aGlzLmV2ZW50Lm1lc3NhZ2VIaXN0b3J5UXVlcnkubGlzdFF1ZXJ5TmFtZV0uaXRlbXM7XG5cbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICBpdGVtLmNvbnRlbnQ/LmZvckVhY2goKGNvbnRlbnRCbG9jaykgPT4ge1xuICAgICAgICBsZXQgcHJvcGVydHk6IGtleW9mIHR5cGVvZiBjb250ZW50QmxvY2s7XG4gICAgICAgIGZvciAocHJvcGVydHkgaW4gY29udGVudEJsb2NrKSB7XG4gICAgICAgICAgLy8gRGVzZXJpYWxpemF0aW9uIG9mIEdyYXBoUWwgcXVlcnkgcmVzdWx0IHNldHMgdGhlc2UgcHJvcGVydGllcyB0byAnbnVsbCdcbiAgICAgICAgICAvLyBUaGlzIGNhbiB0cmlnZ2VyIEJlZHJvY2sgU0RLIHZhbGlkYXRpb24gYXMgaXQgZXhwZWN0cyAndW5kZWZpbmVkJyBpZiBwcm9wZXJ0aWVzIGFyZSBub3Qgc2V0LlxuICAgICAgICAgIC8vIFdlIGNhbid0IGZpeCBob3cgR3JhcGhRbCByZXNwb25zZSBpcyBkZXNlcmlhbGl6ZWQuXG4gICAgICAgICAgLy8gVGhlcmVmb3JlLCB3ZSBhcHBseSB0aGlzIHRyYW5zZm9ybWF0aW9uIHRvIGZpeCB0aGUgZGF0YS5cbiAgICAgICAgICBpZiAoY29udGVudEJsb2NrW3Byb3BlcnR5XSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGVudEJsb2NrW3Byb3BlcnR5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnRCbG9jay50b29sVXNlPy5pbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyB0b29sVXNlLmlucHV0IG1heSBjb21lIGFzIHNlcmlhbGl6ZWQgSlNPTiBmb3IgQ2xpZW50IFRvb2xzLlxuICAgICAgICAgIC8vIFBhcnNlIGl0IGluIHRoYXQgY2FzZS5cbiAgICAgICAgICBjb250ZW50QmxvY2sudG9vbFVzZS5pbnB1dCA9IEpTT04ucGFyc2UoY29udGVudEJsb2NrLnRvb2xVc2UuaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50QmxvY2sudG9vbFJlc3VsdD8uY29udGVudCkge1xuICAgICAgICAgIGNvbnRlbnRCbG9jay50b29sUmVzdWx0LmNvbnRlbnQuZm9yRWFjaCgodG9vbFJlc3VsdENvbnRlbnRCbG9jaykgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b29sUmVzdWx0Q29udGVudEJsb2NrLmpzb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIC8vIHRvb2xSZXN1bHQuY29udGVudFtdLmpzb24gbWF5IGNvbWUgYXMgc2VyaWFsaXplZCBKU09OIGZvciBDbGllbnQgVG9vbHMuXG4gICAgICAgICAgICAgIC8vIFBhcnNlIGl0IGluIHRoYXQgY2FzZS5cbiAgICAgICAgICAgICAgdG9vbFJlc3VsdENvbnRlbnRCbG9jay5qc29uID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAgICAgICB0b29sUmVzdWx0Q29udGVudEJsb2NrLmpzb24sXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9O1xufVxuIl19