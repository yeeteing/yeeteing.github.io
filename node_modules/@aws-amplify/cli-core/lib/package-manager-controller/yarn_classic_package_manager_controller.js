import { existsSync as _existsSync } from 'fs';
import _fsp from 'fs/promises';
import { execa as _execa } from 'execa';
import * as _path from 'path';
import { executeWithDebugLogger as _executeWithDebugLogger } from './execute_with_debugger_logger.js';
import { PackageManagerControllerBase } from './package_manager_controller_base.js';
import { YarnClassicLockFileReader } from './lock-file-reader/yarn_classic_lock_file_reader.js';
/**
 * YarnClassicPackageManagerController is an abstraction around yarn classic commands that are needed to initialize a project and install dependencies
 */
export class YarnClassicPackageManagerController extends PackageManagerControllerBase {
    cwd;
    fsp;
    path;
    execa;
    executeWithDebugLogger;
    existsSync;
    lockFileReader;
    /**
     * Abstraction around yarn classic commands that are needed to initialize a project and install dependencies
     */
    constructor(cwd, fsp = _fsp, path = _path, execa = _execa, executeWithDebugLogger = _executeWithDebugLogger, existsSync = _existsSync, lockFileReader = new YarnClassicLockFileReader()) {
        super(cwd, 'yarn', ['init', '--yes'], 'add', lockFileReader, fsp, path, execa, executeWithDebugLogger, existsSync);
        this.cwd = cwd;
        this.fsp = fsp;
        this.path = path;
        this.execa = execa;
        this.executeWithDebugLogger = executeWithDebugLogger;
        this.existsSync = existsSync;
        this.lockFileReader = lockFileReader;
    }
    initializeTsConfig = async (targetDir) => {
        await this.addTypescript(targetDir);
        await super.initializeTsConfig(targetDir);
    };
    addTypescript = async (targetDir) => {
        await this.executeWithDebugLogger(targetDir, 'yarn', ['add', 'typescript@^5'], this.execa);
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWFybl9jbGFzc2ljX3BhY2thZ2VfbWFuYWdlcl9jb250cm9sbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3BhY2thZ2UtbWFuYWdlci1jb250cm9sbGVyL3lhcm5fY2xhc3NpY19wYWNrYWdlX21hbmFnZXJfY29udHJvbGxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxJQUFJLFdBQVcsRUFBRSxNQUFNLElBQUksQ0FBQztBQUMvQyxPQUFPLElBQUksTUFBTSxhQUFhLENBQUM7QUFDL0IsT0FBTyxFQUFFLEtBQUssSUFBSSxNQUFNLEVBQUUsTUFBTSxPQUFPLENBQUM7QUFDeEMsT0FBTyxLQUFLLEtBQUssTUFBTSxNQUFNLENBQUM7QUFDOUIsT0FBTyxFQUFFLHNCQUFzQixJQUFJLHVCQUF1QixFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFDdEcsT0FBTyxFQUFFLDRCQUE0QixFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFDcEYsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0scURBQXFELENBQUM7QUFFaEc7O0dBRUc7QUFDSCxNQUFNLE9BQU8sbUNBQW9DLFNBQVEsNEJBQTRCO0lBSzlEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBVnJCOztPQUVHO0lBQ0gsWUFDcUIsR0FBVyxFQUNYLE1BQU0sSUFBSSxFQUNWLE9BQU8sS0FBSyxFQUNaLFFBQVEsTUFBTSxFQUNkLHlCQUF5Qix1QkFBdUIsRUFDaEQsYUFBYSxXQUFXLEVBQ3hCLGlCQUFpQixJQUFJLHlCQUF5QixFQUFFO1FBRW5FLEtBQUssQ0FDSCxHQUFHLEVBQ0gsTUFBTSxFQUNOLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxFQUNqQixLQUFLLEVBQ0wsY0FBYyxFQUNkLEdBQUcsRUFDSCxJQUFJLEVBQ0osS0FBSyxFQUNMLHNCQUFzQixFQUN0QixVQUFVLENBQ1gsQ0FBQztRQW5CaUIsUUFBRyxHQUFILEdBQUcsQ0FBUTtRQUNYLFFBQUcsR0FBSCxHQUFHLENBQU87UUFDVixTQUFJLEdBQUosSUFBSSxDQUFRO1FBQ1osVUFBSyxHQUFMLEtBQUssQ0FBUztRQUNkLDJCQUFzQixHQUF0QixzQkFBc0IsQ0FBMEI7UUFDaEQsZUFBVSxHQUFWLFVBQVUsQ0FBYztRQUN4QixtQkFBYyxHQUFkLGNBQWMsQ0FBa0M7SUFjckUsQ0FBQztJQUVELGtCQUFrQixHQUFHLEtBQUssRUFBRSxTQUFpQixFQUFFLEVBQUU7UUFDL0MsTUFBTSxJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3BDLE1BQU0sS0FBSyxDQUFDLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQzVDLENBQUMsQ0FBQztJQUVNLGFBQWEsR0FBRyxLQUFLLEVBQUUsU0FBaUIsRUFBRSxFQUFFO1FBQ2xELE1BQU0sSUFBSSxDQUFDLHNCQUFzQixDQUMvQixTQUFTLEVBQ1QsTUFBTSxFQUNOLENBQUMsS0FBSyxFQUFFLGVBQWUsQ0FBQyxFQUN4QixJQUFJLENBQUMsS0FBSyxDQUNYLENBQUM7SUFDSixDQUFDLENBQUM7Q0FDSCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4aXN0c1N5bmMgYXMgX2V4aXN0c1N5bmMgfSBmcm9tICdmcyc7XG5pbXBvcnQgX2ZzcCBmcm9tICdmcy9wcm9taXNlcyc7XG5pbXBvcnQgeyBleGVjYSBhcyBfZXhlY2EgfSBmcm9tICdleGVjYSc7XG5pbXBvcnQgKiBhcyBfcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IGV4ZWN1dGVXaXRoRGVidWdMb2dnZXIgYXMgX2V4ZWN1dGVXaXRoRGVidWdMb2dnZXIgfSBmcm9tICcuL2V4ZWN1dGVfd2l0aF9kZWJ1Z2dlcl9sb2dnZXIuanMnO1xuaW1wb3J0IHsgUGFja2FnZU1hbmFnZXJDb250cm9sbGVyQmFzZSB9IGZyb20gJy4vcGFja2FnZV9tYW5hZ2VyX2NvbnRyb2xsZXJfYmFzZS5qcyc7XG5pbXBvcnQgeyBZYXJuQ2xhc3NpY0xvY2tGaWxlUmVhZGVyIH0gZnJvbSAnLi9sb2NrLWZpbGUtcmVhZGVyL3lhcm5fY2xhc3NpY19sb2NrX2ZpbGVfcmVhZGVyLmpzJztcblxuLyoqXG4gKiBZYXJuQ2xhc3NpY1BhY2thZ2VNYW5hZ2VyQ29udHJvbGxlciBpcyBhbiBhYnN0cmFjdGlvbiBhcm91bmQgeWFybiBjbGFzc2ljIGNvbW1hbmRzIHRoYXQgYXJlIG5lZWRlZCB0byBpbml0aWFsaXplIGEgcHJvamVjdCBhbmQgaW5zdGFsbCBkZXBlbmRlbmNpZXNcbiAqL1xuZXhwb3J0IGNsYXNzIFlhcm5DbGFzc2ljUGFja2FnZU1hbmFnZXJDb250cm9sbGVyIGV4dGVuZHMgUGFja2FnZU1hbmFnZXJDb250cm9sbGVyQmFzZSB7XG4gIC8qKlxuICAgKiBBYnN0cmFjdGlvbiBhcm91bmQgeWFybiBjbGFzc2ljIGNvbW1hbmRzIHRoYXQgYXJlIG5lZWRlZCB0byBpbml0aWFsaXplIGEgcHJvamVjdCBhbmQgaW5zdGFsbCBkZXBlbmRlbmNpZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCByZWFkb25seSBjd2Q6IHN0cmluZyxcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgZnNwID0gX2ZzcCxcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgcGF0aCA9IF9wYXRoLFxuICAgIHByb3RlY3RlZCByZWFkb25seSBleGVjYSA9IF9leGVjYSxcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgZXhlY3V0ZVdpdGhEZWJ1Z0xvZ2dlciA9IF9leGVjdXRlV2l0aERlYnVnTG9nZ2VyLFxuICAgIHByb3RlY3RlZCByZWFkb25seSBleGlzdHNTeW5jID0gX2V4aXN0c1N5bmMsXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IGxvY2tGaWxlUmVhZGVyID0gbmV3IFlhcm5DbGFzc2ljTG9ja0ZpbGVSZWFkZXIoKSxcbiAgKSB7XG4gICAgc3VwZXIoXG4gICAgICBjd2QsXG4gICAgICAneWFybicsXG4gICAgICBbJ2luaXQnLCAnLS15ZXMnXSxcbiAgICAgICdhZGQnLFxuICAgICAgbG9ja0ZpbGVSZWFkZXIsXG4gICAgICBmc3AsXG4gICAgICBwYXRoLFxuICAgICAgZXhlY2EsXG4gICAgICBleGVjdXRlV2l0aERlYnVnTG9nZ2VyLFxuICAgICAgZXhpc3RzU3luYyxcbiAgICApO1xuICB9XG5cbiAgaW5pdGlhbGl6ZVRzQ29uZmlnID0gYXN5bmMgKHRhcmdldERpcjogc3RyaW5nKSA9PiB7XG4gICAgYXdhaXQgdGhpcy5hZGRUeXBlc2NyaXB0KHRhcmdldERpcik7XG4gICAgYXdhaXQgc3VwZXIuaW5pdGlhbGl6ZVRzQ29uZmlnKHRhcmdldERpcik7XG4gIH07XG5cbiAgcHJpdmF0ZSBhZGRUeXBlc2NyaXB0ID0gYXN5bmMgKHRhcmdldERpcjogc3RyaW5nKSA9PiB7XG4gICAgYXdhaXQgdGhpcy5leGVjdXRlV2l0aERlYnVnTG9nZ2VyKFxuICAgICAgdGFyZ2V0RGlyLFxuICAgICAgJ3lhcm4nLFxuICAgICAgWydhZGQnLCAndHlwZXNjcmlwdEBeNSddLFxuICAgICAgdGhpcy5leGVjYSxcbiAgICApO1xuICB9O1xufVxuIl19