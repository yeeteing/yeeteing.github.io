"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecutionEnvironment = void 0;
exports.writeContextToEnv = writeContextToEnv;
exports.assemblyFromDirectory = assemblyFromDirectory;
exports.settingsFromSynthOptions = settingsFromSynthOptions;
exports.parametersFromSynthOptions = parametersFromSynthOptions;
require("../../../private/dispose-polyfill");
const os = require("node:os");
const path = require("node:path");
const node_util_1 = require("node:util");
const cxschema = require("@aws-cdk/cloud-assembly-schema");
const cxapi = require("@aws-cdk/cx-api");
const fs = require("fs-extra");
const semver_1 = require("semver");
const toolkit_error_1 = require("../../../toolkit/toolkit-error");
const util_1 = require("../../../util");
const private_1 = require("../../io/private");
const rwlock_1 = require("../../rwlock");
const settings_1 = require("../../settings");
const tree_1 = require("../../tree");
const environment_1 = require("../environment");
class ExecutionEnvironment {
    outdir;
    outDirIsTemporary;
    /**
     * Create an ExecutionEnvironment
     *
     * An ExecutionEnvironment holds a writer lock on the given directory which will
     * be cleaned up when the object is disposed.
     *
     * A temporary directory will be created if none is supplied, which will be cleaned
     * up when this object is disposed.
     *
     * If `markSuccessful()` is called, the writer lock is converted to a reader lock
     * and temporary directories will not be cleaned up anymore.
     */
    static async create(services, props = {}) {
        let tempDir = false;
        let dir = props.outdir;
        if (!dir) {
            tempDir = true;
            dir = fs.mkdtempSync(path.join(fs.realpathSync(os.tmpdir()), 'cdk.out'));
        }
        const lock = await new rwlock_1.RWLock(dir).acquireWrite();
        return new ExecutionEnvironment(services, dir, tempDir, lock);
    }
    ioHelper;
    sdkProvider;
    debugFn;
    lock;
    shouldClean;
    constructor(services, outdir, outDirIsTemporary, lock) {
        this.outdir = outdir;
        this.outDirIsTemporary = outDirIsTemporary;
        this.ioHelper = services.ioHelper;
        this.sdkProvider = services.sdkProvider;
        this.debugFn = (msg) => this.ioHelper.defaults.debug(msg);
        this.lock = lock;
        this.shouldClean = outDirIsTemporary;
    }
    async [Symbol.asyncDispose]() {
        await this.lock?.release();
        if (this.shouldClean) {
            await fs.rm(this.outdir, { recursive: true, force: true });
        }
    }
    /**
     * Mark the execution as successful, which stops the writer lock from being released upon disposal
     */
    async markSuccessful() {
        if (!this.lock) {
            throw new TypeError('Cannot mark successful more than once');
        }
        const readLock = await this.lock.convertToReaderLock();
        this.lock = undefined;
        this.shouldClean = false;
        return { readLock };
    }
    /**
     * Begin an execution in this environment
     *
     * This will acquire a write lock on the given environment. The write lock
     * will be released automatically when the return object is disposed, unless it
     * is converted to a reader lock.
     */
    async beginExecution() {
        const lock = await new rwlock_1.RWLock(this.outdir).acquireWrite();
        let converted = false;
        return {
            async writeToReadLock() {
                converted = true;
                return lock.convertToReaderLock();
            },
            [Symbol.asyncDispose]: async () => {
                // Release if not converted
                if (!converted) {
                    await lock.release();
                }
            },
        };
    }
    /**
     * Guess the executable from the command-line argument
     *
     * Only do this if the file is NOT marked as executable. If it is,
     * we'll defer to the shebang inside the file itself.
     *
     * If we're on Windows, we ALWAYS take the handler, since it's hard to
     * verify if registry associations have or have not been set up for this
     * file type, so we'll assume the worst and take control.
     */
    guessExecutable(app) {
        return (0, environment_1.guessExecutable)(app, this.debugFn);
    }
    /**
     * If we don't have region/account defined in context, we fall back to the default SDK behavior
     * where region is retrieved from ~/.aws/config and account is based on default credentials provider
     * chain and then STS is queried.
     *
     * This is done opportunistically: for example, if we can't access STS for some reason or the region
     * is not configured, the context value will be 'null' and there could failures down the line. In
     * some cases, synthesis does not require region/account information at all, so that might be perfectly
     * fine in certain scenarios.
     */
    async defaultEnvVars() {
        const debugFn = (msg) => this.ioHelper.notify(private_1.IO.CDK_ASSEMBLY_I0010.msg(msg));
        const env = await (0, environment_1.prepareDefaultEnvironment)(this.sdkProvider, debugFn);
        env[cxapi.OUTDIR_ENV] = this.outdir;
        await debugFn((0, node_util_1.format)('outdir:', this.outdir));
        // CLI version information
        env[cxapi.CLI_ASM_VERSION_ENV] = cxschema.Manifest.version();
        env[cxapi.CLI_VERSION_ENV] = (0, util_1.versionNumber)();
        await debugFn((0, node_util_1.format)('env:', env));
        return env;
    }
    /**
     * Run code from a different working directory
     */
    async changeDir(block, workingDir) {
        const originalWorkingDir = process.cwd();
        try {
            if (workingDir) {
                process.chdir(workingDir);
            }
            return await block();
        }
        finally {
            if (workingDir) {
                process.chdir(originalWorkingDir);
            }
        }
    }
}
exports.ExecutionEnvironment = ExecutionEnvironment;
/**
 * Serializes the given context to a set if environment variables environment variables
 *
 * Needs to know the size of the rest of the env because that's necessary to do
 * an overflow computation on Windows. This function will mutate the given
 * environment in-place. It should be called as the very last operation on the
 * environment, because afterwards is might be at the maximum size.
 *
 * This *would* have returned an `IAsyncDisposable` but that requires messing
 * with TypeScript type definitions to use it in aws-cdk, so returning an
 * explicit cleanup function is easier.
 */
function writeContextToEnv(env, context) {
    let contextOverflowLocation = null;
    // On Windows, all envvars together must fit in a 32k block (<https://devblogs.microsoft.com/oldnewthing/20100203-00>)
    // On Linux, a single entry may not exceed 131k; but we're treating it as all together because that's safe
    // and it's a single execution path for both platforms.
    const envVariableSizeLimit = os.platform() === 'win32' ? 32760 : 131072;
    const [smallContext, overflow] = (0, util_1.splitBySize)(context, (0, environment_1.spaceAvailableForContext)(env, envVariableSizeLimit));
    // Store the safe part in the environment variable
    env[cxapi.CONTEXT_ENV] = JSON.stringify(smallContext);
    // If there was any overflow, write it to a temporary file
    if (Object.keys(overflow ?? {}).length > 0) {
        const contextDir = fs.mkdtempSync(path.join(os.tmpdir(), 'cdk-context'));
        contextOverflowLocation = path.join(contextDir, 'context-overflow.json');
        fs.writeJSONSync(contextOverflowLocation, overflow);
        env[cxapi.CONTEXT_OVERFLOW_LOCATION_ENV] = contextOverflowLocation;
    }
    return async () => {
        if (contextOverflowLocation) {
            await fs.promises.rm(path.dirname(contextOverflowLocation), { recursive: true, force: true });
        }
    };
}
/**
 * Checks if a given assembly supports context overflow, warn otherwise.
 *
 * @param assembly - the assembly to check
 */
async function checkContextOverflowSupport(assembly, ioHelper) {
    const traceFn = (msg) => ioHelper.defaults.trace(msg);
    const tree = await (0, tree_1.loadTree)(assembly, traceFn);
    const frameworkDoesNotSupportContextOverflow = (0, tree_1.some)(tree, node => {
        const fqn = node.constructInfo?.fqn;
        const version = node.constructInfo?.version;
        return (fqn === 'aws-cdk-lib.App' && version != null && (0, semver_1.lte)(version, '2.38.0')) // v2
            || fqn === '@aws-cdk/core.App'; // v1
    });
    // We're dealing with an old version of the framework here. It is unaware of the temporary
    // file, which means that it will ignore the context overflow.
    if (frameworkDoesNotSupportContextOverflow) {
        await ioHelper.notify(private_1.IO.CDK_ASSEMBLY_W0010.msg('Part of the context could not be sent to the application. Please update the AWS CDK library to the latest version.'));
    }
}
/**
 * Safely create an assembly from a cloud assembly directory
 */
async function assemblyFromDirectory(assemblyDir, ioHelper, loadOptions = {}) {
    try {
        const assembly = new cxapi.CloudAssembly(assemblyDir, {
            skipVersionCheck: !(loadOptions.checkVersion ?? true),
            skipEnumCheck: !(loadOptions.checkEnums ?? true),
            // We sort as we deploy
            topoSort: false,
        });
        await checkContextOverflowSupport(assembly, ioHelper);
        return assembly;
    }
    catch (err) {
        if (err.message.includes(cxschema.VERSION_MISMATCH)) {
            // this means the CLI version is too old.
            // we instruct the user to upgrade.
            const message = 'This AWS CDK Toolkit is not compatible with the AWS CDK library used by your application. Please upgrade to the latest version.';
            await ioHelper.notify(private_1.IO.CDK_ASSEMBLY_E1111.msg(message, { error: err }));
            throw new toolkit_error_1.ToolkitError(`${message}\n(${err.message}`);
        }
        throw err;
    }
}
function settingsFromSynthOptions(synthOpts = {}) {
    return new settings_1.Settings({
        debug: false,
        pathMetadata: true,
        versionReporting: true,
        assetMetadata: true,
        assetStaging: true,
        ...synthOpts,
    }, true);
}
/**
 * Turn synthesis options into context/environment variables that will go to the CDK app
 *
 * These are parameters that control the synthesis operation, configurable by the user
 * from the outside of the app.
 */
function parametersFromSynthOptions(synthOptions) {
    return (0, environment_1.synthParametersFromSettings)(settingsFromSynthOptions(synthOptions ?? {}));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJlcGFyZS1zb3VyY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwcmVwYXJlLXNvdXJjZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFzTEEsOENBeUJDO0FBMkJELHNEQW9CQztBQUVELDREQVNDO0FBUUQsZ0VBRUM7QUFuUkQsNkNBQTJDO0FBQzNDLDhCQUE4QjtBQUM5QixrQ0FBa0M7QUFDbEMseUNBQW1DO0FBQ25DLDJEQUEyRDtBQUMzRCx5Q0FBeUM7QUFDekMsK0JBQStCO0FBQy9CLG1DQUE2QjtBQUU3QixrRUFBOEQ7QUFDOUQsd0NBQTJEO0FBRzNELDhDQUFzQztBQUV0Qyx5Q0FBc0M7QUFDdEMsNkNBQTBDO0FBQzFDLHFDQUE0QztBQUU1QyxnREFBbUk7QUFHbkksTUFBYSxvQkFBb0I7SUFpQ2I7SUFDQTtJQWpDbEI7Ozs7Ozs7Ozs7O09BV0c7SUFDSSxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxRQUF5QixFQUFFLFFBQTZCLEVBQUU7UUFDbkYsSUFBSSxPQUFPLEdBQUcsS0FBSyxDQUFDO1FBQ3BCLElBQUksR0FBRyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7UUFDdkIsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ1QsT0FBTyxHQUFHLElBQUksQ0FBQztZQUNmLEdBQUcsR0FBRyxFQUFFLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBQzNFLENBQUM7UUFFRCxNQUFNLElBQUksR0FBRyxNQUFNLElBQUksZUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ2xELE9BQU8sSUFBSSxvQkFBb0IsQ0FBQyxRQUFRLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNoRSxDQUFDO0lBRWdCLFFBQVEsQ0FBVztJ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Q0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi4vLi4vLi4vcHJpdmF0ZS9kaXNwb3NlLXBvbHlmaWxsJztcbmltcG9ydCAqIGFzIG9zIGZyb20gJ25vZGU6b3MnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdub2RlOnBhdGgnO1xuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnbm9kZTp1dGlsJztcbmltcG9ydCAqIGFzIGN4c2NoZW1hIGZyb20gJ0Bhd3MtY2RrL2Nsb3VkLWFzc2VtYmx5LXNjaGVtYSc7XG5pbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHsgbHRlIH0gZnJvbSAnc2VtdmVyJztcbmltcG9ydCB0eXBlIHsgVG9vbGtpdFNlcnZpY2VzIH0gZnJvbSAnLi4vLi4vLi4vdG9vbGtpdC9wcml2YXRlJztcbmltcG9ydCB7IFRvb2xraXRFcnJvciB9IGZyb20gJy4uLy4uLy4uL3Rvb2xraXQvdG9vbGtpdC1lcnJvcic7XG5pbXBvcnQgeyBzcGxpdEJ5U2l6ZSwgdmVyc2lvbk51bWJlciB9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHR5cGUgeyBTZGtQcm92aWRlciB9IGZyb20gJy4uLy4uL2F3cy1hdXRoL3ByaXZhdGUnO1xuaW1wb3J0IHR5cGUgeyBJb0hlbHBlciB9IGZyb20gJy4uLy4uL2lvL3ByaXZhdGUnO1xuaW1wb3J0IHsgSU8gfSBmcm9tICcuLi8uLi9pby9wcml2YXRlJztcbmltcG9ydCB0eXBlIHsgSVJlYWRMb2NrLCBJV3JpdGVMb2NrIH0gZnJvbSAnLi4vLi4vcndsb2NrJztcbmltcG9ydCB7IFJXTG9jayB9IGZyb20gJy4uLy4uL3J3bG9jayc7XG5pbXBvcnQgeyBTZXR0aW5ncyB9IGZyb20gJy4uLy4uL3NldHRpbmdzJztcbmltcG9ydCB7IGxvYWRUcmVlLCBzb21lIH0gZnJvbSAnLi4vLi4vdHJlZSc7XG5pbXBvcnQgdHlwZSB7IENvbnRleHQsIEVudiB9IGZyb20gJy4uL2Vudmlyb25tZW50JztcbmltcG9ydCB7IHByZXBhcmVEZWZhdWx0RW52aXJvbm1lbnQsIHNwYWNlQXZhaWxhYmxlRm9yQ29udGV4dCwgZ3Vlc3NFeGVjdXRhYmxlLCBzeW50aFBhcmFtZXRlcnNGcm9tU2V0dGluZ3MgfSBmcm9tICcuLi9lbnZpcm9ubWVudCc7XG5pbXBvcnQgdHlwZSB7IEFwcFN5bnRoT3B0aW9ucywgTG9hZEFzc2VtYmx5T3B0aW9ucyB9IGZyb20gJy4uL3NvdXJjZS1idWlsZGVyJztcblxuZXhwb3J0IGNsYXNzIEV4ZWN1dGlvbkVudmlyb25tZW50IGltcGxlbWVudHMgQXN5bmNEaXNwb3NhYmxlIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBFeGVjdXRpb25FbnZpcm9ubWVudFxuICAgKlxuICAgKiBBbiBFeGVjdXRpb25FbnZpcm9ubWVudCBob2xkcyBhIHdyaXRlciBsb2NrIG9uIHRoZSBnaXZlbiBkaXJlY3Rvcnkgd2hpY2ggd2lsbFxuICAgKiBiZSBjbGVhbmVkIHVwIHdoZW4gdGhlIG9iamVjdCBpcyBkaXNwb3NlZC5cbiAgICpcbiAgICogQSB0ZW1wb3JhcnkgZGlyZWN0b3J5IHdpbGwgYmUgY3JlYXRlZCBpZiBub25lIGlzIHN1cHBsaWVkLCB3aGljaCB3aWxsIGJlIGNsZWFuZWRcbiAgICogdXAgd2hlbiB0aGlzIG9iamVjdCBpcyBkaXNwb3NlZC5cbiAgICpcbiAgICogSWYgYG1hcmtTdWNjZXNzZnVsKClgIGlzIGNhbGxlZCwgdGhlIHdyaXRlciBsb2NrIGlzIGNvbnZlcnRlZCB0byBhIHJlYWRlciBsb2NrXG4gICAqIGFuZCB0ZW1wb3JhcnkgZGlyZWN0b3JpZXMgd2lsbCBub3QgYmUgY2xlYW5lZCB1cCBhbnltb3JlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhc3luYyBjcmVhdGUoc2VydmljZXM6IFRvb2xraXRTZXJ2aWNlcywgcHJvcHM6IHsgb3V0ZGlyPzogc3RyaW5nIH0gPSB7fSkge1xuICAgIGxldCB0ZW1wRGlyID0gZmFsc2U7XG4gICAgbGV0IGRpciA9IHByb3BzLm91dGRpcjtcbiAgICBpZiAoIWRpcikge1xuICAgICAgdGVtcERpciA9IHRydWU7XG4gICAgICBkaXIgPSBmcy5ta2R0ZW1wU3luYyhwYXRoLmpvaW4oZnMucmVhbHBhdGhTeW5jKG9zLnRtcGRpcigpKSwgJ2Nkay5vdXQnKSk7XG4gICAgfVxuXG4gICAgY29uc3QgbG9jayA9IGF3YWl0IG5ldyBSV0xvY2soZGlyKS5hY3F1aXJlV3JpdGUoKTtcbiAgICByZXR1cm4gbmV3IEV4ZWN1dGlvbkVudmlyb25tZW50KHNlcnZpY2VzLCBkaXIsIHRlbXBEaXIsIGxvY2spO1xuICB9XG5cbiAgcHJpdmF0ZSByZWFkb25seSBpb0hlbHBlcjogSW9IZWxwZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyO1xuICBwcml2YXRlIHJlYWRvbmx5IGRlYnVnRm46IChtc2c6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgcHJpdmF0ZSBsb2NrOiBJV3JpdGVMb2NrIHwgdW5kZWZpbmVkO1xuICBwcml2YXRlIHNob3VsZENsZWFuOiBib29sZWFuO1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoXG4gICAgc2VydmljZXM6IFRvb2xraXRTZXJ2aWNlcyxcbiAgICBwdWJsaWMgcmVhZG9ubHkgb3V0ZGlyOiBzdHJpbmcsXG4gICAgcHVibGljIHJlYWRvbmx5IG91dERpcklzVGVtcG9yYXJ5OiBib29sZWFuLFxuICAgIGxvY2s6IElXcml0ZUxvY2ssXG4gICkge1xuICAgIHRoaXMuaW9IZWxwZXIgPSBzZXJ2aWNlcy5pb0hlbHBlcjtcbiAgICB0aGlzLnNka1Byb3ZpZGVyID0gc2VydmljZXMuc2RrUHJvdmlkZXI7XG4gICAgdGhpcy5kZWJ1Z0ZuID0gKG1zZzogc3RyaW5nKSA9PiB0aGlzLmlvSGVscGVyLmRlZmF1bHRzLmRlYnVnKG1zZyk7XG4gICAgdGhpcy5sb2NrID0gbG9jaztcbiAgICB0aGlzLnNob3VsZENsZWFuID0gb3V0RGlySXNUZW1wb3Jhcnk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgW1N5bWJvbC5hc3luY0Rpc3Bvc2VdKCkge1xuICAgIGF3YWl0IHRoaXMubG9jaz8ucmVsZWFzZSgpO1xuXG4gICAgaWYgKHRoaXMuc2hvdWxkQ2xlYW4pIHtcbiAgICAgIGF3YWl0IGZzLnJtKHRoaXMub3V0ZGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1hcmsgdGhlIGV4ZWN1dGlvbiBhcyBzdWNjZXNzZnVsLCB3aGljaCBzdG9wcyB0aGUgd3JpdGVyIGxvY2sgZnJvbSBiZWluZyByZWxlYXNlZCB1cG9uIGRpc3Bvc2FsXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbWFya1N1Y2Nlc3NmdWwoKSB7XG4gICAgaWYgKCF0aGlzLmxvY2spIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBtYXJrIHN1Y2Nlc3NmdWwgbW9yZSB0aGFuIG9uY2UnKTtcbiAgICB9XG4gICAgY29uc3QgcmVhZExvY2sgPSBhd2FpdCB0aGlzLmxvY2suY29udmVydFRvUmVhZGVyTG9jaygpO1xuICAgIHRoaXMubG9jayA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNob3VsZENsZWFuID0gZmFsc2U7XG4gICAgcmV0dXJuIHsgcmVhZExvY2sgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCZWdpbiBhbiBleGVjdXRpb24gaW4gdGhpcyBlbnZpcm9ubWVudFxuICAgKlxuICAgKiBUaGlzIHdpbGwgYWNxdWlyZSBhIHdyaXRlIGxvY2sgb24gdGhlIGdpdmVuIGVudmlyb25tZW50LiBUaGUgd3JpdGUgbG9ja1xuICAgKiB3aWxsIGJlIHJlbGVhc2VkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgcmV0dXJuIG9iamVjdCBpcyBkaXNwb3NlZCwgdW5sZXNzIGl0XG4gICAqIGlzIGNvbnZlcnRlZCB0byBhIHJlYWRlciBsb2NrLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGJlZ2luRXhlY3V0aW9uKCk6IFByb21pc2U8eyB3cml0ZVRvUmVhZExvY2soKTogUHJvbWlzZTxJUmVhZExvY2s+IH0gJiBBc3luY0Rpc3Bvc2FibGU+IHtcbiAgICBjb25zdCBsb2NrID0gYXdhaXQgbmV3IFJXTG9jayh0aGlzLm91dGRpcikuYWNxdWlyZVdyaXRlKCk7XG5cbiAgICBsZXQgY29udmVydGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFzeW5jIHdyaXRlVG9SZWFkTG9jaygpIHtcbiAgICAgICAgY29udmVydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGxvY2suY29udmVydFRvUmVhZGVyTG9jaygpO1xuICAgICAgfSxcbiAgICAgIFtTeW1ib2wuYXN5bmNEaXNwb3NlXTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBSZWxlYXNlIGlmIG5vdCBjb252ZXJ0ZWRcbiAgICAgICAgaWYgKCFjb252ZXJ0ZWQpIHtcbiAgICAgICAgICBhd2FpdCBsb2NrLnJlbGVhc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEd1ZXNzIHRoZSBleGVjdXRhYmxlIGZyb20gdGhlIGNvbW1hbmQtbGluZSBhcmd1bWVudFxuICAgKlxuICAgKiBPbmx5IGRvIHRoaXMgaWYgdGhlIGZpbGUgaXMgTk9UIG1hcmtlZCBhcyBleGVjdXRhYmxlLiBJZiBpdCBpcyxcbiAgICogd2UnbGwgZGVmZXIgdG8gdGhlIHNoZWJhbmcgaW5zaWRlIHRoZSBmaWxlIGl0c2VsZi5cbiAgICpcbiAgICogSWYgd2UncmUgb24gV2luZG93cywgd2UgQUxXQVlTIHRha2UgdGhlIGhhbmRsZXIsIHNpbmNlIGl0J3MgaGFyZCB0b1xuICAgKiB2ZXJpZnkgaWYgcmVnaXN0cnkgYXNzb2NpYXRpb25zIGhhdmUgb3IgaGF2ZSBub3QgYmVlbiBzZXQgdXAgZm9yIHRoaXNcbiAgICogZmlsZSB0eXBlLCBzbyB3ZSdsbCBhc3N1bWUgdGhlIHdvcnN0IGFuZCB0YWtlIGNvbnRyb2wuXG4gICAqL1xuICBwdWJsaWMgZ3Vlc3NFeGVjdXRhYmxlKGFwcDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGd1ZXNzRXhlY3V0YWJsZShhcHAsIHRoaXMuZGVidWdGbik7XG4gIH1cblxuICAvKipcbiAgICogSWYgd2UgZG9uJ3QgaGF2ZSByZWdpb24vYWNjb3VudCBkZWZpbmVkIGluIGNvbnRleHQsIHdlIGZhbGwgYmFjayB0byB0aGUgZGVmYXVsdCBTREsgYmVoYXZpb3JcbiAgICogd2hlcmUgcmVnaW9uIGlzIHJldHJpZXZlZCBmcm9tIH4vLmF3cy9jb25maWcgYW5kIGFjY291bnQgaXMgYmFzZWQgb24gZGVmYXVsdCBjcmVkZW50aWFscyBwcm92aWRlclxuICAgKiBjaGFpbiBhbmQgdGhlbiBTVFMgaXMgcXVlcmllZC5cbiAgICpcbiAgICogVGhpcyBpcyBkb25lIG9wcG9ydHVuaXN0aWNhbGx5OiBmb3IgZXhhbXBsZSwgaWYgd2UgY2FuJ3QgYWNjZXNzIFNUUyBmb3Igc29tZSByZWFzb24gb3IgdGhlIHJlZ2lvblxuICAgKiBpcyBub3QgY29uZmlndXJlZCwgdGhlIGNvbnRleHQgdmFsdWUgd2lsbCBiZSAnbnVsbCcgYW5kIHRoZXJlIGNvdWxkIGZhaWx1cmVzIGRvd24gdGhlIGxpbmUuIEluXG4gICAqIHNvbWUgY2FzZXMsIHN5bnRoZXNpcyBkb2VzIG5vdCByZXF1aXJlIHJlZ2lvbi9hY2NvdW50IGluZm9ybWF0aW9uIGF0IGFsbCwgc28gdGhhdCBtaWdodCBiZSBwZXJmZWN0bHlcbiAgICogZmluZSBpbiBjZXJ0YWluIHNjZW5hcmlvcy5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBkZWZhdWx0RW52VmFycygpOiBQcm9taXNlPEVudj4ge1xuICAgIGNvbnN0IGRlYnVnRm4gPSAobXNnOiBzdHJpbmcpID0+IHRoaXMuaW9IZWxwZXIubm90aWZ5KElPLkNES19BU1NFTUJMWV9JMDAxMC5tc2cobXNnKSk7XG4gICAgY29uc3QgZW52ID0gYXdhaXQgcHJlcGFyZURlZmF1bHRFbnZpcm9ubWVudCh0aGlzLnNka1Byb3ZpZGVyLCBkZWJ1Z0ZuKTtcblxuICAgIGVudltjeGFwaS5PVVRESVJfRU5WXSA9IHRoaXMub3V0ZGlyO1xuICAgIGF3YWl0IGRlYnVnRm4oZm9ybWF0KCdvdXRkaXI6JywgdGhpcy5vdXRkaXIpKTtcblxuICAgIC8vIENMSSB2ZXJzaW9uIGluZm9ybWF0aW9uXG4gICAgZW52W2N4YXBpLkNMSV9BU01fVkVSU0lPTl9FTlZdID0gY3hzY2hlbWEuTWFuaWZlc3QudmVyc2lvbigpO1xuICAgIGVudltjeGFwaS5DTElfVkVSU0lPTl9FTlZdID0gdmVyc2lvbk51bWJlcigpO1xuXG4gICAgYXdhaXQgZGVidWdGbihmb3JtYXQoJ2VudjonLCBlbnYpKTtcbiAgICByZXR1cm4gZW52O1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biBjb2RlIGZyb20gYSBkaWZmZXJlbnQgd29ya2luZyBkaXJlY3RvcnlcbiAgICovXG4gIHB1YmxpYyBhc3luYyBjaGFuZ2VEaXI8VD4oYmxvY2s6ICgpID0+IFByb21pc2U8VD4sIHdvcmtpbmdEaXI/OiBzdHJpbmcpIHtcbiAgICBjb25zdCBvcmlnaW5hbFdvcmtpbmdEaXIgPSBwcm9jZXNzLmN3ZCgpO1xuICAgIHRyeSB7XG4gICAgICBpZiAod29ya2luZ0Rpcikge1xuICAgICAgICBwcm9jZXNzLmNoZGlyKHdvcmtpbmdEaXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgYmxvY2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHdvcmtpbmdEaXIpIHtcbiAgICAgICAgcHJvY2Vzcy5jaGRpcihvcmlnaW5hbFdvcmtpbmdEaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNlcmlhbGl6ZXMgdGhlIGdpdmVuIGNvbnRleHQgdG8gYSBzZXQgaWYgZW52aXJvbm1lbnQgdmFyaWFibGVzIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICpcbiAqIE5lZWRzIHRvIGtub3cgdGhlIHNpemUgb2YgdGhlIHJlc3Qgb2YgdGhlIGVudiBiZWNhdXNlIHRoYXQncyBuZWNlc3NhcnkgdG8gZG9cbiAqIGFuIG92ZXJmbG93IGNvbXB1dGF0aW9uIG9uIFdpbmRvd3MuIFRoaXMgZnVuY3Rpb24gd2lsbCBtdXRhdGUgdGhlIGdpdmVuXG4gKiBlbnZpcm9ubWVudCBpbi1wbGFjZS4gSXQgc2hvdWxkIGJlIGNhbGxlZCBhcyB0aGUgdmVyeSBsYXN0IG9wZXJhdGlvbiBvbiB0aGVcbiAqIGVudmlyb25tZW50LCBiZWNhdXNlIGFmdGVyd2FyZHMgaXMgbWlnaHQgYmUgYXQgdGhlIG1heGltdW0gc2l6ZS5cbiAqXG4gKiBUaGlzICp3b3VsZCogaGF2ZSByZXR1cm5lZCBhbiBgSUFzeW5jRGlzcG9zYWJsZWAgYnV0IHRoYXQgcmVxdWlyZXMgbWVzc2luZ1xuICogd2l0aCBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgdG8gdXNlIGl0IGluIGF3cy1jZGssIHNvIHJldHVybmluZyBhblxuICogZXhwbGljaXQgY2xlYW51cCBmdW5jdGlvbiBpcyBlYXNpZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZUNvbnRleHRUb0VudihlbnY6IEVudiwgY29udGV4dDogQ29udGV4dCkge1xuICBsZXQgY29udGV4dE92ZXJmbG93TG9jYXRpb24gPSBudWxsO1xuXG4gIC8vIE9uIFdpbmRvd3MsIGFsbCBlbnZ2YXJzIHRvZ2V0aGVyIG11c3QgZml0IGluIGEgMzJrIGJsb2NrICg8aHR0cHM6Ly9kZXZibG9ncy5taWNyb3NvZnQuY29tL29sZG5ld3RoaW5nLzIwMTAwMjAzLTAwPilcbiAgLy8gT24gTGludXgsIGEgc2luZ2xlIGVudHJ5IG1heSBub3QgZXhjZWVkIDEzMWs7IGJ1dCB3ZSdyZSB0cmVhdGluZyBpdCBhcyBhbGwgdG9nZXRoZXIgYmVjYXVzZSB0aGF0J3Mgc2FmZVxuICAvLyBhbmQgaXQncyBhIHNpbmdsZSBleGVjdXRpb24gcGF0aCBmb3IgYm90aCBwbGF0Zm9ybXMuXG4gIGNvbnN0IGVudlZhcmlhYmxlU2l6ZUxpbWl0ID0gb3MucGxhdGZvcm0oKSA9PT0gJ3dpbjMyJyA/IDMyNzYwIDogMTMxMDcyO1xuICBjb25zdCBbc21hbGxDb250ZXh0LCBvdmVyZmxvd10gPSBzcGxpdEJ5U2l6ZShjb250ZXh0LCBzcGFjZUF2YWlsYWJsZUZvckNvbnRleHQoZW52LCBlbnZWYXJpYWJsZVNpemVMaW1pdCkpO1xuXG4gIC8vIFN0b3JlIHRoZSBzYWZlIHBhcnQgaW4gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlXG4gIGVudltjeGFwaS5DT05URVhUX0VOVl0gPSBKU09OLnN0cmluZ2lmeShzbWFsbENvbnRleHQpO1xuXG4gIC8vIElmIHRoZXJlIHdhcyBhbnkgb3ZlcmZsb3csIHdyaXRlIGl0IHRvIGEgdGVtcG9yYXJ5IGZpbGVcbiAgaWYgKE9iamVjdC5rZXlzKG92ZXJmbG93ID8/IHt9KS5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgY29udGV4dERpciA9IGZzLm1rZHRlbXBTeW5jKHBhdGguam9pbihvcy50bXBkaXIoKSwgJ2Nkay1jb250ZXh0JykpO1xuICAgIGNvbnRleHRPdmVyZmxvd0xvY2F0aW9uID0gcGF0aC5qb2luKGNvbnRleHREaXIsICdjb250ZXh0LW92ZXJmbG93Lmpzb24nKTtcbiAgICBmcy53cml0ZUpTT05TeW5jKGNvbnRleHRPdmVyZmxvd0xvY2F0aW9uLCBvdmVyZmxvdyk7XG4gICAgZW52W2N4YXBpLkNPTlRFWFRfT1ZFUkZMT1dfTE9DQVRJT05fRU5WXSA9IGNvbnRleHRPdmVyZmxvd0xvY2F0aW9uO1xuICB9XG5cbiAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICBpZiAoY29udGV4dE92ZXJmbG93TG9jYXRpb24pIHtcbiAgICAgIGF3YWl0IGZzLnByb21pc2VzLnJtKHBhdGguZGlybmFtZShjb250ZXh0T3ZlcmZsb3dMb2NhdGlvbiksIHsgcmVjdXJzaXZlOiB0cnVlLCBmb3JjZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYXNzZW1ibHkgc3VwcG9ydHMgY29udGV4dCBvdmVyZmxvdywgd2FybiBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIGFzc2VtYmx5IC0gdGhlIGFzc2VtYmx5IHRvIGNoZWNrXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrQ29udGV4dE92ZXJmbG93U3VwcG9ydChhc3NlbWJseTogY3hhcGkuQ2xvdWRBc3NlbWJseSwgaW9IZWxwZXI6IElvSGVscGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHRyYWNlRm4gPSAobXNnOiBzdHJpbmcpID0+IGlvSGVscGVyLmRlZmF1bHRzLnRyYWNlKG1zZyk7XG4gIGNvbnN0IHRyZWUgPSBhd2FpdCBsb2FkVHJlZShhc3NlbWJseSwgdHJhY2VGbik7XG4gIGNvbnN0IGZyYW1ld29ya0RvZXNOb3RTdXBwb3J0Q29udGV4dE92ZXJmbG93ID0gc29tZSh0cmVlLCBub2RlID0+IHtcbiAgICBjb25zdCBmcW4gPSBub2RlLmNvbnN0cnVjdEluZm8/LmZxbjtcbiAgICBjb25zdCB2ZXJzaW9uID0gbm9kZS5jb25zdHJ1Y3RJbmZvPy52ZXJzaW9uO1xuICAgIHJldHVybiAoZnFuID09PSAnYXdzLWNkay1saWIuQXBwJyAmJiB2ZXJzaW9uICE9IG51bGwgJiYgbHRlKHZlcnNpb24sICcyLjM4LjAnKSkgLy8gdjJcbiAgICB8fCBmcW4gPT09ICdAYXdzLWNkay9jb3JlLkFwcCc7IC8vIHYxXG4gIH0pO1xuXG4gIC8vIFdlJ3JlIGRlYWxpbmcgd2l0aCBhbiBvbGQgdmVyc2lvbiBvZiB0aGUgZnJhbWV3b3JrIGhlcmUuIEl0IGlzIHVuYXdhcmUgb2YgdGhlIHRlbXBvcmFyeVxuICAvLyBmaWxlLCB3aGljaCBtZWFucyB0aGF0IGl0IHdpbGwgaWdub3JlIHRoZSBjb250ZXh0IG92ZXJmbG93LlxuICBpZiAoZnJhbWV3b3JrRG9lc05vdFN1cHBvcnRDb250ZXh0T3ZlcmZsb3cpIHtcbiAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX0FTU0VNQkxZX1cwMDEwLm1zZygnUGFydCBvZiB0aGUgY29udGV4dCBjb3VsZCBub3QgYmUgc2VudCB0byB0aGUgYXBwbGljYXRpb24uIFBsZWFzZSB1cGRhdGUgdGhlIEFXUyBDREsgbGlicmFyeSB0byB0aGUgbGF0ZXN0IHZlcnNpb24uJykpO1xuICB9XG59XG5cbi8qKlxuICogU2FmZWx5IGNyZWF0ZSBhbiBhc3NlbWJseSBmcm9tIGEgY2xvdWQgYXNzZW1ibHkgZGlyZWN0b3J5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3NlbWJseUZyb21EaXJlY3RvcnkoYXNzZW1ibHlEaXI6IHN0cmluZywgaW9IZWxwZXI6IElvSGVscGVyLCBsb2FkT3B0aW9uczogTG9hZEFzc2VtYmx5T3B0aW9ucyA9IHt9KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgYXNzZW1ibHkgPSBuZXcgY3hhcGkuQ2xvdWRBc3NlbWJseShhc3NlbWJseURpciwge1xuICAgICAgc2tpcFZlcnNpb25DaGVjazogIShsb2FkT3B0aW9ucy5jaGVja1ZlcnNpb24gPz8gdHJ1ZSksXG4gICAgICBza2lwRW51bUNoZWNrOiAhKGxvYWRPcHRpb25zLmNoZWNrRW51bXMgPz8gdHJ1ZSksXG4gICAgICAvLyBXZSBzb3J0IGFzIHdlIGRlcGxveVxuICAgICAgdG9wb1NvcnQ6IGZhbHNlLFxuICAgIH0pO1xuICAgIGF3YWl0IGNoZWNrQ29udGV4dE92ZXJmbG93U3VwcG9ydChhc3NlbWJseSwgaW9IZWxwZXIpO1xuICAgIHJldHVybiBhc3NlbWJseTtcbiAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoY3hzY2hlbWEuVkVSU0lPTl9NSVNNQVRDSCkpIHtcbiAgICAgIC8vIHRoaXMgbWVhbnMgdGhlIENMSSB2ZXJzaW9uIGlzIHRvbyBvbGQuXG4gICAgICAvLyB3ZSBpbnN0cnVjdCB0aGUgdXNlciB0byB1cGdyYWRlLlxuICAgICAgY29uc3QgbWVzc2FnZSA9ICdUaGlzIEFXUyBDREsgVG9vbGtpdCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBBV1MgQ0RLIGxpYnJhcnkgdXNlZCBieSB5b3VyIGFwcGxpY2F0aW9uLiBQbGVhc2UgdXBncmFkZSB0byB0aGUgbGF0ZXN0IHZlcnNpb24uJztcbiAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfQVNTRU1CTFlfRTExMTEubXNnKG1lc3NhZ2UsIHsgZXJyb3I6IGVyciB9KSk7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGAke21lc3NhZ2V9XFxuKCR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0dGluZ3NGcm9tU3ludGhPcHRpb25zKHN5bnRoT3B0czogQXBwU3ludGhPcHRpb25zID0ge30pOiBTZXR0aW5ncyB7XG4gIHJldHVybiBuZXcgU2V0dGluZ3Moe1xuICAgIGRlYnVnOiBmYWxzZSxcbiAgICBwYXRoTWV0YWRhdGE6IHRydWUsXG4gICAgdmVyc2lvblJlcG9ydGluZzogdHJ1ZSxcbiAgICBhc3NldE1ldGFkYXRhOiB0cnVlLFxuICAgIGFzc2V0U3RhZ2luZzogdHJ1ZSxcbiAgICAuLi5zeW50aE9wdHMsXG4gIH0sIHRydWUpO1xufVxuXG4vKipcbiAqIFR1cm4gc3ludGhlc2lzIG9wdGlvbnMgaW50byBjb250ZXh0L2Vudmlyb25tZW50IHZhcmlhYmxlcyB0aGF0IHdpbGwgZ28gdG8gdGhlIENESyBhcHBcbiAqXG4gKiBUaGVzZSBhcmUgcGFyYW1ldGVycyB0aGF0IGNvbnRyb2wgdGhlIHN5bnRoZXNpcyBvcGVyYXRpb24sIGNvbmZpZ3VyYWJsZSBieSB0aGUgdXNlclxuICogZnJvbSB0aGUgb3V0c2lkZSBvZiB0aGUgYXBwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyYW1ldGVyc0Zyb21TeW50aE9wdGlvbnMoc3ludGhPcHRpb25zPzogQXBwU3ludGhPcHRpb25zKSB7XG4gIHJldHVybiBzeW50aFBhcmFtZXRlcnNGcm9tU2V0dGluZ3Moc2V0dGluZ3NGcm9tU3ludGhPcHRpb25zKHN5bnRoT3B0aW9ucyA/PyB7fSkpO1xufVxuIl19