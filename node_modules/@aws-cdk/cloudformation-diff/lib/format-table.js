"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatTable = formatTable;
const chalk = require("chalk");
const string_width_1 = require("string-width");
const table = require("table");
/**
 * Render a two-dimensional array to a visually attractive table
 *
 * First row is considered the table header.
 */
function formatTable(cells, columns, noHorizontalLines) {
    return table.table(cells, {
        border: TABLE_BORDER_CHARACTERS,
        columns: buildColumnConfig(columns !== undefined ? calculateColumnWidths(cells, columns) : undefined),
        drawHorizontalLine: (line) => {
            // Numbering like this: [line 0] [header = row[0]] [line 1] [row 1] [line 2] [content 2] [line 3]
            if (noHorizontalLines) {
                return line < 2 || line === cells.length;
            }
            return (line < 2 || line === cells.length) || lineBetween(cells[line - 1], cells[line]);
        },
    }).trimRight();
}
/**
 * Whether we should draw a line between two rows
 *
 * Draw horizontal line if 2nd column values are different.
 */
function lineBetween(rowA, rowB) {
    return rowA[1] !== rowB[1];
}
function buildColumnConfig(widths) {
    if (widths === undefined) {
        return undefined;
    }
    const ret = {};
    widths.forEach((width, i) => {
        if (width === undefined) {
            return;
        }
        ret[i] = { width };
    });
    return ret;
}
/**
 * Calculate column widths given a terminal width
 *
 * We do this by calculating a fair share for every column. Extra width smaller
 * than the fair share is evenly distributed over all columns that exceed their
 * fair share.
 */
function calculateColumnWidths(rows, terminalWidth) {
    // The terminal is sometimes reported to be 0. Also if the terminal is VERY narrow,
    // just assume a reasonable minimum size.
    terminalWidth = Math.max(terminalWidth, 40);
    // use 'string-width' to not count ANSI chars as actual character width
    const columns = rows[0].map((_, i) => Math.max(...rows.map(row => (0, string_width_1.default)(String(row[i])))));
    // If we have no terminal width, do nothing
    const contentWidth = terminalWidth - 2 - columns.length * 3;
    // If we don't exceed the terminal width, do nothing
    if (sum(columns) <= contentWidth) {
        return columns;
    }
    const fairShare = Math.min(contentWidth / columns.length);
    const smallColumns = columns.filter(w => w < fairShare);
    let distributableWidth = contentWidth - sum(smallColumns);
    const fairDistributable = Math.floor(distributableWidth / (columns.length - smallColumns.length));
    const ret = new Array();
    for (const requestedWidth of columns) {
        if (requestedWidth < fairShare) {
            // Small column gets what they want
            ret.push(requestedWidth);
        }
        else {
            // Last column gets all remaining, otherwise get fair redist share
            const width = distributableWidth < 2 * fairDistributable ? distributableWidth : fairDistributable;
            ret.push(width);
            distributableWidth -= width;
        }
    }
    return ret;
}
function sum(xs) {
    let total = 0;
    for (const x of xs) {
        total += x;
    }
    return total;
}
// What color the table is going to be
const tableColor = chalk.gray;
// Unicode table characters with a color
const TABLE_BORDER_CHARACTERS = {
    topBody: tableColor('─'),
    topJoin: tableColor('┬'),
    topLeft: tableColor('┌'),
    topRight: tableColor('┐'),
    bottomBody: tableColor('─'),
    bottomJoin: tableColor('┴'),
    bottomLeft: tableColor('└'),
    bottomRight: tableColor('┘'),
    bodyLeft: tableColor('│'),
    bodyRight: tableColor('│'),
    bodyJoin: tableColor('│'),
    joinBody: tableColor('─'),
    joinLeft: tableColor('├'),
    joinRight: tableColor('┤'),
    joinJoin: tableColor('┼'),
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybWF0LXRhYmxlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZm9ybWF0LXRhYmxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBU0Esa0NBWUM7QUFyQkQsK0JBQStCO0FBQy9CLCtDQUF1QztBQUN2QywrQkFBK0I7QUFFL0I7Ozs7R0FJRztBQUNILFNBQWdCLFdBQVcsQ0FBQyxLQUFpQixFQUFFLE9BQTJCLEVBQUUsaUJBQTJCO0lBQ3JHLE9BQU8sS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUU7UUFDeEIsTUFBTSxFQUFFLHVCQUF1QjtRQUMvQixPQUFPLEVBQUUsaUJBQWlCLENBQUMsT0FBTyxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMscUJBQXFCLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7UUFDckcsa0JBQWtCLEVBQUUsQ0FBQyxJQUFJLEVBQUUsRUFBRTtZQUMzQixpR0FBaUc7WUFDakcsSUFBSSxpQkFBaUIsRUFBRSxDQUFDO2dCQUN0QixPQUFPLElBQUksR0FBRyxDQUFDLElBQUksSUFBSSxLQUFLLEtBQUssQ0FBQyxNQUFNLENBQUM7WUFDM0MsQ0FBQztZQUNELE9BQU8sQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLElBQUksS0FBSyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksV0FBVyxDQUFDLEtBQUssQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDMUYsQ0FBQztLQUNGLENBQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUNqQixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQVMsV0FBVyxDQUFDLElBQWMsRUFBRSxJQUFjO0lBQ2pELE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM3QixDQUFDO0FBRUQsU0FBUyxpQkFBaUIsQ0FBQyxNQUE0QjtJ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QUFzQztBQUN0QyxNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDO0FBRTlCLHdDQUF3QztBQUN4QyxNQUFNLHVCQUF1QixHQUFHO0lBQzlCLE9BQU8sRUFBRSxVQUFVLENBQUMsR0FBRyxDQUFDO0lBQ3hCLE9BQU8sRUFBRSxVQUFVLENBQUMsR0FBRyxDQUFDO0lBQ3hCLE9BQU8sRUFBRSxVQUFVLENBQUMsR0FBRyxDQUFDO0lBQ3hCLFFBQVEsRUFBRSxVQUFVLENBQUMsR0FBRyxDQUFDO0lBQ3pCLFVBQVUsRUFBRSxVQUFVLENBQUMsR0FBRyxDQUFDO0lBQzNCLFVBQVUsRUFBRSxVQUFVLENBQUMsR0FBRyxDQUFDO0lBQzNCLFVBQVUsRUFBRSxVQUFVLENBQUMsR0FBRyxDQUFDO0lBQzNCLFdBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxDQUFDO0lBQzVCLFFBQVEsRUFBRSxVQUFVLENBQUMsR0FBRyxDQUFDO0lBQ3pCLFNBQVMsRUFBRSxVQUFVLENBQUMsR0FBRyxDQUFDO0lBQzFCLFFBQVEsRUFBRSxVQUFVLENBQUMsR0FBRyxDQUFDO0lBQ3pCLFFBQVEsRUFBRSxVQUFVLENBQUMsR0FBRyxDQUFDO0lBQ3pCLFFBQVEsRUFBRSxVQUFVLENBQUMsR0FBRyxDQUFDO0lBQ3pCLFNBQVMsRUFBRSxVQUFVLENBQUMsR0FBRyxDQUFDO0lBQzFCLFFBQVEsRUFBRSxVQUFVLENBQUMsR0FBRyxDQUFDO0NBQzFCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgc3RyaW5nV2lkdGggZnJvbSAnc3RyaW5nLXdpZHRoJztcbmltcG9ydCAqIGFzIHRhYmxlIGZyb20gJ3RhYmxlJztcblxuLyoqXG4gKiBSZW5kZXIgYSB0d28tZGltZW5zaW9uYWwgYXJyYXkgdG8gYSB2aXN1YWxseSBhdHRyYWN0aXZlIHRhYmxlXG4gKlxuICogRmlyc3Qgcm93IGlzIGNvbnNpZGVyZWQgdGhlIHRhYmxlIGhlYWRlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFRhYmxlKGNlbGxzOiBzdHJpbmdbXVtdLCBjb2x1bW5zOiBudW1iZXIgfCB1bmRlZmluZWQsIG5vSG9yaXpvbnRhbExpbmVzPzogYm9vbGVhbik6IHN0cmluZyB7XG4gIHJldHVybiB0YWJsZS50YWJsZShjZWxscywge1xuICAgIGJvcmRlcjogVEFCTEVfQk9SREVSX0NIQVJBQ1RFUlMsXG4gICAgY29sdW1uczogYnVpbGRDb2x1bW5Db25maWcoY29sdW1ucyAhPT0gdW5kZWZpbmVkID8gY2FsY3VsYXRlQ29sdW1uV2lkdGhzKGNlbGxzLCBjb2x1bW5zKSA6IHVuZGVmaW5lZCksXG4gICAgZHJhd0hvcml6b250YWxMaW5lOiAobGluZSkgPT4ge1xuICAgICAgLy8gTnVtYmVyaW5nIGxpa2UgdGhpczogW2xpbmUgMF0gW2hlYWRlciA9IHJvd1swXV0gW2xpbmUgMV0gW3JvdyAxXSBbbGluZSAyXSBbY29udGVudCAyXSBbbGluZSAzXVxuICAgICAgaWYgKG5vSG9yaXpvbnRhbExpbmVzKSB7XG4gICAgICAgIHJldHVybiBsaW5lIDwgMiB8fCBsaW5lID09PSBjZWxscy5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gKGxpbmUgPCAyIHx8IGxpbmUgPT09IGNlbGxzLmxlbmd0aCkgfHwgbGluZUJldHdlZW4oY2VsbHNbbGluZSAtIDFdLCBjZWxsc1tsaW5lXSk7XG4gICAgfSxcbiAgfSkudHJpbVJpZ2h0KCk7XG59XG5cbi8qKlxuICogV2hldGhlciB3ZSBzaG91bGQgZHJhdyBhIGxpbmUgYmV0d2VlbiB0d28gcm93c1xuICpcbiAqIERyYXcgaG9yaXpvbnRhbCBsaW5lIGlmIDJuZCBjb2x1bW4gdmFsdWVzIGFyZSBkaWZmZXJlbnQuXG4gKi9cbmZ1bmN0aW9uIGxpbmVCZXR3ZWVuKHJvd0E6IHN0cmluZ1tdLCByb3dCOiBzdHJpbmdbXSkge1xuICByZXR1cm4gcm93QVsxXSAhPT0gcm93QlsxXTtcbn1cblxuZnVuY3Rpb24gYnVpbGRDb2x1bW5Db25maWcod2lkdGhzOiBudW1iZXJbXSB8IHVuZGVmaW5lZCk6IHsgW2luZGV4OiBudW1iZXJdOiB0YWJsZS5Db2x1bW5Vc2VyQ29uZmlnIH0gfCB1bmRlZmluZWQge1xuICBpZiAod2lkdGhzID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgcmV0OiB7IFtpbmRleDogbnVtYmVyXTogdGFibGUuQ29sdW1uVXNlckNvbmZpZyB9ID0ge307XG4gIHdpZHRocy5mb3JFYWNoKCh3aWR0aCwgaSkgPT4ge1xuICAgIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldFtpXSA9IHsgd2lkdGggfTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgY29sdW1uIHdpZHRocyBnaXZlbiBhIHRlcm1pbmFsIHdpZHRoXG4gKlxuICogV2UgZG8gdGhpcyBieSBjYWxjdWxhdGluZyBhIGZhaXIgc2hhcmUgZm9yIGV2ZXJ5IGNvbHVtbi4gRXh0cmEgd2lkdGggc21hbGxlclxuICogdGhhbiB0aGUgZmFpciBzaGFyZSBpcyBldmVubHkgZGlzdHJpYnV0ZWQgb3ZlciBhbGwgY29sdW1ucyB0aGF0IGV4Y2VlZCB0aGVpclxuICogZmFpciBzaGFyZS5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlQ29sdW1uV2lkdGhzKHJvd3M6IHN0cmluZ1tdW10sIHRlcm1pbmFsV2lkdGg6IG51bWJlcik6IG51bWJlcltdIHtcbiAgLy8gVGhlIHRlcm1pbmFsIGlzIHNvbWV0aW1lcyByZXBvcnRlZCB0byBiZSAwLiBBbHNvIGlmIHRoZSB0ZXJtaW5hbCBpcyBWRVJZIG5hcnJvdyxcbiAgLy8ganVzdCBhc3N1bWUgYSByZWFzb25hYmxlIG1pbmltdW0gc2l6ZS5cbiAgdGVybWluYWxXaWR0aCA9IE1hdGgubWF4KHRlcm1pbmFsV2lkdGgsIDQwKTtcblxuICAvLyB1c2UgJ3N0cmluZy13aWR0aCcgdG8gbm90IGNvdW50IEFOU0kgY2hhcnMgYXMgYWN0dWFsIGNoYXJhY3RlciB3aWR0aFxuICBjb25zdCBjb2x1bW5zID0gcm93c1swXS5tYXAoKF8sIGkpID0+IE1hdGgubWF4KC4uLnJvd3MubWFwKHJvdyA9PiBzdHJpbmdXaWR0aChTdHJpbmcocm93W2ldKSkpKSk7XG5cbiAgLy8gSWYgd2UgaGF2ZSBubyB0ZXJtaW5hbCB3aWR0aCwgZG8gbm90aGluZ1xuICBjb25zdCBjb250ZW50V2lkdGggPSB0ZXJtaW5hbFdpZHRoIC0gMiAtIGNvbHVtbnMubGVuZ3RoICogMztcblxuICAvLyBJZiB3ZSBkb24ndCBleGNlZWQgdGhlIHRlcm1pbmFsIHdpZHRoLCBkbyBub3RoaW5nXG4gIGlmIChzdW0oY29sdW1ucykgPD0gY29udGVudFdpZHRoKSB7XG4gICAgcmV0dXJuIGNvbHVtbnM7XG4gIH1cblxuICBjb25zdCBmYWlyU2hhcmUgPSBNYXRoLm1pbihjb250ZW50V2lkdGggLyBjb2x1bW5zLmxlbmd0aCk7XG4gIGNvbnN0IHNtYWxsQ29sdW1ucyA9IGNvbHVtbnMuZmlsdGVyKHcgPT4gdyA8IGZhaXJTaGFyZSk7XG5cbiAgbGV0IGRpc3RyaWJ1dGFibGVXaWR0aCA9IGNvbnRlbnRXaWR0aCAtIHN1bShzbWFsbENvbHVtbnMpO1xuICBjb25zdCBmYWlyRGlzdHJpYnV0YWJsZSA9IE1hdGguZmxvb3IoZGlzdHJpYnV0YWJsZVdpZHRoIC8gKGNvbHVtbnMubGVuZ3RoIC0gc21hbGxDb2x1bW5zLmxlbmd0aCkpO1xuXG4gIGNvbnN0IHJldCA9IG5ldyBBcnJheTxudW1iZXI+KCk7XG4gIGZvciAoY29uc3QgcmVxdWVzdGVkV2lkdGggb2YgY29sdW1ucykge1xuICAgIGlmIChyZXF1ZXN0ZWRXaWR0aCA8IGZhaXJTaGFyZSkge1xuICAgICAgLy8gU21hbGwgY29sdW1uIGdldHMgd2hhdCB0aGV5IHdhbnRcbiAgICAgIHJldC5wdXNoKHJlcXVlc3RlZFdpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGFzdCBjb2x1bW4gZ2V0cyBhbGwgcmVtYWluaW5nLCBvdGhlcndpc2UgZ2V0IGZhaXIgcmVkaXN0IHNoYXJlXG4gICAgICBjb25zdCB3aWR0aCA9IGRpc3RyaWJ1dGFibGVXaWR0aCA8IDIgKiBmYWlyRGlzdHJpYnV0YWJsZSA/IGRpc3RyaWJ1dGFibGVXaWR0aCA6IGZhaXJEaXN0cmlidXRhYmxlO1xuICAgICAgcmV0LnB1c2god2lkdGgpO1xuICAgICAgZGlzdHJpYnV0YWJsZVdpZHRoIC09IHdpZHRoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHN1bSh4czogbnVtYmVyW10pOiBudW1iZXIge1xuICBsZXQgdG90YWwgPSAwO1xuICBmb3IgKGNvbnN0IHggb2YgeHMpIHtcbiAgICB0b3RhbCArPSB4O1xuICB9XG4gIHJldHVybiB0b3RhbDtcbn1cblxuLy8gV2hhdCBjb2xvciB0aGUgdGFibGUgaXMgZ29pbmcgdG8gYmVcbmNvbnN0IHRhYmxlQ29sb3IgPSBjaGFsay5ncmF5O1xuXG4vLyBVbmljb2RlIHRhYmxlIGNoYXJhY3RlcnMgd2l0aCBhIGNvbG9yXG5jb25zdCBUQUJMRV9CT1JERVJfQ0hBUkFDVEVSUyA9IHtcbiAgdG9wQm9keTogdGFibGVDb2xvcign4pSAJyksXG4gIHRvcEpvaW46IHRhYmxlQ29sb3IoJ+KUrCcpLFxuICB0b3BMZWZ0OiB0YWJsZUNvbG9yKCfilIwnKSxcbiAgdG9wUmlnaHQ6IHRhYmxlQ29sb3IoJ+KUkCcpLFxuICBib3R0b21Cb2R5OiB0YWJsZUNvbG9yKCfilIAnKSxcbiAgYm90dG9tSm9pbjogdGFibGVDb2xvcign4pS0JyksXG4gIGJvdHRvbUxlZnQ6IHRhYmxlQ29sb3IoJ+KUlCcpLFxuICBib3R0b21SaWdodDogdGFibGVDb2xvcign4pSYJyksXG4gIGJvZHlMZWZ0OiB0YWJsZUNvbG9yKCfilIInKSxcbiAgYm9keVJpZ2h0OiB0YWJsZUNvbG9yKCfilIInKSxcbiAgYm9keUpvaW46IHRhYmxlQ29sb3IoJ+KUgicpLFxuICBqb2luQm9keTogdGFibGVDb2xvcign4pSAJyksXG4gIGpvaW5MZWZ0OiB0YWJsZUNvbG9yKCfilJwnKSxcbiAgam9pblJpZ2h0OiB0YWJsZUNvbG9yKCfilKQnKSxcbiAgam9pbkpvaW46IHRhYmxlQ29sb3IoJ+KUvCcpLFxufTtcbiJdfQ==