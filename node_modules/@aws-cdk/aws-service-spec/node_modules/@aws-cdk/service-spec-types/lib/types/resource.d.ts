import { Entity, Reference, Relationship } from '@cdklabs/tskb';
import { SpecDatabase } from './database';
export interface Partition extends Entity {
    readonly partition: string;
}
export type HasRegion = Relationship<Partition, Region, {
    isPrimary?: boolean;
}>;
export interface Service extends Entity {
    /**
     * The full name of the service including the group prefix, lowercased and hyphenated.
     *
     * E.g. `AWS::DynamoDB` -> `aws-dynamodb`
     *
     * @example aws-dynamodb
     */
    readonly name: string;
    /**
     * Only the service part of the name, lowercased.
     *
     * E.g. `AWS::DynamoDB` -> `dynamodb`
     *
     * @example dynamodb
     */
    readonly shortName: string;
    /**
     * The shortname of the service in capitalized form
     *
     * E.g. `AWS::DynamoDB` -> `DynamoDB`
     *
     * @example dynamodb
     */
    readonly capitalized: string;
    /**
     * The complete cloudformation style namespace of the service
     *
     * E.g. `AWS::DynamoDB`
     *
     * @example dynamodb
     */
    readonly cloudFormationNamespace: string;
}
export interface Region extends Entity {
    readonly name: string;
    readonly description?: string;
}
export interface Documentation extends Entity {
    readonly markdown: string;
}
export interface Resource extends Entity {
    readonly name: string;
    readonly cloudFormationType: string;
    /**
     * If set, this CloudFormation Transform is required by the resource
     */
    cloudFormationTransform?: string;
    documentation?: string;
    primaryIdentifier?: string[];
    readonly properties: ResourceProperties;
    readonly attributes: Record<string, Attribute>;
    readonly validations?: unknown;
    identifier?: ResourceIdentifier;
    isStateful?: boolean;
    /**
     * Information about the taggability of this resource
     *
     * Undefined if the resource is not taggable.
     */
    tagInformation?: TagInformation;
    /**
     * Whether changes to this resource need to be scrutinized
     *
     * @default ResourceScrutinyType.NONE
     */
    scrutinizable?: ResourceScrutinyType;
    /**
     * Additional paths to properties that also cause replacement.
     *
     * This is to indicate that certain property paths into this resource
     * will cause replacement; only replacements that cannot be represented
     * by tagging the property in a type definition will be included here
     * (for example, because the tagged property would be in a predefined
     * type like `tag`).
     *
     * All properties in this list should be treated as `causesReplacement: 'yes'`.
     *
     * @default -
     */
    additionalReplacementProperties?: string[][];
}
export type ResourceProperties = Record<string, Property>;
export interface TypeDefinition extends Entity {
    readonly name: string;
    documentation?: string;
    readonly properties: ResourceProperties;
    /**
     * If true, render this type even if it is unused.
     */
    mustRenderForBwCompat?: boolean;
}
export interface Property {
    /**
     * Description of the property
     */
    documentation?: string;
    /**
     * Is this property required
     *
     * @default false
     */
    required?: boolean;
    /**
     * The current type of this property
     */
    type: PropertyType;
    /**
     * An ordered list of previous types of this property in ascending order
     *
     * Does not include the current type, use `type` for this.
     */
    previousTypes?: PropertyType[];
    /**
     * A string representation the default value of this property
     *
     * This value is not directly functional; it describes how the underlying resource
     * will behave if the value is not specified.
     *
     * @default - Default unknown
     */
    defaultValue?: string;
    /**
     * Whether this property is deprecated
     *
     * @default - Not deprecated
     */
    deprecated?: Deprecation;
    /**
     * Whether changes to this property needs to be scrutinized specially
     *
     * @default PropertyScrutinyType.NONE
     */
    scrutinizable?: PropertyScrutinyType;
    /**
     * Whether the containing resource will be replaced if this property is changed
     *
     * @default 'no'
     */
    causesReplacement?: 'yes' | 'no' | 'maybe';
}
export declare class RichTypedField {
    private readonly field;
    constructor(field: Pick<Property, 'type' | 'previousTypes'>);
    types(): PropertyType[];
    /**
     * Update the type of this property with a new type
     *
     * Only if it's not in the set of types already.
     *
     * Returns true if the type was updated.
     */
    updateType(type: PropertyType): boolean;
}
export declare class RichProperty extends RichTypedField {
    constructor(property: Property);
}
export declare class RichAttribute extends RichTypedField {
    constructor(attr: Attribute);
}
export interface Attribute {
    documentation?: string;
    type: PropertyType;
    /**
     * An ordered list of previous types of this property in ascending order
     *
     * Does not include the current type, use `type` for this.
     */
    previousTypes?: PropertyType[];
}
export declare enum Deprecation {
    /**
     * Not deprecated
     */
    NONE = "NONE",
    /**
     * Warn about use
     */
    WARN = "WARN",
    /**
     * Do not emit the value at all
     *
     * (Handle properties that were incorrectly added to the spec)
     */
    IGNORE = "IGNORE"
}
export type PropertyType = PrimitiveType | DefinitionReference | BuiltinTagType | ArrayType<PropertyType> | MapType<PropertyType> | TypeUnion<PropertyType>;
export type PrimitiveType = StringType | NumberType | IntegerType | BooleanType | JsonType | DateTimeType | NullType | BuiltinTagType;
export declare function isCollectionType(x: PropertyType): x is ArrayType<any> | MapType<any>;
export interface TagInformation {
    /**
     * Name of the property that holds the tags
     */
    readonly tagPropertyName: string;
    /**
     * Used to instruct cdk.TagManager how to handle tags
     */
    readonly variant: TagVariant;
}
export type TagVariant = 'standard' | 'asg' | 'map';
export interface StringType {
    readonly type: 'string';
}
export interface BuiltinTagType {
    readonly type: 'tag';
}
export interface NumberType {
    readonly type: 'number';
}
export interface IntegerType {
    readonly type: 'integer';
}
export interface BooleanType {
    readonly type: 'boolean';
}
export interface JsonType {
    readonly type: 'json';
}
export interface NullType {
    readonly type: 'null';
}
export interface DateTimeType {
    readonly type: 'date-time';
}
/**
 * The "legacy" tag type (used in the old resource spec)
 */
export interface BuiltinTagType {
    readonly type: 'tag';
}
export interface DefinitionReference {
    readonly type: 'ref';
    readonly reference: Reference<TypeDefinition>;
}
export interface ArrayType<E> {
    readonly type: 'array';
    readonly element: E;
}
export interface MapType<E> {
    readonly type: 'map';
    readonly element: E;
}
export interface TypeUnion<E> {
    readonly type: 'union';
    readonly types: E[];
}
export type HasResource = Relationship<Service, Resource>;
export type RegionHasResource = Relationship<Region, Resource>;
export type RegionHasService = Relationship<Region, Service>;
export type ResourceDoc = Relationship<Resource, Documentation>;
export type ServiceInRegion = Relationship<Region, Service>;
export type ResourceInRegion = Relationship<Region, Resource>;
export type UsesType = Relationship<Resource, TypeDefinition>;
export interface ResourceIdentifier extends Entity {
    readonly arnTemplate?: string;
    readonly primaryIdentifier?: string[];
}
/**
 * Mark a resource as a resource that needs additional scrutiy when added, removed or changed
 *
 * Used to mark resources that represent security policies.
 */
export declare enum ResourceScrutinyType {
    /**
     * No additional scrutiny
     */
    None = "None",
    /**
     * An externally attached policy document to a resource
     *
     * (Common for SQS, SNS, S3, ...)
     */
    ResourcePolicyResource = "ResourcePolicyResource",
    /**
     * This is an IAM policy on an identity resource
     *
     * (Basically saying: this is AWS::IAM::Policy)
     */
    IdentityPolicyResource = "IdentityPolicyResource",
    /**
     * This is a Lambda Permission policy
     */
    LambdaPermission = "LambdaPermission",
    /**
     * An ingress rule object
     */
    IngressRuleResource = "IngressRuleResource",
    /**
     * A set of egress rules
     */
    EgressRuleResource = "EgressRuleResource",
    /**
     * AWS::SSO::Assignment
     *
     * IAM Identity Center (formerly known as SSO)
     */
    SsoAssignmentResource = "SsoAssignmentResource",
    /**
     * AWS::SSO::InstanceAccessControlAttributeConfiguration
     *
     * IAM Identity Center (formerly known as SSO)
     */
    SsoInstanceACAConfigResource = "SsoInstanceACAConfigResource",
    /**
     * AWS::SSO::PermissionSet
     *
     * IAM Identity Center (formerly known as SSO)
     */
    SsoPermissionSet = "SsoPermissionSet"
}
/**
 * Mark a property as a property that needs additional scrutiny when it changes
 *
 * Used to mark sensitive properties that have security-related implications.
 */
export declare enum PropertyScrutinyType {
    /**
     * No additional scrutiny
     */
    None = "None",
    /**
     * This is an IAM policy directly on a resource
     */
    InlineResourcePolicy = "InlineResourcePolicy",
    /**
     * Either an AssumeRolePolicyDocument or a dictionary of policy documents
     */
    InlineIdentityPolicies = "InlineIdentityPolicies",
    /**
     * A list of managed policies (on an identity resource)
     */
    ManagedPolicies = "ManagedPolicies",
    /**
     * A set of ingress rules (on a security group)
     */
    IngressRules = "IngressRules",
    /**
     * A set of egress rules (on a security group)
     */
    EgressRules = "EgressRules"
}
export declare class RichPropertyType {
    private readonly type;
    constructor(type: PropertyType);
    equals(rhs: PropertyType): boolean;
    /**
     * Whether the current type is JavaScript-equal to the RHS type
     *
     * Same as normal equality, but consider `integer` and `number` the same types.
     */
    javascriptEquals(rhs: PropertyType): boolean;
    /**
     * Whether the current type is assignable to the RHS type.
     *
     * This is means every type member of the LHS must be present in the RHS type
     */
    assignableTo(rhs: PropertyType): boolean;
    /**
     * Return a version of this type, but with all type unions in a regularized order
     */
    normalize(db: SpecDatabase): RichPropertyType;
    stringify(db: SpecDatabase, withId?: boolean): string;
    /**
     * Return a sortable key based on this type
     *
     * If a database is given, type definitions will be sorted based on type name,
     * otherwise on identifier
     */
    sortKey(db?: SpecDatabase): string[];
}
