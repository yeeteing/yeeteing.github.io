import { parseXmlBody as parseBody, parseXmlErrorBody as parseErrorBody } from "@aws-sdk/core";
import { HttpRequest as __HttpRequest } from "@smithy/protocol-http";
import { collectBody, decorateServiceException as __decorateServiceException, expectNonNull as __expectNonNull, expectString as __expectString, extendedEncodeURIComponent as __extendedEncodeURIComponent, getArrayIfSingleItem as __getArrayIfSingleItem, parseBoolean as __parseBoolean, parseRfc3339DateTimeWithOffset as __parseRfc3339DateTimeWithOffset, strictParseFloat as __strictParseFloat, strictParseInt32 as __strictParseInt32, strictParseLong as __strictParseLong, withBaseException, } from "@smithy/smithy-client";
import { ElasticLoadBalancingV2ServiceException as __BaseException } from "../models/ElasticLoadBalancingV2ServiceException";
import { AllocationIdNotFoundException, ALPNPolicyNotSupportedException, AvailabilityZoneNotSupportedException, CaCertificatesBundleNotFoundException, CapacityDecreaseRequestsLimitExceededException, CapacityReservationPendingException, CapacityUnitsLimitExceededException, CertificateNotFoundException, DeleteAssociationSameAccountException, DuplicateListenerException, DuplicateLoadBalancerNameException, DuplicateTagKeysException, DuplicateTargetGroupNameException, DuplicateTrustStoreNameException, HealthUnavailableException, IncompatibleProtocolsException, InsufficientCapacityException, InvalidCaCertificatesBundleException, InvalidConfigurationRequestException, InvalidLoadBalancerActionException, InvalidRevocationContentException, InvalidSchemeException, InvalidSecurityGroupException, InvalidSubnetException, InvalidTargetException, ListenerNotFoundException, LoadBalancerNotFoundException, OperationNotPermittedException, PriorityInUseException, PriorRequestNotCompleteException, ResourceInUseException, ResourceNotFoundException, RevocationContentNotFoundException, RevocationIdNotFoundException, RuleNotFoundException, SSLPolicyNotFoundException, SubnetNotFoundException, TargetGroupAssociationLimitException, TargetGroupNotFoundException, TooManyActionsException, TooManyCertificatesException, TooManyListenersException, TooManyLoadBalancersException, TooManyRegistrationsForTargetIdException, TooManyRulesException, TooManyTagsException, TooManyTargetGroupsException, TooManyTargetsException, TooManyTrustStoreRevocationEntriesException, TooManyTrustStoresException, TooManyUniqueTargetGroupsPerLoadBalancerException, TrustStoreAssociationNotFoundException, TrustStoreInUseException, TrustStoreNotFoundException, TrustStoreNotReadyException, UnsupportedProtocolException, } from "../models/models_0";
export const se_AddListenerCertificatesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AddListenerCertificatesInput(input, context),
        [_A]: _ALC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AddTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AddTagsInput(input, context),
        [_A]: _AT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AddTrustStoreRevocationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AddTrustStoreRevocationsInput(input, context),
        [_A]: _ATSR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateListenerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateListenerInput(input, context),
        [_A]: _CL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLoadBalancerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateLoadBalancerInput(input, context),
        [_A]: _CLB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateRuleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateRuleInput(input, context),
        [_A]: _CR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateTargetGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateTargetGroupInput(input, context),
        [_A]: _CTG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateTrustStoreCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateTrustStoreInput(input, context),
        [_A]: _CTS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteListenerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteListenerInput(input, context),
        [_A]: _DL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteLoadBalancerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteLoadBalancerInput(input, context),
        [_A]: _DLB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteRuleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteRuleInput(input, context),
        [_A]: _DR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteSharedTrustStoreAssociationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteSharedTrustStoreAssociationInput(input, context),
        [_A]: _DSTSA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteTargetGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteTargetGroupInput(input, context),
        [_A]: _DTG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteTrustStoreCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteTrustStoreInput(input, context),
        [_A]: _DTS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeregisterTargetsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeregisterTargetsInput(input, context),
        [_A]: _DT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAccountLimitsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAccountLimitsInput(input, context),
        [_A]: _DAL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeCapacityReservationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeCapacityReservationInput(input, context),
        [_A]: _DCR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeListenerAttributesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeListenerAttributesInput(input, context),
        [_A]: _DLA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeListenerCertificatesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeListenerCertificatesInput(input, context),
        [_A]: _DLC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeListenersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeListenersInput(input, context),
        [_A]: _DLe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLoadBalancerAttributesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeLoadBalancerAttributesInput(input, context),
        [_A]: _DLBA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLoadBalancersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeLoadBalancersInput(input, context),
        [_A]: _DLBe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeRulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeRulesInput(input, context),
        [_A]: _DRe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeSSLPoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeSSLPoliciesInput(input, context),
        [_A]: _DSSLP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTagsInput(input, context),
        [_A]: _DTe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTargetGroupAttributesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTargetGroupAttributesInput(input, context),
        [_A]: _DTGA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTargetGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTargetGroupsInput(input, context),
        [_A]: _DTGe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTargetHealthCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTargetHealthInput(input, context),
        [_A]: _DTH,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTrustStoreAssociationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTrustStoreAssociationsInput(input, context),
        [_A]: _DTSA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTrustStoreRevocationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTrustStoreRevocationsInput(input, context),
        [_A]: _DTSR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTrustStoresCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTrustStoresInput(input, context),
        [_A]: _DTSe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetResourcePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetResourcePolicyInput(input, context),
        [_A]: _GRP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetTrustStoreCaCertificatesBundleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetTrustStoreCaCertificatesBundleInput(input, context),
        [_A]: _GTSCCB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetTrustStoreRevocationContentCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetTrustStoreRevocationContentInput(input, context),
        [_A]: _GTSRC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyCapacityReservationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyCapacityReservationInput(input, context),
        [_A]: _MCR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyIpPoolsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyIpPoolsInput(input, context),
        [_A]: _MIP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyListenerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyListenerInput(input, context),
        [_A]: _ML,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyListenerAttributesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyListenerAttributesInput(input, context),
        [_A]: _MLA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyLoadBalancerAttributesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyLoadBalancerAttributesInput(input, context),
        [_A]: _MLBA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyRuleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyRuleInput(input, context),
        [_A]: _MR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyTargetGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyTargetGroupInput(input, context),
        [_A]: _MTG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyTargetGroupAttributesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyTargetGroupAttributesInput(input, context),
        [_A]: _MTGA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyTrustStoreCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyTrustStoreInput(input, context),
        [_A]: _MTS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RegisterTargetsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RegisterTargetsInput(input, context),
        [_A]: _RT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RemoveListenerCertificatesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RemoveListenerCertificatesInput(input, context),
        [_A]: _RLC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RemoveTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RemoveTagsInput(input, context),
        [_A]: _RTe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RemoveTrustStoreRevocationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RemoveTrustStoreRevocationsInput(input, context),
        [_A]: _RTSR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SetIpAddressTypeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetIpAddressTypeInput(input, context),
        [_A]: _SIAT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SetRulePrioritiesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetRulePrioritiesInput(input, context),
        [_A]: _SRP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SetSecurityGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetSecurityGroupsInput(input, context),
        [_A]: _SSG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SetSubnetsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetSubnetsInput(input, context),
        [_A]: _SS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const de_AddListenerCertificatesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AddListenerCertificatesOutput(data.AddListenerCertificatesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AddTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AddTagsOutput(data.AddTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AddTrustStoreRevocationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AddTrustStoreRevocationsOutput(data.AddTrustStoreRevocationsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateListenerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateListenerOutput(data.CreateListenerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateLoadBalancerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateLoadBalancerOutput(data.CreateLoadBalancerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateRuleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateRuleOutput(data.CreateRuleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateTargetGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateTargetGroupOutput(data.CreateTargetGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateTrustStoreCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateTrustStoreOutput(data.CreateTrustStoreResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteListenerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteListenerOutput(data.DeleteListenerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteLoadBalancerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteLoadBalancerOutput(data.DeleteLoadBalancerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteRuleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteRuleOutput(data.DeleteRuleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteSharedTrustStoreAssociationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteSharedTrustStoreAssociationOutput(data.DeleteSharedTrustStoreAssociationResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteTargetGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteTargetGroupOutput(data.DeleteTargetGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteTrustStoreCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteTrustStoreOutput(data.DeleteTrustStoreResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeregisterTargetsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeregisterTargetsOutput(data.DeregisterTargetsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeAccountLimitsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAccountLimitsOutput(data.DescribeAccountLimitsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeCapacityReservationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeCapacityReservationOutput(data.DescribeCapacityReservationResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeListenerAttributesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeListenerAttributesOutput(data.DescribeListenerAttributesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeListenerCertificatesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeListenerCertificatesOutput(data.DescribeListenerCertificatesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeListenersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeListenersOutput(data.DescribeListenersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLoadBalancerAttributesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLoadBalancerAttributesOutput(data.DescribeLoadBalancerAttributesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLoadBalancersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLoadBalancersOutput(data.DescribeLoadBalancersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeRulesOutput(data.DescribeRulesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeSSLPoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeSSLPoliciesOutput(data.DescribeSSLPoliciesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTagsOutput(data.DescribeTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTargetGroupAttributesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTargetGroupAttributesOutput(data.DescribeTargetGroupAttributesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTargetGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTargetGroupsOutput(data.DescribeTargetGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTargetHealthCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTargetHealthOutput(data.DescribeTargetHealthResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTrustStoreAssociationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTrustStoreAssociationsOutput(data.DescribeTrustStoreAssociationsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTrustStoreRevocationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTrustStoreRevocationsOutput(data.DescribeTrustStoreRevocationsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTrustStoresCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTrustStoresOutput(data.DescribeTrustStoresResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetResourcePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetResourcePolicyOutput(data.GetResourcePolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetTrustStoreCaCertificatesBundleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetTrustStoreCaCertificatesBundleOutput(data.GetTrustStoreCaCertificatesBundleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetTrustStoreRevocationContentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetTrustStoreRevocationContentOutput(data.GetTrustStoreRevocationContentResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyCapacityReservationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyCapacityReservationOutput(data.ModifyCapacityReservationResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyIpPoolsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyIpPoolsOutput(data.ModifyIpPoolsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyListenerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyListenerOutput(data.ModifyListenerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyListenerAttributesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyListenerAttributesOutput(data.ModifyListenerAttributesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyLoadBalancerAttributesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyLoadBalancerAttributesOutput(data.ModifyLoadBalancerAttributesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyRuleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyRuleOutput(data.ModifyRuleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyTargetGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyTargetGroupOutput(data.ModifyTargetGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyTargetGroupAttributesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyTargetGroupAttributesOutput(data.ModifyTargetGroupAttributesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyTrustStoreCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyTrustStoreOutput(data.ModifyTrustStoreResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RegisterTargetsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RegisterTargetsOutput(data.RegisterTargetsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RemoveListenerCertificatesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RemoveListenerCertificatesOutput(data.RemoveListenerCertificatesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RemoveTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RemoveTagsOutput(data.RemoveTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RemoveTrustStoreRevocationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RemoveTrustStoreRevocationsOutput(data.RemoveTrustStoreRevocationsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_SetIpAddressTypeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SetIpAddressTypeOutput(data.SetIpAddressTypeResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_SetRulePrioritiesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SetRulePrioritiesOutput(data.SetRulePrioritiesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_SetSecurityGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SetSecurityGroupsOutput(data.SetSecurityGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_SetSubnetsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SetSubnetsOutput(data.SetSubnetsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateNotFound":
        case "com.amazonaws.elasticloadbalancingv2#CertificateNotFoundException":
            throw await de_CertificateNotFoundExceptionRes(parsedOutput, context);
        case "ListenerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#ListenerNotFoundException":
            throw await de_ListenerNotFoundExceptionRes(parsedOutput, context);
        case "TooManyCertificates":
        case "com.amazonaws.elasticloadbalancingv2#TooManyCertificatesException":
            throw await de_TooManyCertificatesExceptionRes(parsedOutput, context);
        case "DuplicateTagKeys":
        case "com.amazonaws.elasticloadbalancingv2#DuplicateTagKeysException":
            throw await de_DuplicateTagKeysExceptionRes(parsedOutput, context);
        case "LoadBalancerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#LoadBalancerNotFoundException":
            throw await de_LoadBalancerNotFoundExceptionRes(parsedOutput, context);
        case "RuleNotFound":
        case "com.amazonaws.elasticloadbalancingv2#RuleNotFoundException":
            throw await de_RuleNotFoundExceptionRes(parsedOutput, context);
        case "TargetGroupNotFound":
        case "com.amazonaws.elasticloadbalancingv2#TargetGroupNotFoundException":
            throw await de_TargetGroupNotFoundExceptionRes(parsedOutput, context);
        case "TooManyTags":
        case "com.amazonaws.elasticloadbalancingv2#TooManyTagsException":
            throw await de_TooManyTagsExceptionRes(parsedOutput, context);
        case "TrustStoreNotFound":
        case "com.amazonaws.elasticloadbalancingv2#TrustStoreNotFoundException":
            throw await de_TrustStoreNotFoundExceptionRes(parsedOutput, context);
        case "InvalidRevocationContent":
        case "com.amazonaws.elasticloadbalancingv2#InvalidRevocationContentException":
            throw await de_InvalidRevocationContentExceptionRes(parsedOutput, context);
        case "RevocationContentNotFound":
        case "com.amazonaws.elasticloadbalancingv2#RevocationContentNotFoundException":
            throw await de_RevocationContentNotFoundExceptionRes(parsedOutput, context);
        case "TooManyTrustStoreRevocationEntries":
        case "com.amazonaws.elasticloadbalancingv2#TooManyTrustStoreRevocationEntriesException":
            throw await de_TooManyTrustStoreRevocationEntriesExceptionRes(parsedOutput, context);
        case "ALPNPolicyNotFound":
        case "com.amazonaws.elasticloadbalancingv2#ALPNPolicyNotSupportedException":
            throw await de_ALPNPolicyNotSupportedExceptionRes(parsedOutput, context);
        case "DuplicateListener":
        case "com.amazonaws.elasticloadbalancingv2#DuplicateListenerException":
            throw await de_DuplicateListenerExceptionRes(parsedOutput, context);
        case "IncompatibleProtocols":
        case "com.amazonaws.elasticloadbalancingv2#IncompatibleProtocolsException":
            throw await de_IncompatibleProtocolsExceptionRes(parsedOutput, context);
        case "InvalidConfigurationRequest":
        case "com.amazonaws.elasticloadbalancingv2#InvalidConfigurationRequestException":
            throw await de_InvalidConfigurationRequestExceptionRes(parsedOutput, context);
        case "InvalidLoadBalancerAction":
        case "com.amazonaws.elasticloadbalancingv2#InvalidLoadBalancerActionException":
            throw await de_InvalidLoadBalancerActionExceptionRes(parsedOutput, context);
        case "SSLPolicyNotFound":
        case "com.amazonaws.elasticloadbalancingv2#SSLPolicyNotFoundException":
            throw await de_SSLPolicyNotFoundExceptionRes(parsedOutput, context);
        case "TargetGroupAssociationLimit":
        case "com.amazonaws.elasticloadbalancingv2#TargetGroupAssociationLimitException":
            throw await de_TargetGroupAssociationLimitExceptionRes(parsedOutput, context);
        case "TooManyActions":
        case "com.amazonaws.elasticloadbalancingv2#TooManyActionsException":
            throw await de_TooManyActionsExceptionRes(parsedOutput, context);
        case "TooManyListeners":
        case "com.amazonaws.elasticloadbalancingv2#TooManyListenersException":
            throw await de_TooManyListenersExceptionRes(parsedOutput, context);
        case "TooManyRegistrationsForTargetId":
        case "com.amazonaws.elasticloadbalancingv2#TooManyRegistrationsForTargetIdException":
            throw await de_TooManyRegistrationsForTargetIdExceptionRes(parsedOutput, context);
        case "TooManyTargets":
        case "com.amazonaws.elasticloadbalancingv2#TooManyTargetsException":
            throw await de_TooManyTargetsExceptionRes(parsedOutput, context);
        case "TooManyUniqueTargetGroupsPerLoadBalancer":
        case "com.amazonaws.elasticloadbalancingv2#TooManyUniqueTargetGroupsPerLoadBalancerException":
            throw await de_TooManyUniqueTargetGroupsPerLoadBalancerExceptionRes(parsedOutput, context);
        case "TrustStoreNotReady":
        case "com.amazonaws.elasticloadbalancingv2#TrustStoreNotReadyException":
            throw await de_TrustStoreNotReadyExceptionRes(parsedOutput, context);
        case "UnsupportedProtocol":
        case "com.amazonaws.elasticloadbalancingv2#UnsupportedProtocolException":
            throw await de_UnsupportedProtocolExceptionRes(parsedOutput, context);
        case "AllocationIdNotFound":
        case "com.amazonaws.elasticloadbalancingv2#AllocationIdNotFoundException":
            throw await de_AllocationIdNotFoundExceptionRes(parsedOutput, context);
        case "AvailabilityZoneNotSupported":
        case "com.amazonaws.elasticloadbalancingv2#AvailabilityZoneNotSupportedException":
            throw await de_AvailabilityZoneNotSupportedExceptionRes(parsedOutput, context);
        case "DuplicateLoadBalancerName":
        case "com.amazonaws.elasticloadbalancingv2#DuplicateLoadBalancerNameException":
            throw await de_DuplicateLoadBalancerNameExceptionRes(parsedOutput, context);
        case "InvalidScheme":
        case "com.amazonaws.elasticloadbalancingv2#InvalidSchemeException":
            throw await de_InvalidSchemeExceptionRes(parsedOutput, context);
        case "InvalidSecurityGroup":
        case "com.amazonaws.elasticloadbalancingv2#InvalidSecurityGroupException":
            throw await de_InvalidSecurityGroupExceptionRes(parsedOutput, context);
        case "InvalidSubnet":
        case "com.amazonaws.elasticloadbalancingv2#InvalidSubnetException":
            throw await de_InvalidSubnetExceptionRes(parsedOutput, context);
        case "OperationNotPermitted":
        case "com.amazonaws.elasticloadbalancingv2#OperationNotPermittedException":
            throw await de_OperationNotPermittedExceptionRes(parsedOutput, context);
        case "ResourceInUse":
        case "com.amazonaws.elasticloadbalancingv2#ResourceInUseException":
            throw await de_ResourceInUseExceptionRes(parsedOutput, context);
        case "SubnetNotFound":
        case "com.amazonaws.elasticloadbalancingv2#SubnetNotFoundException":
            throw await de_SubnetNotFoundExceptionRes(parsedOutput, context);
        case "TooManyLoadBalancers":
        case "com.amazonaws.elasticloadbalancingv2#TooManyLoadBalancersException":
            throw await de_TooManyLoadBalancersExceptionRes(parsedOutput, context);
        case "PriorityInUse":
        case "com.amazonaws.elasticloadbalancingv2#PriorityInUseException":
            throw await de_PriorityInUseExceptionRes(parsedOutput, context);
        case "TooManyRules":
        case "com.amazonaws.elasticloadbalancingv2#TooManyRulesException":
            throw await de_TooManyRulesExceptionRes(parsedOutput, context);
        case "TooManyTargetGroups":
        case "com.amazonaws.elasticloadbalancingv2#TooManyTargetGroupsException":
            throw await de_TooManyTargetGroupsExceptionRes(parsedOutput, context);
        case "DuplicateTargetGroupName":
        case "com.amazonaws.elasticloadbalancingv2#DuplicateTargetGroupNameException":
            throw await de_DuplicateTargetGroupNameExceptionRes(parsedOutput, context);
        case "CaCertificatesBundleNotFound":
        case "com.amazonaws.elasticloadbalancingv2#CaCertificatesBundleNotFoundException":
            throw await de_CaCertificatesBundleNotFoundExceptionRes(parsedOutput, context);
        case "DuplicateTrustStoreName":
        case "com.amazonaws.elasticloadbalancingv2#DuplicateTrustStoreNameException":
            throw await de_DuplicateTrustStoreNameExceptionRes(parsedOutput, context);
        case "InvalidCaCertificatesBundle":
        case "com.amazonaws.elasticloadbalancingv2#InvalidCaCertificatesBundleException":
            throw await de_InvalidCaCertificatesBundleExceptionRes(parsedOutput, context);
        case "TooManyTrustStores":
        case "com.amazonaws.elasticloadbalancingv2#TooManyTrustStoresException":
            throw await de_TooManyTrustStoresExceptionRes(parsedOutput, context);
        case "AssociationNotFound":
        case "com.amazonaws.elasticloadbalancingv2#TrustStoreAssociationNotFoundException":
            throw await de_TrustStoreAssociationNotFoundExceptionRes(parsedOutput, context);
        case "DeleteAssociationSameAccount":
        case "com.amazonaws.elasticloadbalancingv2#DeleteAssociationSameAccountException":
            throw await de_DeleteAssociationSameAccountExceptionRes(parsedOutput, context);
        case "TrustStoreInUse":
        case "com.amazonaws.elasticloadbalancingv2#TrustStoreInUseException":
            throw await de_TrustStoreInUseExceptionRes(parsedOutput, context);
        case "InvalidTarget":
        case "com.amazonaws.elasticloadbalancingv2#InvalidTargetException":
            throw await de_InvalidTargetExceptionRes(parsedOutput, context);
        case "HealthUnavailable":
        case "com.amazonaws.elasticloadbalancingv2#HealthUnavailableException":
            throw await de_HealthUnavailableExceptionRes(parsedOutput, context);
        case "RevocationIdNotFound":
        case "com.amazonaws.elasticloadbalancingv2#RevocationIdNotFoundException":
            throw await de_RevocationIdNotFoundExceptionRes(parsedOutput, context);
        case "ResourceNotFound":
        case "com.amazonaws.elasticloadbalancingv2#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "CapacityDecreaseRequestLimitExceeded":
        case "com.amazonaws.elasticloadbalancingv2#CapacityDecreaseRequestsLimitExceededException":
            throw await de_CapacityDecreaseRequestsLimitExceededExceptionRes(parsedOutput, context);
        case "CapacityReservationPending":
        case "com.amazonaws.elasticloadbalancingv2#CapacityReservationPendingException":
            throw await de_CapacityReservationPendingExceptionRes(parsedOutput, context);
        case "CapacityUnitsLimitExceeded":
        case "com.amazonaws.elasticloadbalancingv2#CapacityUnitsLimitExceededException":
            throw await de_CapacityUnitsLimitExceededExceptionRes(parsedOutput, context);
        case "InsufficientCapacity":
        case "com.amazonaws.elasticloadbalancingv2#InsufficientCapacityException":
            throw await de_InsufficientCapacityExceptionRes(parsedOutput, context);
        case "PriorRequestNotComplete":
        case "com.amazonaws.elasticloadbalancingv2#PriorRequestNotCompleteException":
            throw await de_PriorRequestNotCompleteExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_AllocationIdNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AllocationIdNotFoundException(body.Error, context);
    const exception = new AllocationIdNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ALPNPolicyNotSupportedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ALPNPolicyNotSupportedException(body.Error, context);
    const exception = new ALPNPolicyNotSupportedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_AvailabilityZoneNotSupportedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AvailabilityZoneNotSupportedException(body.Error, context);
    const exception = new AvailabilityZoneNotSupportedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CaCertificatesBundleNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CaCertificatesBundleNotFoundException(body.Error, context);
    const exception = new CaCertificatesBundleNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CapacityDecreaseRequestsLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CapacityDecreaseRequestsLimitExceededException(body.Error, context);
    const exception = new CapacityDecreaseRequestsLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CapacityReservationPendingExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CapacityReservationPendingException(body.Error, context);
    const exception = new CapacityReservationPendingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CapacityUnitsLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CapacityUnitsLimitExceededException(body.Error, context);
    const exception = new CapacityUnitsLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CertificateNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CertificateNotFoundException(body.Error, context);
    const exception = new CertificateNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DeleteAssociationSameAccountExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DeleteAssociationSameAccountException(body.Error, context);
    const exception = new DeleteAssociationSameAccountException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DuplicateListenerExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DuplicateListenerException(body.Error, context);
    const exception = new DuplicateListenerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DuplicateLoadBalancerNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DuplicateLoadBalancerNameException(body.Error, context);
    const exception = new DuplicateLoadBalancerNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DuplicateTagKeysExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DuplicateTagKeysException(body.Error, context);
    const exception = new DuplicateTagKeysException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DuplicateTargetGroupNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DuplicateTargetGroupNameException(body.Error, context);
    const exception = new DuplicateTargetGroupNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DuplicateTrustStoreNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DuplicateTrustStoreNameException(body.Error, context);
    const exception = new DuplicateTrustStoreNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_HealthUnavailableExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_HealthUnavailableException(body.Error, context);
    const exception = new HealthUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_IncompatibleProtocolsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_IncompatibleProtocolsException(body.Error, context);
    const exception = new IncompatibleProtocolsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InsufficientCapacityExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InsufficientCapacityException(body.Error, context);
    const exception = new InsufficientCapacityException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidCaCertificatesBundleExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidCaCertificatesBundleException(body.Error, context);
    const exception = new InvalidCaCertificatesBundleException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidConfigurationRequestExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidConfigurationRequestException(body.Error, context);
    const exception = new InvalidConfigurationRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidLoadBalancerActionExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidLoadBalancerActionException(body.Error, context);
    const exception = new InvalidLoadBalancerActionException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidRevocationContentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidRevocationContentException(body.Error, context);
    const exception = new InvalidRevocationContentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidSchemeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidSchemeException(body.Error, context);
    const exception = new InvalidSchemeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidSecurityGroupExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidSecurityGroupException(body.Error, context);
    const exception = new InvalidSecurityGroupException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidSubnetExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidSubnetException(body.Error, context);
    const exception = new InvalidSubnetException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidTargetExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidTargetException(body.Error, context);
    const exception = new InvalidTargetException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ListenerNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ListenerNotFoundException(body.Error, context);
    const exception = new ListenerNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_LoadBalancerNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_LoadBalancerNotFoundException(body.Error, context);
    const exception = new LoadBalancerNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_OperationNotPermittedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_OperationNotPermittedException(body.Error, context);
    const exception = new OperationNotPermittedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_PriorityInUseExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_PriorityInUseException(body.Error, context);
    const exception = new PriorityInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_PriorRequestNotCompleteExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_PriorRequestNotCompleteException(body.Error, context);
    const exception = new PriorRequestNotCompleteException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceInUseExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceInUseException(body.Error, context);
    const exception = new ResourceInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceNotFoundException(body.Error, context);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_RevocationContentNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_RevocationContentNotFoundException(body.Error, context);
    const exception = new RevocationContentNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_RevocationIdNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_RevocationIdNotFoundException(body.Error, context);
    const exception = new RevocationIdNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_RuleNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_RuleNotFoundException(body.Error, context);
    const exception = new RuleNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SSLPolicyNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SSLPolicyNotFoundException(body.Error, context);
    const exception = new SSLPolicyNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SubnetNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SubnetNotFoundException(body.Error, context);
    const exception = new SubnetNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TargetGroupAssociationLimitExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TargetGroupAssociationLimitException(body.Error, context);
    const exception = new TargetGroupAssociationLimitException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TargetGroupNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TargetGroupNotFoundException(body.Error, context);
    const exception = new TargetGroupNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TooManyActionsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyActionsException(body.Error, context);
    const exception = new TooManyActionsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TooManyCertificatesExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyCertificatesException(body.Error, context);
    const exception = new TooManyCertificatesException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TooManyListenersExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyListenersException(body.Error, context);
    const exception = new TooManyListenersException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TooManyLoadBalancersExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyLoadBalancersException(body.Error, context);
    const exception = new TooManyLoadBalancersException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TooManyRegistrationsForTargetIdExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyRegistrationsForTargetIdException(body.Error, context);
    const exception = new TooManyRegistrationsForTargetIdException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TooManyRulesExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyRulesException(body.Error, context);
    const exception = new TooManyRulesException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TooManyTagsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyTagsException(body.Error, context);
    const exception = new TooManyTagsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TooManyTargetGroupsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyTargetGroupsException(body.Error, context);
    const exception = new TooManyTargetGroupsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TooManyTargetsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyTargetsException(body.Error, context);
    const exception = new TooManyTargetsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TooManyTrustStoreRevocationEntriesExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyTrustStoreRevocationEntriesException(body.Error, context);
    const exception = new TooManyTrustStoreRevocationEntriesException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TooManyTrustStoresExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyTrustStoresException(body.Error, context);
    const exception = new TooManyTrustStoresException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TooManyUniqueTargetGroupsPerLoadBalancerExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyUniqueTargetGroupsPerLoadBalancerException(body.Error, context);
    const exception = new TooManyUniqueTargetGroupsPerLoadBalancerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TrustStoreAssociationNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TrustStoreAssociationNotFoundException(body.Error, context);
    const exception = new TrustStoreAssociationNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TrustStoreInUseExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TrustStoreInUseException(body.Error, context);
    const exception = new TrustStoreInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TrustStoreNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TrustStoreNotFoundException(body.Error, context);
    const exception = new TrustStoreNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TrustStoreNotReadyExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TrustStoreNotReadyException(body.Error, context);
    const exception = new TrustStoreNotReadyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UnsupportedProtocolExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UnsupportedProtocolException(body.Error, context);
    const exception = new UnsupportedProtocolException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const se_Action = (input, context) => {
    const entries = {};
    if (input[_T] != null) {
        entries[_T] = input[_T];
    }
    if (input[_TGA] != null) {
        entries[_TGA] = input[_TGA];
    }
    if (input[_AOC] != null) {
        const memberEntries = se_AuthenticateOidcActionConfig(input[_AOC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AuthenticateOidcConfig.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ACC] != null) {
        const memberEntries = se_AuthenticateCognitoActionConfig(input[_ACC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AuthenticateCognitoConfig.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_O] != null) {
        entries[_O] = input[_O];
    }
    if (input[_RC] != null) {
        const memberEntries = se_RedirectActionConfig(input[_RC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RedirectConfig.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_FRC] != null) {
        const memberEntries = se_FixedResponseActionConfig(input[_FRC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `FixedResponseConfig.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_FC] != null) {
        const memberEntries = se_ForwardActionConfig(input[_FC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ForwardConfig.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_Actions = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Action(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_AddListenerCertificatesInput = (input, context) => {
    const entries = {};
    if (input[_LA] != null) {
        entries[_LA] = input[_LA];
    }
    if (input[_C] != null) {
        const memberEntries = se_CertificateList(input[_C], context);
        if (input[_C]?.length === 0) {
            entries.Certificates = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Certificates.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AddTagsInput = (input, context) => {
    const entries = {};
    if (input[_RA] != null) {
        const memberEntries = se_ResourceArns(input[_RA], context);
        if (input[_RA]?.length === 0) {
            entries.ResourceArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ResourceArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Ta] != null) {
        const memberEntries = se_TagList(input[_Ta], context);
        if (input[_Ta]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AddTrustStoreRevocationsInput = (input, context) => {
    const entries = {};
    if (input[_TSA] != null) {
        entries[_TSA] = input[_TSA];
    }
    if (input[_RCe] != null) {
        const memberEntries = se_RevocationContents(input[_RCe], context);
        if (input[_RCe]?.length === 0) {
            entries.RevocationContents = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RevocationContents.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AlpnPolicyName = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AuthenticateCognitoActionAuthenticationRequestExtraParams = (input, context) => {
    const entries = {};
    let counter = 1;
    Object.keys(input)
        .filter((key) => input[key] != null)
        .forEach((key) => {
        entries[`entry.${counter}.key`] = key;
        entries[`entry.${counter}.value`] = input[key];
        counter++;
    });
    return entries;
};
const se_AuthenticateCognitoActionConfig = (input, context) => {
    const entries = {};
    if (input[_UPA] != null) {
        entries[_UPA] = input[_UPA];
    }
    if (input[_UPCI] != null) {
        entries[_UPCI] = input[_UPCI];
    }
    if (input[_UPD] != null) {
        entries[_UPD] = input[_UPD];
    }
    if (input[_SCN] != null) {
        entries[_SCN] = input[_SCN];
    }
    if (input[_S] != null) {
        entries[_S] = input[_S];
    }
    if (input[_ST] != null) {
        entries[_ST] = input[_ST];
    }
    if (input[_AREP] != null) {
        const memberEntries = se_AuthenticateCognitoActionAuthenticationRequestExtraParams(input[_AREP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AuthenticationRequestExtraParams.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_OUR] != null) {
        entries[_OUR] = input[_OUR];
    }
    return entries;
};
const se_AuthenticateOidcActionAuthenticationRequestExtraParams = (input, context) => {
    const entries = {};
    let counter = 1;
    Object.keys(input)
        .filter((key) => input[key] != null)
        .forEach((key) => {
        entries[`entry.${counter}.key`] = key;
        entries[`entry.${counter}.value`] = input[key];
        counter++;
    });
    return entries;
};
const se_AuthenticateOidcActionConfig = (input, context) => {
    const entries = {};
    if (input[_I] != null) {
        entries[_I] = input[_I];
    }
    if (input[_AE] != null) {
        entries[_AE] = input[_AE];
    }
    if (input[_TE] != null) {
        entries[_TE] = input[_TE];
    }
    if (input[_UIE] != null) {
        entries[_UIE] = input[_UIE];
    }
    if (input[_CI] != null) {
        entries[_CI] = input[_CI];
    }
    if (input[_CS] != null) {
        entries[_CS] = input[_CS];
    }
    if (input[_SCN] != null) {
        entries[_SCN] = input[_SCN];
    }
    if (input[_S] != null) {
        entries[_S] = input[_S];
    }
    if (input[_ST] != null) {
        entries[_ST] = input[_ST];
    }
    if (input[_AREP] != null) {
        const memberEntries = se_AuthenticateOidcActionAuthenticationRequestExtraParams(input[_AREP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AuthenticationRequestExtraParams.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_OUR] != null) {
        entries[_OUR] = input[_OUR];
    }
    if (input[_UECS] != null) {
        entries[_UECS] = input[_UECS];
    }
    return entries;
};
const se_Certificate = (input, context) => {
    const entries = {};
    if (input[_CA] != null) {
        entries[_CA] = input[_CA];
    }
    if (input[_ID] != null) {
        entries[_ID] = input[_ID];
    }
    return entries;
};
const se_CertificateList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Certificate(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_CreateListenerInput = (input, context) => {
    const entries = {};
    if (input[_LBA] != null) {
        entries[_LBA] = input[_LBA];
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_Po] != null) {
        entries[_Po] = input[_Po];
    }
    if (input[_SP] != null) {
        entries[_SP] = input[_SP];
    }
    if (input[_C] != null) {
        const memberEntries = se_CertificateList(input[_C], context);
        if (input[_C]?.length === 0) {
            entries.Certificates = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Certificates.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DA] != null) {
        const memberEntries = se_Actions(input[_DA], context);
        if (input[_DA]?.length === 0) {
            entries.DefaultActions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DefaultActions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AP] != null) {
        const memberEntries = se_AlpnPolicyName(input[_AP], context);
        if (input[_AP]?.length === 0) {
            entries.AlpnPolicy = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlpnPolicy.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Ta] != null) {
        const memberEntries = se_TagList(input[_Ta], context);
        if (input[_Ta]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MA] != null) {
        const memberEntries = se_MutualAuthenticationAttributes(input[_MA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MutualAuthentication.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateLoadBalancerInput = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_Su] != null) {
        const memberEntries = se_Subnets(input[_Su], context);
        if (input[_Su]?.length === 0) {
            entries.Subnets = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Subnets.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SM] != null) {
        const memberEntries = se_SubnetMappings(input[_SM], context);
        if (input[_SM]?.length === 0) {
            entries.SubnetMappings = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetMappings.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SG] != null) {
        const memberEntries = se_SecurityGroups(input[_SG], context);
        if (input[_SG]?.length === 0) {
            entries.SecurityGroups = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroups.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Sc] != null) {
        entries[_Sc] = input[_Sc];
    }
    if (input[_Ta] != null) {
        const memberEntries = se_TagList(input[_Ta], context);
        if (input[_Ta]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_T] != null) {
        entries[_T] = input[_T];
    }
    if (input[_IAT] != null) {
        entries[_IAT] = input[_IAT];
    }
    if (input[_COIP] != null) {
        entries[_COIP] = input[_COIP];
    }
    if (input[_EPFISN] != null) {
        entries[_EPFISN] = input[_EPFISN];
    }
    if (input[_IP] != null) {
        const memberEntries = se_IpamPools(input[_IP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IpamPools.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateRuleInput = (input, context) => {
    const entries = {};
    if (input[_LA] != null) {
        entries[_LA] = input[_LA];
    }
    if (input[_Co] != null) {
        const memberEntries = se_RuleConditionList(input[_Co], context);
        if (input[_Co]?.length === 0) {
            entries.Conditions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Conditions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Pr] != null) {
        entries[_Pr] = input[_Pr];
    }
    if (input[_Ac] != null) {
        const memberEntries = se_Actions(input[_Ac], context);
        if (input[_Ac]?.length === 0) {
            entries.Actions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Actions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Ta] != null) {
        const memberEntries = se_TagList(input[_Ta], context);
        if (input[_Ta]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateTargetGroupInput = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_PV] != null) {
        entries[_PV] = input[_PV];
    }
    if (input[_Po] != null) {
        entries[_Po] = input[_Po];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_HCP] != null) {
        entries[_HCP] = input[_HCP];
    }
    if (input[_HCPe] != null) {
        entries[_HCPe] = input[_HCPe];
    }
    if (input[_HCE] != null) {
        entries[_HCE] = input[_HCE];
    }
    if (input[_HCPea] != null) {
        entries[_HCPea] = input[_HCPea];
    }
    if (input[_HCIS] != null) {
        entries[_HCIS] = input[_HCIS];
    }
    if (input[_HCTS] != null) {
        entries[_HCTS] = input[_HCTS];
    }
    if (input[_HTC] != null) {
        entries[_HTC] = input[_HTC];
    }
    if (input[_UTC] != null) {
        entries[_UTC] = input[_UTC];
    }
    if (input[_M] != null) {
        const memberEntries = se_Matcher(input[_M], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Matcher.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TT] != null) {
        entries[_TT] = input[_TT];
    }
    if (input[_Ta] != null) {
        const memberEntries = se_TagList(input[_Ta], context);
        if (input[_Ta]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_IAT] != null) {
        entries[_IAT] = input[_IAT];
    }
    return entries;
};
const se_CreateTrustStoreInput = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_CCBSB] != null) {
        entries[_CCBSB] = input[_CCBSB];
    }
    if (input[_CCBSK] != null) {
        entries[_CCBSK] = input[_CCBSK];
    }
    if (input[_CCBSOV] != null) {
        entries[_CCBSOV] = input[_CCBSOV];
    }
    if (input[_Ta] != null) {
        const memberEntries = se_TagList(input[_Ta], context);
        if (input[_Ta]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteListenerInput = (input, context) => {
    const entries = {};
    if (input[_LA] != null) {
        entries[_LA] = input[_LA];
    }
    return entries;
};
const se_DeleteLoadBalancerInput = (input, context) => {
    const entries = {};
    if (input[_LBA] != null) {
        entries[_LBA] = input[_LBA];
    }
    return entries;
};
const se_DeleteRuleInput = (input, context) => {
    const entries = {};
    if (input[_RAu] != null) {
        entries[_RAu] = input[_RAu];
    }
    return entries;
};
const se_DeleteSharedTrustStoreAssociationInput = (input, context) => {
    const entries = {};
    if (input[_TSA] != null) {
        entries[_TSA] = input[_TSA];
    }
    if (input[_RAe] != null) {
        entries[_RAe] = input[_RAe];
    }
    return entries;
};
const se_DeleteTargetGroupInput = (input, context) => {
    const entries = {};
    if (input[_TGA] != null) {
        entries[_TGA] = input[_TGA];
    }
    return entries;
};
const se_DeleteTrustStoreInput = (input, context) => {
    const entries = {};
    if (input[_TSA] != null) {
        entries[_TSA] = input[_TSA];
    }
    return entries;
};
const se_DeregisterTargetsInput = (input, context) => {
    const entries = {};
    if (input[_TGA] != null) {
        entries[_TGA] = input[_TGA];
    }
    if (input[_Tar] != null) {
        const memberEntries = se_TargetDescriptions(input[_Tar], context);
        if (input[_Tar]?.length === 0) {
            entries.Targets = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Targets.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeAccountLimitsInput = (input, context) => {
    const entries = {};
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    if (input[_PS] != null) {
        entries[_PS] = input[_PS];
    }
    return entries;
};
const se_DescribeCapacityReservationInput = (input, context) => {
    const entries = {};
    if (input[_LBA] != null) {
        entries[_LBA] = input[_LBA];
    }
    return entries;
};
const se_DescribeListenerAttributesInput = (input, context) => {
    const entries = {};
    if (input[_LA] != null) {
        entries[_LA] = input[_LA];
    }
    return entries;
};
const se_DescribeListenerCertificatesInput = (input, context) => {
    const entries = {};
    if (input[_LA] != null) {
        entries[_LA] = input[_LA];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    if (input[_PS] != null) {
        entries[_PS] = input[_PS];
    }
    return entries;
};
const se_DescribeListenersInput = (input, context) => {
    const entries = {};
    if (input[_LBA] != null) {
        entries[_LBA] = input[_LBA];
    }
    if (input[_LAi] != null) {
        const memberEntries = se_ListenerArns(input[_LAi], context);
        if (input[_LAi]?.length === 0) {
            entries.ListenerArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ListenerArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    if (input[_PS] != null) {
        entries[_PS] = input[_PS];
    }
    return entries;
};
const se_DescribeLoadBalancerAttributesInput = (input, context) => {
    const entries = {};
    if (input[_LBA] != null) {
        entries[_LBA] = input[_LBA];
    }
    return entries;
};
const se_DescribeLoadBalancersInput = (input, context) => {
    const entries = {};
    if (input[_LBAo] != null) {
        const memberEntries = se_LoadBalancerArns(input[_LBAo], context);
        if (input[_LBAo]?.length === 0) {
            entries.LoadBalancerArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LoadBalancerArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Na] != null) {
        const memberEntries = se_LoadBalancerNames(input[_Na], context);
        if (input[_Na]?.length === 0) {
            entries.Names = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Names.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    if (input[_PS] != null) {
        entries[_PS] = input[_PS];
    }
    return entries;
};
const se_DescribeRulesInput = (input, context) => {
    const entries = {};
    if (input[_LA] != null) {
        entries[_LA] = input[_LA];
    }
    if (input[_RAul] != null) {
        const memberEntries = se_RuleArns(input[_RAul], context);
        if (input[_RAul]?.length === 0) {
            entries.RuleArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RuleArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    if (input[_PS] != null) {
        entries[_PS] = input[_PS];
    }
    return entries;
};
const se_DescribeSSLPoliciesInput = (input, context) => {
    const entries = {};
    if (input[_Na] != null) {
        const memberEntries = se_SslPolicyNames(input[_Na], context);
        if (input[_Na]?.length === 0) {
            entries.Names = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Names.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    if (input[_PS] != null) {
        entries[_PS] = input[_PS];
    }
    if (input[_LBT] != null) {
        entries[_LBT] = input[_LBT];
    }
    return entries;
};
const se_DescribeTagsInput = (input, context) => {
    const entries = {};
    if (input[_RA] != null) {
        const memberEntries = se_ResourceArns(input[_RA], context);
        if (input[_RA]?.length === 0) {
            entries.ResourceArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ResourceArns.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeTargetGroupAttributesInput = (input, context) => {
    const entries = {};
    if (input[_TGA] != null) {
        entries[_TGA] = input[_TGA];
    }
    return entries;
};
const se_DescribeTargetGroupsInput = (input, context) => {
    const entries = {};
    if (input[_LBA] != null) {
        entries[_LBA] = input[_LBA];
    }
    if (input[_TGAa] != null) {
        const memberEntries = se_TargetGroupArns(input[_TGAa], context);
        if (input[_TGAa]?.length === 0) {
            entries.TargetGroupArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TargetGroupArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Na] != null) {
        const memberEntries = se_TargetGroupNames(input[_Na], context);
        if (input[_Na]?.length === 0) {
            entries.Names = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Names.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    if (input[_PS] != null) {
        entries[_PS] = input[_PS];
    }
    return entries;
};
const se_DescribeTargetHealthInput = (input, context) => {
    const entries = {};
    if (input[_TGA] != null) {
        entries[_TGA] = input[_TGA];
    }
    if (input[_Tar] != null) {
        const memberEntries = se_TargetDescriptions(input[_Tar], context);
        if (input[_Tar]?.length === 0) {
            entries.Targets = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Targets.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_In] != null) {
        const memberEntries = se_ListOfDescribeTargetHealthIncludeOptions(input[_In], context);
        if (input[_In]?.length === 0) {
            entries.Include = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Include.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeTrustStoreAssociationsInput = (input, context) => {
    const entries = {};
    if (input[_TSA] != null) {
        entries[_TSA] = input[_TSA];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    if (input[_PS] != null) {
        entries[_PS] = input[_PS];
    }
    return entries;
};
const se_DescribeTrustStoreRevocationsInput = (input, context) => {
    const entries = {};
    if (input[_TSA] != null) {
        entries[_TSA] = input[_TSA];
    }
    if (input[_RI] != null) {
        const memberEntries = se_RevocationIds(input[_RI], context);
        if (input[_RI]?.length === 0) {
            entries.RevocationIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RevocationIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    if (input[_PS] != null) {
        entries[_PS] = input[_PS];
    }
    return entries;
};
const se_DescribeTrustStoresInput = (input, context) => {
    const entries = {};
    if (input[_TSAr] != null) {
        const memberEntries = se_TrustStoreArns(input[_TSAr], context);
        if (input[_TSAr]?.length === 0) {
            entries.TrustStoreArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TrustStoreArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Na] != null) {
        const memberEntries = se_TrustStoreNames(input[_Na], context);
        if (input[_Na]?.length === 0) {
            entries.Names = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Names.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    if (input[_PS] != null) {
        entries[_PS] = input[_PS];
    }
    return entries;
};
const se_FixedResponseActionConfig = (input, context) => {
    const entries = {};
    if (input[_MB] != null) {
        entries[_MB] = input[_MB];
    }
    if (input[_SC] != null) {
        entries[_SC] = input[_SC];
    }
    if (input[_CT] != null) {
        entries[_CT] = input[_CT];
    }
    return entries;
};
const se_ForwardActionConfig = (input, context) => {
    const entries = {};
    if (input[_TG] != null) {
        const memberEntries = se_TargetGroupList(input[_TG], context);
        if (input[_TG]?.length === 0) {
            entries.TargetGroups = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TargetGroups.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TGSC] != null) {
        const memberEntries = se_TargetGroupStickinessConfig(input[_TGSC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TargetGroupStickinessConfig.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_GetResourcePolicyInput = (input, context) => {
    const entries = {};
    if (input[_RAe] != null) {
        entries[_RAe] = input[_RAe];
    }
    return entries;
};
const se_GetTrustStoreCaCertificatesBundleInput = (input, context) => {
    const entries = {};
    if (input[_TSA] != null) {
        entries[_TSA] = input[_TSA];
    }
    return entries;
};
const se_GetTrustStoreRevocationContentInput = (input, context) => {
    const entries = {};
    if (input[_TSA] != null) {
        entries[_TSA] = input[_TSA];
    }
    if (input[_RIe] != null) {
        entries[_RIe] = input[_RIe];
    }
    return entries;
};
const se_HostHeaderConditionConfig = (input, context) => {
    const entries = {};
    if (input[_Va] != null) {
        const memberEntries = se_ListOfString(input[_Va], context);
        if (input[_Va]?.length === 0) {
            entries.Values = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Values.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_HttpHeaderConditionConfig = (input, context) => {
    const entries = {};
    if (input[_HHN] != null) {
        entries[_HHN] = input[_HHN];
    }
    if (input[_Va] != null) {
        const memberEntries = se_ListOfString(input[_Va], context);
        if (input[_Va]?.length === 0) {
            entries.Values = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Values.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_HttpRequestMethodConditionConfig = (input, context) => {
    const entries = {};
    if (input[_Va] != null) {
        const memberEntries = se_ListOfString(input[_Va], context);
        if (input[_Va]?.length === 0) {
            entries.Values = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Values.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_IpamPools = (input, context) => {
    const entries = {};
    if (input[_IIPI] != null) {
        entries[_IIPI] = input[_IIPI];
    }
    return entries;
};
const se_ListenerArns = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ListenerAttribute = (input, context) => {
    const entries = {};
    if (input[_K] != null) {
        entries[_K] = input[_K];
    }
    if (input[_Val] != null) {
        entries[_Val] = input[_Val];
    }
    return entries;
};
const se_ListenerAttributes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ListenerAttribute(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_ListOfDescribeTargetHealthIncludeOptions = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ListOfString = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LoadBalancerArns = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LoadBalancerAttribute = (input, context) => {
    const entries = {};
    if (input[_K] != null) {
        entries[_K] = input[_K];
    }
    if (input[_Val] != null) {
        entries[_Val] = input[_Val];
    }
    return entries;
};
const se_LoadBalancerAttributes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_LoadBalancerAttribute(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_LoadBalancerNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_Matcher = (input, context) => {
    const entries = {};
    if (input[_HC] != null) {
        entries[_HC] = input[_HC];
    }
    if (input[_GC] != null) {
        entries[_GC] = input[_GC];
    }
    return entries;
};
const se_MinimumLoadBalancerCapacity = (input, context) => {
    const entries = {};
    if (input[_CU] != null) {
        entries[_CU] = input[_CU];
    }
    return entries;
};
const se_ModifyCapacityReservationInput = (input, context) => {
    const entries = {};
    if (input[_LBA] != null) {
        entries[_LBA] = input[_LBA];
    }
    if (input[_MLBC] != null) {
        const memberEntries = se_MinimumLoadBalancerCapacity(input[_MLBC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MinimumLoadBalancerCapacity.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_RCR] != null) {
        entries[_RCR] = input[_RCR];
    }
    return entries;
};
const se_ModifyIpPoolsInput = (input, context) => {
    const entries = {};
    if (input[_LBA] != null) {
        entries[_LBA] = input[_LBA];
    }
    if (input[_IP] != null) {
        const memberEntries = se_IpamPools(input[_IP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IpamPools.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_RIP] != null) {
        const memberEntries = se_RemoveIpamPools(input[_RIP], context);
        if (input[_RIP]?.length === 0) {
            entries.RemoveIpamPools = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RemoveIpamPools.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyListenerAttributesInput = (input, context) => {
    const entries = {};
    if (input[_LA] != null) {
        entries[_LA] = input[_LA];
    }
    if (input[_At] != null) {
        const memberEntries = se_ListenerAttributes(input[_At], context);
        if (input[_At]?.length === 0) {
            entries.Attributes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Attributes.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyListenerInput = (input, context) => {
    const entries = {};
    if (input[_LA] != null) {
        entries[_LA] = input[_LA];
    }
    if (input[_Po] != null) {
        entries[_Po] = input[_Po];
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_SP] != null) {
        entries[_SP] = input[_SP];
    }
    if (input[_C] != null) {
        const memberEntries = se_CertificateList(input[_C], context);
        if (input[_C]?.length === 0) {
            entries.Certificates = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Certificates.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DA] != null) {
        const memberEntries = se_Actions(input[_DA], context);
        if (input[_DA]?.length === 0) {
            entries.DefaultActions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DefaultActions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AP] != null) {
        const memberEntries = se_AlpnPolicyName(input[_AP], context);
        if (input[_AP]?.length === 0) {
            entries.AlpnPolicy = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlpnPolicy.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MA] != null) {
        const memberEntries = se_MutualAuthenticationAttributes(input[_MA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MutualAuthentication.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyLoadBalancerAttributesInput = (input, context) => {
    const entries = {};
    if (input[_LBA] != null) {
        entries[_LBA] = input[_LBA];
    }
    if (input[_At] != null) {
        const memberEntries = se_LoadBalancerAttributes(input[_At], context);
        if (input[_At]?.length === 0) {
            entries.Attributes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Attributes.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyRuleInput = (input, context) => {
    const entries = {};
    if (input[_RAu] != null) {
        entries[_RAu] = input[_RAu];
    }
    if (input[_Co] != null) {
        const memberEntries = se_RuleConditionList(input[_Co], context);
        if (input[_Co]?.length === 0) {
            entries.Conditions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Conditions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Ac] != null) {
        const memberEntries = se_Actions(input[_Ac], context);
        if (input[_Ac]?.length === 0) {
            entries.Actions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Actions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyTargetGroupAttributesInput = (input, context) => {
    const entries = {};
    if (input[_TGA] != null) {
        entries[_TGA] = input[_TGA];
    }
    if (input[_At] != null) {
        const memberEntries = se_TargetGroupAttributes(input[_At], context);
        if (input[_At]?.length === 0) {
            entries.Attributes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Attributes.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyTargetGroupInput = (input, context) => {
    const entries = {};
    if (input[_TGA] != null) {
        entries[_TGA] = input[_TGA];
    }
    if (input[_HCP] != null) {
        entries[_HCP] = input[_HCP];
    }
    if (input[_HCPe] != null) {
        entries[_HCPe] = input[_HCPe];
    }
    if (input[_HCPea] != null) {
        entries[_HCPea] = input[_HCPea];
    }
    if (input[_HCE] != null) {
        entries[_HCE] = input[_HCE];
    }
    if (input[_HCIS] != null) {
        entries[_HCIS] = input[_HCIS];
    }
    if (input[_HCTS] != null) {
        entries[_HCTS] = input[_HCTS];
    }
    if (input[_HTC] != null) {
        entries[_HTC] = input[_HTC];
    }
    if (input[_UTC] != null) {
        entries[_UTC] = input[_UTC];
    }
    if (input[_M] != null) {
        const memberEntries = se_Matcher(input[_M], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Matcher.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyTrustStoreInput = (input, context) => {
    const entries = {};
    if (input[_TSA] != null) {
        entries[_TSA] = input[_TSA];
    }
    if (input[_CCBSB] != null) {
        entries[_CCBSB] = input[_CCBSB];
    }
    if (input[_CCBSK] != null) {
        entries[_CCBSK] = input[_CCBSK];
    }
    if (input[_CCBSOV] != null) {
        entries[_CCBSOV] = input[_CCBSOV];
    }
    return entries;
};
const se_MutualAuthenticationAttributes = (input, context) => {
    const entries = {};
    if (input[_Mo] != null) {
        entries[_Mo] = input[_Mo];
    }
    if (input[_TSA] != null) {
        entries[_TSA] = input[_TSA];
    }
    if (input[_ICCE] != null) {
        entries[_ICCE] = input[_ICCE];
    }
    if (input[_TSAS] != null) {
        entries[_TSAS] = input[_TSAS];
    }
    if (input[_ATSCN] != null) {
        entries[_ATSCN] = input[_ATSCN];
    }
    return entries;
};
const se_PathPatternConditionConfig = (input, context) => {
    const entries = {};
    if (input[_Va] != null) {
        const memberEntries = se_ListOfString(input[_Va], context);
        if (input[_Va]?.length === 0) {
            entries.Values = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Values.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_QueryStringConditionConfig = (input, context) => {
    const entries = {};
    if (input[_Va] != null) {
        const memberEntries = se_QueryStringKeyValuePairList(input[_Va], context);
        if (input[_Va]?.length === 0) {
            entries.Values = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Values.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_QueryStringKeyValuePair = (input, context) => {
    const entries = {};
    if (input[_K] != null) {
        entries[_K] = input[_K];
    }
    if (input[_Val] != null) {
        entries[_Val] = input[_Val];
    }
    return entries;
};
const se_QueryStringKeyValuePairList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_QueryStringKeyValuePair(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_RedirectActionConfig = (input, context) => {
    const entries = {};
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_Po] != null) {
        entries[_Po] = input[_Po];
    }
    if (input[_H] != null) {
        entries[_H] = input[_H];
    }
    if (input[_Pa] != null) {
        entries[_Pa] = input[_Pa];
    }
    if (input[_Q] != null) {
        entries[_Q] = input[_Q];
    }
    if (input[_SC] != null) {
        entries[_SC] = input[_SC];
    }
    return entries;
};
const se_RegisterTargetsInput = (input, context) => {
    const entries = {};
    if (input[_TGA] != null) {
        entries[_TGA] = input[_TGA];
    }
    if (input[_Tar] != null) {
        const memberEntries = se_TargetDescriptions(input[_Tar], context);
        if (input[_Tar]?.length === 0) {
            entries.Targets = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Targets.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_RemoveIpamPools = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_RemoveListenerCertificatesInput = (input, context) => {
    const entries = {};
    if (input[_LA] != null) {
        entries[_LA] = input[_LA];
    }
    if (input[_C] != null) {
        const memberEntries = se_CertificateList(input[_C], context);
        if (input[_C]?.length === 0) {
            entries.Certificates = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Certificates.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_RemoveTagsInput = (input, context) => {
    const entries = {};
    if (input[_RA] != null) {
        const memberEntries = se_ResourceArns(input[_RA], context);
        if (input[_RA]?.length === 0) {
            entries.ResourceArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ResourceArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TK] != null) {
        const memberEntries = se_TagKeys(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_RemoveTrustStoreRevocationsInput = (input, context) => {
    const entries = {};
    if (input[_TSA] != null) {
        entries[_TSA] = input[_TSA];
    }
    if (input[_RI] != null) {
        const memberEntries = se_RevocationIds(input[_RI], context);
        if (input[_RI]?.length === 0) {
            entries.RevocationIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RevocationIds.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ResourceArns = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_RevocationContent = (input, context) => {
    const entries = {};
    if (input[_SB] != null) {
        entries[_SB] = input[_SB];
    }
    if (input[_SK] != null) {
        entries[_SK] = input[_SK];
    }
    if (input[_SOV] != null) {
        entries[_SOV] = input[_SOV];
    }
    if (input[_RTev] != null) {
        entries[_RTev] = input[_RTev];
    }
    return entries;
};
const se_RevocationContents = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_RevocationContent(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_RevocationIds = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_RuleArns = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_RuleCondition = (input, context) => {
    const entries = {};
    if (input[_F] != null) {
        entries[_F] = input[_F];
    }
    if (input[_Va] != null) {
        const memberEntries = se_ListOfString(input[_Va], context);
        if (input[_Va]?.length === 0) {
            entries.Values = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Values.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_HHC] != null) {
        const memberEntries = se_HostHeaderConditionConfig(input[_HHC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `HostHeaderConfig.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_PPC] != null) {
        const memberEntries = se_PathPatternConditionConfig(input[_PPC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PathPatternConfig.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_HHCt] != null) {
        const memberEntries = se_HttpHeaderConditionConfig(input[_HHCt], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `HttpHeaderConfig.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_QSC] != null) {
        const memberEntries = se_QueryStringConditionConfig(input[_QSC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `QueryStringConfig.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_HRMC] != null) {
        const memberEntries = se_HttpRequestMethodConditionConfig(input[_HRMC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `HttpRequestMethodConfig.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SIC] != null) {
        const memberEntries = se_SourceIpConditionConfig(input[_SIC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SourceIpConfig.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_RuleConditionList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_RuleCondition(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_RulePriorityList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_RulePriorityPair(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_RulePriorityPair = (input, context) => {
    const entries = {};
    if (input[_RAu] != null) {
        entries[_RAu] = input[_RAu];
    }
    if (input[_Pr] != null) {
        entries[_Pr] = input[_Pr];
    }
    return entries;
};
const se_SecurityGroups = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SetIpAddressTypeInput = (input, context) => {
    const entries = {};
    if (input[_LBA] != null) {
        entries[_LBA] = input[_LBA];
    }
    if (input[_IAT] != null) {
        entries[_IAT] = input[_IAT];
    }
    return entries;
};
const se_SetRulePrioritiesInput = (input, context) => {
    const entries = {};
    if (input[_RP] != null) {
        const memberEntries = se_RulePriorityList(input[_RP], context);
        if (input[_RP]?.length === 0) {
            entries.RulePriorities = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RulePriorities.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_SetSecurityGroupsInput = (input, context) => {
    const entries = {};
    if (input[_LBA] != null) {
        entries[_LBA] = input[_LBA];
    }
    if (input[_SG] != null) {
        const memberEntries = se_SecurityGroups(input[_SG], context);
        if (input[_SG]?.length === 0) {
            entries.SecurityGroups = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroups.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ESGIROPLT] != null) {
        entries[_ESGIROPLT] = input[_ESGIROPLT];
    }
    return entries;
};
const se_SetSubnetsInput = (input, context) => {
    const entries = {};
    if (input[_LBA] != null) {
        entries[_LBA] = input[_LBA];
    }
    if (input[_Su] != null) {
        const memberEntries = se_Subnets(input[_Su], context);
        if (input[_Su]?.length === 0) {
            entries.Subnets = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Subnets.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SM] != null) {
        const memberEntries = se_SubnetMappings(input[_SM], context);
        if (input[_SM]?.length === 0) {
            entries.SubnetMappings = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetMappings.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_IAT] != null) {
        entries[_IAT] = input[_IAT];
    }
    if (input[_EPFISN] != null) {
        entries[_EPFISN] = input[_EPFISN];
    }
    return entries;
};
const se_SourceIpConditionConfig = (input, context) => {
    const entries = {};
    if (input[_Va] != null) {
        const memberEntries = se_ListOfString(input[_Va], context);
        if (input[_Va]?.length === 0) {
            entries.Values = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Values.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_SslPolicyNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SubnetMapping = (input, context) => {
    const entries = {};
    if (input[_SI] != null) {
        entries[_SI] = input[_SI];
    }
    if (input[_AI] != null) {
        entries[_AI] = input[_AI];
    }
    if (input[_PIPA] != null) {
        entries[_PIPA] = input[_PIPA];
    }
    if (input[_IPA] != null) {
        entries[_IPA] = input[_IPA];
    }
    if (input[_SNIP] != null) {
        entries[_SNIP] = input[_SNIP];
    }
    return entries;
};
const se_SubnetMappings = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_SubnetMapping(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Subnets = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_Tag = (input, context) => {
    const entries = {};
    if (input[_K] != null) {
        entries[_K] = input[_K];
    }
    if (input[_Val] != null) {
        entries[_Val] = input[_Val];
    }
    return entries;
};
const se_TagKeys = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TagList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Tag(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TargetDescription = (input, context) => {
    const entries = {};
    if (input[_Id] != null) {
        entries[_Id] = input[_Id];
    }
    if (input[_Po] != null) {
        entries[_Po] = input[_Po];
    }
    if (input[_AZ] != null) {
        entries[_AZ] = input[_AZ];
    }
    return entries;
};
const se_TargetDescriptions = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_TargetDescription(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TargetGroupArns = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TargetGroupAttribute = (input, context) => {
    const entries = {};
    if (input[_K] != null) {
        entries[_K] = input[_K];
    }
    if (input[_Val] != null) {
        entries[_Val] = input[_Val];
    }
    return entries;
};
const se_TargetGroupAttributes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_TargetGroupAttribute(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TargetGroupList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_TargetGroupTuple(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TargetGroupNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TargetGroupStickinessConfig = (input, context) => {
    const entries = {};
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_DS] != null) {
        entries[_DS] = input[_DS];
    }
    return entries;
};
const se_TargetGroupTuple = (input, context) => {
    const entries = {};
    if (input[_TGA] != null) {
        entries[_TGA] = input[_TGA];
    }
    if (input[_W] != null) {
        entries[_W] = input[_W];
    }
    return entries;
};
const se_TrustStoreArns = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TrustStoreNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const de_Action = (output, context) => {
    const contents = {};
    if (output[_T] != null) {
        contents[_T] = __expectString(output[_T]);
    }
    if (output[_TGA] != null) {
        contents[_TGA] = __expectString(output[_TGA]);
    }
    if (output[_AOC] != null) {
        contents[_AOC] = de_AuthenticateOidcActionConfig(output[_AOC], context);
    }
    if (output[_ACC] != null) {
        contents[_ACC] = de_AuthenticateCognitoActionConfig(output[_ACC], context);
    }
    if (output[_O] != null) {
        contents[_O] = __strictParseInt32(output[_O]);
    }
    if (output[_RC] != null) {
        contents[_RC] = de_RedirectActionConfig(output[_RC], context);
    }
    if (output[_FRC] != null) {
        contents[_FRC] = de_FixedResponseActionConfig(output[_FRC], context);
    }
    if (output[_FC] != null) {
        contents[_FC] = de_ForwardActionConfig(output[_FC], context);
    }
    return contents;
};
const de_Actions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Action(entry, context);
    });
};
const de_AddListenerCertificatesOutput = (output, context) => {
    const contents = {};
    if (output.Certificates === "") {
        contents[_C] = [];
    }
    else if (output[_C] != null && output[_C][_m] != null) {
        contents[_C] = de_CertificateList(__getArrayIfSingleItem(output[_C][_m]), context);
    }
    return contents;
};
const de_AddTagsOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_AddTrustStoreRevocationsOutput = (output, context) => {
    const contents = {};
    if (output.TrustStoreRevocations === "") {
        contents[_TSR] = [];
    }
    else if (output[_TSR] != null && output[_TSR][_m] != null) {
        contents[_TSR] = de_TrustStoreRevocations(__getArrayIfSingleItem(output[_TSR][_m]), context);
    }
    return contents;
};
const de_AdministrativeOverride = (output, context) => {
    const contents = {};
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_R] != null) {
        contents[_R] = __expectString(output[_R]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    return contents;
};
const de_AllocationIdNotFoundException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_AlpnPolicyName = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ALPNPolicyNotSupportedException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_AnomalyDetection = (output, context) => {
    const contents = {};
    if (output[_Re] != null) {
        contents[_Re] = __expectString(output[_Re]);
    }
    if (output[_MIE] != null) {
        contents[_MIE] = __expectString(output[_MIE]);
    }
    return contents;
};
const de_AuthenticateCognitoActionAuthenticationRequestExtraParams = (output, context) => {
    return output.reduce((acc, pair) => {
        if (pair["value"] === null) {
            return acc;
        }
        acc[pair["key"]] = __expectString(pair["value"]);
        return acc;
    }, {});
};
const de_AuthenticateCognitoActionConfig = (output, context) => {
    const contents = {};
    if (output[_UPA] != null) {
        contents[_UPA] = __expectString(output[_UPA]);
    }
    if (output[_UPCI] != null) {
        contents[_UPCI] = __expectString(output[_UPCI]);
    }
    if (output[_UPD] != null) {
        contents[_UPD] = __expectString(output[_UPD]);
    }
    if (output[_SCN] != null) {
        contents[_SCN] = __expectString(output[_SCN]);
    }
    if (output[_S] != null) {
        contents[_S] = __expectString(output[_S]);
    }
    if (output[_ST] != null) {
        contents[_ST] = __strictParseLong(output[_ST]);
    }
    if (output.AuthenticationRequestExtraParams === "") {
        contents[_AREP] = {};
    }
    else if (output[_AREP] != null && output[_AREP][_e] != null) {
        contents[_AREP] = de_AuthenticateCognitoActionAuthenticationRequestExtraParams(__getArrayIfSingleItem(output[_AREP][_e]), context);
    }
    if (output[_OUR] != null) {
        contents[_OUR] = __expectString(output[_OUR]);
    }
    return contents;
};
const de_AuthenticateOidcActionAuthenticationRequestExtraParams = (output, context) => {
    return output.reduce((acc, pair) => {
        if (pair["value"] === null) {
            return acc;
        }
        acc[pair["key"]] = __expectString(pair["value"]);
        return acc;
    }, {});
};
const de_AuthenticateOidcActionConfig = (output, context) => {
    const contents = {};
    if (output[_I] != null) {
        contents[_I] = __expectString(output[_I]);
    }
    if (output[_AE] != null) {
        contents[_AE] = __expectString(output[_AE]);
    }
    if (output[_TE] != null) {
        contents[_TE] = __expectString(output[_TE]);
    }
    if (output[_UIE] != null) {
        contents[_UIE] = __expectString(output[_UIE]);
    }
    if (output[_CI] != null) {
        contents[_CI] = __expectString(output[_CI]);
    }
    if (output[_CS] != null) {
        contents[_CS] = __expectString(output[_CS]);
    }
    if (output[_SCN] != null) {
        contents[_SCN] = __expectString(output[_SCN]);
    }
    if (output[_S] != null) {
        contents[_S] = __expectString(output[_S]);
    }
    if (output[_ST] != null) {
        contents[_ST] = __strictParseLong(output[_ST]);
    }
    if (output.AuthenticationRequestExtraParams === "") {
        contents[_AREP] = {};
    }
    else if (output[_AREP] != null && output[_AREP][_e] != null) {
        contents[_AREP] = de_AuthenticateOidcActionAuthenticationRequestExtraParams(__getArrayIfSingleItem(output[_AREP][_e]), context);
    }
    if (output[_OUR] != null) {
        contents[_OUR] = __expectString(output[_OUR]);
    }
    if (output[_UECS] != null) {
        contents[_UECS] = __parseBoolean(output[_UECS]);
    }
    return contents;
};
const de_AvailabilityZone = (output, context) => {
    const contents = {};
    if (output[_ZN] != null) {
        contents[_ZN] = __expectString(output[_ZN]);
    }
    if (output[_SI] != null) {
        contents[_SI] = __expectString(output[_SI]);
    }
    if (output[_OI] != null) {
        contents[_OI] = __expectString(output[_OI]);
    }
    if (output.LoadBalancerAddresses === "") {
        contents[_LBAoa] = [];
    }
    else if (output[_LBAoa] != null && output[_LBAoa][_m] != null) {
        contents[_LBAoa] = de_LoadBalancerAddresses(__getArrayIfSingleItem(output[_LBAoa][_m]), context);
    }
    if (output.SourceNatIpv6Prefixes === "") {
        contents[_SNIPo] = [];
    }
    else if (output[_SNIPo] != null && output[_SNIPo][_m] != null) {
        contents[_SNIPo] = de_SourceNatIpv6Prefixes(__getArrayIfSingleItem(output[_SNIPo][_m]), context);
    }
    return contents;
};
const de_AvailabilityZoneNotSupportedException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_AvailabilityZones = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AvailabilityZone(entry, context);
    });
};
const de_CaCertificatesBundleNotFoundException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_CapacityDecreaseRequestsLimitExceededException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_CapacityReservationPendingException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_CapacityReservationStatus = (output, context) => {
    const contents = {};
    if (output[_Cod] != null) {
        contents[_Cod] = __expectString(output[_Cod]);
    }
    if (output[_R] != null) {
        contents[_R] = __expectString(output[_R]);
    }
    return contents;
};
const de_CapacityUnitsLimitExceededException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_Certificate = (output, context) => {
    const contents = {};
    if (output[_CA] != null) {
        contents[_CA] = __expectString(output[_CA]);
    }
    if (output[_ID] != null) {
        contents[_ID] = __parseBoolean(output[_ID]);
    }
    return contents;
};
const de_CertificateList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Certificate(entry, context);
    });
};
const de_CertificateNotFoundException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_Cipher = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = __expectString(output[_N]);
    }
    if (output[_Pr] != null) {
        contents[_Pr] = __strictParseInt32(output[_Pr]);
    }
    return contents;
};
const de_Ciphers = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Cipher(entry, context);
    });
};
const de_CreateListenerOutput = (output, context) => {
    const contents = {};
    if (output.Listeners === "") {
        contents[_L] = [];
    }
    else if (output[_L] != null && output[_L][_m] != null) {
        contents[_L] = de_Listeners(__getArrayIfSingleItem(output[_L][_m]), context);
    }
    return contents;
};
const de_CreateLoadBalancerOutput = (output, context) => {
    const contents = {};
    if (output.LoadBalancers === "") {
        contents[_LB] = [];
    }
    else if (output[_LB] != null && output[_LB][_m] != null) {
        contents[_LB] = de_LoadBalancers(__getArrayIfSingleItem(output[_LB][_m]), context);
    }
    return contents;
};
const de_CreateRuleOutput = (output, context) => {
    const contents = {};
    if (output.Rules === "") {
        contents[_Ru] = [];
    }
    else if (output[_Ru] != null && output[_Ru][_m] != null) {
        contents[_Ru] = de_Rules(__getArrayIfSingleItem(output[_Ru][_m]), context);
    }
    return contents;
};
const de_CreateTargetGroupOutput = (output, context) => {
    const contents = {};
    if (output.TargetGroups === "") {
        contents[_TG] = [];
    }
    else if (output[_TG] != null && output[_TG][_m] != null) {
        contents[_TG] = de_TargetGroups(__getArrayIfSingleItem(output[_TG][_m]), context);
    }
    return contents;
};
const de_CreateTrustStoreOutput = (output, context) => {
    const contents = {};
    if (output.TrustStores === "") {
        contents[_TS] = [];
    }
    else if (output[_TS] != null && output[_TS][_m] != null) {
        contents[_TS] = de_TrustStores(__getArrayIfSingleItem(output[_TS][_m]), context);
    }
    return contents;
};
const de_DeleteAssociationSameAccountException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_DeleteListenerOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_DeleteLoadBalancerOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_DeleteRuleOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_DeleteSharedTrustStoreAssociationOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_DeleteTargetGroupOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_DeleteTrustStoreOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_DeregisterTargetsOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_DescribeAccountLimitsOutput = (output, context) => {
    const contents = {};
    if (output.Limits === "") {
        contents[_Li] = [];
    }
    else if (output[_Li] != null && output[_Li][_m] != null) {
        contents[_Li] = de_Limits(__getArrayIfSingleItem(output[_Li][_m]), context);
    }
    if (output[_NM] != null) {
        contents[_NM] = __expectString(output[_NM]);
    }
    return contents;
};
const de_DescribeCapacityReservationOutput = (output, context) => {
    const contents = {};
    if (output[_LMT] != null) {
        contents[_LMT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_LMT]));
    }
    if (output[_DRR] != null) {
        contents[_DRR] = __strictParseInt32(output[_DRR]);
    }
    if (output[_MLBC] != null) {
        contents[_MLBC] = de_MinimumLoadBalancerCapacity(output[_MLBC], context);
    }
    if (output.CapacityReservationState === "") {
        contents[_CRS] = [];
    }
    else if (output[_CRS] != null && output[_CRS][_m] != null) {
        contents[_CRS] = de_ZonalCapacityReservationStates(__getArrayIfSingleItem(output[_CRS][_m]), context);
    }
    return contents;
};
const de_DescribeListenerAttributesOutput = (output, context) => {
    const contents = {};
    if (output.Attributes === "") {
        contents[_At] = [];
    }
    else if (output[_At] != null && output[_At][_m] != null) {
        contents[_At] = de_ListenerAttributes(__getArrayIfSingleItem(output[_At][_m]), context);
    }
    return contents;
};
const de_DescribeListenerCertificatesOutput = (output, context) => {
    const contents = {};
    if (output.Certificates === "") {
        contents[_C] = [];
    }
    else if (output[_C] != null && output[_C][_m] != null) {
        contents[_C] = de_CertificateList(__getArrayIfSingleItem(output[_C][_m]), context);
    }
    if (output[_NM] != null) {
        contents[_NM] = __expectString(output[_NM]);
    }
    return contents;
};
const de_DescribeListenersOutput = (output, context) => {
    const contents = {};
    if (output.Listeners === "") {
        contents[_L] = [];
    }
    else if (output[_L] != null && output[_L][_m] != null) {
        contents[_L] = de_Listeners(__getArrayIfSingleItem(output[_L][_m]), context);
    }
    if (output[_NM] != null) {
        contents[_NM] = __expectString(output[_NM]);
    }
    return contents;
};
const de_DescribeLoadBalancerAttributesOutput = (output, context) => {
    const contents = {};
    if (output.Attributes === "") {
        contents[_At] = [];
    }
    else if (output[_At] != null && output[_At][_m] != null) {
        contents[_At] = de_LoadBalancerAttributes(__getArrayIfSingleItem(output[_At][_m]), context);
    }
    return contents;
};
const de_DescribeLoadBalancersOutput = (output, context) => {
    const contents = {};
    if (output.LoadBalancers === "") {
        contents[_LB] = [];
    }
    else if (output[_LB] != null && output[_LB][_m] != null) {
        contents[_LB] = de_LoadBalancers(__getArrayIfSingleItem(output[_LB][_m]), context);
    }
    if (output[_NM] != null) {
        contents[_NM] = __expectString(output[_NM]);
    }
    return contents;
};
const de_DescribeRulesOutput = (output, context) => {
    const contents = {};
    if (output.Rules === "") {
        contents[_Ru] = [];
    }
    else if (output[_Ru] != null && output[_Ru][_m] != null) {
        contents[_Ru] = de_Rules(__getArrayIfSingleItem(output[_Ru][_m]), context);
    }
    if (output[_NM] != null) {
        contents[_NM] = __expectString(output[_NM]);
    }
    return contents;
};
const de_DescribeSSLPoliciesOutput = (output, context) => {
    const contents = {};
    if (output.SslPolicies === "") {
        contents[_SPs] = [];
    }
    else if (output[_SPs] != null && output[_SPs][_m] != null) {
        contents[_SPs] = de_SslPolicies(__getArrayIfSingleItem(output[_SPs][_m]), context);
    }
    if (output[_NM] != null) {
        contents[_NM] = __expectString(output[_NM]);
    }
    return contents;
};
const de_DescribeTagsOutput = (output, context) => {
    const contents = {};
    if (output.TagDescriptions === "") {
        contents[_TD] = [];
    }
    else if (output[_TD] != null && output[_TD][_m] != null) {
        contents[_TD] = de_TagDescriptions(__getArrayIfSingleItem(output[_TD][_m]), context);
    }
    return contents;
};
const de_DescribeTargetGroupAttributesOutput = (output, context) => {
    const contents = {};
    if (output.Attributes === "") {
        contents[_At] = [];
    }
    else if (output[_At] != null && output[_At][_m] != null) {
        contents[_At] = de_TargetGroupAttributes(__getArrayIfSingleItem(output[_At][_m]), context);
    }
    return contents;
};
const de_DescribeTargetGroupsOutput = (output, context) => {
    const contents = {};
    if (output.TargetGroups === "") {
        contents[_TG] = [];
    }
    else if (output[_TG] != null && output[_TG][_m] != null) {
        contents[_TG] = de_TargetGroups(__getArrayIfSingleItem(output[_TG][_m]), context);
    }
    if (output[_NM] != null) {
        contents[_NM] = __expectString(output[_NM]);
    }
    return contents;
};
const de_DescribeTargetHealthOutput = (output, context) => {
    const contents = {};
    if (output.TargetHealthDescriptions === "") {
        contents[_THD] = [];
    }
    else if (output[_THD] != null && output[_THD][_m] != null) {
        contents[_THD] = de_TargetHealthDescriptions(__getArrayIfSingleItem(output[_THD][_m]), context);
    }
    return contents;
};
const de_DescribeTrustStoreAssociationsOutput = (output, context) => {
    const contents = {};
    if (output.TrustStoreAssociations === "") {
        contents[_TSAru] = [];
    }
    else if (output[_TSAru] != null && output[_TSAru][_m] != null) {
        contents[_TSAru] = de_TrustStoreAssociations(__getArrayIfSingleItem(output[_TSAru][_m]), context);
    }
    if (output[_NM] != null) {
        contents[_NM] = __expectString(output[_NM]);
    }
    return contents;
};
const de_DescribeTrustStoreRevocation = (output, context) => {
    const contents = {};
    if (output[_TSA] != null) {
        contents[_TSA] = __expectString(output[_TSA]);
    }
    if (output[_RIe] != null) {
        contents[_RIe] = __strictParseLong(output[_RIe]);
    }
    if (output[_RTev] != null) {
        contents[_RTev] = __expectString(output[_RTev]);
    }
    if (output[_NORE] != null) {
        contents[_NORE] = __strictParseLong(output[_NORE]);
    }
    return contents;
};
const de_DescribeTrustStoreRevocationResponse = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DescribeTrustStoreRevocation(entry, context);
    });
};
const de_DescribeTrustStoreRevocationsOutput = (output, context) => {
    const contents = {};
    if (output.TrustStoreRevocations === "") {
        contents[_TSR] = [];
    }
    else if (output[_TSR] != null && output[_TSR][_m] != null) {
        contents[_TSR] = de_DescribeTrustStoreRevocationResponse(__getArrayIfSingleItem(output[_TSR][_m]), context);
    }
    if (output[_NM] != null) {
        contents[_NM] = __expectString(output[_NM]);
    }
    return contents;
};
const de_DescribeTrustStoresOutput = (output, context) => {
    const contents = {};
    if (output.TrustStores === "") {
        contents[_TS] = [];
    }
    else if (output[_TS] != null && output[_TS][_m] != null) {
        contents[_TS] = de_TrustStores(__getArrayIfSingleItem(output[_TS][_m]), context);
    }
    if (output[_NM] != null) {
        contents[_NM] = __expectString(output[_NM]);
    }
    return contents;
};
const de_DuplicateListenerException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_DuplicateLoadBalancerNameException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_DuplicateTagKeysException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_DuplicateTargetGroupNameException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_DuplicateTrustStoreNameException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_FixedResponseActionConfig = (output, context) => {
    const contents = {};
    if (output[_MB] != null) {
        contents[_MB] = __expectString(output[_MB]);
    }
    if (output[_SC] != null) {
        contents[_SC] = __expectString(output[_SC]);
    }
    if (output[_CT] != null) {
        contents[_CT] = __expectString(output[_CT]);
    }
    return contents;
};
const de_ForwardActionConfig = (output, context) => {
    const contents = {};
    if (output.TargetGroups === "") {
        contents[_TG] = [];
    }
    else if (output[_TG] != null && output[_TG][_m] != null) {
        contents[_TG] = de_TargetGroupList(__getArrayIfSingleItem(output[_TG][_m]), context);
    }
    if (output[_TGSC] != null) {
        contents[_TGSC] = de_TargetGroupStickinessConfig(output[_TGSC], context);
    }
    return contents;
};
const de_GetResourcePolicyOutput = (output, context) => {
    const contents = {};
    if (output[_Pol] != null) {
        contents[_Pol] = __expectString(output[_Pol]);
    }
    return contents;
};
const de_GetTrustStoreCaCertificatesBundleOutput = (output, context) => {
    const contents = {};
    if (output[_Lo] != null) {
        contents[_Lo] = __expectString(output[_Lo]);
    }
    return contents;
};
const de_GetTrustStoreRevocationContentOutput = (output, context) => {
    const contents = {};
    if (output[_Lo] != null) {
        contents[_Lo] = __expectString(output[_Lo]);
    }
    return contents;
};
const de_HealthUnavailableException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_HostHeaderConditionConfig = (output, context) => {
    const contents = {};
    if (output.Values === "") {
        contents[_Va] = [];
    }
    else if (output[_Va] != null && output[_Va][_m] != null) {
        contents[_Va] = de_ListOfString(__getArrayIfSingleItem(output[_Va][_m]), context);
    }
    return contents;
};
const de_HttpHeaderConditionConfig = (output, context) => {
    const contents = {};
    if (output[_HHN] != null) {
        contents[_HHN] = __expectString(output[_HHN]);
    }
    if (output.Values === "") {
        contents[_Va] = [];
    }
    else if (output[_Va] != null && output[_Va][_m] != null) {
        contents[_Va] = de_ListOfString(__getArrayIfSingleItem(output[_Va][_m]), context);
    }
    return contents;
};
const de_HttpRequestMethodConditionConfig = (output, context) => {
    const contents = {};
    if (output.Values === "") {
        contents[_Va] = [];
    }
    else if (output[_Va] != null && output[_Va][_m] != null) {
        contents[_Va] = de_ListOfString(__getArrayIfSingleItem(output[_Va][_m]), context);
    }
    return contents;
};
const de_IncompatibleProtocolsException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_InsufficientCapacityException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_InvalidCaCertificatesBundleException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_InvalidConfigurationRequestException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_InvalidLoadBalancerActionException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_InvalidRevocationContentException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_InvalidSchemeException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_InvalidSecurityGroupException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_InvalidSubnetException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_InvalidTargetException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_IpamPools = (output, context) => {
    const contents = {};
    if (output[_IIPI] != null) {
        contents[_IIPI] = __expectString(output[_IIPI]);
    }
    return contents;
};
const de_Limit = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = __expectString(output[_N]);
    }
    if (output[_Max] != null) {
        contents[_Max] = __expectString(output[_Max]);
    }
    return contents;
};
const de_Limits = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Limit(entry, context);
    });
};
const de_Listener = (output, context) => {
    const contents = {};
    if (output[_LA] != null) {
        contents[_LA] = __expectString(output[_LA]);
    }
    if (output[_LBA] != null) {
        contents[_LBA] = __expectString(output[_LBA]);
    }
    if (output[_Po] != null) {
        contents[_Po] = __strictParseInt32(output[_Po]);
    }
    if (output[_P] != null) {
        contents[_P] = __expectString(output[_P]);
    }
    if (output.Certificates === "") {
        contents[_C] = [];
    }
    else if (output[_C] != null && output[_C][_m] != null) {
        contents[_C] = de_CertificateList(__getArrayIfSingleItem(output[_C][_m]), context);
    }
    if (output[_SP] != null) {
        contents[_SP] = __expectString(output[_SP]);
    }
    if (output.DefaultActions === "") {
        contents[_DA] = [];
    }
    else if (output[_DA] != null && output[_DA][_m] != null) {
        contents[_DA] = de_Actions(__getArrayIfSingleItem(output[_DA][_m]), context);
    }
    if (output.AlpnPolicy === "") {
        contents[_AP] = [];
    }
    else if (output[_AP] != null && output[_AP][_m] != null) {
        contents[_AP] = de_AlpnPolicyName(__getArrayIfSingleItem(output[_AP][_m]), context);
    }
    if (output[_MA] != null) {
        contents[_MA] = de_MutualAuthenticationAttributes(output[_MA], context);
    }
    return contents;
};
const de_ListenerAttribute = (output, context) => {
    const contents = {};
    if (output[_K] != null) {
        contents[_K] = __expectString(output[_K]);
    }
    if (output[_Val] != null) {
        contents[_Val] = __expectString(output[_Val]);
    }
    return contents;
};
const de_ListenerAttributes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ListenerAttribute(entry, context);
    });
};
const de_ListenerNotFoundException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_Listeners = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Listener(entry, context);
    });
};
const de_ListOfString = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_LoadBalancer = (output, context) => {
    const contents = {};
    if (output[_LBA] != null) {
        contents[_LBA] = __expectString(output[_LBA]);
    }
    if (output[_DNSN] != null) {
        contents[_DNSN] = __expectString(output[_DNSN]);
    }
    if (output[_CHZI] != null) {
        contents[_CHZI] = __expectString(output[_CHZI]);
    }
    if (output[_CTr] != null) {
        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CTr]));
    }
    if (output[_LBN] != null) {
        contents[_LBN] = __expectString(output[_LBN]);
    }
    if (output[_Sc] != null) {
        contents[_Sc] = __expectString(output[_Sc]);
    }
    if (output[_VI] != null) {
        contents[_VI] = __expectString(output[_VI]);
    }
    if (output[_St] != null) {
        contents[_St] = de_LoadBalancerState(output[_St], context);
    }
    if (output[_T] != null) {
        contents[_T] = __expectString(output[_T]);
    }
    if (output.AvailabilityZones === "") {
        contents[_AZv] = [];
    }
    else if (output[_AZv] != null && output[_AZv][_m] != null) {
        contents[_AZv] = de_AvailabilityZones(__getArrayIfSingleItem(output[_AZv][_m]), context);
    }
    if (output.SecurityGroups === "") {
        contents[_SG] = [];
    }
    else if (output[_SG] != null && output[_SG][_m] != null) {
        contents[_SG] = de_SecurityGroups(__getArrayIfSingleItem(output[_SG][_m]), context);
    }
    if (output[_IAT] != null) {
        contents[_IAT] = __expectString(output[_IAT]);
    }
    if (output[_COIP] != null) {
        contents[_COIP] = __expectString(output[_COIP]);
    }
    if (output[_ESGIROPLT] != null) {
        contents[_ESGIROPLT] = __expectString(output[_ESGIROPLT]);
    }
    if (output[_EPFISN] != null) {
        contents[_EPFISN] = __expectString(output[_EPFISN]);
    }
    if (output[_IP] != null) {
        contents[_IP] = de_IpamPools(output[_IP], context);
    }
    return contents;
};
const de_LoadBalancerAddress = (output, context) => {
    const contents = {};
    if (output[_IA] != null) {
        contents[_IA] = __expectString(output[_IA]);
    }
    if (output[_AI] != null) {
        contents[_AI] = __expectString(output[_AI]);
    }
    if (output[_PIPA] != null) {
        contents[_PIPA] = __expectString(output[_PIPA]);
    }
    if (output[_IPA] != null) {
        contents[_IPA] = __expectString(output[_IPA]);
    }
    return contents;
};
const de_LoadBalancerAddresses = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LoadBalancerAddress(entry, context);
    });
};
const de_LoadBalancerArns = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_LoadBalancerAttribute = (output, context) => {
    const contents = {};
    if (output[_K] != null) {
        contents[_K] = __expectString(output[_K]);
    }
    if (output[_Val] != null) {
        contents[_Val] = __expectString(output[_Val]);
    }
    return contents;
};
const de_LoadBalancerAttributes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LoadBalancerAttribute(entry, context);
    });
};
const de_LoadBalancerNotFoundException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_LoadBalancers = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LoadBalancer(entry, context);
    });
};
const de_LoadBalancerState = (output, context) => {
    const contents = {};
    if (output[_Cod] != null) {
        contents[_Cod] = __expectString(output[_Cod]);
    }
    if (output[_R] != null) {
        contents[_R] = __expectString(output[_R]);
    }
    return contents;
};
const de_Matcher = (output, context) => {
    const contents = {};
    if (output[_HC] != null) {
        contents[_HC] = __expectString(output[_HC]);
    }
    if (output[_GC] != null) {
        contents[_GC] = __expectString(output[_GC]);
    }
    return contents;
};
const de_MinimumLoadBalancerCapacity = (output, context) => {
    const contents = {};
    if (output[_CU] != null) {
        contents[_CU] = __strictParseInt32(output[_CU]);
    }
    return contents;
};
const de_ModifyCapacityReservationOutput = (output, context) => {
    const contents = {};
    if (output[_LMT] != null) {
        contents[_LMT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_LMT]));
    }
    if (output[_DRR] != null) {
        contents[_DRR] = __strictParseInt32(output[_DRR]);
    }
    if (output[_MLBC] != null) {
        contents[_MLBC] = de_MinimumLoadBalancerCapacity(output[_MLBC], context);
    }
    if (output.CapacityReservationState === "") {
        contents[_CRS] = [];
    }
    else if (output[_CRS] != null && output[_CRS][_m] != null) {
        contents[_CRS] = de_ZonalCapacityReservationStates(__getArrayIfSingleItem(output[_CRS][_m]), context);
    }
    return contents;
};
const de_ModifyIpPoolsOutput = (output, context) => {
    const contents = {};
    if (output[_IP] != null) {
        contents[_IP] = de_IpamPools(output[_IP], context);
    }
    return contents;
};
const de_ModifyListenerAttributesOutput = (output, context) => {
    const contents = {};
    if (output.Attributes === "") {
        contents[_At] = [];
    }
    else if (output[_At] != null && output[_At][_m] != null) {
        contents[_At] = de_ListenerAttributes(__getArrayIfSingleItem(output[_At][_m]), context);
    }
    return contents;
};
const de_ModifyListenerOutput = (output, context) => {
    const contents = {};
    if (output.Listeners === "") {
        contents[_L] = [];
    }
    else if (output[_L] != null && output[_L][_m] != null) {
        contents[_L] = de_Listeners(__getArrayIfSingleItem(output[_L][_m]), context);
    }
    return contents;
};
const de_ModifyLoadBalancerAttributesOutput = (output, context) => {
    const contents = {};
    if (output.Attributes === "") {
        contents[_At] = [];
    }
    else if (output[_At] != null && output[_At][_m] != null) {
        contents[_At] = de_LoadBalancerAttributes(__getArrayIfSingleItem(output[_At][_m]), context);
    }
    return contents;
};
const de_ModifyRuleOutput = (output, context) => {
    const contents = {};
    if (output.Rules === "") {
        contents[_Ru] = [];
    }
    else if (output[_Ru] != null && output[_Ru][_m] != null) {
        contents[_Ru] = de_Rules(__getArrayIfSingleItem(output[_Ru][_m]), context);
    }
    return contents;
};
const de_ModifyTargetGroupAttributesOutput = (output, context) => {
    const contents = {};
    if (output.Attributes === "") {
        contents[_At] = [];
    }
    else if (output[_At] != null && output[_At][_m] != null) {
        contents[_At] = de_TargetGroupAttributes(__getArrayIfSingleItem(output[_At][_m]), context);
    }
    return contents;
};
const de_ModifyTargetGroupOutput = (output, context) => {
    const contents = {};
    if (output.TargetGroups === "") {
        contents[_TG] = [];
    }
    else if (output[_TG] != null && output[_TG][_m] != null) {
        contents[_TG] = de_TargetGroups(__getArrayIfSingleItem(output[_TG][_m]), context);
    }
    return contents;
};
const de_ModifyTrustStoreOutput = (output, context) => {
    const contents = {};
    if (output.TrustStores === "") {
        contents[_TS] = [];
    }
    else if (output[_TS] != null && output[_TS][_m] != null) {
        contents[_TS] = de_TrustStores(__getArrayIfSingleItem(output[_TS][_m]), context);
    }
    return contents;
};
const de_MutualAuthenticationAttributes = (output, context) => {
    const contents = {};
    if (output[_Mo] != null) {
        contents[_Mo] = __expectString(output[_Mo]);
    }
    if (output[_TSA] != null) {
        contents[_TSA] = __expectString(output[_TSA]);
    }
    if (output[_ICCE] != null) {
        contents[_ICCE] = __parseBoolean(output[_ICCE]);
    }
    if (output[_TSAS] != null) {
        contents[_TSAS] = __expectString(output[_TSAS]);
    }
    if (output[_ATSCN] != null) {
        contents[_ATSCN] = __expectString(output[_ATSCN]);
    }
    return contents;
};
const de_OperationNotPermittedException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_PathPatternConditionConfig = (output, context) => {
    const contents = {};
    if (output.Values === "") {
        contents[_Va] = [];
    }
    else if (output[_Va] != null && output[_Va][_m] != null) {
        contents[_Va] = de_ListOfString(__getArrayIfSingleItem(output[_Va][_m]), context);
    }
    return contents;
};
const de_PriorityInUseException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_PriorRequestNotCompleteException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_QueryStringConditionConfig = (output, context) => {
    const contents = {};
    if (output.Values === "") {
        contents[_Va] = [];
    }
    else if (output[_Va] != null && output[_Va][_m] != null) {
        contents[_Va] = de_QueryStringKeyValuePairList(__getArrayIfSingleItem(output[_Va][_m]), context);
    }
    return contents;
};
const de_QueryStringKeyValuePair = (output, context) => {
    const contents = {};
    if (output[_K] != null) {
        contents[_K] = __expectString(output[_K]);
    }
    if (output[_Val] != null) {
        contents[_Val] = __expectString(output[_Val]);
    }
    return contents;
};
const de_QueryStringKeyValuePairList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_QueryStringKeyValuePair(entry, context);
    });
};
const de_RedirectActionConfig = (output, context) => {
    const contents = {};
    if (output[_P] != null) {
        contents[_P] = __expectString(output[_P]);
    }
    if (output[_Po] != null) {
        contents[_Po] = __expectString(output[_Po]);
    }
    if (output[_H] != null) {
        contents[_H] = __expectString(output[_H]);
    }
    if (output[_Pa] != null) {
        contents[_Pa] = __expectString(output[_Pa]);
    }
    if (output[_Q] != null) {
        contents[_Q] = __expectString(output[_Q]);
    }
    if (output[_SC] != null) {
        contents[_SC] = __expectString(output[_SC]);
    }
    return contents;
};
const de_RegisterTargetsOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_RemoveListenerCertificatesOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_RemoveTagsOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_RemoveTrustStoreRevocationsOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_ResourceInUseException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_ResourceNotFoundException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_RevocationContentNotFoundException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_RevocationIdNotFoundException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_Rule = (output, context) => {
    const contents = {};
    if (output[_RAu] != null) {
        contents[_RAu] = __expectString(output[_RAu]);
    }
    if (output[_Pr] != null) {
        contents[_Pr] = __expectString(output[_Pr]);
    }
    if (output.Conditions === "") {
        contents[_Co] = [];
    }
    else if (output[_Co] != null && output[_Co][_m] != null) {
        contents[_Co] = de_RuleConditionList(__getArrayIfSingleItem(output[_Co][_m]), context);
    }
    if (output.Actions === "") {
        contents[_Ac] = [];
    }
    else if (output[_Ac] != null && output[_Ac][_m] != null) {
        contents[_Ac] = de_Actions(__getArrayIfSingleItem(output[_Ac][_m]), context);
    }
    if (output[_ID] != null) {
        contents[_ID] = __parseBoolean(output[_ID]);
    }
    return contents;
};
const de_RuleCondition = (output, context) => {
    const contents = {};
    if (output[_F] != null) {
        contents[_F] = __expectString(output[_F]);
    }
    if (output.Values === "") {
        contents[_Va] = [];
    }
    else if (output[_Va] != null && output[_Va][_m] != null) {
        contents[_Va] = de_ListOfString(__getArrayIfSingleItem(output[_Va][_m]), context);
    }
    if (output[_HHC] != null) {
        contents[_HHC] = de_HostHeaderConditionConfig(output[_HHC], context);
    }
    if (output[_PPC] != null) {
        contents[_PPC] = de_PathPatternConditionConfig(output[_PPC], context);
    }
    if (output[_HHCt] != null) {
        contents[_HHCt] = de_HttpHeaderConditionConfig(output[_HHCt], context);
    }
    if (output[_QSC] != null) {
        contents[_QSC] = de_QueryStringConditionConfig(output[_QSC], context);
    }
    if (output[_HRMC] != null) {
        contents[_HRMC] = de_HttpRequestMethodConditionConfig(output[_HRMC], context);
    }
    if (output[_SIC] != null) {
        contents[_SIC] = de_SourceIpConditionConfig(output[_SIC], context);
    }
    return contents;
};
const de_RuleConditionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RuleCondition(entry, context);
    });
};
const de_RuleNotFoundException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_Rules = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Rule(entry, context);
    });
};
const de_SecurityGroups = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_SetIpAddressTypeOutput = (output, context) => {
    const contents = {};
    if (output[_IAT] != null) {
        contents[_IAT] = __expectString(output[_IAT]);
    }
    return contents;
};
const de_SetRulePrioritiesOutput = (output, context) => {
    const contents = {};
    if (output.Rules === "") {
        contents[_Ru] = [];
    }
    else if (output[_Ru] != null && output[_Ru][_m] != null) {
        contents[_Ru] = de_Rules(__getArrayIfSingleItem(output[_Ru][_m]), context);
    }
    return contents;
};
const de_SetSecurityGroupsOutput = (output, context) => {
    const contents = {};
    if (output.SecurityGroupIds === "") {
        contents[_SGI] = [];
    }
    else if (output[_SGI] != null && output[_SGI][_m] != null) {
        contents[_SGI] = de_SecurityGroups(__getArrayIfSingleItem(output[_SGI][_m]), context);
    }
    if (output[_ESGIROPLT] != null) {
        contents[_ESGIROPLT] = __expectString(output[_ESGIROPLT]);
    }
    return contents;
};
const de_SetSubnetsOutput = (output, context) => {
    const contents = {};
    if (output.AvailabilityZones === "") {
        contents[_AZv] = [];
    }
    else if (output[_AZv] != null && output[_AZv][_m] != null) {
        contents[_AZv] = de_AvailabilityZones(__getArrayIfSingleItem(output[_AZv][_m]), context);
    }
    if (output[_IAT] != null) {
        contents[_IAT] = __expectString(output[_IAT]);
    }
    if (output[_EPFISN] != null) {
        contents[_EPFISN] = __expectString(output[_EPFISN]);
    }
    return contents;
};
const de_SourceIpConditionConfig = (output, context) => {
    const contents = {};
    if (output.Values === "") {
        contents[_Va] = [];
    }
    else if (output[_Va] != null && output[_Va][_m] != null) {
        contents[_Va] = de_ListOfString(__getArrayIfSingleItem(output[_Va][_m]), context);
    }
    return contents;
};
const de_SourceNatIpv6Prefixes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_SslPolicies = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SslPolicy(entry, context);
    });
};
const de_SslPolicy = (output, context) => {
    const contents = {};
    if (output.SslProtocols === "") {
        contents[_SPsl] = [];
    }
    else if (output[_SPsl] != null && output[_SPsl][_m] != null) {
        contents[_SPsl] = de_SslProtocols(__getArrayIfSingleItem(output[_SPsl][_m]), context);
    }
    if (output.Ciphers === "") {
        contents[_Ci] = [];
    }
    else if (output[_Ci] != null && output[_Ci][_m] != null) {
        contents[_Ci] = de_Ciphers(__getArrayIfSingleItem(output[_Ci][_m]), context);
    }
    if (output[_N] != null) {
        contents[_N] = __expectString(output[_N]);
    }
    if (output.SupportedLoadBalancerTypes === "") {
        contents[_SLBT] = [];
    }
    else if (output[_SLBT] != null && output[_SLBT][_m] != null) {
        contents[_SLBT] = de_ListOfString(__getArrayIfSingleItem(output[_SLBT][_m]), context);
    }
    return contents;
};
const de_SSLPolicyNotFoundException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_SslProtocols = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_SubnetNotFoundException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_Tag = (output, context) => {
    const contents = {};
    if (output[_K] != null) {
        contents[_K] = __expectString(output[_K]);
    }
    if (output[_Val] != null) {
        contents[_Val] = __expectString(output[_Val]);
    }
    return contents;
};
const de_TagDescription = (output, context) => {
    const contents = {};
    if (output[_RAe] != null) {
        contents[_RAe] = __expectString(output[_RAe]);
    }
    if (output.Tags === "") {
        contents[_Ta] = [];
    }
    else if (output[_Ta] != null && output[_Ta][_m] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_Ta][_m]), context);
    }
    return contents;
};
const de_TagDescriptions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TagDescription(entry, context);
    });
};
const de_TagList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Tag(entry, context);
    });
};
const de_TargetDescription = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = __expectString(output[_Id]);
    }
    if (output[_Po] != null) {
        contents[_Po] = __strictParseInt32(output[_Po]);
    }
    if (output[_AZ] != null) {
        contents[_AZ] = __expectString(output[_AZ]);
    }
    return contents;
};
const de_TargetGroup = (output, context) => {
    const contents = {};
    if (output[_TGA] != null) {
        contents[_TGA] = __expectString(output[_TGA]);
    }
    if (output[_TGN] != null) {
        contents[_TGN] = __expectString(output[_TGN]);
    }
    if (output[_P] != null) {
        contents[_P] = __expectString(output[_P]);
    }
    if (output[_Po] != null) {
        contents[_Po] = __strictParseInt32(output[_Po]);
    }
    if (output[_VI] != null) {
        contents[_VI] = __expectString(output[_VI]);
    }
    if (output[_HCP] != null) {
        contents[_HCP] = __expectString(output[_HCP]);
    }
    if (output[_HCPe] != null) {
        contents[_HCPe] = __expectString(output[_HCPe]);
    }
    if (output[_HCE] != null) {
        contents[_HCE] = __parseBoolean(output[_HCE]);
    }
    if (output[_HCIS] != null) {
        contents[_HCIS] = __strictParseInt32(output[_HCIS]);
    }
    if (output[_HCTS] != null) {
        contents[_HCTS] = __strictParseInt32(output[_HCTS]);
    }
    if (output[_HTC] != null) {
        contents[_HTC] = __strictParseInt32(output[_HTC]);
    }
    if (output[_UTC] != null) {
        contents[_UTC] = __strictParseInt32(output[_UTC]);
    }
    if (output[_HCPea] != null) {
        contents[_HCPea] = __expectString(output[_HCPea]);
    }
    if (output[_M] != null) {
        contents[_M] = de_Matcher(output[_M], context);
    }
    if (output.LoadBalancerArns === "") {
        contents[_LBAo] = [];
    }
    else if (output[_LBAo] != null && output[_LBAo][_m] != null) {
        contents[_LBAo] = de_LoadBalancerArns(__getArrayIfSingleItem(output[_LBAo][_m]), context);
    }
    if (output[_TT] != null) {
        contents[_TT] = __expectString(output[_TT]);
    }
    if (output[_PV] != null) {
        contents[_PV] = __expectString(output[_PV]);
    }
    if (output[_IAT] != null) {
        contents[_IAT] = __expectString(output[_IAT]);
    }
    return contents;
};
const de_TargetGroupAssociationLimitException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_TargetGroupAttribute = (output, context) => {
    const contents = {};
    if (output[_K] != null) {
        contents[_K] = __expectString(output[_K]);
    }
    if (output[_Val] != null) {
        contents[_Val] = __expectString(output[_Val]);
    }
    return contents;
};
const de_TargetGroupAttributes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TargetGroupAttribute(entry, context);
    });
};
const de_TargetGroupList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TargetGroupTuple(entry, context);
    });
};
const de_TargetGroupNotFoundException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_TargetGroups = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TargetGroup(entry, context);
    });
};
const de_TargetGroupStickinessConfig = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = __parseBoolean(output[_E]);
    }
    if (output[_DS] != null) {
        contents[_DS] = __strictParseInt32(output[_DS]);
    }
    return contents;
};
const de_TargetGroupTuple = (output, context) => {
    const contents = {};
    if (output[_TGA] != null) {
        contents[_TGA] = __expectString(output[_TGA]);
    }
    if (output[_W] != null) {
        contents[_W] = __strictParseInt32(output[_W]);
    }
    return contents;
};
const de_TargetHealth = (output, context) => {
    const contents = {};
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_R] != null) {
        contents[_R] = __expectString(output[_R]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    return contents;
};
const de_TargetHealthDescription = (output, context) => {
    const contents = {};
    if (output[_Targ] != null) {
        contents[_Targ] = de_TargetDescription(output[_Targ], context);
    }
    if (output[_HCPe] != null) {
        contents[_HCPe] = __expectString(output[_HCPe]);
    }
    if (output[_TH] != null) {
        contents[_TH] = de_TargetHealth(output[_TH], context);
    }
    if (output[_AD] != null) {
        contents[_AD] = de_AnomalyDetection(output[_AD], context);
    }
    if (output[_AO] != null) {
        contents[_AO] = de_AdministrativeOverride(output[_AO], context);
    }
    return contents;
};
const de_TargetHealthDescriptions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TargetHealthDescription(entry, context);
    });
};
const de_TooManyActionsException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_TooManyCertificatesException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_TooManyListenersException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_TooManyLoadBalancersException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_TooManyRegistrationsForTargetIdException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_TooManyRulesException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_TooManyTagsException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_TooManyTargetGroupsException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_TooManyTargetsException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_TooManyTrustStoreRevocationEntriesException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_TooManyTrustStoresException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_TooManyUniqueTargetGroupsPerLoadBalancerException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_TrustStore = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = __expectString(output[_N]);
    }
    if (output[_TSA] != null) {
        contents[_TSA] = __expectString(output[_TSA]);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = __expectString(output[_Sta]);
    }
    if (output[_NOCC] != null) {
        contents[_NOCC] = __strictParseInt32(output[_NOCC]);
    }
    if (output[_TRE] != null) {
        contents[_TRE] = __strictParseLong(output[_TRE]);
    }
    return contents;
};
const de_TrustStoreAssociation = (output, context) => {
    const contents = {};
    if (output[_RAe] != null) {
        contents[_RAe] = __expectString(output[_RAe]);
    }
    return contents;
};
const de_TrustStoreAssociationNotFoundException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_TrustStoreAssociations = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TrustStoreAssociation(entry, context);
    });
};
const de_TrustStoreInUseException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_TrustStoreNotFoundException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_TrustStoreNotReadyException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_TrustStoreRevocation = (output, context) => {
    const contents = {};
    if (output[_TSA] != null) {
        contents[_TSA] = __expectString(output[_TSA]);
    }
    if (output[_RIe] != null) {
        contents[_RIe] = __strictParseLong(output[_RIe]);
    }
    if (output[_RTev] != null) {
        contents[_RTev] = __expectString(output[_RTev]);
    }
    if (output[_NORE] != null) {
        contents[_NORE] = __strictParseLong(output[_NORE]);
    }
    return contents;
};
const de_TrustStoreRevocations = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TrustStoreRevocation(entry, context);
    });
};
const de_TrustStores = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TrustStore(entry, context);
    });
};
const de_UnsupportedProtocolException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_ZonalCapacityReservationState = (output, context) => {
    const contents = {};
    if (output[_St] != null) {
        contents[_St] = de_CapacityReservationStatus(output[_St], context);
    }
    if (output[_AZ] != null) {
        contents[_AZ] = __expectString(output[_AZ]);
    }
    if (output[_ECU] != null) {
        contents[_ECU] = __strictParseFloat(output[_ECU]);
    }
    return contents;
};
const de_ZonalCapacityReservationStates = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ZonalCapacityReservationState(entry, context);
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = withBaseException(__BaseException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new __HttpRequest(contents);
};
const SHARED_HEADERS = {
    "content-type": "application/x-www-form-urlencoded",
};
const _ = "2015-12-01";
const _A = "Action";
const _ACC = "AuthenticateCognitoConfig";
const _AD = "AnomalyDetection";
const _AE = "AuthorizationEndpoint";
const _AI = "AllocationId";
const _ALC = "AddListenerCertificates";
const _AO = "AdministrativeOverride";
const _AOC = "AuthenticateOidcConfig";
const _AP = "AlpnPolicy";
const _AREP = "AuthenticationRequestExtraParams";
const _AT = "AddTags";
const _ATSCN = "AdvertiseTrustStoreCaNames";
const _ATSR = "AddTrustStoreRevocations";
const _AZ = "AvailabilityZone";
const _AZv = "AvailabilityZones";
const _Ac = "Actions";
const _At = "Attributes";
const _C = "Certificates";
const _CA = "CertificateArn";
const _CCBSB = "CaCertificatesBundleS3Bucket";
const _CCBSK = "CaCertificatesBundleS3Key";
const _CCBSOV = "CaCertificatesBundleS3ObjectVersion";
const _CHZI = "CanonicalHostedZoneId";
const _CI = "ClientId";
const _CL = "CreateListener";
const _CLB = "CreateLoadBalancer";
const _COIP = "CustomerOwnedIpv4Pool";
const _CR = "CreateRule";
const _CRS = "CapacityReservationState";
const _CS = "ClientSecret";
const _CT = "ContentType";
const _CTG = "CreateTargetGroup";
const _CTS = "CreateTrustStore";
const _CTr = "CreatedTime";
const _CU = "CapacityUnits";
const _Ci = "Ciphers";
const _Co = "Conditions";
const _Cod = "Code";
const _D = "Description";
const _DA = "DefaultActions";
const _DAL = "DescribeAccountLimits";
const _DCR = "DescribeCapacityReservation";
const _DL = "DeleteListener";
const _DLA = "DescribeListenerAttributes";
const _DLB = "DeleteLoadBalancer";
const _DLBA = "DescribeLoadBalancerAttributes";
const _DLBe = "DescribeLoadBalancers";
const _DLC = "DescribeListenerCertificates";
const _DLe = "DescribeListeners";
const _DNSN = "DNSName";
const _DR = "DeleteRule";
const _DRR = "DecreaseRequestsRemaining";
const _DRe = "DescribeRules";
const _DS = "DurationSeconds";
const _DSSLP = "DescribeSSLPolicies";
const _DSTSA = "DeleteSharedTrustStoreAssociation";
const _DT = "DeregisterTargets";
const _DTG = "DeleteTargetGroup";
const _DTGA = "DescribeTargetGroupAttributes";
const _DTGe = "DescribeTargetGroups";
const _DTH = "DescribeTargetHealth";
const _DTS = "DeleteTrustStore";
const _DTSA = "DescribeTrustStoreAssociations";
const _DTSR = "DescribeTrustStoreRevocations";
const _DTSe = "DescribeTrustStores";
const _DTe = "DescribeTags";
const _E = "Enabled";
const _ECU = "EffectiveCapacityUnits";
const _EPFISN = "EnablePrefixForIpv6SourceNat";
const _ESGIROPLT = "EnforceSecurityGroupInboundRulesOnPrivateLinkTraffic";
const _F = "Field";
const _FC = "ForwardConfig";
const _FRC = "FixedResponseConfig";
const _GC = "GrpcCode";
const _GRP = "GetResourcePolicy";
const _GTSCCB = "GetTrustStoreCaCertificatesBundle";
const _GTSRC = "GetTrustStoreRevocationContent";
const _H = "Host";
const _HC = "HttpCode";
const _HCE = "HealthCheckEnabled";
const _HCIS = "HealthCheckIntervalSeconds";
const _HCP = "HealthCheckProtocol";
const _HCPe = "HealthCheckPort";
const _HCPea = "HealthCheckPath";
const _HCTS = "HealthCheckTimeoutSeconds";
const _HHC = "HostHeaderConfig";
const _HHCt = "HttpHeaderConfig";
const _HHN = "HttpHeaderName";
const _HRMC = "HttpRequestMethodConfig";
const _HTC = "HealthyThresholdCount";
const _I = "Issuer";
const _IA = "IpAddress";
const _IAT = "IpAddressType";
const _ICCE = "IgnoreClientCertificateExpiry";
const _ID = "IsDefault";
const _IIPI = "Ipv4IpamPoolId";
const _IP = "IpamPools";
const _IPA = "IPv6Address";
const _Id = "Id";
const _In = "Include";
const _K = "Key";
const _L = "Listeners";
const _LA = "ListenerArn";
const _LAi = "ListenerArns";
const _LB = "LoadBalancers";
const _LBA = "LoadBalancerArn";
const _LBAo = "LoadBalancerArns";
const _LBAoa = "LoadBalancerAddresses";
const _LBN = "LoadBalancerName";
const _LBT = "LoadBalancerType";
const _LMT = "LastModifiedTime";
const _Li = "Limits";
const _Lo = "Location";
const _M = "Matcher";
const _MA = "MutualAuthentication";
const _MB = "MessageBody";
const _MCR = "ModifyCapacityReservation";
const _MIE = "MitigationInEffect";
const _MIP = "ModifyIpPools";
const _ML = "ModifyListener";
const _MLA = "ModifyListenerAttributes";
const _MLBA = "ModifyLoadBalancerAttributes";
const _MLBC = "MinimumLoadBalancerCapacity";
const _MR = "ModifyRule";
const _MTG = "ModifyTargetGroup";
const _MTGA = "ModifyTargetGroupAttributes";
const _MTS = "ModifyTrustStore";
const _Ma = "Marker";
const _Max = "Max";
const _Me = "Message";
const _Mo = "Mode";
const _N = "Name";
const _NM = "NextMarker";
const _NOCC = "NumberOfCaCertificates";
const _NORE = "NumberOfRevokedEntries";
const _Na = "Names";
const _O = "Order";
const _OI = "OutpostId";
const _OUR = "OnUnauthenticatedRequest";
const _P = "Protocol";
const _PIPA = "PrivateIPv4Address";
const _PPC = "PathPatternConfig";
const _PS = "PageSize";
const _PV = "ProtocolVersion";
const _Pa = "Path";
const _Po = "Port";
const _Pol = "Policy";
const _Pr = "Priority";
const _Q = "Query";
const _QSC = "QueryStringConfig";
const _R = "Reason";
const _RA = "ResourceArns";
const _RAe = "ResourceArn";
const _RAu = "RuleArn";
const _RAul = "RuleArns";
const _RC = "RedirectConfig";
const _RCR = "ResetCapacityReservation";
const _RCe = "RevocationContents";
const _RI = "RevocationIds";
const _RIP = "RemoveIpamPools";
const _RIe = "RevocationId";
const _RLC = "RemoveListenerCertificates";
const _RP = "RulePriorities";
const _RT = "RegisterTargets";
const _RTSR = "RemoveTrustStoreRevocations";
const _RTe = "RemoveTags";
const _RTev = "RevocationType";
const _Re = "Result";
const _Ru = "Rules";
const _S = "Scope";
const _SB = "S3Bucket";
const _SC = "StatusCode";
const _SCN = "SessionCookieName";
const _SG = "SecurityGroups";
const _SGI = "SecurityGroupIds";
const _SI = "SubnetId";
const _SIAT = "SetIpAddressType";
const _SIC = "SourceIpConfig";
const _SK = "S3Key";
const _SLBT = "SupportedLoadBalancerTypes";
const _SM = "SubnetMappings";
const _SNIP = "SourceNatIpv6Prefix";
const _SNIPo = "SourceNatIpv6Prefixes";
const _SOV = "S3ObjectVersion";
const _SP = "SslPolicy";
const _SPs = "SslPolicies";
const _SPsl = "SslProtocols";
const _SRP = "SetRulePriorities";
const _SS = "SetSubnets";
const _SSG = "SetSecurityGroups";
const _ST = "SessionTimeout";
const _Sc = "Scheme";
const _St = "State";
const _Sta = "Status";
const _Su = "Subnets";
const _T = "Type";
const _TD = "TagDescriptions";
const _TE = "TokenEndpoint";
const _TG = "TargetGroups";
const _TGA = "TargetGroupArn";
const _TGAa = "TargetGroupArns";
const _TGN = "TargetGroupName";
const _TGSC = "TargetGroupStickinessConfig";
const _TH = "TargetHealth";
const _THD = "TargetHealthDescriptions";
const _TK = "TagKeys";
const _TRE = "TotalRevokedEntries";
const _TS = "TrustStores";
const _TSA = "TrustStoreArn";
const _TSAS = "TrustStoreAssociationStatus";
const _TSAr = "TrustStoreArns";
const _TSAru = "TrustStoreAssociations";
const _TSR = "TrustStoreRevocations";
const _TT = "TargetType";
const _Ta = "Tags";
const _Tar = "Targets";
const _Targ = "Target";
const _UECS = "UseExistingClientSecret";
const _UIE = "UserInfoEndpoint";
const _UPA = "UserPoolArn";
const _UPCI = "UserPoolClientId";
const _UPD = "UserPoolDomain";
const _UTC = "UnhealthyThresholdCount";
const _V = "Version";
const _VI = "VpcId";
const _Va = "Values";
const _Val = "Value";
const _W = "Weight";
const _ZN = "ZoneName";
const _e = "entry";
const _m = "member";
const buildFormUrlencodedString = (formEntries) => Object.entries(formEntries)
    .map(([key, value]) => __extendedEncodeURIComponent(key) + "=" + __extendedEncodeURIComponent(value))
    .join("&");
const loadQueryErrorCode = (output, data) => {
    if (data.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};
