"use strict";
/*
 * The Cloudformation refactoring API needs, in addition to the mappings, the
 * resulting templates for each affected stack. The resulting templates are
 * basically the synthesis produced, but with some differences:
 *
 * - Resources that exist in the local stacks, but not in the remote stacks, are
 *   not included.
 * - Resources that exist in the remote stacks, but not in the local stacks, are
 *   preserved.
 * - For resources that exist in both stacks, but have different properties, the
 *   deployed properties are used, but the references may need to be updated, if
 *   the resources they reference were moved in the refactoring.
 *
 * Why does the last difference exist, to begin with? By default, to establish
 * whether two given resources are the same, roughly speaking we compute the hash
 * of their properties and compare them. But there is a better source of resource
 * identity, that we can exploit when it is present: the physical name. In such
 * cases, we can track a resource move even if the properties are different, as
 * long as the physical name is the same.
 *
 * The process of computing the resulting templates consists in:
 *
 * 1. Computing a graph of deployed resources.
 * 2. Mapping edges and nodes according to the mappings (that we either
 *    computed or got directly from the user).
 * 3. Computing the resulting templates by traversing the graph and
 *    collecting the resources that are not mapped out, and updating the
 *    references to the resources that were moved.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateStackDefinitions = generateStackDefinitions;
const cloudformation_1 = require("./cloudformation");
const toolkit_error_1 = require("../../toolkit/toolkit-error");
function generateStackDefinitions(mappings, deployedStacks, localStacks) {
    const localExports = indexExports(localStacks);
    const deployedExports = indexExports(deployedStacks);
    const edgeMapper = new EdgeMapper(mappings);
    // Build a graph of the deployed stacks
    const deployedGraph = graph(deployedStacks, deployedExports);
    // Map all the edges, including their endpoints, to their new locations.
    const edges = edgeMapper.mapEdges(deployedGraph.edges);
    // All the edges have been mapped, which means that isolated nodes were left behind. Map them too.
    const nodes = mapNodes(deployedGraph.isolatedNodes, mappings);
    // Now we can generate the templates for each stack
    const templates = generateTemplates(edges, nodes, edgeMapper.affectedStackNames, localExports, deployedStacks);
    // Finally, generate the stack definitions, to be included in the refactor request.
    return Object.entries(templates).map(([stackName, template]) => ({
        StackName: stackName,
        TemplateBody: JSON.stringify(template),
    }));
}
function graph(deployedStacks, deployedExports) {
    const deployedNodeMap = buildNodes(deployedStacks);
    const deployedNodes = Array.from(deployedNodeMap.values());
    const edges = buildEdges(deployedNodeMap, deployedExports);
    const isolatedNodes = deployedNodes.filter((node) => {
        return !edges.some((edge) => edge.source.location.equalTo(node.location) ||
            edge.targets.some((target) => target.location.equalTo(node.location)));
    });
    return { edges, isolatedNodes };
}
function buildNodes(stacks) {
    const result = new Map();
    for (const stack of stacks) {
        const template = stack.template;
        for (const [logicalId, resource] of Object.entries(template.Resources ?? {})) {
            const location = new cloudformation_1.ResourceLocation(stack, logicalId);
            result.set(`${stack.stackName}.${logicalId}`, {
                location,
                rawValue: resource,
            });
        }
    }
    return result;
}
function buildEdges(nodeMap, exports) {
    const nodes = Array.from(nodeMap.values());
    return nodes.flatMap((node) => buildEdgesForResource(node, node.rawValue));
    function buildEdgesForResource(source, value, path = []) {
        if (!value || typeof value !== 'object')
            return [];
        if (Array.isArray(value)) {
            return value.flatMap((x, index) => buildEdgesForResource(source, x, path.concat(String(index))));
        }
        if ('Ref' in value) {
            return [makeRef(source.location.stack.stackName, value.Ref)];
        }
        if ('Fn::GetAtt' in value) {
            return [makeGetAtt(source.location.stack.stackName, value['Fn::GetAtt'])];
        }
        if ('Fn::ImportValue' in value) {
            const exportName = value['Fn::ImportValue'];
            const x = exports[exportName];
            if ('Ref' in x.value) {
                return [
                    {
                        ...makeRef(x.stackName, x.value.Ref),
                        reference: new ImportValue(Ref.INSTANCE),
                    },
                ];
            }
            if ('Fn::GetAtt' in x.value) {
                const getAtt = makeGetAtt(x.stackName, x.value['Fn::GetAtt']);
                return [
                    {
                        ...getAtt,
                        reference: new ImportValue(getAtt.reference),
                    },
                ];
            }
            return [];
        }
        if ('Fn::Sub' in value) {
            let inputString;
            let variables;
            const sub = value['Fn::Sub'];
            if (typeof sub === 'string') {
                inputString = sub;
            }
            else {
                [inputString, variables] = sub;
            }
            let varNames = Array.from(inputString.matchAll(/\${([a-zA-Z0-9_.]+)}/g))
                .map((x) => x[1])
                .filter((varName) => (value['Fn::Sub'][1] ?? {})[varName] == null);
            const edges = varNames.map((varName) => {
                return varName.includes('.')
                    ? makeGetAtt(source.location.stack.stackName, varName)
                    : makeRef(source.location.stack.stackName, varName);
            });
            const edgesFromInputString = [
                {
                    source,
                    targets: edges.flatMap((edge) => edge.targets),
                    reference: new Sub(inputString, varNames),
                    path: path.concat('Fn::Sub', '0'),
                },
            ];
            const edgesFromVariables = buildEdgesForResource(source, variables, path.concat('Fn::Sub', '1'));
            return [...edgesFromInputString, ...edgesFromVariables];
        }
        const edges = [];
        // DependsOn is only handled at the top level of the resource
        if ('DependsOn' in value && path.length === 0) {
            if (typeof value.DependsOn === 'string') {
                edges.push({
                    ...makeRef(source.location.stack.stackName, value.DependsOn),
                    reference: DependsOn.INSTANCE,
                });
            }
            else if (Array.isArray(value.DependsOn)) {
                edges.push({
                    source,
                    targets: value.DependsOn.flatMap((dependsOn) => makeRef(source.location.stack.stackName, dependsOn).targets),
                    path: path.concat('DependsOn'),
                    reference: DependsOn.INSTANCE,
                });
            }
        }
        edges.push(...Object.entries(value).flatMap(([k, v]) => buildEdgesForResource(source, v, path.concat(k))));
        return edges;
        function makeRef(stackName, logicalId) {
            const key = `${stackName}.${logicalId}`;
            const target = nodeMap.get(key);
            return {
                path,
                source,
                targets: [target],
                reference: Ref.INSTANCE,
            };
        }
        function makeGetAtt(stackName, att) {
            let logicalId = '';
            let attributeName = '';
            if (typeof att === 'string') {
                [logicalId, attributeName] = att.split(/\.(.*)/s);
            }
            else if (Array.isArray(att) && att.length === 2) {
                [logicalId, attributeName] = att;
            }
            const key = `${stackName}.${logicalId}`;
            const target = nodeMap.get(key);
            return {
                path,
                source,
                targets: [target],
                reference: new GetAtt(attributeName),
            };
        }
    }
}
function mapNodes(nodes, mappings) {
    return nodes.map((node) => {
        const newLocation = mapLocation(node.location, mappings);
        return {
            location: newLocation,
            rawValue: node.rawValue,
        };
    });
}
function generateTemplates(edges, nodes, stackNames, exports, deployedStacks) {
    updateReferences(edges, exports);
    const templates = {};
    // Take the CloudFormation raw value of each the node and put it into the appropriate template.
    const allNodes = unique(edges.flatMap((e) => [e.source, ...e.targets]).concat(nodes));
    allNodes.forEach((node) => {
        const stackName = node.location.stack.stackName;
        const logicalId = node.location.logicalResourceId;
        if (templates[stackName] === undefined) {
            templates[stackName] = {
                Resources: {},
            };
        }
        templates[stackName].Resources[logicalId] = node.rawValue;
    });
    // Add outputs to the templates
    edges.forEach((edge) => {
        if (edge.reference instanceof ImportValue) {
            const stackName = edge.targets[0].location.stack.stackName;
            const template = templates[stackName];
            template.Outputs = {
                ...(template.Outputs ?? {}),
                ...edge.reference.output,
            };
        }
    });
    // The freshly generated templates contain only resources and outputs.
    // Combine them with the existing templates to preserve metadata and other properties.
    return Object.fromEntries(stackNames.map((stackName) => {
        const oldTemplate = deployedStacks.find((s) => s.stackName === stackName)?.template ?? {};
        const newTemplate = templates[stackName] ?? { Resources: {} };
        const combinedTemplate = { ...oldTemplate, ...newTemplate };
        sanitizeDependencies(combinedTemplate);
        return [stackName, combinedTemplate];
    }));
}
/**
 * Update the CloudFormation resources based on information from the edges.
 * Each edge corresponds to a path in some resource object. The value at that
 * path is updated to the CloudFormation value represented by the edge's annotation.
 */
function updateReferences(edges, exports) {
    edges.forEach((edge) => {
        const cfnValue = edge.reference.toCfn(edge.targets, exports);
        const obj = edge.path.slice(0, edge.path.length - 1).reduce(getPropValue, edge.source.rawValue);
        setPropValue(obj, edge.path[edge.path.length - 1], cfnValue);
    });
    function getPropValue(obj, prop) {
        const index = parseInt(prop);
        return obj[Number.isNaN(index) ? prop : index];
    }
    function setPropValue(obj, prop, value) {
        const index = parseInt(prop);
        obj[Number.isNaN(index) ? prop : index] = value;
    }
}
class EdgeMapper {
    mappings;
    affectedStacks = new Set();
    nodeMap = new Map();
    constructor(mappings) {
        this.mappings = mappings;
    }
    /**
     * For each input edge, produce an output edge such that:
     *   - The source and targets are mapped to their new locations
     *   - The annotation is converted between in-stack and cross-stack references, as appropriate
     */
    mapEdges(edges) {
        return edges
            .map((edge) => {
            const oldSource = edge.source;
            const oldTargets = edge.targets;
            const newSource = this.mapNode(oldSource);
            const newTargets = oldTargets.map((t) => this.mapNode(t));
            const oldSourceStackName = oldSource.location.stack.stackName;
            const oldTargetStackName = oldTargets[0].location.stack.stackName;
            const newSourceStackName = newSource.location.stack.stackName;
            const newTargetStackName = newTargets[0].location.stack.stackName;
            this.affectedStacks.add(newSourceStackName);
            this.affectedStacks.add(newTargetStackName);
            this.affectedStacks.add(oldSourceStackName);
            this.affectedStacks.add(oldTargetStackName);
            let reference = edge.reference;
            if (oldSourceStackName === oldTargetStackName && newSourceStackName !== newTargetStackName) {
                if (edge.reference instanceof DependsOn) {
                    return undefined;
                }
                // in-stack reference to cross-stack reference: wrap the old annotation
                reference = new ImportValue(edge.reference);
            }
            else if (oldSourceStackName !== oldTargetStackName && newSourceStackName === newTargetStackName) {
                // cross-stack reference to in-stack reference: unwrap the old annotation
                if (edge.reference instanceof ImportValue) {
                    reference = edge.reference.reference;
                }
            }
            return {
                path: edge.path,
                source: newSource,
                targets: newTargets,
                reference,
            };
        })
            .filter((edge) => edge !== undefined);
    }
    get affectedStackNames() {
        const fromMappings = this.mappings.flatMap((m) => [m.source.stack.stackName, m.destination.stack.stackName]);
        return unique([...this.affectedStacks, ...fromMappings]);
    }
    mapNode(node) {
        const newLocation = mapLocation(node.location, this.mappings);
        const key = `${newLocation.stack.stackName}.${newLocation.logicalResourceId}`;
        if (!this.nodeMap.has(key)) {
            this.nodeMap.set(key, {
                location: newLocation,
                rawValue: node.rawValue,
            });
        }
        return this.nodeMap.get(key);
    }
}
function mapLocation(location, mappings) {
    const mapping = mappings.find((m) => m.source.equalTo(location));
    if (mapping) {
        return mapping.destination;
    }
    return location;
}
function indexExports(stacks) {
    return Object.fromEntries(stacks.flatMap((s) => Object.entries(s.template.Outputs ?? {})
        .filter(([_, o]) => typeof o.Export?.Name === 'string' && (o.Value.Ref != null || o.Value['Fn::GetAtt'] != null))
        .map(([name, o]) => [o.Export.Name, { stackName: s.stackName, outputName: name, value: o.Value }])));
}
function unique(arr) {
    return Array.from(new Set(arr));
}
/**
 * Updates the DependsOn property of all resources, removing references
 * to resources that do not exist in the template. Unlike Refs and GetAtts,
 * which get transformed to ImportValues when the referenced resource is
 * moved to another stack, DependsOn doesn't cross stack boundaries.
 */
function sanitizeDependencies(template) {
    const resources = template.Resources ?? {};
    for (const resource of Object.values(resources)) {
        if (typeof resource.DependsOn === 'string' && resources[resource.DependsOn] == null) {
            delete resource.DependsOn;
        }
        if (Array.isArray(resource.DependsOn)) {
            resource.DependsOn = resource.DependsOn.filter((dep) => resources[dep] != null);
            if (resource.DependsOn.length === 0) {
                delete resource.DependsOn;
            }
        }
    }
}
class Ref {
    static INSTANCE = new Ref();
    constructor() {
    }
    toCfn(targets) {
        return { Ref: targets[0].location.logicalResourceId };
    }
}
class GetAtt {
    attributeName;
    constructor(attributeName) {
        this.attributeName = attributeName;
    }
    toCfn(targets) {
        return {
            'Fn::GetAtt': [targets[0].location.logicalResourceId, this.attributeName],
        };
    }
}
class ImportValue {
    reference;
    outputName;
    outputContent;
    constructor(reference) {
        this.reference = reference;
    }
    toCfn(targets, exports) {
        const exp = this.findExport(targets, exports);
        if (exp) {
            this.outputName = exp[1].outputName;
            this.outputContent = {
                Value: exp[1].value,
                Export: {
                    Name: exp[0],
                },
            };
            return { 'Fn::ImportValue': exp[0] };
        }
        // TODO better message
        throw new toolkit_error_1.ToolkitError('Unknown export for ImportValue: ' + JSON.stringify(this.reference));
    }
    findExport(targets, exports) {
        const target = targets[0];
        if (this.reference instanceof Ref) {
            return Object.entries(exports).find(([_, exportValue]) => {
                return (exportValue.stackName === target.location.stack.stackName &&
                    exportValue.value.Ref === target.location.logicalResourceId);
            });
        }
        else {
            return Object.entries(exports).find(([_, exportValue]) => {
                const getAtt = this.reference;
                return (exportValue.stackName === target.location.stack.stackName &&
                    exportValue.value['Fn::GetAtt'] &&
                    ((exportValue.value['Fn::GetAtt'][0] === target.location.logicalResourceId &&
                        exportValue.value['Fn::GetAtt'][1] === getAtt.attributeName) ||
                        exportValue.value['Fn::GetAtt'] === `${target.location.logicalResourceId}.${getAtt.attributeName}`));
            });
        }
    }
    get output() {
        if (this.outputName == null) {
            throw new toolkit_error_1.ToolkitError('Cannot access output before calling toCfn');
        }
        return { [this.outputName]: this.outputContent };
    }
}
class Sub {
    inputString;
    varNames;
    constructor(inputString, varNames) {
        this.inputString = inputString;
        this.varNames = varNames;
    }
    toCfn(targets) {
        let inputString = this.inputString;
        this.varNames.forEach((varName, index) => {
            const [_, attr] = varName.split(/\.(.*)/s);
            const target = targets[index];
            inputString = inputString.replace(`\${${varName}`, `\${${target.location.logicalResourceId}${attr ? `.${attr}` : ''}`);
        });
        return inputString;
    }
}
class DependsOn {
    static INSTANCE = new DependsOn();
    constructor() {
    }
    toCfn(targets) {
        return targets.map((t) => t.location.logicalResourceId);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhY2stZGVmaW5pdGlvbnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzdGFjay1kZWZpbml0aW9ucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E0Qkc7O0FBT0gsNERBMEJDO0FBN0JELHFEQUFvRDtBQUNwRCwrREFBMkQ7QUFFM0QsU0FBZ0Isd0JBQXdCLENBQ3RDLFFBQTJCLEVBQzNCLGNBQXFDLEVBQ3JDLFdBQWtDO0lBRWxDLE1BQU0sWUFBWSxHQUFpQyxZQUFZLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDN0UsTUFBTSxlQUFlLEdBQWlDLFlBQVksQ0FBQyxjQUFjLENBQUMsQ0FBQztJQUNuRixNQUFNLFVBQVUsR0FBRyxJQUFJLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUU1Qyx1Q0FBdUM7SUFDdkMsTUFBTSxhQUFhLEdBQUcsS0FBSyxDQUFDLGNBQWMsRUFBRSxlQUFlLENBQUMsQ0FBQztJQUU3RCx3RUFBd0U7SUFDeEUsTUFBTSxLQUFLLEdBQUcsVUFBVSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7SUFFdkQsa0dBQWtHO0lBQ2xHLE1BQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsYUFBYSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBRTlELG1EQUFtRDtJQUNuRCxNQUFNLFNBQVMsR0FBRyxpQkFBaUIsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLFVBQVUsQ0FBQyxrQkFBa0IsRUFBRSxZQUFZLEVBQUUsY0FBYyxDQUFDLENBQUM7SUFFL0csbUZBQW1GO0lBQ25GLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLFNBQVMsRUFBRSxRQUFRLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUMvRCxTQUFTLEVBQUUsU0FBUztRQUNwQixZQUFZLEVBQUUsSUFBSSxDQUFD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ZHMsIGluIGFkZGl0aW9uIHRvIHRoZSBtYXBwaW5ncywgdGhlXG4gKiByZXN1bHRpbmcgdGVtcGxhdGVzIGZvciBlYWNoIGFmZmVjdGVkIHN0YWNrLiBUaGUgcmVzdWx0aW5nIHRlbXBsYXRlcyBhcmVcbiAqIGJhc2ljYWxseSB0aGUgc3ludGhlc2lzIHByb2R1Y2VkLCBidXQgd2l0aCBzb21lIGRpZmZlcmVuY2VzOlxuICpcbiAqIC0gUmVzb3VyY2VzIHRoYXQgZXhpc3QgaW4gdGhlIGxvY2FsIHN0YWNrcywgYnV0IG5vdCBpbiB0aGUgcmVtb3RlIHN0YWNrcywgYXJlXG4gKiAgIG5vdCBpbmNsdWRlZC5cbiAqIC0gUmVzb3VyY2VzIHRoYXQgZXhpc3QgaW4gdGhlIHJlbW90ZSBzdGFja3MsIGJ1dCBub3QgaW4gdGhlIGxvY2FsIHN0YWNrcywgYXJlXG4gKiAgIHByZXNlcnZlZC5cbiAqIC0gRm9yIHJlc291cmNlcyB0aGF0IGV4aXN0IGluIGJvdGggc3RhY2tzLCBidXQgaGF2ZSBkaWZmZXJlbnQgcHJvcGVydGllcywgdGhlXG4gKiAgIGRlcGxveWVkIHByb3BlcnRpZXMgYXJlIHVzZWQsIGJ1dCB0aGUgcmVmZXJlbmNlcyBtYXkgbmVlZCB0byBiZSB1cGRhdGVkLCBpZlxuICogICB0aGUgcmVzb3VyY2VzIHRoZXkgcmVmZXJlbmNlIHdlcmUgbW92ZWQgaW4gdGhlIHJlZmFjdG9yaW5nLlxuICpcbiAqIFdoeSBkb2VzIHRoZSBsYXN0IGRpZmZlcmVuY2UgZXhpc3QsIHRvIGJlZ2luIHdpdGg/IEJ5IGRlZmF1bHQsIHRvIGVzdGFibGlzaFxuICogd2hldGhlciB0d28gZ2l2ZW4gcmVzb3VyY2VzIGFyZSB0aGUgc2FtZSwgcm91Z2hseSBzcGVha2luZyB3ZSBjb21wdXRlIHRoZSBoYXNoXG4gKiBvZiB0aGVpciBwcm9wZXJ0aWVzIGFuZCBjb21wYXJlIHRoZW0uIEJ1dCB0aGVyZSBpcyBhIGJldHRlciBzb3VyY2Ugb2YgcmVzb3VyY2VcbiAqIGlkZW50aXR5LCB0aGF0IHdlIGNhbiBleHBsb2l0IHdoZW4gaXQgaXMgcHJlc2VudDogdGhlIHBoeXNpY2FsIG5hbWUuIEluIHN1Y2hcbiAqIGNhc2VzLCB3ZSBjYW4gdHJhY2sgYSByZXNvdXJjZSBtb3ZlIGV2ZW4gaWYgdGhlIHByb3BlcnRpZXMgYXJlIGRpZmZlcmVudCwgYXNcbiAqIGxvbmcgYXMgdGhlIHBoeXNpY2FsIG5hbWUgaXMgdGhlIHNhbWUuXG4gKlxuICogVGhlIHByb2Nlc3Mgb2YgY29tcHV0aW5nIHRoZSByZXN1bHRpbmcgdGVtcGxhdGVzIGNvbnNpc3RzIGluOlxuICpcbiAqIDEuIENvbXB1dGluZyBhIGdyYXBoIG9mIGRlcGxveWVkIHJlc291cmNlcy5cbiAqIDIuIE1hcHBpbmcgZWRnZXMgYW5kIG5vZGVzIGFjY29yZGluZyB0byB0aGUgbWFwcGluZ3MgKHRoYXQgd2UgZWl0aGVyXG4gKiAgICBjb21wdXRlZCBvciBnb3QgZGlyZWN0bHkgZnJvbSB0aGUgdXNlcikuXG4gKiAzLiBDb21wdXRpbmcgdGhlIHJlc3VsdGluZyB0ZW1wbGF0ZXMgYnkgdHJhdmVyc2luZyB0aGUgZ3JhcGggYW5kXG4gKiAgICBjb2xsZWN0aW5nIHRoZSByZXNvdXJjZXMgdGhhdCBhcmUgbm90IG1hcHBlZCBvdXQsIGFuZCB1cGRhdGluZyB0aGVcbiAqICAgIHJlZmVyZW5jZXMgdG8gdGhlIHJlc291cmNlcyB0aGF0IHdlcmUgbW92ZWQuXG4gKi9cblxuaW1wb3J0IHR5cGUgeyBTdGFja0RlZmluaXRpb24gfSBmcm9tICdAYXdzLXNkay9jbGllbnQtY2xvdWRmb3JtYXRpb24nO1xuaW1wb3J0IHR5cGUgeyBDbG91ZEZvcm1hdGlvblN0YWNrLCBDbG91ZEZvcm1hdGlvblRlbXBsYXRlLCBSZXNvdXJjZU1hcHBpbmcgfSBmcm9tICcuL2Nsb3VkZm9ybWF0aW9uJztcbmltcG9ydCB7IFJlc291cmNlTG9jYXRpb24gfSBmcm9tICcuL2Nsb3VkZm9ybWF0aW9uJztcbmltcG9ydCB7IFRvb2xraXRFcnJvciB9IGZyb20gJy4uLy4uL3Rvb2xraXQvdG9vbGtpdC1lcnJvcic7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVN0YWNrRGVmaW5pdGlvbnMoXG4gIG1hcHBpbmdzOiBSZXNvdXJjZU1hcHBpbmdbXSxcbiAgZGVwbG95ZWRTdGFja3M6IENsb3VkRm9ybWF0aW9uU3RhY2tbXSxcbiAgbG9jYWxTdGFja3M6IENsb3VkRm9ybWF0aW9uU3RhY2tbXSxcbik6IFN0YWNrRGVmaW5pdGlvbltdIHtcbiAgY29uc3QgbG9jYWxFeHBvcnRzOiBSZWNvcmQ8c3RyaW5nLCBTY29wZWRFeHBvcnQ+ID0gaW5kZXhFeHBvcnRzKGxvY2FsU3RhY2tzKTtcbiAgY29uc3QgZGVwbG95ZWRFeHBvcnRzOiBSZWNvcmQ8c3RyaW5nLCBTY29wZWRFeHBvcnQ+ID0gaW5kZXhFeHBvcnRzKGRlcGxveWVkU3RhY2tzKTtcbiAgY29uc3QgZWRnZU1hcHBlciA9IG5ldyBFZGdlTWFwcGVyKG1hcHBpbmdzKTtcblxuICAvLyBCdWlsZCBhIGdyYXBoIG9mIHRoZSBkZXBsb3llZCBzdGFja3NcbiAgY29uc3QgZGVwbG95ZWRHcmFwaCA9IGdyYXBoKGRlcGxveWVkU3RhY2tzLCBkZXBsb3llZEV4cG9ydHMpO1xuXG4gIC8vIE1hcCBhbGwgdGhlIGVkZ2VzLCBpbmNsdWRpbmcgdGhlaXIgZW5kcG9pbnRzLCB0byB0aGVpciBuZXcgbG9jYXRpb25zLlxuICBjb25zdCBlZGdlcyA9IGVkZ2VNYXBwZXIubWFwRWRnZXMoZGVwbG95ZWRHcmFwaC5lZGdlcyk7XG5cbiAgLy8gQWxsIHRoZSBlZGdlcyBoYXZlIGJlZW4gbWFwcGVkLCB3aGljaCBtZWFucyB0aGF0IGlzb2xhdGVkIG5vZGVzIHdlcmUgbGVmdCBiZWhpbmQuIE1hcCB0aGVtIHRvby5cbiAgY29uc3Qgbm9kZXMgPSBtYXBOb2RlcyhkZXBsb3llZEdyYXBoLmlzb2xhdGVkTm9kZXMsIG1hcHBpbmdzKTtcblxuICAvLyBOb3cgd2UgY2FuIGdlbmVyYXRlIHRoZSB0ZW1wbGF0ZXMgZm9yIGVhY2ggc3RhY2tcbiAgY29uc3QgdGVtcGxhdGVzID0gZ2VuZXJhdGVUZW1wbGF0ZXMoZWRnZXMsIG5vZGVzLCBlZGdlTWFwcGVyLmFmZmVjdGVkU3RhY2tOYW1lcywgbG9jYWxFeHBvcnRzLCBkZXBsb3llZFN0YWNrcyk7XG5cbiAgLy8gRmluYWxseSwgZ2VuZXJhdGUgdGhlIHN0YWNrIGRlZmluaXRpb25zLCB0byBiZSBpbmNsdWRlZCBpbiB0aGUgcmVmYWN0b3IgcmVxdWVzdC5cbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRlbXBsYXRlcykubWFwKChbc3RhY2tOYW1lLCB0ZW1wbGF0ZV0pID0+ICh7XG4gICAgU3RhY2tOYW1lOiBzdGFja05hbWUsXG4gICAgVGVtcGxhdGVCb2R5OiBKU09OLnN0cmluZ2lmeSh0ZW1wbGF0ZSksXG4gIH0pKTtcbn1cblxuZnVuY3Rpb24gZ3JhcGgoZGVwbG95ZWRTdGFja3M6IENsb3VkRm9ybWF0aW9uU3RhY2tbXSwgZGVwbG95ZWRFeHBvcnRzOiBSZWNvcmQ8c3RyaW5nLCBTY29wZWRFeHBvcnQ+KTpcbnsgZWRnZXM6IFJlc291cmNlRWRnZVtdOyBpc29sYXRlZE5vZGVzOiBSZXNvdXJjZU5vZGVbXSB9IHtcbiAgY29uc3QgZGVwbG95ZWROb2RlTWFwOiBNYXA8c3RyaW5nLCBSZXNvdXJjZU5vZGU+ID0gYnVpbGROb2RlcyhkZXBsb3llZFN0YWNrcyk7XG4gIGNvbnN0IGRlcGxveWVkTm9kZXMgPSBBcnJheS5mcm9tKGRlcGxveWVkTm9kZU1hcC52YWx1ZXMoKSk7XG5cbiAgY29uc3QgZWRnZXMgPSBidWlsZEVkZ2VzKGRlcGxveWVkTm9kZU1hcCwgZGVwbG95ZWRFeHBvcnRzKTtcblxuICBjb25zdCBpc29sYXRlZE5vZGVzID0gZGVwbG95ZWROb2Rlcy5maWx0ZXIoKG5vZGUpID0+IHtcbiAgICByZXR1cm4gIWVkZ2VzLnNvbWUoXG4gICAgICAoZWRnZSkgPT5cbiAgICAgICAgZWRnZS5zb3VyY2UubG9jYXRpb24uZXF1YWxUbyhub2RlLmxvY2F0aW9uKSB8fFxuICAgICAgICBlZGdlLnRhcmdldHMuc29tZSgodGFyZ2V0KSA9PiB0YXJnZXQubG9jYXRpb24uZXF1YWxUbyhub2RlLmxvY2F0aW9uKSksXG4gICAgKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgZWRnZXMsIGlzb2xhdGVkTm9kZXMgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGROb2RlcyhzdGFja3M6IENsb3VkRm9ybWF0aW9uU3RhY2tbXSk6IE1hcDxzdHJpbmcsIFJlc291cmNlTm9kZT4ge1xuICBjb25zdCByZXN1bHQgPSBuZXcgTWFwPHN0cmluZywgUmVzb3VyY2VOb2RlPigpO1xuXG4gIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBzdGFjay50ZW1wbGF0ZTtcbiAgICBmb3IgKGNvbnN0IFtsb2dpY2FsSWQsIHJlc291cmNlXSBvZiBPYmplY3QuZW50cmllcyh0ZW1wbGF0ZS5SZXNvdXJjZXMgPz8ge30pKSB7XG4gICAgICBjb25zdCBsb2NhdGlvbiA9IG5ldyBSZXNvdXJjZUxvY2F0aW9uKHN0YWNrLCBsb2dpY2FsSWQpO1xuICAgICAgcmVzdWx0LnNldChgJHtzdGFjay5zdGFja05hbWV9LiR7bG9naWNhbElkfWAsIHtcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIHJhd1ZhbHVlOiByZXNvdXJjZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRWRnZXMoXG4gIG5vZGVNYXA6IE1hcDxzdHJpbmcsIFJlc291cmNlTm9kZT4sXG4gIGV4cG9ydHM6IFJlY29yZDxcbiAgICBzdHJpbmcsXG4gICAge1xuICAgICAgc3RhY2tOYW1lOiBzdHJpbmc7XG4gICAgICB2YWx1ZTogYW55O1xuICAgIH1cbiAgPixcbik6IFJlc291cmNlRWRnZVtdIHtcbiAgY29uc3Qgbm9kZXMgPSBBcnJheS5mcm9tKG5vZGVNYXAudmFsdWVzKCkpO1xuICByZXR1cm4gbm9kZXMuZmxhdE1hcCgobm9kZSkgPT4gYnVpbGRFZGdlc0ZvclJlc291cmNlKG5vZGUsIG5vZGUucmF3VmFsdWUpKTtcblxuICBmdW5jdGlvbiBidWlsZEVkZ2VzRm9yUmVzb3VyY2Uoc291cmNlOiBSZXNvdXJjZU5vZGUsIHZhbHVlOiBhbnksIHBhdGg6IHN0cmluZ1tdID0gW10pOiBSZXNvdXJjZUVkZ2VbXSB7XG4gICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSByZXR1cm4gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUuZmxhdE1hcCgoeCwgaW5kZXgpID0+IGJ1aWxkRWRnZXNGb3JSZXNvdXJjZShzb3VyY2UsIHgsIHBhdGguY29uY2F0KFN0cmluZyhpbmRleCkpKSk7XG4gICAgfVxuXG4gICAgaWYgKCdSZWYnIGluIHZhbHVlKSB7XG4gICAgICByZXR1cm4gW21ha2VSZWYoc291cmNlLmxvY2F0aW9uLnN0YWNrLnN0YWNrTmFtZSwgdmFsdWUuUmVmKV07XG4gICAgfVxuXG4gICAgaWYgKCdGbjo6R2V0QXR0JyBpbiB2YWx1ZSkge1xuICAgICAgcmV0dXJuIFttYWtlR2V0QXR0KHNvdXJjZS5sb2NhdGlvbi5zdGFjay5zdGFja05hbWUsIHZhbHVlWydGbjo6R2V0QXR0J10pXTtcbiAgICB9XG5cbiAgICBpZiAoJ0ZuOjpJbXBvcnRWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgIGNvbnN0IGV4cG9ydE5hbWUgPSB2YWx1ZVsnRm46OkltcG9ydFZhbHVlJ107XG4gICAgICBjb25zdCB4ID0gZXhwb3J0c1tleHBvcnROYW1lXSE7XG5cbiAgICAgIGlmICgnUmVmJyBpbiB4LnZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4ubWFrZVJlZih4LnN0YWNrTmFtZSwgeC52YWx1ZS5SZWYpLFxuICAgICAgICAgICAgcmVmZXJlbmNlOiBuZXcgSW1wb3J0VmFsdWUoUmVmLklOU1RBTkNFKSxcbiAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ0ZuOjpHZXRBdHQnIGluIHgudmFsdWUpIHtcbiAgICAgICAgY29uc3QgZ2V0QXR0ID0gbWFrZUdldEF0dCh4LnN0YWNrTmFtZSwgeC52YWx1ZVsnRm46OkdldEF0dCddKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi5nZXRBdHQsXG4gICAgICAgICAgICByZWZlcmVuY2U6IG5ldyBJbXBvcnRWYWx1ZShnZXRBdHQucmVmZXJlbmNlKSxcbiAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKCdGbjo6U3ViJyBpbiB2YWx1ZSkge1xuICAgICAgbGV0IGlucHV0U3RyaW5nOiBzdHJpbmc7XG4gICAgICBsZXQgdmFyaWFibGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkO1xuICAgICAgY29uc3Qgc3ViID0gdmFsdWVbJ0ZuOjpTdWInXTtcbiAgICAgIGlmICh0eXBlb2Ygc3ViID09PSAnc3RyaW5nJykge1xuICAgICAgICBpbnB1dFN0cmluZyA9IHN1YjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFtpbnB1dFN0cmluZywgdmFyaWFibGVzXSA9IHN1YjtcbiAgICAgIH1cblxuICAgICAgbGV0IHZhck5hbWVzID0gQXJyYXkuZnJvbShpbnB1dFN0cmluZy5tYXRjaEFsbCgvXFwkeyhbYS16QS1aMC05Xy5dKyl9L2cpKVxuICAgICAgICAubWFwKCh4KSA9PiB4WzFdKVxuICAgICAgICAuZmlsdGVyKCh2YXJOYW1lKSA9PiAodmFsdWVbJ0ZuOjpTdWInXVsxXSA/PyB7fSlbdmFyTmFtZV0gPT0gbnVsbCk7XG5cbiAgICAgIGNvbnN0IGVkZ2VzID0gdmFyTmFtZXMubWFwKCh2YXJOYW1lKSA9PiB7XG4gICAgICAgIHJldHVybiB2YXJOYW1lLmluY2x1ZGVzKCcuJylcbiAgICAgICAgICA/IG1ha2VHZXRBdHQoc291cmNlLmxvY2F0aW9uLnN0YWNrLnN0YWNrTmFtZSwgdmFyTmFtZSlcbiAgICAgICAgICA6IG1ha2VSZWYoc291cmNlLmxvY2F0aW9uLnN0YWNrLnN0YWNrTmFtZSwgdmFyTmFtZSk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZWRnZXNGcm9tSW5wdXRTdHJpbmcgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0czogZWRnZXMuZmxhdE1hcCgoZWRnZSkgPT4gZWRnZS50YXJnZXRzKSxcbiAgICAgICAgICByZWZlcmVuY2U6IG5ldyBTdWIoaW5wdXRTdHJpbmcsIHZhck5hbWVzKSxcbiAgICAgICAgICBwYXRoOiBwYXRoLmNvbmNhdCgnRm46OlN1YicsICcwJyksXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBlZGdlc0Zyb21WYXJpYWJsZXMgPSBidWlsZEVkZ2VzRm9yUmVzb3VyY2Uoc291cmNlLCB2YXJpYWJsZXMsIHBhdGguY29uY2F0KCdGbjo6U3ViJywgJzEnKSk7XG5cbiAgICAgIHJldHVybiBbLi4uZWRnZXNGcm9tSW5wdXRTdHJpbmcsIC4uLmVkZ2VzRnJvbVZhcmlhYmxlc107XG4gICAgfVxuXG4gICAgY29uc3QgZWRnZXM6IFJlc291cmNlRWRnZVtdID0gW107XG5cbiAgICAvLyBEZXBlbmRzT24gaXMgb25seSBoYW5kbGVkIGF0IHRoZSB0b3AgbGV2ZWwgb2YgdGhlIHJlc291cmNlXG4gICAgaWYgKCdEZXBlbmRzT24nIGluIHZhbHVlICYmIHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlLkRlcGVuZHNPbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZWRnZXMucHVzaCh7XG4gICAgICAgICAgLi4ubWFrZVJlZihzb3VyY2UubG9jYXRpb24uc3RhY2suc3RhY2tOYW1lLCB2YWx1ZS5EZXBlbmRzT24pLFxuICAgICAgICAgIHJlZmVyZW5jZTogRGVwZW5kc09uLklOU1RBTkNFLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZS5EZXBlbmRzT24pKSB7XG4gICAgICAgIGVkZ2VzLnB1c2goe1xuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICB0YXJnZXRzOiB2YWx1ZS5EZXBlbmRzT24uZmxhdE1hcChcbiAgICAgICAgICAgIChkZXBlbmRzT246IHN0cmluZykgPT4gbWFrZVJlZihzb3VyY2UubG9jYXRpb24uc3RhY2suc3RhY2tOYW1lLCBkZXBlbmRzT24pLnRhcmdldHMsXG4gICAgICAgICAgKSxcbiAgICAgICAgICBwYXRoOiBwYXRoLmNvbmNhdCgnRGVwZW5kc09uJyksXG4gICAgICAgICAgcmVmZXJlbmNlOiBEZXBlbmRzT24uSU5TVEFOQ0UsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVkZ2VzLnB1c2goLi4uT2JqZWN0LmVudHJpZXModmFsdWUpLmZsYXRNYXAoKFtrLCB2XSkgPT4gYnVpbGRFZGdlc0ZvclJlc291cmNlKHNvdXJjZSwgdiwgcGF0aC5jb25jYXQoaykpKSk7XG5cbiAgICByZXR1cm4gZWRnZXM7XG5cbiAgICBmdW5jdGlvbiBtYWtlUmVmKHN0YWNrTmFtZTogc3RyaW5nLCBsb2dpY2FsSWQ6IHN0cmluZyk6IFJlc291cmNlRWRnZSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtzdGFja05hbWV9LiR7bG9naWNhbElkfWA7XG4gICAgICBjb25zdCB0YXJnZXQgPSBub2RlTWFwLmdldChrZXkpITtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgc291cmNlLFxuICAgICAgICB0YXJnZXRzOiBbdGFyZ2V0XSxcbiAgICAgICAgcmVmZXJlbmNlOiBSZWYuSU5TVEFOQ0UsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXRBdHQoc3RhY2tOYW1lOiBzdHJpbmcsIGF0dDogc3RyaW5nIHwgc3RyaW5nW10pOiBSZXNvdXJjZUVkZ2Uge1xuICAgICAgbGV0IGxvZ2ljYWxJZDogc3RyaW5nID0gJyc7XG4gICAgICBsZXQgYXR0cmlidXRlTmFtZTogc3RyaW5nID0gJyc7XG4gICAgICBpZiAodHlwZW9mIGF0dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgW2xvZ2ljYWxJZCwgYXR0cmlidXRlTmFtZV0gPSBhdHQuc3BsaXQoL1xcLiguKikvcyk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXR0KSAmJiBhdHQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIFtsb2dpY2FsSWQsIGF0dHJpYnV0ZU5hbWVdID0gYXR0O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBrZXkgPSBgJHtzdGFja05hbWV9LiR7bG9naWNhbElkfWA7XG4gICAgICBjb25zdCB0YXJnZXQgPSBub2RlTWFwLmdldChrZXkpITtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgc291cmNlLFxuICAgICAgICB0YXJnZXRzOiBbdGFyZ2V0XSxcbiAgICAgICAgcmVmZXJlbmNlOiBuZXcgR2V0QXR0KGF0dHJpYnV0ZU5hbWUpLFxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFwTm9kZXMobm9kZXM6IFJlc291cmNlTm9kZVtdLCBtYXBwaW5nczogUmVzb3VyY2VNYXBwaW5nW10pOiBSZXNvdXJjZU5vZGVbXSB7XG4gIHJldHVybiBub2Rlcy5tYXAoKG5vZGUpID0+IHtcbiAgICBjb25zdCBuZXdMb2NhdGlvbiA9IG1hcExvY2F0aW9uKG5vZGUubG9jYXRpb24sIG1hcHBpbmdzKTtcbiAgICByZXR1cm4ge1xuICAgICAgbG9jYXRpb246IG5ld0xvY2F0aW9uLFxuICAgICAgcmF3VmFsdWU6IG5vZGUucmF3VmFsdWUsXG4gICAgfSBhcyBSZXNvdXJjZU5vZGU7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVRlbXBsYXRlcyhcbiAgZWRnZXM6IFJlc291cmNlRWRnZVtdLFxuICBub2RlczogUmVzb3VyY2VOb2RlW10sXG4gIHN0YWNrTmFtZXM6IHN0cmluZ1tdLFxuICBleHBvcnRzOiBSZWNvcmQ8c3RyaW5nLCBTY29wZWRFeHBvcnQ+LFxuICBkZXBsb3llZFN0YWNrczogQ2xvdWRGb3JtYXRpb25TdGFja1tdKTogUmVjb3JkPHN0cmluZywgQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZT4ge1xuICB1cGRhdGVSZWZlcmVuY2VzKGVkZ2VzLCBleHBvcnRzKTtcbiAgY29uc3QgdGVtcGxhdGVzOiBSZWNvcmQ8c3RyaW5nLCBDbG91ZEZvcm1hdGlvblRlbXBsYXRlPiA9IHt9O1xuXG4gIC8vIFRha2UgdGhlIENsb3VkRm9ybWF0aW9uIHJhdyB2YWx1ZSBvZiBlYWNoIHRoZSBub2RlIGFuZCBwdXQgaXQgaW50byB0aGUgYXBwcm9wcmlhdGUgdGVtcGxhdGUuXG4gIGNvbnN0IGFsbE5vZGVzID0gdW5pcXVlKGVkZ2VzLmZsYXRNYXAoKGUpID0+IFtlLnNvdXJjZSwgLi4uZS50YXJnZXRzXSkuY29uY2F0KG5vZGVzKSk7XG4gIGFsbE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICBjb25zdCBzdGFja05hbWUgPSBub2RlLmxvY2F0aW9uLnN0YWNrLnN0YWNrTmFtZTtcbiAgICBjb25zdCBsb2dpY2FsSWQgPSBub2RlLmxvY2F0aW9uLmxvZ2ljYWxSZXNvdXJjZUlkO1xuXG4gICAgaWYgKHRlbXBsYXRlc1tzdGFja05hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRlbXBsYXRlc1tzdGFja05hbWVdID0ge1xuICAgICAgICBSZXNvdXJjZXM6IHt9LFxuICAgICAgfTtcbiAgICB9XG4gICAgdGVtcGxhdGVzW3N0YWNrTmFtZV0uUmVzb3VyY2VzIVtsb2dpY2FsSWRdID0gbm9kZS5yYXdWYWx1ZTtcbiAgfSk7XG5cbiAgLy8gQWRkIG91dHB1dHMgdG8gdGhlIHRlbXBsYXRlc1xuICBlZGdlcy5mb3JFYWNoKChlZGdlKSA9PiB7XG4gICAgaWYgKGVkZ2UucmVmZXJlbmNlIGluc3RhbmNlb2YgSW1wb3J0VmFsdWUpIHtcbiAgICAgIGNvbnN0IHN0YWNrTmFtZSA9IGVkZ2UudGFyZ2V0c1swXS5sb2NhdGlvbi5zdGFjay5zdGFja05hbWU7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlc1tzdGFja05hbWVdO1xuICAgICAgdGVtcGxhdGUuT3V0cHV0cyA9IHtcbiAgICAgICAgLi4uKHRlbXBsYXRlLk91dHB1dHMgPz8ge30pLFxuICAgICAgICAuLi5lZGdlLnJlZmVyZW5jZS5vdXRwdXQsXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gVGhlIGZyZXNobHkgZ2VuZXJhdGVkIHRlbXBsYXRlcyBjb250YWluIG9ubHkgcmVzb3VyY2VzIGFuZCBvdXRwdXRzLlxuICAvLyBDb21iaW5lIHRoZW0gd2l0aCB0aGUgZXhpc3RpbmcgdGVtcGxhdGVzIHRvIHByZXNlcnZlIG1ldGFkYXRhIGFuZCBvdGhlciBwcm9wZXJ0aWVzLlxuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIHN0YWNrTmFtZXMubWFwKChzdGFja05hbWUpID0+IHtcbiAgICAgIGNvbnN0IG9sZFRlbXBsYXRlID0gZGVwbG95ZWRTdGFja3MuZmluZCgocykgPT4gcy5zdGFja05hbWUgPT09IHN0YWNrTmFtZSk/LnRlbXBsYXRlID8/IHt9O1xuICAgICAgY29uc3QgbmV3VGVtcGxhdGUgPSB0ZW1wbGF0ZXNbc3RhY2tOYW1lXSA/PyB7IFJlc291cmNlczoge30gfTtcbiAgICAgIGNvbnN0IGNvbWJpbmVkVGVtcGxhdGUgPSB7IC4uLm9sZFRlbXBsYXRlLCAuLi5uZXdUZW1wbGF0ZSB9O1xuXG4gICAgICBzYW5pdGl6ZURlcGVuZGVuY2llcyhjb21iaW5lZFRlbXBsYXRlKTtcbiAgICAgIHJldHVybiBbc3RhY2tOYW1lLCBjb21iaW5lZFRlbXBsYXRlXTtcbiAgICB9KSxcbiAgKTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgdGhlIENsb3VkRm9ybWF0aW9uIHJlc291cmNlcyBiYXNlZCBvbiBpbmZvcm1hdGlvbiBmcm9tIHRoZSBlZGdlcy5cbiAqIEVhY2ggZWRnZSBjb3JyZXNwb25kcyB0byBhIHBhdGggaW4gc29tZSByZXNvdXJjZSBvYmplY3QuIFRoZSB2YWx1ZSBhdCB0aGF0XG4gKiBwYXRoIGlzIHVwZGF0ZWQgdG8gdGhlIENsb3VkRm9ybWF0aW9uIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZSBlZGdlJ3MgYW5ub3RhdGlvbi5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlUmVmZXJlbmNlcyhlZGdlczogUmVzb3VyY2VFZGdlW10sIGV4cG9ydHM6IFJlY29yZDxzdHJpbmcsIFNjb3BlZEV4cG9ydD4pIHtcbiAgZWRnZXMuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgIGNvbnN0IGNmblZhbHVlID0gZWRnZS5yZWZlcmVuY2UudG9DZm4oZWRnZS50YXJnZXRzLCBleHBvcnRzKTtcbiAgICBjb25zdCBvYmogPSBlZGdlLnBhdGguc2xpY2UoMCwgZWRnZS5wYXRoLmxlbmd0aCAtIDEpLnJlZHVjZShnZXRQcm9wVmFsdWUsIGVkZ2Uuc291cmNlLnJhd1ZhbHVlKTtcbiAgICBzZXRQcm9wVmFsdWUob2JqLCBlZGdlLnBhdGhbZWRnZS5wYXRoLmxlbmd0aCAtIDFdLCBjZm5WYWx1ZSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGdldFByb3BWYWx1ZShvYmo6IGFueSwgcHJvcDogc3RyaW5nKTogYW55IHtcbiAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KHByb3ApO1xuICAgIHJldHVybiBvYmpbTnVtYmVyLmlzTmFOKGluZGV4KSA/IHByb3AgOiBpbmRleF07XG4gIH1cblxuICBmdW5jdGlvbiBzZXRQcm9wVmFsdWUob2JqOiBhbnksIHByb3A6IHN0cmluZywgdmFsdWU6IGFueSkge1xuICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQocHJvcCk7XG4gICAgb2JqW051bWJlci5pc05hTihpbmRleCkgPyBwcm9wIDogaW5kZXhdID0gdmFsdWU7XG4gIH1cbn1cblxuY2xhc3MgRWRnZU1hcHBlciB7XG4gIHB1YmxpYyByZWFkb25seSBhZmZlY3RlZFN0YWNrczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgbm9kZU1hcDogTWFwPHN0cmluZywgUmVzb3VyY2VOb2RlPiA9IG5ldyBNYXAoKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IG1hcHBpbmdzOiBSZXNvdXJjZU1hcHBpbmdbXSkge1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciBlYWNoIGlucHV0IGVkZ2UsIHByb2R1Y2UgYW4gb3V0cHV0IGVkZ2Ugc3VjaCB0aGF0OlxuICAgKiAgIC0gVGhlIHNvdXJjZSBhbmQgdGFyZ2V0cyBhcmUgbWFwcGVkIHRvIHRoZWlyIG5ldyBsb2NhdGlvbnNcbiAgICogICAtIFRoZSBhbm5vdGF0aW9uIGlzIGNvbnZlcnRlZCBiZXR3ZWVuIGluLXN0YWNrIGFuZCBjcm9zcy1zdGFjayByZWZlcmVuY2VzLCBhcyBhcHByb3ByaWF0ZVxuICAgKi9cbiAgbWFwRWRnZXMoZWRnZXM6IFJlc291cmNlRWRnZVtdKTogUmVzb3VyY2VFZGdlW10ge1xuICAgIHJldHVybiBlZGdlc1xuICAgICAgLm1hcCgoZWRnZSkgPT4ge1xuICAgICAgICBjb25zdCBvbGRTb3VyY2UgPSBlZGdlLnNvdXJjZTtcbiAgICAgICAgY29uc3Qgb2xkVGFyZ2V0cyA9IGVkZ2UudGFyZ2V0cztcbiAgICAgICAgY29uc3QgbmV3U291cmNlID0gdGhpcy5tYXBOb2RlKG9sZFNvdXJjZSk7XG4gICAgICAgIGNvbnN0IG5ld1RhcmdldHMgPSBvbGRUYXJnZXRzLm1hcCgodCkgPT4gdGhpcy5tYXBOb2RlKHQpKTtcblxuICAgICAgICBjb25zdCBvbGRTb3VyY2VTdGFja05hbWUgPSBvbGRTb3VyY2UubG9jYXRpb24uc3RhY2suc3RhY2tOYW1lO1xuICAgICAgICBjb25zdCBvbGRUYXJnZXRTdGFja05hbWUgPSBvbGRUYXJnZXRzWzBdLmxvY2F0aW9uLnN0YWNrLnN0YWNrTmFtZTtcblxuICAgICAgICBjb25zdCBuZXdTb3VyY2VTdGFja05hbWUgPSBuZXdTb3VyY2UubG9jYXRpb24uc3RhY2suc3RhY2tOYW1lO1xuICAgICAgICBjb25zdCBuZXdUYXJnZXRTdGFja05hbWUgPSBuZXdUYXJnZXRzWzBdLmxvY2F0aW9uLnN0YWNrLnN0YWNrTmFtZTtcblxuICAgICAgICB0aGlzLmFmZmVjdGVkU3RhY2tzLmFkZChuZXdTb3VyY2VTdGFja05hbWUpO1xuICAgICAgICB0aGlzLmFmZmVjdGVkU3RhY2tzLmFkZChuZXdUYXJnZXRTdGFja05hbWUpO1xuICAgICAgICB0aGlzLmFmZmVjdGVkU3RhY2tzLmFkZChvbGRTb3VyY2VTdGFja05hbWUpO1xuICAgICAgICB0aGlzLmFmZmVjdGVkU3RhY2tzLmFkZChvbGRUYXJnZXRTdGFja05hbWUpO1xuXG4gICAgICAgIGxldCByZWZlcmVuY2U6IENsb3VkRm9ybWF0aW9uUmVmZXJlbmNlID0gZWRnZS5yZWZlcmVuY2U7XG4gICAgICAgIGlmIChvbGRTb3VyY2VTdGFja05hbWUgPT09IG9sZFRhcmdldFN0YWNrTmFtZSAmJiBuZXdTb3VyY2VTdGFja05hbWUgIT09IG5ld1RhcmdldFN0YWNrTmFtZSkge1xuICAgICAgICAgIGlmIChlZGdlLnJlZmVyZW5jZSBpbnN0YW5jZW9mIERlcGVuZHNPbikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpbi1zdGFjayByZWZlcmVuY2UgdG8gY3Jvc3Mtc3RhY2sgcmVmZXJlbmNlOiB3cmFwIHRoZSBvbGQgYW5ub3RhdGlvblxuICAgICAgICAgIHJlZmVyZW5jZSA9IG5ldyBJbXBvcnRWYWx1ZShlZGdlLnJlZmVyZW5jZSk7XG4gICAgICAgIH0gZWxzZSBpZiAob2xkU291cmNlU3RhY2tOYW1lICE9PSBvbGRUYXJnZXRTdGFja05hbWUgJiYgbmV3U291cmNlU3RhY2tOYW1lID09PSBuZXdUYXJnZXRTdGFja05hbWUpIHtcbiAgICAgICAgICAvLyBjcm9zcy1zdGFjayByZWZlcmVuY2UgdG8gaW4tc3RhY2sgcmVmZXJlbmNlOiB1bndyYXAgdGhlIG9sZCBhbm5vdGF0aW9uXG4gICAgICAgICAgaWYgKGVkZ2UucmVmZXJlbmNlIGluc3RhbmNlb2YgSW1wb3J0VmFsdWUpIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZSA9IGVkZ2UucmVmZXJlbmNlLnJlZmVyZW5jZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhdGg6IGVkZ2UucGF0aCxcbiAgICAgICAgICBzb3VyY2U6IG5ld1NvdXJjZSxcbiAgICAgICAgICB0YXJnZXRzOiBuZXdUYXJnZXRzLFxuICAgICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKChlZGdlKSA9PiBlZGdlICE9PSB1bmRlZmluZWQpO1xuICB9XG5cbiAgZ2V0IGFmZmVjdGVkU3RhY2tOYW1lcygpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgZnJvbU1hcHBpbmdzID0gdGhpcy5tYXBwaW5ncy5mbGF0TWFwKChtKSA9PiBbbS5zb3VyY2Uuc3RhY2suc3RhY2tOYW1lLCBtLmRlc3RpbmF0aW9uLnN0YWNrLnN0YWNrTmFtZV0pO1xuICAgIHJldHVybiB1bmlxdWUoWy4uLnRoaXMuYWZmZWN0ZWRTdGFja3MsIC4uLmZyb21NYXBwaW5nc10pO1xuICB9XG5cbiAgcHJpdmF0ZSBtYXBOb2RlKG5vZGU6IFJlc291cmNlTm9kZSk6IFJlc291cmNlTm9kZSB7XG4gICAgY29uc3QgbmV3TG9jYXRpb24gPSBtYXBMb2NhdGlvbihub2RlLmxvY2F0aW9uLCB0aGlzLm1hcHBpbmdzKTtcbiAgICBjb25zdCBrZXkgPSBgJHtuZXdMb2NhdGlvbi5zdGFjay5zdGFja05hbWV9LiR7bmV3TG9jYXRpb24ubG9naWNhbFJlc291cmNlSWR9YDtcbiAgICBpZiAoIXRoaXMubm9kZU1hcC5oYXMoa2V5KSkge1xuICAgICAgdGhpcy5ub2RlTWFwLnNldChrZXksIHtcbiAgICAgICAgbG9jYXRpb246IG5ld0xvY2F0aW9uLFxuICAgICAgICByYXdWYWx1ZTogbm9kZS5yYXdWYWx1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ub2RlTWFwLmdldChrZXkpITtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBMb2NhdGlvbihsb2NhdGlvbjogUmVzb3VyY2VMb2NhdGlvbiwgbWFwcGluZ3M6IFJlc291cmNlTWFwcGluZ1tdKTogUmVzb3VyY2VMb2NhdGlvbiB7XG4gIGNvbnN0IG1hcHBpbmcgPSBtYXBwaW5ncy5maW5kKChtKSA9PiBtLnNvdXJjZS5lcXVhbFRvKGxvY2F0aW9uKSk7XG4gIGlmIChtYXBwaW5nKSB7XG4gICAgcmV0dXJuIG1hcHBpbmcuZGVzdGluYXRpb247XG4gIH1cbiAgcmV0dXJuIGxvY2F0aW9uO1xufVxuXG5mdW5jdGlvbiBpbmRleEV4cG9ydHMoc3RhY2tzOiBDbG91ZEZvcm1hdGlvblN0YWNrW10pOiBSZWNvcmQ8c3RyaW5nLCBTY29wZWRFeHBvcnQ+IHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBzdGFja3MuZmxhdE1hcCgocykgPT5cbiAgICAgIE9iamVjdC5lbnRyaWVzKHMudGVtcGxhdGUuT3V0cHV0cyA/PyB7fSlcbiAgICAgICAgLmZpbHRlcihcbiAgICAgICAgICAoW18sIG9dKSA9PiB0eXBlb2Ygby5FeHBvcnQ/Lk5hbWUgPT09ICdzdHJpbmcnICYmIChvLlZhbHVlLlJlZiAhPSBudWxsIHx8IG8uVmFsdWVbJ0ZuOjpHZXRBdHQnXSAhPSBudWxsKSxcbiAgICAgICAgKVxuICAgICAgICAubWFwKChbbmFtZSwgb10pID0+IFtvLkV4cG9ydC5OYW1lLCB7IHN0YWNrTmFtZTogcy5zdGFja05hbWUsIG91dHB1dE5hbWU6IG5hbWUsIHZhbHVlOiBvLlZhbHVlIH1dKSxcbiAgICApLFxuICApO1xufVxuXG5mdW5jdGlvbiB1bmlxdWU8VD4oYXJyOiBBcnJheTxUPikge1xuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGFycikpO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIERlcGVuZHNPbiBwcm9wZXJ0eSBvZiBhbGwgcmVzb3VyY2VzLCByZW1vdmluZyByZWZlcmVuY2VzXG4gKiB0byByZXNvdXJjZXMgdGhhdCBkbyBub3QgZXhpc3QgaW4gdGhlIHRlbXBsYXRlLiBVbmxpa2UgUmVmcyBhbmQgR2V0QXR0cyxcbiAqIHdoaWNoIGdldCB0cmFuc2Zvcm1lZCB0byBJbXBvcnRWYWx1ZXMgd2hlbiB0aGUgcmVmZXJlbmNlZCByZXNvdXJjZSBpc1xuICogbW92ZWQgdG8gYW5vdGhlciBzdGFjaywgRGVwZW5kc09uIGRvZXNuJ3QgY3Jvc3Mgc3RhY2sgYm91bmRhcmllcy5cbiAqL1xuZnVuY3Rpb24gc2FuaXRpemVEZXBlbmRlbmNpZXModGVtcGxhdGU6IENsb3VkRm9ybWF0aW9uVGVtcGxhdGUpIHtcbiAgY29uc3QgcmVzb3VyY2VzID0gdGVtcGxhdGUuUmVzb3VyY2VzID8/IHt9O1xuICBmb3IgKGNvbnN0IHJlc291cmNlIG9mIE9iamVjdC52YWx1ZXMocmVzb3VyY2VzKSkge1xuICAgIGlmICh0eXBlb2YgcmVzb3VyY2UuRGVwZW5kc09uID09PSAnc3RyaW5nJyAmJiByZXNvdXJjZXNbcmVzb3VyY2UuRGVwZW5kc09uXSA9PSBudWxsKSB7XG4gICAgICBkZWxldGUgcmVzb3VyY2UuRGVwZW5kc09uO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHJlc291cmNlLkRlcGVuZHNPbikpIHtcbiAgICAgIHJlc291cmNlLkRlcGVuZHNPbiA9IHJlc291cmNlLkRlcGVuZHNPbi5maWx0ZXIoKGRlcCkgPT4gcmVzb3VyY2VzW2RlcF0gIT0gbnVsbCk7XG4gICAgICBpZiAocmVzb3VyY2UuRGVwZW5kc09uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgcmVzb3VyY2UuRGVwZW5kc09uO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pbnRlcmZhY2UgU2NvcGVkRXhwb3J0IHtcbiAgc3RhY2tOYW1lOiBzdHJpbmc7XG4gIG91dHB1dE5hbWU6IHN0cmluZztcbiAgdmFsdWU6IGFueTtcbn1cblxuaW50ZXJmYWNlIFJlc291cmNlTm9kZSB7XG4gIGxvY2F0aW9uOiBSZXNvdXJjZUxvY2F0aW9uO1xuICByYXdWYWx1ZTogYW55O1xufVxuXG4vKipcbiAqIEFuIGVkZ2UgaW4gdGhlIHJlc291cmNlIGdyYXBoLCByZXByZXNlbnRpbmcgYSByZWZlcmVuY2UgZnJvbSBvbmUgcmVzb3VyY2VcbiAqIHRvIG9uZSBvciBtb3JlIHRhcmdldCByZXNvdXJjZXMuIChUZWNobmljYWxseSwgYSBoeXBlcmVkZ2UuKVxuICovXG5pbnRlcmZhY2UgUmVzb3VyY2VFZGdlIHtcbiAgLyoqXG4gICAqIFRoZSBzb3VyY2UgcmVzb3VyY2Ugb2YgdGhlIGVkZ2UuXG4gICAqL1xuICBzb3VyY2U6IFJlc291cmNlTm9kZTtcblxuICAvKipcbiAgICogVGhlIHRhcmdldCByZXNvdXJjZXMgb2YgdGhlIGVkZ2UuIEluIGNhc2Ugb2YgRGVwZW5kc09uLFxuICAgKiB0aGlzIGNhbiBiZSBtdWx0aXBsZSByZXNvdXJjZXMuXG4gICAqL1xuICB0YXJnZXRzOiBSZXNvdXJjZU5vZGVbXTtcblxuICAvKipcbiAgICogVGhlIHBhdGggaW4gdGhlIHNvdXJjZSByZXNvdXJjZSB3aGVyZSB0aGUgcmVmZXJlbmNlIGlzIGxvY2F0ZWQuXG4gICAqL1xuICBwYXRoOiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogVGhlIENsb3VkRm9ybWF0aW9uIHJlZmVyZW5jZSB0aGF0IHRoaXMgZWRnZSByZXByZXNlbnRzLlxuICAgKi9cbiAgcmVmZXJlbmNlOiBDbG91ZEZvcm1hdGlvblJlZmVyZW5jZTtcbn1cblxuaW50ZXJmYWNlIENsb3VkRm9ybWF0aW9uUmVmZXJlbmNlIHtcbiAgdG9DZm4odGFyZ2V0czogUmVzb3VyY2VOb2RlW10sIGV4cG9ydHM6IFJlY29yZDxzdHJpbmcsIFNjb3BlZEV4cG9ydD4pOiBhbnk7XG59XG5cbmNsYXNzIFJlZiBpbXBsZW1lbnRzIENsb3VkRm9ybWF0aW9uUmVmZXJlbmNlIHtcbiAgcHVibGljIHN0YXRpYyBJTlNUQU5DRSA9IG5ldyBSZWYoKTtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICB9XG5cbiAgdG9DZm4odGFyZ2V0czogUmVzb3VyY2VOb2RlW10pOiBhbnkge1xuICAgIHJldHVybiB7IFJlZjogdGFyZ2V0c1swXS5sb2NhdGlvbi5sb2dpY2FsUmVzb3VyY2VJZCB9O1xuICB9XG59XG5cbmNsYXNzIEdldEF0dCBpbXBsZW1lbnRzIENsb3VkRm9ybWF0aW9uUmVmZXJlbmNlIHtcbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGF0dHJpYnV0ZU5hbWU6IHN0cmluZykge1xuICB9XG5cbiAgdG9DZm4odGFyZ2V0czogUmVzb3VyY2VOb2RlW10pOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAnRm46OkdldEF0dCc6IFt0YXJnZXRzWzBdLmxvY2F0aW9uLmxvZ2ljYWxSZXNvdXJjZUlkLCB0aGlzLmF0dHJpYnV0ZU5hbWVdLFxuICAgIH07XG4gIH1cbn1cblxuY2xhc3MgSW1wb3J0VmFsdWUgaW1wbGVtZW50cyBDbG91ZEZvcm1hdGlvblJlZmVyZW5jZSB7XG4gIHByaXZhdGUgb3V0cHV0TmFtZT86IHN0cmluZztcbiAgcHJpdmF0ZSBvdXRwdXRDb250ZW50PzogYW55O1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSByZWZlcmVuY2U6IENsb3VkRm9ybWF0aW9uUmVmZXJlbmNlKSB7XG4gIH1cblxuICB0b0Nmbih0YXJnZXRzOiBSZXNvdXJjZU5vZGVbXSwgZXhwb3J0czogUmVjb3JkPHN0cmluZywgU2NvcGVkRXhwb3J0Pik6IGFueSB7XG4gICAgY29uc3QgZXhwID0gdGhpcy5maW5kRXhwb3J0KHRhcmdldHMsIGV4cG9ydHMpO1xuICAgIGlmIChleHApIHtcbiAgICAgIHRoaXMub3V0cHV0TmFtZSA9IGV4cFsxXS5vdXRwdXROYW1lO1xuICAgICAgdGhpcy5vdXRwdXRDb250ZW50ID0ge1xuICAgICAgICBWYWx1ZTogZXhwWzFdLnZhbHVlLFxuICAgICAgICBFeHBvcnQ6IHtcbiAgICAgICAgICBOYW1lOiBleHBbMF0sXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHsgJ0ZuOjpJbXBvcnRWYWx1ZSc6IGV4cFswXSB9O1xuICAgIH1cbiAgICAvLyBUT0RPIGJldHRlciBtZXNzYWdlXG4gICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignVW5rbm93biBleHBvcnQgZm9yIEltcG9ydFZhbHVlOiAnICsgSlNPTi5zdHJpbmdpZnkodGhpcy5yZWZlcmVuY2UpKTtcbiAgfVxuXG4gIHByaXZhdGUgZmluZEV4cG9ydCh0YXJnZXRzOiBSZXNvdXJjZU5vZGVbXSwgZXhwb3J0czogUmVjb3JkPHN0cmluZywgU2NvcGVkRXhwb3J0Pikge1xuICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldHNbMF07XG4gICAgaWYgKHRoaXMucmVmZXJlbmNlIGluc3RhbmNlb2YgUmVmKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZXhwb3J0cykuZmluZCgoW18sIGV4cG9ydFZhbHVlXSkgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGV4cG9ydFZhbHVlLnN0YWNrTmFtZSA9PT0gdGFyZ2V0LmxvY2F0aW9uLnN0YWNrLnN0YWNrTmFtZSAmJlxuICAgICAgICAgIGV4cG9ydFZhbHVlLnZhbHVlLlJlZiA9PT0gdGFyZ2V0LmxvY2F0aW9uLmxvZ2ljYWxSZXNvdXJjZUlkXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGV4cG9ydHMpLmZpbmQoKFtfLCBleHBvcnRWYWx1ZV0pID0+IHtcbiAgICAgICAgY29uc3QgZ2V0QXR0ID0gdGhpcy5yZWZlcmVuY2UgYXMgR2V0QXR0O1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgZXhwb3J0VmFsdWUuc3RhY2tOYW1lID09PSB0YXJnZXQubG9jYXRpb24uc3RhY2suc3RhY2tOYW1lICYmXG4gICAgICAgICAgZXhwb3J0VmFsdWUudmFsdWVbJ0ZuOjpHZXRBdHQnXSAmJlxuICAgICAgICAgICgoZXhwb3J0VmFsdWUudmFsdWVbJ0ZuOjpHZXRBdHQnXVswXSA9PT0gdGFyZ2V0LmxvY2F0aW9uLmxvZ2ljYWxSZXNvdXJjZUlkICYmXG4gICAgICAgICAgICAgIGV4cG9ydFZhbHVlLnZhbHVlWydGbjo6R2V0QXR0J11bMV0gPT09IGdldEF0dC5hdHRyaWJ1dGVOYW1lKSB8fFxuICAgICAgICAgICAgZXhwb3J0VmFsdWUudmFsdWVbJ0ZuOjpHZXRBdHQnXSA9PT0gYCR7dGFyZ2V0LmxvY2F0aW9uLmxvZ2ljYWxSZXNvdXJjZUlkfS4ke2dldEF0dC5hdHRyaWJ1dGVOYW1lfWApXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBnZXQgb3V0cHV0KCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgIGlmICh0aGlzLm91dHB1dE5hbWUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignQ2Fubm90IGFjY2VzcyBvdXRwdXQgYmVmb3JlIGNhbGxpbmcgdG9DZm4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgW3RoaXMub3V0cHV0TmFtZV06IHRoaXMub3V0cHV0Q29udGVudCB9O1xuICB9XG59XG5cbmNsYXNzIFN1YiBpbXBsZW1lbnRzIENsb3VkRm9ybWF0aW9uUmVmZXJlbmNlIHtcbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGlucHV0U3RyaW5nOiBzdHJpbmcsIHB1YmxpYyByZWFkb25seSB2YXJOYW1lczogc3RyaW5nW10pIHtcbiAgfVxuXG4gIHRvQ2ZuKHRhcmdldHM6IFJlc291cmNlTm9kZVtdKTogYW55IHtcbiAgICBsZXQgaW5wdXRTdHJpbmcgPSB0aGlzLmlucHV0U3RyaW5nO1xuXG4gICAgdGhpcy52YXJOYW1lcy5mb3JFYWNoKCh2YXJOYW1lLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgW18sIGF0dHJdID0gdmFyTmFtZS5zcGxpdCgvXFwuKC4qKS9zKTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldHNbaW5kZXhdO1xuICAgICAgaW5wdXRTdHJpbmcgPSBpbnB1dFN0cmluZy5yZXBsYWNlKGBcXCR7JHt2YXJOYW1lfWAsIGBcXCR7JHt0YXJnZXQubG9jYXRpb24ubG9naWNhbFJlc291cmNlSWR9JHthdHRyID8gYC4ke2F0dHJ9YCA6ICcnfWAsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGlucHV0U3RyaW5nO1xuICB9XG59XG5cbmNsYXNzIERlcGVuZHNPbiBpbXBsZW1lbnRzIENsb3VkRm9ybWF0aW9uUmVmZXJlbmNlIHtcbiAgcHVibGljIHN0YXRpYyBJTlNUQU5DRSA9IG5ldyBEZXBlbmRzT24oKTtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICB9XG5cbiAgdG9DZm4odGFyZ2V0czogUmVzb3VyY2VOb2RlW10pOiBhbnkge1xuICAgIHJldHVybiB0YXJnZXRzLm1hcCgodCkgPT4gdC5sb2NhdGlvbi5sb2dpY2FsUmVzb3VyY2VJZCk7XG4gIH1cbn1cbiJdfQ==