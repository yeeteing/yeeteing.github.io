"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectAccumulator = exports.ObjectAccumulatorVersionMismatchError = exports.ObjectAccumulatorPropertyAlreadyExistsError = void 0;
const lodash_mergewith_1 = __importDefault(require("lodash.mergewith"));
const semver_1 = __importDefault(require("semver"));
/**
 * This error is thrown when there's a collision in the object keys
 */
class ObjectAccumulatorPropertyAlreadyExistsError extends Error {
    key;
    existingValue;
    incomingValue;
    /**
     * Creates property already exists error.
     */
    constructor(key, existingValue, incomingValue) {
        super(`Property ${key} already exists`);
        this.key = key;
        this.existingValue = existingValue;
        this.incomingValue = incomingValue;
    }
}
exports.ObjectAccumulatorPropertyAlreadyExistsError = ObjectAccumulatorPropertyAlreadyExistsError;
/**
 * This error is thrown when partial objects with different versions are being accumulated
 */
class ObjectAccumulatorVersionMismatchError extends Error {
    existingVersion;
    newVersion;
    /**
     * Creates property already exists error.
     */
    constructor(existingVersion, newVersion) {
        super(`Version mismatch: Cannot accumulate new objects with version ${newVersion} with existing accumulated object with version ${existingVersion}`);
        this.existingVersion = existingVersion;
        this.newVersion = newVersion;
    }
}
exports.ObjectAccumulatorVersionMismatchError = ObjectAccumulatorVersionMismatchError;
/**
 * A class that can accumulate (squash merge) objects into single instance.
 */
class ObjectAccumulator {
    accumulator;
    versionKey;
    /**
     * creates object accumulator.
     */
    constructor(accumulator, versionKey = 'version') {
        this.accumulator = accumulator;
        this.versionKey = versionKey;
    }
    /**
     * Accumulate a new object part with accumulator.
     * This method throws if there is any intersection between the object parts
     * except for the versionKey, which should be the same across all object parts (nested objects included)
     * @param part a new object part to accumulate
     * @returns the accumulator object for easy chaining
     */
    accumulate = (part) => {
        (0, lodash_mergewith_1.default)(this.accumulator, part, (existingValue, incomingValue, key) => {
            if (Array.isArray(existingValue)) {
                return existingValue.concat(incomingValue);
            }
            if (existingValue && typeof existingValue !== 'object') {
                if (key === this.versionKey) {
                    const incomingVersion = semver_1.default.coerce(incomingValue);
                    const existingVersion = semver_1.default.coerce(existingValue);
                    if (incomingVersion && existingVersion) {
                        // Only throw if the major version is not equal
                        if (incomingVersion.major !== existingVersion.major) {
                            throw new ObjectAccumulatorVersionMismatchError(existingValue, incomingValue);
                        }
                        else {
                            // We always get the max version to persist in the accumulated object
                            return semver_1.default.gte(incomingVersion, existingVersion)
                                ? incomingValue
                                : existingValue;
                        }
                    }
                }
                else if (key !== this.versionKey) {
                    throw new ObjectAccumulatorPropertyAlreadyExistsError(key, existingValue, incomingValue);
                }
            }
            // returning undefined falls back to default merge algorithm
            return undefined;
        });
        return this;
    };
    getAccumulatedObject = () => {
        return this.accumulator;
    };
}
exports.ObjectAccumulator = ObjectAccumulator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2JqZWN0X2FjY3VtdWxhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL29iamVjdF9hY2N1bXVsYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQSx3RUFBeUM7QUFDekMsb0RBQTRCO0FBQzVCOztHQUVHO0FBQ0gsTUFBYSwyQ0FBNEMsU0FBUSxLQUFLO0lBS3pEO0lBQ0E7SUFDQTtJQU5YOztPQUVHO0lBQ0gsWUFDVyxHQUFXLEVBQ1gsYUFBc0IsRUFDdEIsYUFBc0I7UUFFL0IsS0FBSyxDQUFDLFlBQVksR0FBRyxpQkFBaUIsQ0FBQyxDQUFDO1FBSi9CLFFBQUcsR0FBSCxHQUFHLENBQVE7UUFDWCxrQkFBYSxHQUFiLGFBQWEsQ0FBUztRQUN0QixrQkFBYSxHQUFiLGFBQWEsQ0FBUztJQUdqQyxDQUFDO0NBQ0Y7QUFYRCxrR0FXQztBQUVEOztHQUVHO0FBQ0gsTUFBYSxxQ0FBc0MsU0FBUSxLQUFLO0lBS25EO0lBQ0E7SUFMWDs7T0FFRztJQUNILFlBQ1csZUFBdUIsRUFDdkIsVUFBa0I7UUFFM0IsS0FBSyxDQUNILGdFQUFnRSxVQUFVLGtEQUFrRCxlQUFlLEVBQUUsQ0FDOUksQ0FBQztRQUxPLG9CQUFlLEdBQWYsZUFBZSxDQUFRO1FBQ3ZCLGVBQVUsR0FBVixVQUFVLENBQVE7SUFLN0IsQ0FBQztDQUNGO0FBWkQsc0ZBWUM7QUFFRDs7R0FFRztBQUNILE1BQWEsaUJBQWlCO0lBS1Q7SUFDQTtJQUxuQjs7T0FFRztJQUNILFlBQ21CLFdBQWtELEVBQ2xELGFBQWEsU0FBUztRQUR0QixnQkFBVyxHQUFYLFdBQVcsQ0FBdUM7UUFDbEQsZUFBVSxHQUFWLFVBQVUsQ0FBWTtJQUN0QyxDQUFDO0lBRUo7Ozs7OztPQU1HO0lBQ0gsVUFBVSxHQUFHLENBQ1gsSUFBMkMsRUFDckIsRUFBRTtRQUN4QixJQUFBLDBCQUFTLEVBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxhQUFhLEVBQUUsYUFBYSxFQUFFLEdBQUcsRUFBRSxFQUFFO1lBQ3RFLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDO2dCQUNqQyxPQUFPLGFBQWEsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDN0MsQ0FBQztZQUNELElBQUksYUFBYSxJQUFJLE9BQU8sYUFBYSxLQUFLLFFBQVEsRUFBRSxDQUFDO2dCQUN2RCxJQUFJLEdBQUcsS0FBSyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7b0JBQzVCLE1BQU0sZUFBZSxHQUFHLGdCQUFNLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDO29CQUNyRCxNQUFNLGVBQWUsR0FBRyxnQkFBTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQztvQkFDckQsSUFBSSxlQUFlLElBQUksZUFBZSxFQUFFLENBQUM7d0JBQ3ZDLCtDQUErQzt3QkFDL0MsSUFBSSxlQUFlLENBQUMsS0FBSyxLQUFLLGVBQWUsQ0FBQyxLQUFLLEVBQUUsQ0FBQzs0QkFDcEQsTUFBTSxJQUFJLHFDQUFxQyxDQUM3QyxhQUFhLEVBQ2IsYUFBYSxDQUNkLENBQUM7d0JBQ0osQ0FBQzs2QkFBTSxDQUFDOzRCQUNOLHFFQUFxRTs0QkFDckUsT0FBTyxnQkFBTSxDQUFDLEdBQUcsQ0FBQyxlQUFlLEVBQUUsZUFBZSxDQUFDO2dDQUNqRCxDQUFDLENBQUMsYUFBYTtnQ0FDZixDQUFDLENBQUMsYUFBYSxDQUFDO3dCQUNwQixDQUFDO29CQUNILENBQUM7Z0JBQ0gsQ0FBQztxQkFBTSxJQUFJLEdBQUcsS0FBSyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7b0JBQ25DLE1BQU0sSUFBSSwyQ0FBMkMsQ0FDbkQsR0FBRyxFQUNILGFBQWEsRUFDYixhQUFhLENBQ2QsQ0FBQztnQkFDSixDQUFDO1lBQ0gsQ0FBQztZQUVELDREQUE0RDtZQUM1RCxPQUFPLFNBQVMsQ0FBQztRQUNuQixDQUFDLENBQUMsQ0FBQztRQUNILE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQyxDQUFDO0lBRUYsb0JBQW9CLEdBQUcsR0FBRyxFQUFFO1FBQzFCLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQztJQUMxQixDQUFDLENBQUM7Q0FDSDtBQTNERCw4Q0EyREMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEZWVwUGFydGlhbEFtcGxpZnlHZW5lcmF0ZWRDb25maWdzIH0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsdWdpbi10eXBlcyc7XG5pbXBvcnQgbWVyZ2VXaXRoIGZyb20gJ2xvZGFzaC5tZXJnZXdpdGgnO1xuaW1wb3J0IHNlbXZlciBmcm9tICdzZW12ZXInO1xuLyoqXG4gKiBUaGlzIGVycm9yIGlzIHRocm93biB3aGVuIHRoZXJlJ3MgYSBjb2xsaXNpb24gaW4gdGhlIG9iamVjdCBrZXlzXG4gKi9cbmV4cG9ydCBjbGFzcyBPYmplY3RBY2N1bXVsYXRvclByb3BlcnR5QWxyZWFkeUV4aXN0c0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogQ3JlYXRlcyBwcm9wZXJ0eSBhbHJlYWR5IGV4aXN0cyBlcnJvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHJlYWRvbmx5IGtleTogc3RyaW5nLFxuICAgIHJlYWRvbmx5IGV4aXN0aW5nVmFsdWU6IHVua25vd24sXG4gICAgcmVhZG9ubHkgaW5jb21pbmdWYWx1ZTogdW5rbm93bixcbiAgKSB7XG4gICAgc3VwZXIoYFByb3BlcnR5ICR7a2V5fSBhbHJlYWR5IGV4aXN0c2ApO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBlcnJvciBpcyB0aHJvd24gd2hlbiBwYXJ0aWFsIG9iamVjdHMgd2l0aCBkaWZmZXJlbnQgdmVyc2lvbnMgYXJlIGJlaW5nIGFjY3VtdWxhdGVkXG4gKi9cbmV4cG9ydCBjbGFzcyBPYmplY3RBY2N1bXVsYXRvclZlcnNpb25NaXNtYXRjaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogQ3JlYXRlcyBwcm9wZXJ0eSBhbHJlYWR5IGV4aXN0cyBlcnJvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHJlYWRvbmx5IGV4aXN0aW5nVmVyc2lvbjogc3RyaW5nLFxuICAgIHJlYWRvbmx5IG5ld1ZlcnNpb246IHN0cmluZyxcbiAgKSB7XG4gICAgc3VwZXIoXG4gICAgICBgVmVyc2lvbiBtaXNtYXRjaDogQ2Fubm90IGFjY3VtdWxhdGUgbmV3IG9iamVjdHMgd2l0aCB2ZXJzaW9uICR7bmV3VmVyc2lvbn0gd2l0aCBleGlzdGluZyBhY2N1bXVsYXRlZCBvYmplY3Qgd2l0aCB2ZXJzaW9uICR7ZXhpc3RpbmdWZXJzaW9ufWAsXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgY2xhc3MgdGhhdCBjYW4gYWNjdW11bGF0ZSAoc3F1YXNoIG1lcmdlKSBvYmplY3RzIGludG8gc2luZ2xlIGluc3RhbmNlLlxuICovXG5leHBvcnQgY2xhc3MgT2JqZWN0QWNjdW11bGF0b3I8VD4ge1xuICAvKipcbiAgICogY3JlYXRlcyBvYmplY3QgYWNjdW11bGF0b3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGFjY3VtdWxhdG9yOiBEZWVwUGFydGlhbEFtcGxpZnlHZW5lcmF0ZWRDb25maWdzPFQ+LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdmVyc2lvbktleSA9ICd2ZXJzaW9uJyxcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBBY2N1bXVsYXRlIGEgbmV3IG9iamVjdCBwYXJ0IHdpdGggYWNjdW11bGF0b3IuXG4gICAqIFRoaXMgbWV0aG9kIHRocm93cyBpZiB0aGVyZSBpcyBhbnkgaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhlIG9iamVjdCBwYXJ0c1xuICAgKiBleGNlcHQgZm9yIHRoZSB2ZXJzaW9uS2V5LCB3aGljaCBzaG91bGQgYmUgdGhlIHNhbWUgYWNyb3NzIGFsbCBvYmplY3QgcGFydHMgKG5lc3RlZCBvYmplY3RzIGluY2x1ZGVkKVxuICAgKiBAcGFyYW0gcGFydCBhIG5ldyBvYmplY3QgcGFydCB0byBhY2N1bXVsYXRlXG4gICAqIEByZXR1cm5zIHRoZSBhY2N1bXVsYXRvciBvYmplY3QgZm9yIGVhc3kgY2hhaW5pbmdcbiAgICovXG4gIGFjY3VtdWxhdGUgPSAoXG4gICAgcGFydDogRGVlcFBhcnRpYWxBbXBsaWZ5R2VuZXJhdGVkQ29uZmlnczxUPixcbiAgKTogT2JqZWN0QWNjdW11bGF0b3I8VD4gPT4ge1xuICAgIG1lcmdlV2l0aCh0aGlzLmFjY3VtdWxhdG9yLCBwYXJ0LCAoZXhpc3RpbmdWYWx1ZSwgaW5jb21pbmdWYWx1ZSwga2V5KSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShleGlzdGluZ1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdWYWx1ZS5jb25jYXQoaW5jb21pbmdWYWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoZXhpc3RpbmdWYWx1ZSAmJiB0eXBlb2YgZXhpc3RpbmdWYWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gdGhpcy52ZXJzaW9uS2V5KSB7XG4gICAgICAgICAgY29uc3QgaW5jb21pbmdWZXJzaW9uID0gc2VtdmVyLmNvZXJjZShpbmNvbWluZ1ZhbHVlKTtcbiAgICAgICAgICBjb25zdCBleGlzdGluZ1ZlcnNpb24gPSBzZW12ZXIuY29lcmNlKGV4aXN0aW5nVmFsdWUpO1xuICAgICAgICAgIGlmIChpbmNvbWluZ1ZlcnNpb24gJiYgZXhpc3RpbmdWZXJzaW9uKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHRocm93IGlmIHRoZSBtYWpvciB2ZXJzaW9uIGlzIG5vdCBlcXVhbFxuICAgICAgICAgICAgaWYgKGluY29taW5nVmVyc2lvbi5tYWpvciAhPT0gZXhpc3RpbmdWZXJzaW9uLm1ham9yKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RBY2N1bXVsYXRvclZlcnNpb25NaXNtYXRjaEVycm9yKFxuICAgICAgICAgICAgICAgIGV4aXN0aW5nVmFsdWUsXG4gICAgICAgICAgICAgICAgaW5jb21pbmdWYWx1ZSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFdlIGFsd2F5cyBnZXQgdGhlIG1heCB2ZXJzaW9uIHRvIHBlcnNpc3QgaW4gdGhlIGFjY3VtdWxhdGVkIG9iamVjdFxuICAgICAgICAgICAgICByZXR1cm4gc2VtdmVyLmd0ZShpbmNvbWluZ1ZlcnNpb24sIGV4aXN0aW5nVmVyc2lvbilcbiAgICAgICAgICAgICAgICA/IGluY29taW5nVmFsdWVcbiAgICAgICAgICAgICAgICA6IGV4aXN0aW5nVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGtleSAhPT0gdGhpcy52ZXJzaW9uS2V5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE9iamVjdEFjY3VtdWxhdG9yUHJvcGVydHlBbHJlYWR5RXhpc3RzRXJyb3IoXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleGlzdGluZ1ZhbHVlLFxuICAgICAgICAgICAgaW5jb21pbmdWYWx1ZSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHJldHVybmluZyB1bmRlZmluZWQgZmFsbHMgYmFjayB0byBkZWZhdWx0IG1lcmdlIGFsZ29yaXRobVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBnZXRBY2N1bXVsYXRlZE9iamVjdCA9ICgpID0+IHtcbiAgICByZXR1cm4gdGhpcy5hY2N1bXVsYXRvcjtcbiAgfTtcbn1cbiJdfQ==