"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyDefaults = applyDefaults;
exports.isEmpty = isEmpty;
exports.deepClone = deepClone;
exports.mapObject = mapObject;
exports.makeObject = makeObject;
exports.deepGet = deepGet;
exports.deepSet = deepSet;
exports.deepMerge = deepMerge;
exports.splitBySize = splitBySize;
exports.transformObjectKeys = transformObjectKeys;
exports.noUndefined = noUndefined;
const types_1 = require("./types");
const toolkit_error_1 = require("../toolkit/toolkit-error");
/**
 * Return a new object by adding missing keys into another object
 */
function applyDefaults(hash, defaults) {
    const result = {};
    Object.keys(hash).forEach(k => result[k] = hash[k]);
    Object.keys(defaults)
        .filter(k => !(k in result))
        .forEach(k => result[k] = defaults[k]);
    return result;
}
/**
 * Return whether the given parameter is an empty object or empty list.
 */
function isEmpty(x) {
    if (x == null) {
        return false;
    }
    if ((0, types_1.isArray)(x)) {
        return x.length === 0;
    }
    return Object.keys(x).length === 0;
}
/**
 * Deep clone a tree of objects, lists or scalars
 *
 * Does not support cycles.
 */
function deepClone(x) {
    if (typeof x === 'undefined') {
        return undefined;
    }
    if (x === null) {
        return null;
    }
    if ((0, types_1.isArray)(x)) {
        return x.map(deepClone);
    }
    if ((0, types_1.isObject)(x)) {
        return makeObject(mapObject(x, (k, v) => [k, deepClone(v)]));
    }
    return x;
}
/**
 * Map over an object, treating it as a dictionary
 */
function mapObject(x, fn) {
    const ret = [];
    Object.keys(x).forEach(key => {
        ret.push(fn(key, x[key]));
    });
    return ret;
}
/**
 * Construct an object from a list of (k, v) pairs
 */
function makeObject(pairs) {
    const ret = {};
    for (const pair of pairs) {
        ret[pair[0]] = pair[1];
    }
    return ret;
}
/**
 * Deep get a value from a tree of nested objects
 *
 * Returns undefined if any part of the path was unset or
 * not an object.
 */
function deepGet(x, path) {
    path = path.slice();
    while (path.length > 0 && (0, types_1.isObject)(x)) {
        const key = path.shift();
        x = x[key];
    }
    return path.length === 0 ? x : undefined;
}
/**
 * Deep set a value in a tree of nested objects
 *
 * Throws an error if any part of the path is not an object.
 */
function deepSet(x, path, value) {
    path = path.slice();
    if (path.length === 0) {
        throw new toolkit_error_1.ToolkitError('Path may not be empty');
    }
    while (path.length > 1 && (0, types_1.isObject)(x)) {
        const key = path.shift();
        if (isPrototypePollutingKey(key)) {
            continue;
        }
        if (!(key in x)) {
            x[key] = {};
        }
        x = x[key];
    }
    if (!(0, types_1.isObject)(x)) {
        throw new toolkit_error_1.ToolkitError(`Expected an object, got '${x}'`);
    }
    const finalKey = path[0];
    if (isPrototypePollutingKey(finalKey)) {
        return;
    }
    if (value !== undefined) {
        x[finalKey] = value;
    }
    else {
        delete x[finalKey];
    }
}
/**
 * Helper to detect prototype polluting keys
 *
 * A key matching this, MUST NOT be used in an assignment.
 * Use this to check user-input.
 */
function isPrototypePollutingKey(key) {
    return key === '__proto__' || key === 'constructor' || key === 'prototype';
}
/**
 * Recursively merge objects together
 *
 * The leftmost object is mutated and returned. Arrays are not merged
 * but overwritten just like scalars.
 *
 * If an object is merged into a non-object, the non-object is lost.
 */
function deepMerge(...objects) {
    function mergeOne(target, source) {
        for (const key of Object.keys(source)) {
            if (isPrototypePollutingKey(key)) {
                continue;
            }
            const value = source[key];
            if ((0, types_1.isObject)(value)) {
                if (!(0, types_1.isObject)(target[key])) {
                    target[key] = {};
                } // Overwrite on purpose
                mergeOne(target[key], value);
            }
            else if (typeof value !== 'undefined') {
                target[key] = value;
            }
        }
    }
    const others = objects.filter(x => x != null);
    if (others.length === 0) {
        return {};
    }
    const into = others.splice(0, 1)[0];
    others.forEach(other => mergeOne(into, other));
    return into;
}
/**
 * Splits the given object into two, such that:
 *
 * 1. The size of the first object (after stringified in UTF-8) is less than or equal to the provided size limit.
 * 2. Merging the two objects results in the original one.
 */
function splitBySize(data, maxSizeBytes) {
    if (maxSizeBytes < 2) {
        // It's impossible to fit anything in the first object
        return [undefined, data];
    }
    const entries = Object.entries(data);
    return recurse(0, 0);
    function recurse(index, runningTotalSize) {
        if (index >= entries.length) {
            // Everything fits in the first object
            return [data, undefined];
        }
        const size = runningTotalSize + entrySize(entries[index]);
        return (size > maxSizeBytes) ? cutAt(index) : recurse(index + 1, size);
    }
    function entrySize(entry) {
        return Buffer.byteLength(JSON.stringify(Object.fromEntries([entry])));
    }
    function cutAt(index) {
        return [
            Object.fromEntries(entries.slice(0, index)),
            Object.fromEntries(entries.slice(index)),
        ];
    }
}
/**
 * This function transforms all keys (recursively) in the provided `val` object.
 *
 * @param val - The object whose keys need to be transformed.
 * @param transform - The function that will be applied to each key.
 * @param exclude - The keys that will not be transformed and copied to output directly
 * @returns A new object with the same values as `val`, but with all keys transformed according to `transform`.
 */
function transformObjectKeys(val, transform, exclude = {}) {
    if (val == null || typeof val !== 'object') {
        return val;
    }
    if (Array.isArray(val)) {
        // For arrays we just pass parent's exclude object directly
        // since it makes no sense to specify different exclude options for each array element
        return val.map((input) => transformObjectKeys(input, transform, exclude));
    }
    const ret = {};
    for (const [k, v] of Object.entries(val)) {
        const childExclude = exclude[k];
        if (childExclude === true) {
            // we don't transform this object if the key is specified in exclude
            ret[transform(k)] = v;
        }
        else {
            ret[transform(k)] = transformObjectKeys(v, transform, childExclude);
        }
    }
    return ret;
}
/**
 * Remove undefined values from a dictionary
 */
function noUndefined(xs) {
    return Object.fromEntries(Object.entries(xs).filter(([_, v]) => v !== undefined));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2JqZWN0cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm9iamVjdHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFPQSxzQ0FVQztBQUtELDBCQVFDO0FBT0QsOEJBY0M7QUFLRCw4QkFNQztBQUtELGdDQU1DO0FBUUQsMEJBUUM7QUFPRCwwQkFtQ0M7QUFvQkQsOEJBNkJDO0FBUUQsa0NBNEJDO0FBWUQsa0RBb0JDO0FBS0Qsa0NBRUM7QUE5UEQsbUNBQTRDO0FBQzVDLDREQUF3RDtBQUV4RDs7R0FFRztBQUNILFNBQWdCLGFBQWEsQ0FBQyxJQUFTLEVBQUUsUUFBYTtJQUNwRCxNQUFNLE1BQU0sR0FBUSxFQUFHLENBQUM7SUFFeEIsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFcEQsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7U0FDbEIsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsQ0FBQztTQUMzQixPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFekMsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsT0FBTyxDQUFDLENBQU07SUFDNUIsSUFBSSxDQUFDLElBQUksSUFBSSxFQUFFLENBQUM7UUFDZCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFDRCxJQUFJLElBQUEsZUFBTyxFQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDZixPQUFPLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO0lBQ3hCLENBQUM7SUFDRCxPQUFPLE1BQU0s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IjpbImltcG9ydCB0eXBlIHsgT2JqIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBpc0FycmF5LCBpc09iamVjdCB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgVG9vbGtpdEVycm9yIH0gZnJvbSAnLi4vdG9vbGtpdC90b29sa2l0LWVycm9yJztcblxuLyoqXG4gKiBSZXR1cm4gYSBuZXcgb2JqZWN0IGJ5IGFkZGluZyBtaXNzaW5nIGtleXMgaW50byBhbm90aGVyIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlEZWZhdWx0cyhoYXNoOiBhbnksIGRlZmF1bHRzOiBhbnkpIHtcbiAgY29uc3QgcmVzdWx0OiBhbnkgPSB7IH07XG5cbiAgT2JqZWN0LmtleXMoaGFzaCkuZm9yRWFjaChrID0+IHJlc3VsdFtrXSA9IGhhc2hba10pO1xuXG4gIE9iamVjdC5rZXlzKGRlZmF1bHRzKVxuICAgIC5maWx0ZXIoayA9PiAhKGsgaW4gcmVzdWx0KSlcbiAgICAuZm9yRWFjaChrID0+IHJlc3VsdFtrXSA9IGRlZmF1bHRzW2tdKTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIHRoZSBnaXZlbiBwYXJhbWV0ZXIgaXMgYW4gZW1wdHkgb2JqZWN0IG9yIGVtcHR5IGxpc3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5KHg6IGFueSkge1xuICBpZiAoeCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc0FycmF5KHgpKSB7XG4gICAgcmV0dXJuIHgubGVuZ3RoID09PSAwO1xuICB9XG4gIHJldHVybiBPYmplY3Qua2V5cyh4KS5sZW5ndGggPT09IDA7XG59XG5cbi8qKlxuICogRGVlcCBjbG9uZSBhIHRyZWUgb2Ygb2JqZWN0cywgbGlzdHMgb3Igc2NhbGFyc1xuICpcbiAqIERvZXMgbm90IHN1cHBvcnQgY3ljbGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcENsb25lKHg6IGFueSk6IGFueSB7XG4gIGlmICh0eXBlb2YgeCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh4ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGlzQXJyYXkoeCkpIHtcbiAgICByZXR1cm4geC5tYXAoZGVlcENsb25lKTtcbiAgfVxuICBpZiAoaXNPYmplY3QoeCkpIHtcbiAgICByZXR1cm4gbWFrZU9iamVjdChtYXBPYmplY3QoeCwgKGssIHYpID0+IFtrLCBkZWVwQ2xvbmUodildIGFzIFtzdHJpbmcsIGFueV0pKTtcbiAgfVxuICByZXR1cm4geDtcbn1cblxuLyoqXG4gKiBNYXAgb3ZlciBhbiBvYmplY3QsIHRyZWF0aW5nIGl0IGFzIGEgZGljdGlvbmFyeVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwT2JqZWN0PFQsIFU+KHg6IE9iajxUPiwgZm46IChrZXk6IHN0cmluZywgdmFsdWU6IFQpID0+IFUpOiBVW10ge1xuICBjb25zdCByZXQ6IFVbXSA9IFtdO1xuICBPYmplY3Qua2V5cyh4KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgcmV0LnB1c2goZm4oa2V5LCB4W2tleV0pKTtcbiAgfSk7XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogQ29uc3RydWN0IGFuIG9iamVjdCBmcm9tIGEgbGlzdCBvZiAoaywgdikgcGFpcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VPYmplY3Q8VD4ocGFpcnM6IEFycmF5PFtzdHJpbmcsIFRdPik6IE9iajxUPiB7XG4gIGNvbnN0IHJldDogT2JqPFQ+ID0ge307XG4gIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgIHJldFtwYWlyWzBdXSA9IHBhaXJbMV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBEZWVwIGdldCBhIHZhbHVlIGZyb20gYSB0cmVlIG9mIG5lc3RlZCBvYmplY3RzXG4gKlxuICogUmV0dXJucyB1bmRlZmluZWQgaWYgYW55IHBhcnQgb2YgdGhlIHBhdGggd2FzIHVuc2V0IG9yXG4gKiBub3QgYW4gb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcEdldCh4OiBhbnksIHBhdGg6IHN0cmluZ1tdKTogYW55IHtcbiAgcGF0aCA9IHBhdGguc2xpY2UoKTtcblxuICB3aGlsZSAocGF0aC5sZW5ndGggPiAwICYmIGlzT2JqZWN0KHgpKSB7XG4gICAgY29uc3Qga2V5ID0gcGF0aC5zaGlmdCgpITtcbiAgICB4ID0geFtrZXldO1xuICB9XG4gIHJldHVybiBwYXRoLmxlbmd0aCA9PT0gMCA/IHggOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogRGVlcCBzZXQgYSB2YWx1ZSBpbiBhIHRyZWUgb2YgbmVzdGVkIG9iamVjdHNcbiAqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgYW55IHBhcnQgb2YgdGhlIHBhdGggaXMgbm90IGFuIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBTZXQoeDogYW55LCBwYXRoOiBzdHJpbmdbXSwgdmFsdWU6IGFueSkge1xuICBwYXRoID0gcGF0aC5zbGljZSgpO1xuXG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ1BhdGggbWF5IG5vdCBiZSBlbXB0eScpO1xuICB9XG5cbiAgd2hpbGUgKHBhdGgubGVuZ3RoID4gMSAmJiBpc09iamVjdCh4KSkge1xuICAgIGNvbnN0IGtleSA9IHBhdGguc2hpZnQoKSE7XG5cbiAgICBpZiAoaXNQcm90b3R5cGVQb2xsdXRpbmdLZXkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCEoa2V5IGluIHgpKSB7XG4gICAgICB4W2tleV0gPSB7fTtcbiAgICB9XG4gICAgeCA9IHhba2V5XTtcbiAgfVxuXG4gIGlmICghaXNPYmplY3QoeCkpIHtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBFeHBlY3RlZCBhbiBvYmplY3QsIGdvdCAnJHt4fSdgKTtcbiAgfVxuXG4gIGNvbnN0IGZpbmFsS2V5ID0gcGF0aFswXTtcblxuICBpZiAoaXNQcm90b3R5cGVQb2xsdXRpbmdLZXkoZmluYWxLZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICB4W2ZpbmFsS2V5XSA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSB4W2ZpbmFsS2V5XTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB0byBkZXRlY3QgcHJvdG90eXBlIHBvbGx1dGluZyBrZXlzXG4gKlxuICogQSBrZXkgbWF0Y2hpbmcgdGhpcywgTVVTVCBOT1QgYmUgdXNlZCBpbiBhbiBhc3NpZ25tZW50LlxuICogVXNlIHRoaXMgdG8gY2hlY2sgdXNlci1pbnB1dC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGVQb2xsdXRpbmdLZXkoa2V5OiBzdHJpbmcpIHtcbiAgcmV0dXJuIGtleSA9PT0gJ19fcHJvdG9fXycgfHwga2V5ID09PSAnY29uc3RydWN0b3InIHx8IGtleSA9PT0gJ3Byb3RvdHlwZSc7XG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyB0b2dldGhlclxuICpcbiAqIFRoZSBsZWZ0bW9zdCBvYmplY3QgaXMgbXV0YXRlZCBhbmQgcmV0dXJuZWQuIEFycmF5cyBhcmUgbm90IG1lcmdlZFxuICogYnV0IG92ZXJ3cml0dGVuIGp1c3QgbGlrZSBzY2FsYXJzLlxuICpcbiAqIElmIGFuIG9iamVjdCBpcyBtZXJnZWQgaW50byBhIG5vbi1vYmplY3QsIHRoZSBub24tb2JqZWN0IGlzIGxvc3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWVwTWVyZ2UoLi4ub2JqZWN0czogQXJyYXk8T2JqPGFueT4gfCB1bmRlZmluZWQ+KSB7XG4gIGZ1bmN0aW9uIG1lcmdlT25lKHRhcmdldDogT2JqPGFueT4sIHNvdXJjZTogT2JqPGFueT4pIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzb3VyY2UpKSB7XG4gICAgICBpZiAoaXNQcm90b3R5cGVQb2xsdXRpbmdLZXkoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KHRhcmdldFtrZXldKSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0ge307XG4gICAgICAgIH0gLy8gT3ZlcndyaXRlIG9uIHB1cnBvc2VcbiAgICAgICAgbWVyZ2VPbmUodGFyZ2V0W2tleV0sIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG90aGVycyA9IG9iamVjdHMuZmlsdGVyKHggPT4geCAhPSBudWxsKSBhcyBBcnJheTxPYmo8YW55Pj47XG5cbiAgaWYgKG90aGVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgaW50byA9IG90aGVycy5zcGxpY2UoMCwgMSlbMF07XG5cbiAgb3RoZXJzLmZvckVhY2gob3RoZXIgPT4gbWVyZ2VPbmUoaW50bywgb3RoZXIpKTtcbiAgcmV0dXJuIGludG87XG59XG5cbi8qKlxuICogU3BsaXRzIHRoZSBnaXZlbiBvYmplY3QgaW50byB0d28sIHN1Y2ggdGhhdDpcbiAqXG4gKiAxLiBUaGUgc2l6ZSBvZiB0aGUgZmlyc3Qgb2JqZWN0IChhZnRlciBzdHJpbmdpZmllZCBpbiBVVEYtOCkgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBzaXplIGxpbWl0LlxuICogMi4gTWVyZ2luZyB0aGUgdHdvIG9iamVjdHMgcmVzdWx0cyBpbiB0aGUgb3JpZ2luYWwgb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRCeVNpemUoZGF0YTogYW55LCBtYXhTaXplQnl0ZXM6IG51bWJlcik6IFthbnksIGFueV0ge1xuICBpZiAobWF4U2l6ZUJ5dGVzIDwgMikge1xuICAgIC8vIEl0J3MgaW1wb3NzaWJsZSB0byBmaXQgYW55dGhpbmcgaW4gdGhlIGZpcnN0IG9iamVjdFxuICAgIHJldHVybiBbdW5kZWZpbmVkLCBkYXRhXTtcbiAgfVxuICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZGF0YSk7XG4gIHJldHVybiByZWN1cnNlKDAsIDApO1xuXG4gIGZ1bmN0aW9uIHJlY3Vyc2UoaW5kZXg6IG51bWJlciwgcnVubmluZ1RvdGFsU2l6ZTogbnVtYmVyKTogW2FueSwgYW55XSB7XG4gICAgaWYgKGluZGV4ID49IGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAvLyBFdmVyeXRoaW5nIGZpdHMgaW4gdGhlIGZpcnN0IG9iamVjdFxuICAgICAgcmV0dXJuIFtkYXRhLCB1bmRlZmluZWRdO1xuICAgIH1cblxuICAgIGNvbnN0IHNpemUgPSBydW5uaW5nVG90YWxTaXplICsgZW50cnlTaXplKGVudHJpZXNbaW5kZXhdKTtcbiAgICByZXR1cm4gKHNpemUgPiBtYXhTaXplQnl0ZXMpID8gY3V0QXQoaW5kZXgpIDogcmVjdXJzZShpbmRleCArIDEsIHNpemUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW50cnlTaXplKGVudHJ5OiBbc3RyaW5nLCB1bmtub3duXSkge1xuICAgIHJldHVybiBCdWZmZXIuYnl0ZUxlbmd0aChKU09OLnN0cmluZ2lmeShPYmplY3QuZnJvbUVudHJpZXMoW2VudHJ5XSkpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGN1dEF0KGluZGV4OiBudW1iZXIpOiBbYW55LCBhbnldIHtcbiAgICByZXR1cm4gW1xuICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKGVudHJpZXMuc2xpY2UoMCwgaW5kZXgpKSxcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhlbnRyaWVzLnNsaWNlKGluZGV4KSksXG4gICAgXTtcbiAgfVxufVxuXG50eXBlIEV4Y2x1ZGUgPSB7IFtrZXk6IHN0cmluZ106IEV4Y2x1ZGUgfCB0cnVlIH07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiB0cmFuc2Zvcm1zIGFsbCBrZXlzIChyZWN1cnNpdmVseSkgaW4gdGhlIHByb3ZpZGVkIGB2YWxgIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsIC0gVGhlIG9iamVjdCB3aG9zZSBrZXlzIG5lZWQgdG8gYmUgdHJhbnNmb3JtZWQuXG4gKiBAcGFyYW0gdHJhbnNmb3JtIC0gVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGVhY2gga2V5LlxuICogQHBhcmFtIGV4Y2x1ZGUgLSBUaGUga2V5cyB0aGF0IHdpbGwgbm90IGJlIHRyYW5zZm9ybWVkIGFuZCBjb3BpZWQgdG8gb3V0cHV0IGRpcmVjdGx5XG4gKiBAcmV0dXJucyBBIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgYHZhbGAsIGJ1dCB3aXRoIGFsbCBrZXlzIHRyYW5zZm9ybWVkIGFjY29yZGluZyB0byBgdHJhbnNmb3JtYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU9iamVjdEtleXModmFsOiBhbnksIHRyYW5zZm9ybTogKHN0cjogc3RyaW5nKSA9PiBzdHJpbmcsIGV4Y2x1ZGU6IEV4Y2x1ZGUgPSB7fSk6IGFueSB7XG4gIGlmICh2YWwgPT0gbnVsbCB8fCB0eXBlb2YgdmFsICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIC8vIEZvciBhcnJheXMgd2UganVzdCBwYXNzIHBhcmVudCdzIGV4Y2x1ZGUgb2JqZWN0IGRpcmVjdGx5XG4gICAgLy8gc2luY2UgaXQgbWFrZXMgbm8gc2Vuc2UgdG8gc3BlY2lmeSBkaWZmZXJlbnQgZXhjbHVkZSBvcHRpb25zIGZvciBlYWNoIGFycmF5IGVsZW1lbnRcbiAgICByZXR1cm4gdmFsLm1hcCgoaW5wdXQ6IGFueSkgPT4gdHJhbnNmb3JtT2JqZWN0S2V5cyhpbnB1dCwgdHJhbnNmb3JtLCBleGNsdWRlKSk7XG4gIH1cbiAgY29uc3QgcmV0OiB7IFtrOiBzdHJpbmddOiBhbnkgfSA9IHt9O1xuICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyh2YWwpKSB7XG4gICAgY29uc3QgY2hpbGRFeGNsdWRlID0gZXhjbHVkZVtrXTtcbiAgICBpZiAoY2hpbGRFeGNsdWRlID09PSB0cnVlKSB7XG4gICAgICAvLyB3ZSBkb24ndCB0cmFuc2Zvcm0gdGhpcyBvYmplY3QgaWYgdGhlIGtleSBpcyBzcGVjaWZpZWQgaW4gZXhjbHVkZVxuICAgICAgcmV0W3RyYW5zZm9ybShrKV0gPSB2O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRbdHJhbnNmb3JtKGspXSA9IHRyYW5zZm9ybU9iamVjdEtleXModiwgdHJhbnNmb3JtLCBjaGlsZEV4Y2x1ZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIFJlbW92ZSB1bmRlZmluZWQgdmFsdWVzIGZyb20gYSBkaWN0aW9uYXJ5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub1VuZGVmaW5lZDxBPih4czogUmVjb3JkPHN0cmluZywgQT4pOiBSZWNvcmQ8c3RyaW5nLCBOb25OdWxsYWJsZTxBPj4ge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHhzKS5maWx0ZXIoKFtfLCB2XSkgPT4gdiAhPT0gdW5kZWZpbmVkKSkgYXMgYW55O1xufVxuIl19