#!/usr/bin/env node
import { context as openTelemetryContext, trace as openTelemetryTrace, } from '@opentelemetry/api';
import { AsyncLocalStorageContextManager } from '@opentelemetry/context-async-hooks';
import { BasicTracerProvider } from '@opentelemetry/sdk-trace-base';
import { createMainParser } from './main_parser_factory.js';
import { attachUnhandledExceptionListeners, generateCommandFailureHandler, } from './error_handler.js';
import { extractSubCommands } from './extract_sub_commands.js';
import { AmplifyFault, PackageJsonReader, TelemetrySpanProcessorFactory, UsageDataEmitterFactory, setSpanAttributes, telemetrySpanAttributeCountLimit, translateErrorToTelemetryErrorDetails, } from '@aws-amplify/platform-core';
import { fileURLToPath } from 'node:url';
import { verifyCommandName } from './verify_command_name.js';
import { hideBin } from 'yargs/helpers';
import { PackageManagerControllerFactory, format } from '@aws-amplify/cli-core';
import { NoticesRenderer } from './notices/notices_renderer.js';
import { extractCommandInfo } from './extract_command_info.js';
const packageManagerController = new PackageManagerControllerFactory().getPackageManagerController();
const dependencies = await packageManagerController.tryGetDependencies();
const packageJson = new PackageJsonReader().read(fileURLToPath(new URL('../package.json', import.meta.url)));
const libraryVersion = packageJson.version;
if (libraryVersion == undefined) {
    throw new AmplifyFault('UnknownVersionFault', {
        message: 'Library version cannot be determined. Check the library installation',
    });
}
const usageDataEmitter = await new UsageDataEmitterFactory().getInstance(libraryVersion, dependencies);
attachUnhandledExceptionListeners(usageDataEmitter);
const contextManager = new AsyncLocalStorageContextManager();
openTelemetryContext.setGlobalContextManager(contextManager);
const telemetrySpanProcessor = await new TelemetrySpanProcessorFactory().getInstance(dependencies);
openTelemetryTrace.setGlobalTracerProvider(new BasicTracerProvider({
    spanProcessors: [telemetrySpanProcessor],
    spanLimits: {
        attributeCountLimit: telemetrySpanAttributeCountLimit,
    },
}));
const tracer = openTelemetryTrace.getTracer('amplify-backend');
await tracer.startActiveSpan('command', async (span) => {
    const startTime = Date.now();
    verifyCommandName();
    const noticesRenderer = new NoticesRenderer(packageManagerController);
    const parser = createMainParser(libraryVersion, noticesRenderer);
    const errorHandler = generateCommandFailureHandler(parser, usageDataEmitter);
    const initTime = Date.now() - startTime;
    // Below is a workaround in order to send telemetry data when user force closes a prompt (e.g. with Ctrl+C)
    const handleAbortion = async (code) => {
        const data = {
            event: {
                state: 'ABORTED',
                command: extractCommandInfo(parser) ?? { path: [], parameters: [] },
            },
            latency: {
                total: Date.now() - startTime,
                init: initTime,
            },
        };
        setSpanAttributes(span, data);
        span.end();
        // Ensure all spans are exported before exiting
        await telemetrySpanProcessor.forceFlush();
        process.exit(code);
    };
    process.on('beforeExit', (code) => void handleAbortion(code));
    try {
        await parser.parseAsync(hideBin(process.argv));
        const metricDimension = {};
        const subCommands = extractSubCommands(parser);
        if (subCommands) {
            metricDimension.command = subCommands;
        }
        await noticesRenderer.tryFindAndPrintApplicableNotices({
            event: 'postCommand',
        });
        await usageDataEmitter.emitSuccess({}, metricDimension);
        const data = {
            event: {
                state: 'SUCCEEDED',
                command: extractCommandInfo(parser) ?? { path: [], parameters: [] },
            },
            latency: {
                total: Date.now() - startTime,
                init: initTime,
            },
        };
        setSpanAttributes(span, data);
        span.end();
        // Ensure all spans are exported before exiting
        await telemetrySpanProcessor.forceFlush();
    }
    catch (e) {
        if (e instanceof Error) {
            const data = {
                event: {
                    state: 'FAILED',
                    command: extractCommandInfo(parser) ?? { path: [], parameters: [] },
                },
                latency: {
                    total: Date.now() - startTime,
                    init: initTime,
                },
                error: translateErrorToTelemetryErrorDetails(e),
            };
            setSpanAttributes(span, data);
            await noticesRenderer.tryFindAndPrintApplicableNotices({
                event: 'postCommand',
                error: e,
            });
            span.end();
            // Ensure all spans are exported before exiting
            await telemetrySpanProcessor.forceFlush();
            await errorHandler(format.error(e), e);
        }
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW1weC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9hbXB4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQSxPQUFPLEVBRUwsT0FBTyxJQUFJLG9CQUFvQixFQUMvQixLQUFLLElBQUksa0JBQWtCLEdBQzVCLE1BQU0sb0JBQW9CLENBQUM7QUFDNUIsT0FBTyxFQUFFLCtCQUErQixFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFDckYsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFDcEUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDNUQsT0FBTyxFQUNMLGlDQUFpQyxFQUNqQyw2QkFBNkIsR0FDOUIsTUFBTSxvQkFBb0IsQ0FBQztBQUM1QixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUMvRCxPQUFPLEVBQ0wsWUFBWSxFQUNaLGlCQUFpQixFQUVqQiw2QkFBNkIsRUFDN0IsdUJBQXVCLEVBQ3ZCLGlCQUFpQixFQUNqQixnQ0FBZ0MsRUFDaEMscUNBQXFDLEdBQ3RDLE1BQU0sNEJBQTRCLENBQUM7QUFDcEMsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUN6QyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUM3RCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3hDLE9BQU8sRUFBRSwrQkFBK0IsRUFBRSxNQUFNLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUNoRixPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFDaEUsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFHL0QsTUFBTSx3QkFBd0IsR0FDNUIsSUFBSSwrQkFBK0IsRUFBRSxDQUFDLDJCQUEyQixFQUFFLENBQUM7QUFDdEUsTUFBTSxZQUFZLEdBQUcsTUFBTSx3QkFB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LFVBQVUsRUFBRSxFQUFFLEVBQUU7aUJBQ3BFO2dCQUNELE9BQU8sRUFBRTtvQkFDUCxLQUFLLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLFNBQVM7b0JBQzdCLElBQUksRUFBRSxRQUFRO2lCQUNmO2dCQUNELEtBQUssRUFBRSxxQ0FBcUMsQ0FBQyxDQUFDLENBQUM7YUFDaEQsQ0FBQztZQUNGLGlCQUFpQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztZQUM5QixNQUFNLGVBQWUsQ0FBQyxnQ0FBZ0MsQ0FBQztnQkFDckQsS0FBSyxFQUFFLGFBQWE7Z0JBQ3BCLEtBQUssRUFBRSxDQUFDO2FBQ1QsQ0FBQyxDQUFDO1lBQ0gsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ1gsK0NBQStDO1lBQy9DLE1BQU0sc0JBQXNCLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDMUMsTUFBTSxZQUFZLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN6QyxDQUFDO0lBQ0gsQ0FBQztBQUNILENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiIyEvdXNyL2Jpbi9lbnYgbm9kZVxuaW1wb3J0IHtcbiAgU3BhbixcbiAgY29udGV4dCBhcyBvcGVuVGVsZW1ldHJ5Q29udGV4dCxcbiAgdHJhY2UgYXMgb3BlblRlbGVtZXRyeVRyYWNlLFxufSBmcm9tICdAb3BlbnRlbGVtZXRyeS9hcGknO1xuaW1wb3J0IHsgQXN5bmNMb2NhbFN0b3JhZ2VDb250ZXh0TWFuYWdlciB9IGZyb20gJ0BvcGVudGVsZW1ldHJ5L2NvbnRleHQtYXN5bmMtaG9va3MnO1xuaW1wb3J0IHsgQmFzaWNUcmFjZXJQcm92aWRlciB9IGZyb20gJ0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlJztcbmltcG9ydCB7IGNyZWF0ZU1haW5QYXJzZXIgfSBmcm9tICcuL21haW5fcGFyc2VyX2ZhY3RvcnkuanMnO1xuaW1wb3J0IHtcbiAgYXR0YWNoVW5oYW5kbGVkRXhjZXB0aW9uTGlzdGVuZXJzLFxuICBnZW5lcmF0ZUNvbW1hbmRGYWlsdXJlSGFuZGxlcixcbn0gZnJvbSAnLi9lcnJvcl9oYW5kbGVyLmpzJztcbmltcG9ydCB7IGV4dHJhY3RTdWJDb21tYW5kcyB9IGZyb20gJy4vZXh0cmFjdF9zdWJfY29tbWFuZHMuanMnO1xuaW1wb3J0IHtcbiAgQW1wbGlmeUZhdWx0LFxuICBQYWNrYWdlSnNvblJlYWRlcixcbiAgVGVsZW1ldHJ5UGF5bG9hZCxcbiAgVGVsZW1ldHJ5U3BhblByb2Nlc3NvckZhY3RvcnksXG4gIFVzYWdlRGF0YUVtaXR0ZXJGYWN0b3J5LFxuICBzZXRTcGFuQXR0cmlidXRlcyxcbiAgdGVsZW1ldHJ5U3BhbkF0dHJpYnV0ZUNvdW50TGltaXQsXG4gIHRyYW5zbGF0ZUVycm9yVG9UZWxlbWV0cnlFcnJvckRldGFpbHMsXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbGF0Zm9ybS1jb3JlJztcbmltcG9ydCB7IGZpbGVVUkxUb1BhdGggfSBmcm9tICdub2RlOnVybCc7XG5pbXBvcnQgeyB2ZXJpZnlDb21tYW5kTmFtZSB9IGZyb20gJy4vdmVyaWZ5X2NvbW1hbmRfbmFtZS5qcyc7XG5pbXBvcnQgeyBoaWRlQmluIH0gZnJvbSAneWFyZ3MvaGVscGVycyc7XG5pbXBvcnQgeyBQYWNrYWdlTWFuYWdlckNvbnRyb2xsZXJGYWN0b3J5LCBmb3JtYXQgfSBmcm9tICdAYXdzLWFtcGxpZnkvY2xpLWNvcmUnO1xuaW1wb3J0IHsgTm90aWNlc1JlbmRlcmVyIH0gZnJvbSAnLi9ub3RpY2VzL25vdGljZXNfcmVuZGVyZXIuanMnO1xuaW1wb3J0IHsgZXh0cmFjdENvbW1hbmRJbmZvIH0gZnJvbSAnLi9leHRyYWN0X2NvbW1hbmRfaW5mby5qcyc7XG5pbXBvcnQgeyBEZWVwUGFydGlhbCB9IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbHVnaW4tdHlwZXMnO1xuXG5jb25zdCBwYWNrYWdlTWFuYWdlckNvbnRyb2xsZXIgPVxuICBuZXcgUGFja2FnZU1hbmFnZXJDb250cm9sbGVyRmFjdG9yeSgpLmdldFBhY2thZ2VNYW5hZ2VyQ29udHJvbGxlcigpO1xuY29uc3QgZGVwZW5kZW5jaWVzID0gYXdhaXQgcGFja2FnZU1hbmFnZXJDb250cm9sbGVyLnRyeUdldERlcGVuZGVuY2llcygpO1xuXG5jb25zdCBwYWNrYWdlSnNvbiA9IG5ldyBQYWNrYWdlSnNvblJlYWRlcigpLnJlYWQoXG4gIGZpbGVVUkxUb1BhdGgobmV3IFVSTCgnLi4vcGFja2FnZS5qc29uJywgaW1wb3J0Lm1ldGEudXJsKSksXG4pO1xuY29uc3QgbGlicmFyeVZlcnNpb24gPSBwYWNrYWdlSnNvbi52ZXJzaW9uO1xuXG5pZiAobGlicmFyeVZlcnNpb24gPT0gdW5kZWZpbmVkKSB7XG4gIHRocm93IG5ldyBBbXBsaWZ5RmF1bHQoJ1Vua25vd25WZXJzaW9uRmF1bHQnLCB7XG4gICAgbWVzc2FnZTpcbiAgICAgICdMaWJyYXJ5IHZlcnNpb24gY2Fubm90IGJlIGRldGVybWluZWQuIENoZWNrIHRoZSBsaWJyYXJ5IGluc3RhbGxhdGlvbicsXG4gIH0pO1xufVxuXG5jb25zdCB1c2FnZURhdGFFbWl0dGVyID0gYXdhaXQgbmV3IFVzYWdlRGF0YUVtaXR0ZXJGYWN0b3J5KCkuZ2V0SW5zdGFuY2UoXG4gIGxpYnJhcnlWZXJzaW9uLFxuICBkZXBlbmRlbmNpZXMsXG4pO1xuXG5hdHRhY2hVbmhhbmRsZWRFeGNlcHRpb25MaXN0ZW5lcnModXNhZ2VEYXRhRW1pdHRlcik7XG5cbmNvbnN0IGNvbnRleHRNYW5hZ2VyID0gbmV3IEFzeW5jTG9jYWxTdG9yYWdlQ29udGV4dE1hbmFnZXIoKTtcbm9wZW5UZWxlbWV0cnlDb250ZXh0LnNldEdsb2JhbENvbnRleHRNYW5hZ2VyKGNvbnRleHRNYW5hZ2VyKTtcblxuY29uc3QgdGVsZW1ldHJ5U3BhblByb2Nlc3NvciA9XG4gIGF3YWl0IG5ldyBUZWxlbWV0cnlTcGFuUHJvY2Vzc29yRmFjdG9yeSgpLmdldEluc3RhbmNlKGRlcGVuZGVuY2llcyk7XG5cbm9wZW5UZWxlbWV0cnlUcmFjZS5zZXRHbG9iYWxUcmFjZXJQcm92aWRlcihcbiAgbmV3IEJhc2ljVHJhY2VyUHJvdmlkZXIoe1xuICAgIHNwYW5Qcm9jZXNzb3JzOiBbdGVsZW1ldHJ5U3BhblByb2Nlc3Nvcl0sXG4gICAgc3BhbkxpbWl0czoge1xuICAgICAgYXR0cmlidXRlQ291bnRMaW1pdDogdGVsZW1ldHJ5U3BhbkF0dHJpYnV0ZUNvdW50TGltaXQsXG4gICAgfSxcbiAgfSksXG4pO1xuXG5jb25zdCB0cmFjZXIgPSBvcGVuVGVsZW1ldHJ5VHJhY2UuZ2V0VHJhY2VyKCdhbXBsaWZ5LWJhY2tlbmQnKTtcblxuYXdhaXQgdHJhY2VyLnN0YXJ0QWN0aXZlU3BhbignY29tbWFuZCcsIGFzeW5jIChzcGFuOiBTcGFuKSA9PiB7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgdmVyaWZ5Q29tbWFuZE5hbWUoKTtcblxuICBjb25zdCBub3RpY2VzUmVuZGVyZXIgPSBuZXcgTm90aWNlc1JlbmRlcmVyKHBhY2thZ2VNYW5hZ2VyQ29udHJvbGxlcik7XG4gIGNvbnN0IHBhcnNlciA9IGNyZWF0ZU1haW5QYXJzZXIobGlicmFyeVZlcnNpb24sIG5vdGljZXNSZW5kZXJlcik7XG4gIGNvbnN0IGVycm9ySGFuZGxlciA9IGdlbmVyYXRlQ29tbWFuZEZhaWx1cmVIYW5kbGVyKHBhcnNlciwgdXNhZ2VEYXRhRW1pdHRlcik7XG4gIGNvbnN0IGluaXRUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAvLyBCZWxvdyBpcyBhIHdvcmthcm91bmQgaW4gb3JkZXIgdG8gc2VuZCB0ZWxlbWV0cnkgZGF0YSB3aGVuIHVzZXIgZm9yY2UgY2xvc2VzIGEgcHJvbXB0IChlLmcuIHdpdGggQ3RybCtDKVxuICBjb25zdCBoYW5kbGVBYm9ydGlvbiA9IGFzeW5jIChjb2RlOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBkYXRhOiBEZWVwUGFydGlhbDxUZWxlbWV0cnlQYXlsb2FkPiA9IHtcbiAgICAgIGV2ZW50OiB7XG4gICAgICAgIHN0YXRlOiAnQUJPUlRFRCcsXG4gICAgICAgIGNvbW1hbmQ6IGV4dHJhY3RDb21tYW5kSW5mbyhwYXJzZXIpID8/IHsgcGF0aDogW10sIHBhcmFtZXRlcnM6IFtdIH0sXG4gICAgICB9LFxuICAgICAgbGF0ZW5jeToge1xuICAgICAgICB0b3RhbDogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgICAgICAgaW5pdDogaW5pdFRpbWUsXG4gICAgICB9LFxuICAgIH07XG4gICAgc2V0U3BhbkF0dHJpYnV0ZXMoc3BhbiwgZGF0YSk7XG4gICAgc3Bhbi5lbmQoKTtcblxuICAgIC8vIEVuc3VyZSBhbGwgc3BhbnMgYXJlIGV4cG9ydGVkIGJlZm9yZSBleGl0aW5nXG4gICAgYXdhaXQgdGVsZW1ldHJ5U3BhblByb2Nlc3Nvci5mb3JjZUZsdXNoKCk7XG5cbiAgICBwcm9jZXNzLmV4aXQoY29kZSk7XG4gIH07XG4gIHByb2Nlc3Mub24oJ2JlZm9yZUV4aXQnLCAoY29kZSkgPT4gdm9pZCBoYW5kbGVBYm9ydGlvbihjb2RlKSk7XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCBwYXJzZXIucGFyc2VBc3luYyhoaWRlQmluKHByb2Nlc3MuYXJndikpO1xuICAgIGNvbnN0IG1ldHJpY0RpbWVuc2lvbjogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICAgIGNvbnN0IHN1YkNvbW1hbmRzID0gZXh0cmFjdFN1YkNvbW1hbmRzKHBhcnNlcik7XG5cbiAgICBpZiAoc3ViQ29tbWFuZHMpIHtcbiAgICAgIG1ldHJpY0RpbWVuc2lvbi5jb21tYW5kID0gc3ViQ29tbWFuZHM7XG4gICAgfVxuXG4gICAgYXdhaXQgbm90aWNlc1JlbmRlcmVyLnRyeUZpbmRBbmRQcmludEFwcGxpY2FibGVOb3RpY2VzKHtcbiAgICAgIGV2ZW50OiAncG9zdENvbW1hbmQnLFxuICAgIH0pO1xuICAgIGF3YWl0IHVzYWdlRGF0YUVtaXR0ZXIuZW1pdFN1Y2Nlc3Moe30sIG1ldHJpY0RpbWVuc2lvbik7XG4gICAgY29uc3QgZGF0YTogRGVlcFBhcnRpYWw8VGVsZW1ldHJ5UGF5bG9hZD4gPSB7XG4gICAgICBldmVudDoge1xuICAgICAgICBzdGF0ZTogJ1NVQ0NFRURFRCcsXG4gICAgICAgIGNvbW1hbmQ6IGV4dHJhY3RDb21tYW5kSW5mbyhwYXJzZXIpID8/IHsgcGF0aDogW10sIHBhcmFtZXRlcnM6IFtdIH0sXG4gICAgICB9LFxuICAgICAgbGF0ZW5jeToge1xuICAgICAgICB0b3RhbDogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgICAgICAgaW5pdDogaW5pdFRpbWUsXG4gICAgICB9LFxuICAgIH07XG4gICAgc2V0U3BhbkF0dHJpYnV0ZXMoc3BhbiwgZGF0YSk7XG4gICAgc3Bhbi5lbmQoKTtcblxuICAgIC8vIEVuc3VyZSBhbGwgc3BhbnMgYXJlIGV4cG9ydGVkIGJlZm9yZSBleGl0aW5nXG4gICAgYXdhaXQgdGVsZW1ldHJ5U3BhblByb2Nlc3Nvci5mb3JjZUZsdXNoKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBjb25zdCBkYXRhOiBEZWVwUGFydGlhbDxUZWxlbWV0cnlQYXlsb2FkPiA9IHtcbiAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICBzdGF0ZTogJ0ZBSUxFRCcsXG4gICAgICAgICAgY29tbWFuZDogZXh0cmFjdENvbW1hbmRJbmZvKHBhcnNlcikgPz8geyBwYXRoOiBbXSwgcGFyYW1ldGVyczogW10gfSxcbiAgICAgICAgfSxcbiAgICAgICAgbGF0ZW5jeToge1xuICAgICAgICAgIHRvdGFsOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxuICAgICAgICAgIGluaXQ6IGluaXRUaW1lLFxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogdHJhbnNsYXRlRXJyb3JUb1RlbGVtZXRyeUVycm9yRGV0YWlscyhlKSxcbiAgICAgIH07XG4gICAgICBzZXRTcGFuQXR0cmlidXRlcyhzcGFuLCBkYXRhKTtcbiAgICAgIGF3YWl0IG5vdGljZXNSZW5kZXJlci50cnlGaW5kQW5kUHJpbnRBcHBsaWNhYmxlTm90aWNlcyh7XG4gICAgICAgIGV2ZW50OiAncG9zdENvbW1hbmQnLFxuICAgICAgICBlcnJvcjogZSxcbiAgICAgIH0pO1xuICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgIC8vIEVuc3VyZSBhbGwgc3BhbnMgYXJlIGV4cG9ydGVkIGJlZm9yZSBleGl0aW5nXG4gICAgICBhd2FpdCB0ZWxlbWV0cnlTcGFuUHJvY2Vzc29yLmZvcmNlRmx1c2goKTtcbiAgICAgIGF3YWl0IGVycm9ySGFuZGxlcihmb3JtYXQuZXJyb3IoZSksIGUpO1xuICAgIH1cbiAgfVxufSk7XG4iXX0=