"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RWLock = void 0;
const fs_1 = require("fs");
const path = require("path");
const toolkit_error_1 = require("../toolkit/toolkit-error");
/**
 * A single-writer/multi-reader lock on a directory
 *
 * It uses marker files with PIDs in them as a locking marker; the PIDs will be
 * checked for liveness, so that if the process exits without cleaning up the
 * files the lock is implicitly released.
 *
 * This class is not 100% race safe, but in practice it should be a lot
 * better than the 0 protection we have today.
 */
/* c8 ignore start */ // code paths are unpredictable
class RWLock {
    directory;
    pidString;
    writerFile;
    readCounter = 0;
    constructor(directory) {
        this.directory = directory;
        this.pidString = `${process.pid}`;
        this.writerFile = path.join(this.directory, 'synth.lock');
    }
    /**
     * Acquire a writer lock.
     *
     * No other readers or writers must exist for the given directory.
     */
    async acquireWrite() {
        await this.assertNoOtherWriters();
        const readers = await this._currentReaders();
        if (readers.length > 0) {
            throw new toolkit_error_1.ToolkitError(`Other CLIs (PID=${readers}) are currently reading from ${this.directory}. Invoke the CLI in sequence, or use '--output' to synth into different directories.`);
        }
        await writeFileAtomic(this.writerFile, this.pidString);
        let released = false;
        return {
            release: async () => {
                // Releasing needs a flag, otherwise we might delete a file that some other lock has created in the mean time.
                if (!released) {
                    await deleteFile(this.writerFile);
                    released = true;
                }
            },
            convertToReaderLock: async () => {
                // Acquire the read lock before releasing the write lock. Slightly less
                // chance of racing!
                const ret = await this.doAcquireRead();
                await deleteFile(this.writerFile);
                return ret;
            },
        };
    }
    /**
     * Acquire a read lock
     *
     * Will fail if there are any writers.
     */
    async acquireRead() {
        await this.assertNoOtherWriters();
        return this.doAcquireRead();
    }
    /**
     * Obtains the name fo a (new) `readerFile` to use. This includes a counter so
     * that if multiple threads of the same PID attempt to concurrently acquire
     * the same lock, they're guaranteed to use a different reader file name (only
     * one thread will ever execute JS code at once, guaranteeing the readCounter
     * is incremented "atomically" from the point of view of this PID.).
     */
    readerFile() {
        return path.join(this.directory, `read.${this.pidString}.${++this.readCounter}.lock`);
    }
    /**
     * Do the actual acquiring of a read lock.
     */
    async doAcquireRead() {
        const readerFile = this.readerFile();
        await writeFileAtomic(readerFile, this.pidString);
        let released = false;
        return {
            release: async () => {
                // Releasing needs a flag, otherwise we might delete a file that some other lock has created in the mean time.
                if (!released) {
                    await deleteFile(readerFile);
                    released = true;
                }
            },
        };
    }
    async assertNoOtherWriters() {
        const writer = await this._currentWriter();
        if (writer) {
            throw new toolkit_error_1.ToolkitError(`Another CLI (PID=${writer}) is currently synthing to ${this.directory}. Invoke the CLI in sequence, or use '--output' to synth into different directories.`);
        }
    }
    /**
     * Check the current writer (if any)
     *
     * Publicly accessible for testing purposes. Do not use.
     *
     * @internal
     */
    async _currentWriter() {
        const contents = await readFileIfExists(this.writerFile);
        if (!contents) {
            return undefined;
        }
        const pid = parseInt(contents, 10);
        if (!processExists(pid)) {
            // Do cleanup of a stray file now
            await deleteFile(this.writerFile);
            return undefined;
        }
        return pid;
    }
    /**
     * Check the current readers (if any)
     *
     * Publicly accessible for testing purposes. Do not use.
     *
     * @internal
     */
    async _currentReaders() {
        const re = /^read\.([^.]+)\.[^.]+\.lock$/;
        const ret = new Array();
        let children;
        try {
            children = await fs_1.promises.readdir(this.directory, { encoding: 'utf-8' });
        }
        catch (e) {
            // Can't be locked if the directory doesn't exist
            if (e.code === 'ENOENT') {
                return [];
            }
            throw e;
        }
        for (const fname of children) {
            const m = fname.match(re);
            if (m) {
                const pid = parseInt(m[1], 10);
                if (processExists(pid)) {
                    ret.push(pid);
                }
                else {
                    // Do cleanup of a stray file now
                    await deleteFile(path.join(this.directory, fname));
                }
            }
        }
        return ret;
    }
}
exports.RWLock = RWLock;
/* c8 ignore start */ // code paths are unpredictable
async function readFileIfExists(filename) {
    try {
        return await fs_1.promises.readFile(filename, { encoding: 'utf-8' });
    }
    catch (e) {
        if (e.code === 'ENOENT') {
            return undefined;
        }
        throw e;
    }
}
/* c8 ignore stop */
let tmpCounter = 0;
/* c8 ignore start */ // code paths are unpredictable
async function writeFileAtomic(filename, contents) {
    await fs_1.promises.mkdir(path.dirname(filename), { recursive: true });
    const tmpFile = `${filename}.${process.pid}_${++tmpCounter}`;
    await fs_1.promises.writeFile(tmpFile, contents, { encoding: 'utf-8' });
    await fs_1.promises.rename(tmpFile, filename);
}
/* c8 ignore stop */
/* c8 ignore start */ // code paths are unpredictable
async function deleteFile(filename) {
    try {
        await fs_1.promises.unlink(filename);
    }
    catch (e) {
        if (e.code === 'ENOENT') {
            return;
        }
        throw e;
    }
}
/* c8 ignore stop */
/* c8 ignore start */ // code paths are unpredictable
function processExists(pid) {
    try {
        process.kill(pid, 0);
        return true;
    }
    catch (e) {
        return false;
    }
}
/* c8 ignore stop */
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicndsb2NrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicndsb2NrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDJCQUFvQztBQUNwQyw2QkFBNkI7QUFDN0IsNERBQXdEO0FBRXhEOzs7Ozs7Ozs7R0FTRztBQUNILHFCQUFxQixDQUFDLCtCQUErQjtBQUNyRCxNQUFhLE1BQU07SUFLVztJQUpYLFNBQVMsQ0FBUztJQUNsQixVQUFVLENBQVM7SUFDNUIsV0FBVyxHQUFHLENBQUMsQ0FBQztJQUV4QixZQUE0QixTQUFpQjtRQUFqQixjQUFTLEdBQVQsU0FBUyxDQUFRO1FBQzNDLElBQUksQ0FBQyxTQUFTLEdBQUcsR0FBRyxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUM7UUFFbEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDNUQsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxLQUFLLENBQUMsWUFBWTtRQUN2QixNQUFNLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1FBRWxDLE1BQU0sT0FBTyxHQUFHLE1BQU0sSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQzdDLElBQUksT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUN2QixNQUFNLElBQUksNEJBQVksQ0FBQyxtQkFBbUIsT0FBTyxnQ0FBZ0MsSUFBSSxDQUFDLFNBQVMsc0ZBQXNGLENBQUMsQ0FBQztRQUN6TCxDQUFDO1FBRUQsTUFBTSxlQUFlLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFdkQsSUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLE9BQU87WUFDTCxPQUFPLEVBQUUsS0FBSyxJQUFJLEVBQUU7Z0JBQ2xCLDhHQUE4RztnQkFDOUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO29CQUNkLE1BQU0s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Q0FBQztBQUNILENBQUM7QUFDRCxvQkFBb0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwcm9taXNlcyBhcyBmcyB9IGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuLi90b29sa2l0L3Rvb2xraXQtZXJyb3InO1xuXG4vKipcbiAqIEEgc2luZ2xlLXdyaXRlci9tdWx0aS1yZWFkZXIgbG9jayBvbiBhIGRpcmVjdG9yeVxuICpcbiAqIEl0IHVzZXMgbWFya2VyIGZpbGVzIHdpdGggUElEcyBpbiB0aGVtIGFzIGEgbG9ja2luZyBtYXJrZXI7IHRoZSBQSURzIHdpbGwgYmVcbiAqIGNoZWNrZWQgZm9yIGxpdmVuZXNzLCBzbyB0aGF0IGlmIHRoZSBwcm9jZXNzIGV4aXRzIHdpdGhvdXQgY2xlYW5pbmcgdXAgdGhlXG4gKiBmaWxlcyB0aGUgbG9jayBpcyBpbXBsaWNpdGx5IHJlbGVhc2VkLlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgbm90IDEwMCUgcmFjZSBzYWZlLCBidXQgaW4gcHJhY3RpY2UgaXQgc2hvdWxkIGJlIGEgbG90XG4gKiBiZXR0ZXIgdGhhbiB0aGUgMCBwcm90ZWN0aW9uIHdlIGhhdmUgdG9kYXkuXG4gKi9cbi8qIGM4IGlnbm9yZSBzdGFydCAqLyAvLyBjb2RlIHBhdGhzIGFyZSB1bnByZWRpY3RhYmxlXG5leHBvcnQgY2xhc3MgUldMb2NrIHtcbiAgcHJpdmF0ZSByZWFkb25seSBwaWRTdHJpbmc6IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSB3cml0ZXJGaWxlOiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZENvdW50ZXIgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBkaXJlY3Rvcnk6IHN0cmluZykge1xuICAgIHRoaXMucGlkU3RyaW5nID0gYCR7cHJvY2Vzcy5waWR9YDtcblxuICAgIHRoaXMud3JpdGVyRmlsZSA9IHBhdGguam9pbih0aGlzLmRpcmVjdG9yeSwgJ3N5bnRoLmxvY2snKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3F1aXJlIGEgd3JpdGVyIGxvY2suXG4gICAqXG4gICAqIE5vIG90aGVyIHJlYWRlcnMgb3Igd3JpdGVycyBtdXN0IGV4aXN0IGZvciB0aGUgZ2l2ZW4gZGlyZWN0b3J5LlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGFjcXVpcmVXcml0ZSgpOiBQcm9taXNlPElXcml0ZUxvY2s+IHtcbiAgICBhd2FpdCB0aGlzLmFzc2VydE5vT3RoZXJXcml0ZXJzKCk7XG5cbiAgICBjb25zdCByZWFkZXJzID0gYXdhaXQgdGhpcy5fY3VycmVudFJlYWRlcnMoKTtcbiAgICBpZiAocmVhZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBPdGhlciBDTElzIChQSUQ9JHtyZWFkZXJzfSkgYXJlIGN1cnJlbnRseSByZWFkaW5nIGZyb20gJHt0aGlzLmRpcmVjdG9yeX0uIEludm9rZSB0aGUgQ0xJIGluIHNlcXVlbmNlLCBvciB1c2UgJy0tb3V0cHV0JyB0byBzeW50aCBpbnRvIGRpZmZlcmVudCBkaXJlY3Rvcmllcy5gKTtcbiAgICB9XG5cbiAgICBhd2FpdCB3cml0ZUZpbGVBdG9taWModGhpcy53cml0ZXJGaWxlLCB0aGlzLnBpZFN0cmluZyk7XG5cbiAgICBsZXQgcmVsZWFzZWQgPSBmYWxzZTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVsZWFzZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBSZWxlYXNpbmcgbmVlZHMgYSBmbGFnLCBvdGhlcndpc2Ugd2UgbWlnaHQgZGVsZXRlIGEgZmlsZSB0aGF0IHNvbWUgb3RoZXIgbG9jayBoYXMgY3JlYXRlZCBpbiB0aGUgbWVhbiB0aW1lLlxuICAgICAgICBpZiAoIXJlbGVhc2VkKSB7XG4gICAgICAgICAgYXdhaXQgZGVsZXRlRmlsZSh0aGlzLndyaXRlckZpbGUpO1xuICAgICAgICAgIHJlbGVhc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNvbnZlcnRUb1JlYWRlckxvY2s6IGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gQWNxdWlyZSB0aGUgcmVhZCBsb2NrIGJlZm9yZSByZWxlYXNpbmcgdGhlIHdyaXRlIGxvY2suIFNsaWdodGx5IGxlc3NcbiAgICAgICAgLy8gY2hhbmNlIG9mIHJhY2luZyFcbiAgICAgICAgY29uc3QgcmV0ID0gYXdhaXQgdGhpcy5kb0FjcXVpcmVSZWFkKCk7XG4gICAgICAgIGF3YWl0IGRlbGV0ZUZpbGUodGhpcy53cml0ZXJGaWxlKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3F1aXJlIGEgcmVhZCBsb2NrXG4gICAqXG4gICAqIFdpbGwgZmFpbCBpZiB0aGVyZSBhcmUgYW55IHdyaXRlcnMuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgYWNxdWlyZVJlYWQoKTogUHJvbWlzZTxJUmVhZExvY2s+IHtcbiAgICBhd2FpdCB0aGlzLmFzc2VydE5vT3RoZXJXcml0ZXJzKCk7XG4gICAgcmV0dXJuIHRoaXMuZG9BY3F1aXJlUmVhZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9idGFpbnMgdGhlIG5hbWUgZm8gYSAobmV3KSBgcmVhZGVyRmlsZWAgdG8gdXNlLiBUaGlzIGluY2x1ZGVzIGEgY291bnRlciBzb1xuICAgKiB0aGF0IGlmIG11bHRpcGxlIHRocmVhZHMgb2YgdGhlIHNhbWUgUElEIGF0dGVtcHQgdG8gY29uY3VycmVudGx5IGFjcXVpcmVcbiAgICogdGhlIHNhbWUgbG9jaywgdGhleSdyZSBndWFyYW50ZWVkIHRvIHVzZSBhIGRpZmZlcmVudCByZWFkZXIgZmlsZSBuYW1lIChvbmx5XG4gICAqIG9uZSB0aHJlYWQgd2lsbCBldmVyIGV4ZWN1dGUgSlMgY29kZSBhdCBvbmNlLCBndWFyYW50ZWVpbmcgdGhlIHJlYWRDb3VudGVyXG4gICAqIGlzIGluY3JlbWVudGVkIFwiYXRvbWljYWxseVwiIGZyb20gdGhlIHBvaW50IG9mIHZpZXcgb2YgdGhpcyBQSUQuKS5cbiAgICovXG4gIHByaXZhdGUgcmVhZGVyRmlsZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBwYXRoLmpvaW4odGhpcy5kaXJlY3RvcnksIGByZWFkLiR7dGhpcy5waWRTdHJpbmd9LiR7Kyt0aGlzLnJlYWRDb3VudGVyfS5sb2NrYCk7XG4gIH1cblxuICAvKipcbiAgICogRG8gdGhlIGFjdHVhbCBhY3F1aXJpbmcgb2YgYSByZWFkIGxvY2suXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGRvQWNxdWlyZVJlYWQoKTogUHJvbWlzZTxJUmVhZExvY2s+IHtcbiAgICBjb25zdCByZWFkZXJGaWxlID0gdGhpcy5yZWFkZXJGaWxlKCk7XG4gICAgYXdhaXQgd3JpdGVGaWxlQXRvbWljKHJlYWRlckZpbGUsIHRoaXMucGlkU3RyaW5nKTtcblxuICAgIGxldCByZWxlYXNlZCA9IGZhbHNlO1xuICAgIHJldHVybiB7XG4gICAgICByZWxlYXNlOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIFJlbGVhc2luZyBuZWVkcyBhIGZsYWcsIG90aGVyd2lzZSB3ZSBtaWdodCBkZWxldGUgYSBmaWxlIHRoYXQgc29tZSBvdGhlciBsb2NrIGhhcyBjcmVhdGVkIGluIHRoZSBtZWFuIHRpbWUuXG4gICAgICAgIGlmICghcmVsZWFzZWQpIHtcbiAgICAgICAgICBhd2FpdCBkZWxldGVGaWxlKHJlYWRlckZpbGUpO1xuICAgICAgICAgIHJlbGVhc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBhc3NlcnROb090aGVyV3JpdGVycygpIHtcbiAgICBjb25zdCB3cml0ZXIgPSBhd2FpdCB0aGlzLl9jdXJyZW50V3JpdGVyKCk7XG4gICAgaWYgKHdyaXRlcikge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgQW5vdGhlciBDTEkgKFBJRD0ke3dyaXRlcn0pIGlzIGN1cnJlbnRseSBzeW50aGluZyB0byAke3RoaXMuZGlyZWN0b3J5fS4gSW52b2tlIHRoZSBDTEkgaW4gc2VxdWVuY2UsIG9yIHVzZSAnLS1vdXRwdXQnIHRvIHN5bnRoIGludG8gZGlmZmVyZW50IGRpcmVjdG9yaWVzLmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB0aGUgY3VycmVudCB3cml0ZXIgKGlmIGFueSlcbiAgICpcbiAgICogUHVibGljbHkgYWNjZXNzaWJsZSBmb3IgdGVzdGluZyBwdXJwb3Nlcy4gRG8gbm90IHVzZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgX2N1cnJlbnRXcml0ZXIoKTogUHJvbWlzZTxudW1iZXIgfCB1bmRlZmluZWQ+IHtcbiAgICBjb25zdCBjb250ZW50cyA9IGF3YWl0IHJlYWRGaWxlSWZFeGlzdHModGhpcy53cml0ZXJGaWxlKTtcbiAgICBpZiAoIWNvbnRlbnRzKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHBpZCA9IHBhcnNlSW50KGNvbnRlbnRzLCAxMCk7XG4gICAgaWYgKCFwcm9jZXNzRXhpc3RzKHBpZCkpIHtcbiAgICAgIC8vIERvIGNsZWFudXAgb2YgYSBzdHJheSBmaWxlIG5vd1xuICAgICAgYXdhaXQgZGVsZXRlRmlsZSh0aGlzLndyaXRlckZpbGUpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGlkO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoZSBjdXJyZW50IHJlYWRlcnMgKGlmIGFueSlcbiAgICpcbiAgICogUHVibGljbHkgYWNjZXNzaWJsZSBmb3IgdGVzdGluZyBwdXJwb3Nlcy4gRG8gbm90IHVzZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgX2N1cnJlbnRSZWFkZXJzKCk6IFByb21pc2U8bnVtYmVyW10+IHtcbiAgICBjb25zdCByZSA9IC9ecmVhZFxcLihbXi5dKylcXC5bXi5dK1xcLmxvY2skLztcbiAgICBjb25zdCByZXQgPSBuZXcgQXJyYXk8bnVtYmVyPigpO1xuXG4gICAgbGV0IGNoaWxkcmVuO1xuICAgIHRyeSB7XG4gICAgICBjaGlsZHJlbiA9IGF3YWl0IGZzLnJlYWRkaXIodGhpcy5kaXJlY3RvcnksIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSk7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAvLyBDYW4ndCBiZSBsb2NrZWQgaWYgdGhlIGRpcmVjdG9yeSBkb2Vzbid0IGV4aXN0XG4gICAgICBpZiAoZS5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgZm5hbWUgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IG0gPSBmbmFtZS5tYXRjaChyZSk7XG4gICAgICBpZiAobSkge1xuICAgICAgICBjb25zdCBwaWQgPSBwYXJzZUludChtWzFdLCAxMCk7XG4gICAgICAgIGlmIChwcm9jZXNzRXhpc3RzKHBpZCkpIHtcbiAgICAgICAgICByZXQucHVzaChwaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERvIGNsZWFudXAgb2YgYSBzdHJheSBmaWxlIG5vd1xuICAgICAgICAgIGF3YWl0IGRlbGV0ZUZpbGUocGF0aC5qb2luKHRoaXMuZGlyZWN0b3J5LCBmbmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8qKlxuICogQW4gYWNxdWlyZWQgbG9ja1xuICovXG5leHBvcnQgaW50ZXJmYWNlIElSZWFkTG9jayB7XG4gIC8qKlxuICAgKiBSZWxlYXNlIHRoZSBsb2NrLiBDYW4gYmUgY2FsbGVkIG1vcmUgdGhhbiBvbmNlLlxuICAgKi9cbiAgcmVsZWFzZSgpOiBQcm9taXNlPHZvaWQ+O1xufVxuXG4vKipcbiAqIEFuIGFjcXVpcmVkIHdyaXRlciBsb2NrXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSVdyaXRlTG9jayBleHRlbmRzIElSZWFkTG9jayB7XG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSB3cml0ZXIgbG9jayB0byBhIHJlYWRlciBsb2NrXG4gICAqL1xuICBjb252ZXJ0VG9SZWFkZXJMb2NrKCk6IFByb21pc2U8SVJlYWRMb2NrPjtcbn1cblxuLyogYzggaWdub3JlIHN0YXJ0ICovIC8vIGNvZGUgcGF0aHMgYXJlIHVucHJlZGljdGFibGVcbmFzeW5jIGZ1bmN0aW9uIHJlYWRGaWxlSWZFeGlzdHMoZmlsZW5hbWU6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGZzLnJlYWRGaWxlKGZpbGVuYW1lLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pO1xuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICBpZiAoZS5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxubGV0IHRtcENvdW50ZXIgPSAwO1xuLyogYzggaWdub3JlIHN0YXJ0ICovIC8vIGNvZGUgcGF0aHMgYXJlIHVucHJlZGljdGFibGVcbmFzeW5jIGZ1bmN0aW9uIHdyaXRlRmlsZUF0b21pYyhmaWxlbmFtZTogc3RyaW5nLCBjb250ZW50czogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gIGF3YWl0IGZzLm1rZGlyKHBhdGguZGlybmFtZShmaWxlbmFtZSksIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICBjb25zdCB0bXBGaWxlID0gYCR7ZmlsZW5hbWV9LiR7cHJvY2Vzcy5waWR9XyR7Kyt0bXBDb3VudGVyfWA7XG4gIGF3YWl0IGZzLndyaXRlRmlsZSh0bXBGaWxlLCBjb250ZW50cywgeyBlbmNvZGluZzogJ3V0Zi04JyB9KTtcbiAgYXdhaXQgZnMucmVuYW1lKHRtcEZpbGUsIGZpbGVuYW1lKTtcbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqLyAvLyBjb2RlIHBhdGhzIGFyZSB1bnByZWRpY3RhYmxlXG5hc3luYyBmdW5jdGlvbiBkZWxldGVGaWxlKGZpbGVuYW1lOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBmcy51bmxpbmsoZmlsZW5hbWUpO1xuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICBpZiAoZS5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9XG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi8gLy8gY29kZSBwYXRocyBhcmUgdW5wcmVkaWN0YWJsZVxuZnVuY3Rpb24gcHJvY2Vzc0V4aXN0cyhwaWQ6IG51bWJlcikge1xuICB0cnkge1xuICAgIHByb2Nlc3Mua2lsbChwaWQsIDApO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuIl19