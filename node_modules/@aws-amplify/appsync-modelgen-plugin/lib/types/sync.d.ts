import { Types, PluginFunction as PluginFunctionAsync, CodegenPlugin as CodegenPluginAsync } from "@graphql-codegen/plugin-helpers";
declare type PluginMapContainer = Pick<Types.GenerateOptions, 'pluginMap'>;
declare type CacheContainer = Pick<Types.GenerateOptions, 'cache'>;
declare type SyncPluginMap<Obj extends PluginMapContainer> = Omit<Obj, 'pluginMap'> & {
    pluginMap: {
        [K in keyof Obj['pluginMap']]: Omit<Obj['pluginMap'][K], 'plugin'> & {
            plugin: (...args: Parameters<Obj['pluginMap'][K]['plugin']>) => Awaited<ReturnType<Obj['pluginMap'][K]['plugin']>>;
        };
    };
};
declare type SyncCache<Obj extends CacheContainer> = Omit<Obj, 'cache'> & {
    cache?: (<T>(namespace: string, key: string, factory: () => T) => T) | undefined;
};
export declare namespace SyncTypes {
    type GenerateOptions = SyncCache<SyncPluginMap<Types.GenerateOptions>>;
    type PresetFnArgs<Config = any, PluginConfig = {
        [key: string]: any;
    }> = SyncCache<SyncPluginMap<Types.PresetFnArgs<Config, PluginConfig>>>;
    type OutputPreset<TPresetConfig = any> = {
        buildGeneratesSection: (options: PresetFnArgs<TPresetConfig>) => GenerateOptions[];
    };
    type PluginFunction<T> = (...args: Parameters<PluginFunctionAsync<T>>) => Awaited<ReturnType<PluginFunctionAsync<T>>>;
    type CodegenPlugin<T = any> = Omit<CodegenPluginAsync<T>, 'plugin'> & {
        plugin: PluginFunction<T>;
    };
    type DocumentFile = Types.DocumentFile;
    type PluginConfig = Types.PluginConfig;
    type ConfiguredPlugin = Types.ConfiguredPlugin;
    type SkipDocumentsValidationOptions = Types.SkipDocumentsValidationOptions;
    type PluginOutput = Types.PluginOutput;
}
export {};
//# sourceMappingURL=sync.d.ts.map