"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addMetadataAssetsToManifest = addMetadataAssetsToManifest;
const path = require("path");
const cxschema = require("@aws-cdk/cloud-assembly-schema");
const cxapi = require("@aws-cdk/cx-api");
const chalk = require("chalk");
const toolkit_error_1 = require("../../toolkit/toolkit-error");
/**
 * Take the metadata assets from the given stack and add them to the given asset manifest
 *
 * Returns the CloudFormation parameters that need to be sent to the template to
 * pass Asset coordinates.
 */
async function addMetadataAssetsToManifest(ioHelper, stack, assetManifest, envResources, reuse) {
    reuse = reuse || [];
    const assets = stack.assets;
    if (assets.length === 0) {
        return {};
    }
    const toolkitInfo = await envResources.lookupToolkit();
    if (!toolkitInfo.found) {
        // eslint-disable-next-line @stylistic/max-len
        throw new toolkit_error_1.ToolkitError(`This stack uses assets, so the toolkit stack must be deployed to the environment (Run "${chalk.blue('cdk bootstrap ' + stack.environment.name)}")`);
    }
    const params = {};
    for (const asset of assets) {
        // FIXME: Should have excluded by construct path here instead of by unique ID, preferably using
        // minimatch so we can support globs. Maybe take up during artifact refactoring.
        const reuseAsset = reuse.indexOf(asset.id) > -1;
        if (reuseAsset) {
            await ioHelper.defaults.debug(`Reusing asset ${asset.id}: ${JSON.stringify(asset)}`);
            continue;
        }
        await ioHelper.defaults.debug(`Preparing asset ${asset.id}: ${JSON.stringify(asset)}`);
        if (!stack.assembly) {
            throw new toolkit_error_1.ToolkitError('Unexpected: stack assembly is required in order to find assets in assembly directory');
        }
        Object.assign(params, await prepareAsset(ioHelper, asset, assetManifest, envResources, toolkitInfo));
    }
    return params;
}
// eslint-disable-next-line @stylistic/max-len
async function prepareAsset(ioHelper, asset, assetManifest, envResources, toolkitInfo) {
    switch (asset.packaging) {
        case 'zip':
        case 'file':
            return prepareFileAsset(ioHelper, asset, assetManifest, toolkitInfo, asset.packaging === 'zip' ? cxschema.FileAssetPackaging.ZIP_DIRECTORY : cxschema.FileAssetPackaging.FILE);
        case 'container-image':
            return prepareDockerImageAsset(asset, assetManifest, envResources);
        default:
            // eslint-disable-next-line @stylistic/max-len
            throw new toolkit_error_1.ToolkitError(`Unsupported packaging type: ${asset.packaging}. You might need to upgrade your aws-cdk toolkit to support this asset type.`);
    }
}
async function prepareFileAsset(ioHelper, asset, assetManifest, toolkitInfo, packaging) {
    const extension = packaging === cxschema.FileAssetPackaging.ZIP_DIRECTORY ? '.zip' : path.extname(asset.path);
    const baseName = `${asset.sourceHash}${extension}`;
    // Simplify key: assets/abcdef/abcdef.zip is kinda silly and unnecessary, so if they're the same just pick one component.
    const s3Prefix = asset.id === asset.sourceHash ? 'assets/' : `assets/${asset.id}/`;
    const key = `${s3Prefix}${baseName}`;
    const s3url = `s3://${toolkitInfo.bucketName}/${key}`;
    await ioHelper.defaults.debug(`Storing asset ${asset.path} at ${s3url}`);
    assetManifest.addFileAsset(asset.sourceHash, {
        path: asset.path,
        packaging,
    }, {
        bucketName: toolkitInfo.bucketName,
        objectKey: key,
    });
    return {
        [asset.s3BucketParameter]: toolkitInfo.bucketName,
        [asset.s3KeyParameter]: `${s3Prefix}${cxapi.ASSET_PREFIX_SEPARATOR}${baseName}`,
        [asset.artifactHashParameter]: asset.sourceHash,
    };
}
async function prepareDockerImageAsset(asset, assetManifest, envResources) {
    // Pre-1.21.0, repositoryName can be specified by the user or can be left out, in which case we make
    // a per-asset repository which will get adopted and cleaned up along with the stack.
    // Post-1.21.0, repositoryName will always be specified and it will be a shared repository between
    // all assets, and asset will have imageTag specified as well. Validate the combination.
    if (!asset.imageNameParameter && (!asset.repositoryName || !asset.imageTag)) {
        throw new toolkit_error_1.ToolkitError('Invalid Docker image asset configuration: "repositoryName" and "imageTag" are required when "imageNameParameter" is left out');
    }
    const repositoryName = asset.repositoryName ?? 'cdk/' + asset.id.replace(/[:/]/g, '-').toLowerCase();
    // Make sure the repository exists, since the 'cdk-assets' tool will not create it for us.
    const { repositoryUri } = await envResources.prepareEcrRepository(repositoryName);
    const imageTag = asset.imageTag ?? asset.sourceHash;
    assetManifest.addDockerImageAsset(asset.sourceHash, {
        directory: asset.path,
        dockerBuildArgs: asset.buildArgs,
        dockerBuildSsh: asset.buildSsh,
        dockerBuildTarget: asset.target,
        dockerFile: asset.file,
        networkMode: asset.networkMode,
        platform: asset.platform,
        dockerOutputs: asset.outputs,
    }, {
        repositoryName,
        imageTag,
    });
    if (!asset.imageNameParameter) {
        return {};
    }
    return { [asset.imageNameParameter]: `${repositoryUri}:${imageTag}` };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXNzZXRzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYXNzZXRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBZ0JBLGtFQXlDQztBQXpERCw2QkFBNkI7QUFDN0IsMkRBQTJEO0FBQzNELHlDQUF5QztBQUN6QywrQkFBK0I7QUFFL0IsK0RBQTJEO0FBSzNEOzs7OztHQUtHO0FBQ0ksS0FBSyxVQUFVLDJCQUEyQixDQUMvQyxRQUFrQixFQUNsQixLQUF3QyxFQUN4QyxhQUFtQyxFQUNuQyxZQUFrQyxFQUNsQyxLQUFnQjtJQUVoQixLQUFLLEdBQUcsS0FBSyxJQUFJLEVBQUUsQ0FBQztJQUNwQixNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDO0lBRTVCLElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztRQUN4QixPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFFRCxNQUFNLFdBQVcsR0FBRyxNQUFNLFlBQVksQ0FBQyxhQUFhLEVBQUUsQ0FBQztJQUN2RCxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ3ZCLDhDQUE4QztRQUM5QyxNQUFNLElBQUksNEJBQVksQ0FBQywwRkFBMEYsS0FBSyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxLQUFLLENBQUMsV0FBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMvSyxDQUFDO0lBRUQsTUFBTSxNQUFNLEdBQTJCLEVBQUUsQ0FBQztJQUUxQyxLQUFLLE1BQU0sS0FBSyxJQUFJLE1BQU0sRUFBRSxDQUFDO1FBQzNCLCtGQUErRjtRQUMvRixnRkFBZ0Y7UUFDaEYsTUFBTSxVQUFVLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFFaEQsSUFBSSxVQUFVLEVBQUUsQ0FBQztZQUNmLE1BQU0sUUFBUSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsaUJB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LEtBQUssQ0FBQyxJQUFJO1FBQ3RCLFdBQVcsRUFBRSxLQUFLLENBQUMsV0FBVztRQUM5QixRQUFRLEVBQUUsS0FBSyxDQUFDLFFBQVE7UUFDeEIsYUFBYSxFQUFFLEtBQUssQ0FBQyxPQUFPO0tBQzdCLEVBQUU7UUFDRCxjQUFjO1FBQ2QsUUFBUTtLQUNULENBQUMsQ0FBQztJQUVILElBQUksQ0FBQyxLQUFLLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQUM5QixPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFDRCxPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUMsa0JBQWtCLENBQUMsRUFBRSxHQUFHLGFBQWEsSUFBSSxRQUFRLEVBQUUsRUFBRSxDQUFDO0FBQ3hFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgY3hzY2hlbWEgZnJvbSAnQGF3cy1jZGsvY2xvdWQtYXNzZW1ibHktc2NoZW1hJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgdHlwZSB7IEFzc2V0TWFuaWZlc3RCdWlsZGVyIH0gZnJvbSAnLi9hc3NldC1tYW5pZmVzdC1idWlsZGVyJztcbmltcG9ydCB7IFRvb2xraXRFcnJvciB9IGZyb20gJy4uLy4uL3Rvb2xraXQvdG9vbGtpdC1lcnJvcic7XG5pbXBvcnQgdHlwZSB7IEVudmlyb25tZW50UmVzb3VyY2VzIH0gZnJvbSAnLi4vZW52aXJvbm1lbnQnO1xuaW1wb3J0IHR5cGUgeyBJb0hlbHBlciB9IGZyb20gJy4uL2lvL3ByaXZhdGUnO1xuaW1wb3J0IHR5cGUgeyBUb29sa2l0SW5mbyB9IGZyb20gJy4uL3Rvb2xraXQtaW5mbyc7XG5cbi8qKlxuICogVGFrZSB0aGUgbWV0YWRhdGEgYXNzZXRzIGZyb20gdGhlIGdpdmVuIHN0YWNrIGFuZCBhZGQgdGhlbSB0byB0aGUgZ2l2ZW4gYXNzZXQgbWFuaWZlc3RcbiAqXG4gKiBSZXR1cm5zIHRoZSBDbG91ZEZvcm1hdGlvbiBwYXJhbWV0ZXJzIHRoYXQgbmVlZCB0byBiZSBzZW50IHRvIHRoZSB0ZW1wbGF0ZSB0b1xuICogcGFzcyBBc3NldCBjb29yZGluYXRlcy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFkZE1ldGFkYXRhQXNzZXRzVG9NYW5pZmVzdChcbiAgaW9IZWxwZXI6IElvSGVscGVyLFxuICBzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0LFxuICBhc3NldE1hbmlmZXN0OiBBc3NldE1hbmlmZXN0QnVpbGRlcixcbiAgZW52UmVzb3VyY2VzOiBFbnZpcm9ubWVudFJlc291cmNlcyxcbiAgcmV1c2U/OiBzdHJpbmdbXSxcbik6IFByb21pc2U8UmVjb3JkPHN0cmluZywgc3RyaW5nPj4ge1xuICByZXVzZSA9IHJldXNlIHx8IFtdO1xuICBjb25zdCBhc3NldHMgPSBzdGFjay5hc3NldHM7XG5cbiAgaWYgKGFzc2V0cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBjb25zdCB0b29sa2l0SW5mbyA9IGF3YWl0IGVudlJlc291cmNlcy5sb29rdXBUb29sa2l0KCk7XG4gIGlmICghdG9vbGtpdEluZm8uZm91bmQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHN0eWxpc3RpYy9tYXgtbGVuXG4gICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgVGhpcyBzdGFjayB1c2VzIGFzc2V0cywgc28gdGhlIHRvb2xraXQgc3RhY2sgbXVzdCBiZSBkZXBsb3llZCB0byB0aGUgZW52aXJvbm1lbnQgKFJ1biBcIiR7Y2hhbGsuYmx1ZSgnY2RrIGJvb3RzdHJhcCAnICsgc3RhY2suZW52aXJvbm1lbnQhLm5hbWUpfVwiKWApO1xuICB9XG5cbiAgY29uc3QgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cbiAgZm9yIChjb25zdCBhc3NldCBvZiBhc3NldHMpIHtcbiAgICAvLyBGSVhNRTogU2hvdWxkIGhhdmUgZXhjbHVkZWQgYnkgY29uc3RydWN0IHBhdGggaGVyZSBpbnN0ZWFkIG9mIGJ5IHVuaXF1ZSBJRCwgcHJlZmVyYWJseSB1c2luZ1xuICAgIC8vIG1pbmltYXRjaCBzbyB3ZSBjYW4gc3VwcG9ydCBnbG9icy4gTWF5YmUgdGFrZSB1cCBkdXJpbmcgYXJ0aWZhY3QgcmVmYWN0b3JpbmcuXG4gICAgY29uc3QgcmV1c2VBc3NldCA9IHJldXNlLmluZGV4T2YoYXNzZXQuaWQpID4gLTE7XG5cbiAgICBpZiAocmV1c2VBc3NldCkge1xuICAgICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMuZGVidWcoYFJldXNpbmcgYXNzZXQgJHthc3NldC5pZH06ICR7SlNPTi5zdHJpbmdpZnkoYXNzZXQpfWApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMuZGVidWcoYFByZXBhcmluZyBhc3NldCAke2Fzc2V0LmlkfTogJHtKU09OLnN0cmluZ2lmeShhc3NldCl9YCk7XG4gICAgaWYgKCFzdGFjay5hc3NlbWJseSkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignVW5leHBlY3RlZDogc3RhY2sgYXNzZW1ibHkgaXMgcmVxdWlyZWQgaW4gb3JkZXIgdG8gZmluZCBhc3NldHMgaW4gYXNzZW1ibHkgZGlyZWN0b3J5Jyk7XG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbihwYXJhbXMsIGF3YWl0IHByZXBhcmVBc3NldChpb0hlbHBlciwgYXNzZXQsIGFzc2V0TWFuaWZlc3QsIGVudlJlc291cmNlcywgdG9vbGtpdEluZm8pKTtcbiAgfVxuXG4gIHJldHVybiBwYXJhbXM7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAc3R5bGlzdGljL21heC1sZW5cbmFzeW5jIGZ1bmN0aW9uIHByZXBhcmVBc3NldChcbiAgaW9IZWxwZXI6IElvSGVscGVyLFxuICBhc3NldDogY3hzY2hlbWEuQXNzZXRNZXRhZGF0YUVudHJ5LFxuICBhc3NldE1hbmlmZXN0OiBBc3NldE1hbmlmZXN0QnVpbGRlcixcbiAgZW52UmVzb3VyY2VzOiBFbnZpcm9ubWVudFJlc291cmNlcyxcbiAgdG9vbGtpdEluZm86IFRvb2xraXRJbmZvLFxuKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+PiB7XG4gIHN3aXRjaCAoYXNzZXQucGFja2FnaW5nKSB7XG4gICAgY2FzZSAnemlwJzpcbiAgICBjYXNlICdmaWxlJzpcbiAgICAgIHJldHVybiBwcmVwYXJlRmlsZUFzc2V0KFxuICAgICAgICBpb0hlbHBlcixcbiAgICAgICAgYXNzZXQsXG4gICAgICAgIGFzc2V0TWFuaWZlc3QsXG4gICAgICAgIHRvb2xraXRJbmZvLFxuICAgICAgICBhc3NldC5wYWNrYWdpbmcgPT09ICd6aXAnID8gY3hzY2hlbWEuRmlsZUFzc2V0UGFja2FnaW5nLlpJUF9ESVJFQ1RPUlkgOiBjeHNjaGVtYS5GaWxlQXNzZXRQYWNrYWdpbmcuRklMRSk7XG4gICAgY2FzZSAnY29udGFpbmVyLWltYWdlJzpcbiAgICAgIHJldHVybiBwcmVwYXJlRG9ja2VySW1hZ2VBc3NldChhc3NldCwgYXNzZXRNYW5pZmVzdCwgZW52UmVzb3VyY2VzKTtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBzdHlsaXN0aWMvbWF4LWxlblxuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgVW5zdXBwb3J0ZWQgcGFja2FnaW5nIHR5cGU6ICR7KGFzc2V0IGFzIGFueSkucGFja2FnaW5nfS4gWW91IG1pZ2h0IG5lZWQgdG8gdXBncmFkZSB5b3VyIGF3cy1jZGsgdG9vbGtpdCB0byBzdXBwb3J0IHRoaXMgYXNzZXQgdHlwZS5gKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBwcmVwYXJlRmlsZUFzc2V0KFxuICBpb0hlbHBlcjogSW9IZWxwZXIsXG4gIGFzc2V0OiBjeHNjaGVtYS5GaWxlQXNzZXRNZXRhZGF0YUVudHJ5LFxuICBhc3NldE1hbmlmZXN0OiBBc3NldE1hbmlmZXN0QnVpbGRlcixcbiAgdG9vbGtpdEluZm86IFRvb2xraXRJbmZvLFxuICBwYWNrYWdpbmc6IGN4c2NoZW1hLkZpbGVBc3NldFBhY2thZ2luZyxcbik6IFByb21pc2U8UmVjb3JkPHN0cmluZywgc3RyaW5nPj4ge1xuICBjb25zdCBleHRlbnNpb24gPSBwYWNrYWdpbmcgPT09IGN4c2NoZW1hLkZpbGVBc3NldFBhY2thZ2luZy5aSVBfRElSRUNUT1JZID8gJy56aXAnIDogcGF0aC5leHRuYW1lKGFzc2V0LnBhdGgpO1xuICBjb25zdCBiYXNlTmFtZSA9IGAke2Fzc2V0LnNvdXJjZUhhc2h9JHtleHRlbnNpb259YDtcbiAgLy8gU2ltcGxpZnkga2V5OiBhc3NldHMvYWJjZGVmL2FiY2RlZi56aXAgaXMga2luZGEgc2lsbHkgYW5kIHVubmVjZXNzYXJ5LCBzbyBpZiB0aGV5J3JlIHRoZSBzYW1lIGp1c3QgcGljayBvbmUgY29tcG9uZW50LlxuICBjb25zdCBzM1ByZWZpeCA9IGFzc2V0LmlkID09PSBhc3NldC5zb3VyY2VIYXNoID8gJ2Fzc2V0cy8nIDogYGFzc2V0cy8ke2Fzc2V0LmlkfS9gO1xuICBjb25zdCBrZXkgPSBgJHtzM1ByZWZpeH0ke2Jhc2VOYW1lfWA7XG4gIGNvbnN0IHMzdXJsID0gYHMzOi8vJHt0b29sa2l0SW5mby5idWNrZXROYW1lfS8ke2tleX1gO1xuXG4gIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLmRlYnVnKGBTdG9yaW5nIGFzc2V0ICR7YXNzZXQucGF0aH0gYXQgJHtzM3VybH1gKTtcblxuICBhc3NldE1hbmlmZXN0LmFkZEZpbGVBc3NldChhc3NldC5zb3VyY2VIYXNoLCB7XG4gICAgcGF0aDogYXNzZXQucGF0aCxcbiAgICBwYWNrYWdpbmcsXG4gIH0sIHtcbiAgICBidWNrZXROYW1lOiB0b29sa2l0SW5mby5idWNrZXROYW1lLFxuICAgIG9iamVjdEtleToga2V5LFxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIFthc3NldC5zM0J1Y2tldFBhcmFtZXRlcl06IHRvb2xraXRJbmZvLmJ1Y2tldE5hbWUsXG4gICAgW2Fzc2V0LnMzS2V5UGFyYW1ldGVyXTogYCR7czNQcmVmaXh9JHtjeGFwaS5BU1NFVF9QUkVGSVhfU0VQQVJBVE9SfSR7YmFzZU5hbWV9YCxcbiAgICBbYXNzZXQuYXJ0aWZhY3RIYXNoUGFyYW1ldGVyXTogYXNzZXQuc291cmNlSGFzaCxcbiAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcHJlcGFyZURvY2tlckltYWdlQXNzZXQoXG4gIGFzc2V0OiBjeHNjaGVtYS5Db250YWluZXJJbWFnZUFzc2V0TWV0YWRhdGFFbnRyeSxcbiAgYXNzZXRNYW5pZmVzdDogQXNzZXRNYW5pZmVzdEJ1aWxkZXIsXG4gIGVudlJlc291cmNlczogRW52aXJvbm1lbnRSZXNvdXJjZXMpOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHN0cmluZz4+IHtcbiAgLy8gUHJlLTEuMjEuMCwgcmVwb3NpdG9yeU5hbWUgY2FuIGJlIHNwZWNpZmllZCBieSB0aGUgdXNlciBvciBjYW4gYmUgbGVmdCBvdXQsIGluIHdoaWNoIGNhc2Ugd2UgbWFrZVxuICAvLyBhIHBlci1hc3NldCByZXBvc2l0b3J5IHdoaWNoIHdpbGwgZ2V0IGFkb3B0ZWQgYW5kIGNsZWFuZWQgdXAgYWxvbmcgd2l0aCB0aGUgc3RhY2suXG4gIC8vIFBvc3QtMS4yMS4wLCByZXBvc2l0b3J5TmFtZSB3aWxsIGFsd2F5cyBiZSBzcGVjaWZpZWQgYW5kIGl0IHdpbGwgYmUgYSBzaGFyZWQgcmVwb3NpdG9yeSBiZXR3ZWVuXG4gIC8vIGFsbCBhc3NldHMsIGFuZCBhc3NldCB3aWxsIGhhdmUgaW1hZ2VUYWcgc3BlY2lmaWVkIGFzIHdlbGwuIFZhbGlkYXRlIHRoZSBjb21iaW5hdGlvbi5cbiAgaWYgKCFhc3NldC5pbWFnZU5hbWVQYXJhbWV0ZXIgJiYgKCFhc3NldC5yZXBvc2l0b3J5TmFtZSB8fCAhYXNzZXQuaW1hZ2VUYWcpKSB7XG4gICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignSW52YWxpZCBEb2NrZXIgaW1hZ2UgYXNzZXQgY29uZmlndXJhdGlvbjogXCJyZXBvc2l0b3J5TmFtZVwiIGFuZCBcImltYWdlVGFnXCIgYXJlIHJlcXVpcmVkIHdoZW4gXCJpbWFnZU5hbWVQYXJhbWV0ZXJcIiBpcyBsZWZ0IG91dCcpO1xuICB9XG5cbiAgY29uc3QgcmVwb3NpdG9yeU5hbWUgPSBhc3NldC5yZXBvc2l0b3J5TmFtZSA/PyAnY2RrLycgKyBhc3NldC5pZC5yZXBsYWNlKC9bOi9dL2csICctJykudG9Mb3dlckNhc2UoKTtcblxuICAvLyBNYWtlIHN1cmUgdGhlIHJlcG9zaXRvcnkgZXhpc3RzLCBzaW5jZSB0aGUgJ2Nkay1hc3NldHMnIHRvb2wgd2lsbCBub3QgY3JlYXRlIGl0IGZvciB1cy5cbiAgY29uc3QgeyByZXBvc2l0b3J5VXJpIH0gPSBhd2FpdCBlbnZSZXNvdXJjZXMucHJlcGFyZUVjclJlcG9zaXRvcnkocmVwb3NpdG9yeU5hbWUpO1xuICBjb25zdCBpbWFnZVRhZyA9IGFzc2V0LmltYWdlVGFnID8/IGFzc2V0LnNvdXJjZUhhc2g7XG5cbiAgYXNzZXRNYW5pZmVzdC5hZGREb2NrZXJJbWFnZUFzc2V0KGFzc2V0LnNvdXJjZUhhc2gsIHtcbiAgICBkaXJlY3Rvcnk6IGFzc2V0LnBhdGgsXG4gICAgZG9ja2VyQnVpbGRBcmdzOiBhc3NldC5idWlsZEFyZ3MsXG4gICAgZG9ja2VyQnVpbGRTc2g6IGFzc2V0LmJ1aWxkU3NoLFxuICAgIGRvY2tlckJ1aWxkVGFyZ2V0OiBhc3NldC50YXJnZXQsXG4gICAgZG9ja2VyRmlsZTogYXNzZXQuZmlsZSxcbiAgICBuZXR3b3JrTW9kZTogYXNzZXQubmV0d29ya01vZGUsXG4gICAgcGxhdGZvcm06IGFzc2V0LnBsYXRmb3JtLFxuICAgIGRvY2tlck91dHB1dHM6IGFzc2V0Lm91dHB1dHMsXG4gIH0sIHtcbiAgICByZXBvc2l0b3J5TmFtZSxcbiAgICBpbWFnZVRhZyxcbiAgfSk7XG5cbiAgaWYgKCFhc3NldC5pbWFnZU5hbWVQYXJhbWV0ZXIpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcmV0dXJuIHsgW2Fzc2V0LmltYWdlTmFtZVBhcmFtZXRlcl06IGAke3JlcG9zaXRvcnlVcml9OiR7aW1hZ2VUYWd9YCB9O1xufVxuIl19