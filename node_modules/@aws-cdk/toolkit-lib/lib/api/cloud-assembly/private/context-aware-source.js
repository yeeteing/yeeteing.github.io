"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContextAwareCloudAssemblySource = void 0;
const contextproviders = require("../../../context-providers");
const toolkit_error_1 = require("../../../toolkit/toolkit-error");
const private_1 = require("../../io/private");
/**
 * A CloudAssemblySource that wraps another CloudAssemblySource and runs a lookup loop on it
 *
 * This means that if the underlying CloudAssemblySource produces a manifest
 * with provider queries in it, the `ContextAwareCloudAssemblySource` will
 * perform the necessary context lookups and invoke the underlying
 * `CloudAssemblySource` again with thew missing context information.
 *
 * This is only useful if the underlying `CloudAssemblySource` can respond to
 * this new context information (it must be a CDK app source); if it is just a
 * static directory, then the contents of the assembly won't change in response
 * to context.
 *
 * The context is passed between `ContextAwareCloudAssemblySource` and the wrapped
 * cloud assembly source via a contex file on disk, so the wrapped assembly source
 * should re-read the context file on every invocation.
 */
class ContextAwareCloudAssemblySource {
    source;
    props;
    canLookup;
    context;
    ioHelper;
    constructor(source, props) {
        this.source = source;
        this.props = props;
        this.canLookup = props.lookups ?? true;
        this.context = props.contextStore;
        this.ioHelper = props.services.ioHelper;
    }
    /**
     * Produce a Cloud Assembly, i.e. a set of stacks
     */
    async produce() {
        // We may need to run the cloud assembly source multiple times in order to satisfy all missing context
        // (When the source producer runs, it will tell us about context it wants to use
        // but it missing. We'll then look up the context and run the executable again, and
        // again, until it doesn't complain anymore or we've stopped making progress).
        let previouslyMissingKeys;
        while (true) {
            const readableAsm = await this.source.produce();
            const assembly = readableAsm.cloudAssembly;
            if (assembly.manifest.missing && assembly.manifest.missing.length > 0) {
                const missingKeysSet = missingContextKeys(assembly.manifest.missing);
                const missingKeys = Array.from(missingKeysSet);
                if (!this.canLookup) {
                    throw new toolkit_error_1.ToolkitError('Context lookups have been disabled. '
                        + 'Make sure all necessary context is already in \'cdk.context.json\' by running \'cdk synth\' on a machine with sufficient AWS credentials and committing the result. '
                        + `Missing context keys: '${missingKeys.join(', ')}'`);
                }
                let tryLookup = true;
                if (previouslyMissingKeys && equalSets(missingKeysSet, previouslyMissingKeys)) {
                    await this.ioHelper.notify(private_1.IO.CDK_ASSEMBLY_I0240.msg('Not making progress trying to resolve environmental context. Giving up.', { missingKeys }));
                    tryLookup = false;
                }
                previouslyMissingKeys = missingKeysSet;
                if (tryLookup) {
                    await this.ioHelper.notify(private_1.IO.CDK_ASSEMBLY_I0241.msg('Some context information is missing. Fetching...', { missingKeys }));
                    const contextUpdates = await contextproviders.provideContextValues(assembly.manifest.missing, this.props.services.sdkProvider, this.props.services.pluginHost, this.ioHelper);
                    await this.ioHelper.notify(private_1.IO.CDK_ASSEMBLY_I0042.msg('Writing context updates...', {
                        context: contextUpdates,
                    }));
                    await this.context.update(contextUpdates);
                    // Execute again. Unlock the assembly here so that the producer can acquire
                    // a read lock on the directory again.
                    await readableAsm._unlock();
                    continue;
                }
            }
            return readableAsm;
        }
    }
}
exports.ContextAwareCloudAssemblySource = ContextAwareCloudAssemblySource;
/**
 * Return all keys of missing context items
 */
function missingContextKeys(missing) {
    return new Set((missing || []).map(m => m.key));
}
/**
 * Are two sets equal to each other
 */
function equalSets(a, b) {
    if (a.size !== b.size) {
        return false;
    }
    for (const x of a) {
        if (!b.has(x)) {
            return false;
        }
    }
    return true;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGV4dC1hd2FyZS1zb3VyY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb250ZXh0LWF3YXJlLXNvdXJjZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFDQSwrREFBK0Q7QUFFL0Qsa0VBQThEO0FBRTlELDhDQUFzQztBQTBCdEM7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQkc7QUFDSCxNQUFhLCtCQUErQjtJQUtiO0lBQStDO0lBSnBFLFNBQVMsQ0FBVTtJQUNuQixPQUFPLENBQWdCO0lBQ3ZCLFFBQVEsQ0FBVztJQUUzQixZQUE2QixNQUE0QixFQUFtQixLQUFxQztRQUFwRixXQUFNLEdBQU4sTUFBTSxDQUFzQjtRQUFtQixVQUFLLEdBQUwsS0FBSyxDQUFnQztRQUMvRyxJQUFJLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDLFlBQVksQ0FBQztRQUNsQyxJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDO0lBQzFDLENBQUM7SUFFRDs7T0FFRztJQUNJLEtBQUssQ0FBQyxPQUFPO1FBQ2xCLHNHQUFzRztRQUN0RyxnRkFBZ0Y7UUFDaEYsbUZBQW1GO1FBQ25GLDhFQUE4RTtRQUM5RSxJQUFJLHFCQUE4QyxDQUFDO1FBQ25ELE9BQU8sSUFBSSxFQUFFLENBQUM7WUFDWixNQUFNLFdBQVcsR0FBRyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFLENBQUM7WUFFaEQsTUFBTSxRQUFRLEdBQUcsV0FBVyxDQUFDLGFBQWEsQ0FBQztZQUMzQyxJQUFJLFFBQVEsQ0FBQyxRQUFRLENBQUMsT0FBTyxJQUFJLFFBQVEsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztnQkFDdEUsTUFBTSxjQUFjLEdBQUcsa0JBQWtCLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDckUsTUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztnQkFFL0MsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztvQkFDcEIsTUFBTSxJQUFJLDRCQUFZLENBQ3BCLHNDQUFzQzswQkFDcEMsc0tBQXNLOzBCQUN0SywwQkFBMEIsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQzNELENBQUM7Z0JBRUQsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDO2dCQUNyQixJQUFJLHFCQUFxQixJQUFJLFNBQVMsQ0FBQyxjQUFjLEVBQUUscUJBQXFCLENBQUMsRUFBRSxDQUFDO29CQUM5RSxNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFlBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMseUVBQXlFLEVBQUUsRUFBRSxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUM7b0JBQ2xKLFNBQVMsR0FBRyxLQUFLLENBQUM7Z0JBQ3BCLENBQUM7Z0JBRUQscUJBQXFCLEdBQUcsY0FBYyxDQUFDO2dCQUV2QyxJQUFJLFNBQVMsRUFBRSxDQUFDO29CQUNkLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsWUFBRSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxrREFBa0QsRUFBRSxFQUFFLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQztvQkFDM0gsTUFBTSxjQUFjLEdBQUcsTUFBTSxnQkFBZ0IsQ0FBQyxvQkFBb0IsQ0FDaEUsUUFBUSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQ3pCLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFDL0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUM5QixJQUFJLENBQUMsUUFBUSxDQUNkLENBQUM7b0JBRUYsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxZQUFFLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLDRCQUE0QixFQUFFO3dCQUNqRixPQUFPLEVBQUUsY0FBYztxQkFDeEIsQ0FBQyxDQUFDLENBQUM7b0JBQ0osTUFBTSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQztvQkFFMUMsMkVBQTJFO29CQUMzRSxzQ0FBc0M7b0JBQ3RDLE1BQU0sV0FBVyxDQUFDLE9BQU8sRUFBRSxDQUFDO29CQUM1QixTQUFTO2dCQUNYLENBQUM7WUFDSCxDQUFDO1lBRUQsT0FBTyxXQUFXLENBQUM7UUFDckIsQ0FBQztJQUNILENBQUM7Q0FDRjtBQW5FRCwwRUFtRUM7QUFFRDs7R0FFRztBQUNILFNBQVMsa0JBQWtCLENBQUMsT0FBMEI7SUFDcEQsT0FBTyxJQUFJLEdBQUcsQ0FBQyxDQUFDLE9BQU8sSUFBSSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNsRCxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFTLFNBQVMsQ0FBSSxDQUFTLEVBQUUsQ0FBUztJQUN4QyxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3RCLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUNELEtBQUssTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7UUFDbEIsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUNkLE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQztJQUNILENBQUM7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IE1pc3NpbmdDb250ZXh0IH0gZnJvbSAnQGF3cy1jZGsvY2xvdWQtYXNzZW1ibHktc2NoZW1hJztcbmltcG9ydCAqIGFzIGNvbnRleHRwcm92aWRlcnMgZnJvbSAnLi4vLi4vLi4vY29udGV4dC1wcm92aWRlcnMnO1xuaW1wb3J0IHR5cGUgeyBUb29sa2l0U2VydmljZXMgfSBmcm9tICcuLi8uLi8uLi90b29sa2l0L3ByaXZhdGUnO1xuaW1wb3J0IHsgVG9vbGtpdEVycm9yIH0gZnJvbSAnLi4vLi4vLi4vdG9vbGtpdC90b29sa2l0LWVycm9yJztcbmltcG9ydCB0eXBlIHsgSW9IZWxwZXIgfSBmcm9tICcuLi8uLi9pby9wcml2YXRlJztcbmltcG9ydCB7IElPIH0gZnJvbSAnLi4vLi4vaW8vcHJpdmF0ZSc7XG5pbXBvcnQgdHlwZSB7IElDb250ZXh0U3RvcmUgfSBmcm9tICcuLi9jb250ZXh0LXN0b3JlJztcbmltcG9ydCB0eXBlIHsgSUNsb3VkQXNzZW1ibHlTb3VyY2UsIElSZWFkYWJsZUNsb3VkQXNzZW1ibHkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGV4dEF3YXJlQ2xvdWRBc3NlbWJseVByb3BzIHtcbiAgLyoqXG4gICAqIEFXUyBvYmplY3QgKHVzZWQgYnkgY29udGV4dHByb3ZpZGVyKVxuICAgKiBAZGVwcmVjYXRlZCBjb250ZXh0IHNob3VsZCBiZSBtb3ZlZCB0byB0aGUgdG9vbGtpdCBpdHNlbGZcbiAgICovXG4gIHJlYWRvbmx5IHNlcnZpY2VzOiBUb29sa2l0U2VydmljZXM7XG5cbiAgLyoqXG4gICAqIExvY2F0aW9uIHRvIHJlYWQgYW5kIHdyaXRlIGNvbnRleHRcbiAgICovXG4gIHJlYWRvbmx5IGNvbnRleHRTdG9yZTogSUNvbnRleHRTdG9yZTtcblxuICAvKipcbiAgICogRW5hYmxlIGNvbnRleHQgbG9va3Vwcy5cbiAgICpcbiAgICogUHJvZHVjaW5nIGEgYGN4YXBpLkNsb3VkQXNzZW1ibHlgIHdpbGwgZmFpbCBpZiB0aGlzIGlzIGRpc2FibGVkIGFuZCBjb250ZXh0IGxvb2t1cHMgbmVlZCB0byBiZSBwZXJmb3JtZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IGxvb2t1cHM/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEEgQ2xvdWRBc3NlbWJseVNvdXJjZSB0aGF0IHdyYXBzIGFub3RoZXIgQ2xvdWRBc3NlbWJseVNvdXJjZSBhbmQgcnVucyBhIGxvb2t1cCBsb29wIG9uIGl0XG4gKlxuICogVGhpcyBtZWFucyB0aGF0IGlmIHRoZSB1bmRlcmx5aW5nIENsb3VkQXNzZW1ibHlTb3VyY2UgcHJvZHVjZXMgYSBtYW5pZmVzdFxuICogd2l0aCBwcm92aWRlciBxdWVyaWVzIGluIGl0LCB0aGUgYENvbnRleHRBd2FyZUNsb3VkQXNzZW1ibHlTb3VyY2VgIHdpbGxcbiAqIHBlcmZvcm0gdGhlIG5lY2Vzc2FyeSBjb250ZXh0IGxvb2t1cHMgYW5kIGludm9rZSB0aGUgdW5kZXJseWluZ1xuICogYENsb3VkQXNzZW1ibHlTb3VyY2VgIGFnYWluIHdpdGggdGhldyBtaXNzaW5nIGNvbnRleHQgaW5mb3JtYXRpb24uXG4gKlxuICogVGhpcyBpcyBvbmx5IHVzZWZ1bCBpZiB0aGUgdW5kZXJseWluZyBgQ2xvdWRBc3NlbWJseVNvdXJjZWAgY2FuIHJlc3BvbmQgdG9cbiAqIHRoaXMgbmV3IGNvbnRleHQgaW5mb3JtYXRpb24gKGl0IG11c3QgYmUgYSBDREsgYXBwIHNvdXJjZSk7IGlmIGl0IGlzIGp1c3QgYVxuICogc3RhdGljIGRpcmVjdG9yeSwgdGhlbiB0aGUgY29udGVudHMgb2YgdGhlIGFzc2VtYmx5IHdvbid0IGNoYW5nZSBpbiByZXNwb25zZVxuICogdG8gY29udGV4dC5cbiAqXG4gKiBUaGUgY29udGV4dCBpcyBwYXNzZWQgYmV0d2VlbiBgQ29udGV4dEF3YXJlQ2xvdWRBc3NlbWJseVNvdXJjZWAgYW5kIHRoZSB3cmFwcGVkXG4gKiBjbG91ZCBhc3NlbWJseSBzb3VyY2UgdmlhIGEgY29udGV4IGZpbGUgb24gZGlzaywgc28gdGhlIHdyYXBwZWQgYXNzZW1ibHkgc291cmNlXG4gKiBzaG91bGQgcmUtcmVhZCB0aGUgY29udGV4dCBmaWxlIG9uIGV2ZXJ5IGludm9jYXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250ZXh0QXdhcmVDbG91ZEFzc2VtYmx5U291cmNlIGltcGxlbWVudHMgSUNsb3VkQXNzZW1ibHlTb3VyY2Uge1xuICBwcml2YXRlIGNhbkxvb2t1cDogYm9vbGVhbjtcbiAgcHJpdmF0ZSBjb250ZXh0OiBJQ29udGV4dFN0b3JlO1xuICBwcml2YXRlIGlvSGVscGVyOiBJb0hlbHBlcjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHNvdXJjZTogSUNsb3VkQXNzZW1ibHlTb3VyY2UsIHByaXZhdGUgcmVhZG9ubHkgcHJvcHM6IENvbnRleHRBd2FyZUNsb3VkQXNzZW1ibHlQcm9wcykge1xuICAgIHRoaXMuY2FuTG9va3VwID0gcHJvcHMubG9va3VwcyA/PyB0cnVlO1xuICAgIHRoaXMuY29udGV4dCA9IHByb3BzLmNvbnRleHRTdG9yZTtcbiAgICB0aGlzLmlvSGVscGVyID0gcHJvcHMuc2VydmljZXMuaW9IZWxwZXI7XG4gIH1cblxuICAvKipcbiAgICogUHJvZHVjZSBhIENsb3VkIEFzc2VtYmx5LCBpLmUuIGEgc2V0IG9mIHN0YWNrc1xuICAgKi9cbiAgcHVibGljIGFzeW5jIHByb2R1Y2UoKTogUHJvbWlzZTxJUmVhZGFibGVDbG91ZEFzc2VtYmx5PiB7XG4gICAgLy8gV2UgbWF5IG5lZWQgdG8gcnVuIHRoZSBjbG91ZCBhc3NlbWJseSBzb3VyY2UgbXVsdGlwbGUgdGltZXMgaW4gb3JkZXIgdG8gc2F0aXNmeSBhbGwgbWlzc2luZyBjb250ZXh0XG4gICAgLy8gKFdoZW4gdGhlIHNvdXJjZSBwcm9kdWNlciBydW5zLCBpdCB3aWxsIHRlbGwgdXMgYWJvdXQgY29udGV4dCBpdCB3YW50cyB0byB1c2VcbiAgICAvLyBidXQgaXQgbWlzc2luZy4gV2UnbGwgdGhlbiBsb29rIHVwIHRoZSBjb250ZXh0IGFuZCBydW4gdGhlIGV4ZWN1dGFibGUgYWdhaW4sIGFuZFxuICAgIC8vIGFnYWluLCB1bnRpbCBpdCBkb2Vzbid0IGNvbXBsYWluIGFueW1vcmUgb3Igd2UndmUgc3RvcHBlZCBtYWtpbmcgcHJvZ3Jlc3MpLlxuICAgIGxldCBwcmV2aW91c2x5TWlzc2luZ0tleXM6IFNldDxzdHJpbmc+IHwgdW5kZWZpbmVkO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCByZWFkYWJsZUFzbSA9IGF3YWl0IHRoaXMuc291cmNlLnByb2R1Y2UoKTtcblxuICAgICAgY29uc3QgYXNzZW1ibHkgPSByZWFkYWJsZUFzbS5jbG91ZEFzc2VtYmx5O1xuICAgICAgaWYgKGFzc2VtYmx5Lm1hbmlmZXN0Lm1pc3NpbmcgJiYgYXNzZW1ibHkubWFuaWZlc3QubWlzc2luZy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdLZXlzU2V0ID0gbWlzc2luZ0NvbnRleHRLZXlzKGFzc2VtYmx5Lm1hbmlmZXN0Lm1pc3NpbmcpO1xuICAgICAgICBjb25zdCBtaXNzaW5nS2V5cyA9IEFycmF5LmZyb20obWlzc2luZ0tleXNTZXQpO1xuXG4gICAgICAgIGlmICghdGhpcy5jYW5Mb29rdXApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKFxuICAgICAgICAgICAgJ0NvbnRleHQgbG9va3VwcyBoYXZlIGJlZW4gZGlzYWJsZWQuICdcbiAgICAgICAgICAgICsgJ01ha2Ugc3VyZSBhbGwgbmVjZXNzYXJ5IGNvbnRleHQgaXMgYWxyZWFkeSBpbiBcXCdjZGsuY29udGV4dC5qc29uXFwnIGJ5IHJ1bm5pbmcgXFwnY2RrIHN5bnRoXFwnIG9uIGEgbWFjaGluZSB3aXRoIHN1ZmZpY2llbnQgQVdTIGNyZWRlbnRpYWxzIGFuZCBjb21taXR0aW5nIHRoZSByZXN1bHQuICdcbiAgICAgICAgICAgICsgYE1pc3NpbmcgY29udGV4dCBrZXlzOiAnJHttaXNzaW5nS2V5cy5qb2luKCcsICcpfSdgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0cnlMb29rdXAgPSB0cnVlO1xuICAgICAgICBpZiAocHJldmlvdXNseU1pc3NpbmdLZXlzICYmIGVxdWFsU2V0cyhtaXNzaW5nS2V5c1NldCwgcHJldmlvdXNseU1pc3NpbmdLZXlzKSkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuaW9IZWxwZXIubm90aWZ5KElPLkNES19BU1NFTUJMWV9JMDI0MC5tc2coJ05vdCBtYWtpbmcgcHJvZ3Jlc3MgdHJ5aW5nIHRvIHJlc29sdmUgZW52aXJvbm1lbnRhbCBjb250ZXh0LiBHaXZpbmcgdXAuJywgeyBtaXNzaW5nS2V5cyB9KSk7XG4gICAgICAgICAgdHJ5TG9va3VwID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c2x5TWlzc2luZ0tleXMgPSBtaXNzaW5nS2V5c1NldDtcblxuICAgICAgICBpZiAodHJ5TG9va3VwKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5pb0hlbHBlci5ub3RpZnkoSU8uQ0RLX0FTU0VNQkxZX0kwMjQxLm1zZygnU29tZSBjb250ZXh0IGluZm9ybWF0aW9uIGlzIG1pc3NpbmcuIEZldGNoaW5nLi4uJywgeyBtaXNzaW5nS2V5cyB9KSk7XG4gICAgICAgICAgY29uc3QgY29udGV4dFVwZGF0ZXMgPSBhd2FpdCBjb250ZXh0cHJvdmlkZXJzLnByb3ZpZGVDb250ZXh0VmFsdWVzKFxuICAgICAgICAgICAgYXNzZW1ibHkubWFuaWZlc3QubWlzc2luZyxcbiAgICAgICAgICAgIHRoaXMucHJvcHMuc2VydmljZXMuc2RrUHJvdmlkZXIsXG4gICAgICAgICAgICB0aGlzLnByb3BzLnNlcnZpY2VzLnBsdWdpbkhvc3QsXG4gICAgICAgICAgICB0aGlzLmlvSGVscGVyLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBhd2FpdCB0aGlzLmlvSGVscGVyLm5vdGlmeShJTy5DREtfQVNTRU1CTFlfSTAwNDIubXNnKCdXcml0aW5nIGNvbnRleHQgdXBkYXRlcy4uLicsIHtcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRVcGRhdGVzLFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBhd2FpdCB0aGlzLmNvbnRleHQudXBkYXRlKGNvbnRleHRVcGRhdGVzKTtcblxuICAgICAgICAgIC8vIEV4ZWN1dGUgYWdhaW4uIFVubG9jayB0aGUgYXNzZW1ibHkgaGVyZSBzbyB0aGF0IHRoZSBwcm9kdWNlciBjYW4gYWNxdWlyZVxuICAgICAgICAgIC8vIGEgcmVhZCBsb2NrIG9uIHRoZSBkaXJlY3RvcnkgYWdhaW4uXG4gICAgICAgICAgYXdhaXQgcmVhZGFibGVBc20uX3VubG9jaygpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWFkYWJsZUFzbTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gYWxsIGtleXMgb2YgbWlzc2luZyBjb250ZXh0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIG1pc3NpbmdDb250ZXh0S2V5cyhtaXNzaW5nPzogTWlzc2luZ0NvbnRleHRbXSk6IFNldDxzdHJpbmc+IHtcbiAgcmV0dXJuIG5ldyBTZXQoKG1pc3NpbmcgfHwgW10pLm1hcChtID0+IG0ua2V5KSk7XG59XG5cbi8qKlxuICogQXJlIHR3byBzZXRzIGVxdWFsIHRvIGVhY2ggb3RoZXJcbiAqL1xuZnVuY3Rpb24gZXF1YWxTZXRzPEE+KGE6IFNldDxBPiwgYjogU2V0PEE+KSB7XG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IHggb2YgYSkge1xuICAgIGlmICghYi5oYXMoeCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG4iXX0=