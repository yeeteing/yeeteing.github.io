"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CallerDirectoryExtractor = void 0;
const path_1 = __importDefault(require("path"));
const os = __importStar(require("os"));
const extract_file_path_from_stack_trace_line_1 = require("./extract_file_path_from_stack_trace_line");
/**
 * Extracts the path of the caller of the code that generated the input stack trace.
 * In other words, extracts the path from the _second_ entry in the stack trace
 * (the first entry being the location where the stack trace was created and the second entry being the location that called the code that generated the stack trace)
 */
class CallerDirectoryExtractor {
    stackTrace;
    /**
     * Creates caller directory extractor.
     */
    constructor(stackTrace) {
        this.stackTrace = stackTrace;
    }
    extract = () => {
        let stackTrace = this.stackTrace;
        const unresolvedImportLocationError = new Error('Could not determine import path to construct absolute code path from relative path. Consider using an absolute path instead.');
        if (!stackTrace) {
            throw unresolvedImportLocationError;
        }
        // normalize EOL to \n so that parsing is consistent across platforms
        stackTrace = stackTrace.replaceAll(os.EOL, '\n');
        const stacktraceLines = stackTrace
            .split('\n')
            .map((line) => line.trim())
            .filter((line) => line.startsWith('at')) || [];
        if (stacktraceLines.length < 2) {
            throw unresolvedImportLocationError;
        }
        const stackTraceImportLine = stacktraceLines[1]; // the first entry is the file where the error was initialized (our code). The second entry is where the customer called our code which is what we are interested in
        const filePath = new extract_file_path_from_stack_trace_line_1.FilePathExtractor(stackTraceImportLine).extract();
        if (filePath) {
            return path_1.default.dirname(filePath);
        }
        throw unresolvedImportLocationError;
    };
}
exports.CallerDirectoryExtractor = CallerDirectoryExtractor;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsbGVyX2RpcmVjdG9yeV9leHRyYWN0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvY2FsbGVyX2RpcmVjdG9yeV9leHRyYWN0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsZ0RBQXdCO0FBQ3hCLHVDQUF5QjtBQUN6Qix1R0FBOEU7QUFFOUU7Ozs7R0FJRztBQUNILE1BQWEsd0JBQXdCO0lBSU47SUFIN0I7O09BRUc7SUFDSCxZQUE2QixVQUE4QjtRQUE5QixlQUFVLEdBQVYsVUFBVSxDQUFvQjtJQUFHLENBQUM7SUFFL0QsT0FBTyxHQUFHLEdBQUcsRUFBRTtRQUNiLElBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7UUFDakMsTUFBTSw2QkFBNkIsR0FBRyxJQUFJLEtBQUssQ0FDN0MsOEhBQThILENBQy9ILENBQUM7UUFDRixJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDaEIsTUFBTSw2QkFBNkIsQ0FBQztRQUN0QyxDQUFDO1FBQ0QscUVBQXFFO1FBQ3JFLFVBQVUsR0FBRyxVQUFVLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDakQsTUFBTSxlQUFlLEdBQ25CLFVBQVU7YUFDUCxLQUFLLENBQUMsSUFBSSxDQUFDO2FBQ1gsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7YUFDMUIsTUFBTSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ25ELElBQUksZUFBZSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUMvQixNQUFNLDZCQUE2QixDQUFDO1FBQ3RDLENBQUM7UUFDRCxNQUFNLG9CQUFvQixHQUFHLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLG9LQUFvSztRQUVyTixNQUFNLFFBQVEsR0FBRyxJQUFJLDJEQUFpQixDQUFDLG9CQUFvQixDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDdkUsSUFBSSxRQUFRLEVBQUUsQ0FBQztZQUNiLE9BQU8sY0FBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNoQyxDQUFDO1FBQ0QsTUFBTSw2QkFBNkIsQ0FBQztJQUN0QyxDQUFDLENBQUM7Q0FDSDtBQWhDRCw0REFnQ0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIG9zIGZyb20gJ29zJztcbmltcG9ydCB7IEZpbGVQYXRoRXh0cmFjdG9yIH0gZnJvbSAnLi9leHRyYWN0X2ZpbGVfcGF0aF9mcm9tX3N0YWNrX3RyYWNlX2xpbmUnO1xuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBwYXRoIG9mIHRoZSBjYWxsZXIgb2YgdGhlIGNvZGUgdGhhdCBnZW5lcmF0ZWQgdGhlIGlucHV0IHN0YWNrIHRyYWNlLlxuICogSW4gb3RoZXIgd29yZHMsIGV4dHJhY3RzIHRoZSBwYXRoIGZyb20gdGhlIF9zZWNvbmRfIGVudHJ5IGluIHRoZSBzdGFjayB0cmFjZVxuICogKHRoZSBmaXJzdCBlbnRyeSBiZWluZyB0aGUgbG9jYXRpb24gd2hlcmUgdGhlIHN0YWNrIHRyYWNlIHdhcyBjcmVhdGVkIGFuZCB0aGUgc2Vjb25kIGVudHJ5IGJlaW5nIHRoZSBsb2NhdGlvbiB0aGF0IGNhbGxlZCB0aGUgY29kZSB0aGF0IGdlbmVyYXRlZCB0aGUgc3RhY2sgdHJhY2UpXG4gKi9cbmV4cG9ydCBjbGFzcyBDYWxsZXJEaXJlY3RvcnlFeHRyYWN0b3Ige1xuICAvKipcbiAgICogQ3JlYXRlcyBjYWxsZXIgZGlyZWN0b3J5IGV4dHJhY3Rvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgc3RhY2tUcmFjZTogc3RyaW5nIHwgdW5kZWZpbmVkKSB7fVxuXG4gIGV4dHJhY3QgPSAoKSA9PiB7XG4gICAgbGV0IHN0YWNrVHJhY2UgPSB0aGlzLnN0YWNrVHJhY2U7XG4gICAgY29uc3QgdW5yZXNvbHZlZEltcG9ydExvY2F0aW9uRXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAnQ291bGQgbm90IGRldGVybWluZSBpbXBvcnQgcGF0aCB0byBjb25zdHJ1Y3QgYWJzb2x1dGUgY29kZSBwYXRoIGZyb20gcmVsYXRpdmUgcGF0aC4gQ29uc2lkZXIgdXNpbmcgYW4gYWJzb2x1dGUgcGF0aCBpbnN0ZWFkLicsXG4gICAgKTtcbiAgICBpZiAoIXN0YWNrVHJhY2UpIHtcbiAgICAgIHRocm93IHVucmVzb2x2ZWRJbXBvcnRMb2NhdGlvbkVycm9yO1xuICAgIH1cbiAgICAvLyBub3JtYWxpemUgRU9MIHRvIFxcbiBzbyB0aGF0IHBhcnNpbmcgaXMgY29uc2lzdGVudCBhY3Jvc3MgcGxhdGZvcm1zXG4gICAgc3RhY2tUcmFjZSA9IHN0YWNrVHJhY2UucmVwbGFjZUFsbChvcy5FT0wsICdcXG4nKTtcbiAgICBjb25zdCBzdGFja3RyYWNlTGluZXMgPVxuICAgICAgc3RhY2tUcmFjZVxuICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgIC5tYXAoKGxpbmUpID0+IGxpbmUudHJpbSgpKVxuICAgICAgICAuZmlsdGVyKChsaW5lKSA9PiBsaW5lLnN0YXJ0c1dpdGgoJ2F0JykpIHx8IFtdO1xuICAgIGlmIChzdGFja3RyYWNlTGluZXMubGVuZ3RoIDwgMikge1xuICAgICAgdGhyb3cgdW5yZXNvbHZlZEltcG9ydExvY2F0aW9uRXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IHN0YWNrVHJhY2VJbXBvcnRMaW5lID0gc3RhY2t0cmFjZUxpbmVzWzFdOyAvLyB0aGUgZmlyc3QgZW50cnkgaXMgdGhlIGZpbGUgd2hlcmUgdGhlIGVycm9yIHdhcyBpbml0aWFsaXplZCAob3VyIGNvZGUpLiBUaGUgc2Vjb25kIGVudHJ5IGlzIHdoZXJlIHRoZSBjdXN0b21lciBjYWxsZWQgb3VyIGNvZGUgd2hpY2ggaXMgd2hhdCB3ZSBhcmUgaW50ZXJlc3RlZCBpblxuXG4gICAgY29uc3QgZmlsZVBhdGggPSBuZXcgRmlsZVBhdGhFeHRyYWN0b3Ioc3RhY2tUcmFjZUltcG9ydExpbmUpLmV4dHJhY3QoKTtcbiAgICBpZiAoZmlsZVBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmRpcm5hbWUoZmlsZVBhdGgpO1xuICAgIH1cbiAgICB0aHJvdyB1bnJlc29sdmVkSW1wb3J0TG9jYXRpb25FcnJvcjtcbiAgfTtcbn1cbiJdfQ==