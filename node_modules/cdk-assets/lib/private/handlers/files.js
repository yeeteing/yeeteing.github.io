"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileAssetHandler = void 0;
const fs_1 = require("fs");
const path = require("path");
const cloud_assembly_schema_1 = require("@aws-cdk/cloud-assembly-schema");
const mime = require("mime");
const client_options_1 = require("./client-options");
const progress_1 = require("../../progress");
const archive_1 = require("../archive");
const fs_extra_1 = require("../fs-extra");
const placeholders_1 = require("../placeholders");
const shell_1 = require("../shell");
/**
 * The size of an empty zip file is 22 bytes
 *
 * Ref: https://en.wikipedia.org/wiki/ZIP_(file_format)
 */
const EMPTY_ZIP_FILE_SIZE = 22;
class FileAssetHandler {
    constructor(workDir, asset, host) {
        this.workDir = workDir;
        this.asset = asset;
        this.host = host;
        this.fileCacheRoot = path.join(workDir, '.cache');
    }
    async build() {
    }
    async isPublished() {
        const destination = await (0, placeholders_1.replaceAwsPlaceholders)(this.asset.destination, this.host.aws);
        const s3Url = `s3://${destination.bucketName}/${destination.objectKey}`;
        try {
            const s3 = await this.host.aws.s3Client({
                ...(0, client_options_1.destinationToClientOptions)(destination),
                quiet: true,
            });
            this.host.emitMessage(progress_1.EventType.CHECK, `Check ${s3Url}`);
            if (await objectExists(s3, destination.bucketName, destination.objectKey)) {
                this.host.emitMessage(progress_1.EventType.FOUND, `Found ${s3Url}`);
                return true;
            }
        }
        catch (e) {
            this.host.emitMessage(progress_1.EventType.DEBUG, `${e.message}`);
        }
        return false;
    }
    async publish(options = {}) {
        const destination = await (0, placeholders_1.replaceAwsPlaceholders)(this.asset.destination, this.host.aws);
        const s3Url = `s3://${destination.bucketName}/${destination.objectKey}`;
        const clientOptions = (0, client_options_1.destinationToClientOptions)(destination);
        const s3 = await this.host.aws.s3Client(clientOptions);
        this.host.emitMessage(progress_1.EventType.CHECK, `Check ${s3Url}`);
        const bucketInfo = BucketInformation.for(this.host);
        // A thunk for describing the current account. Used when we need to format an error
        // message, not in the success case.
        const account = async () => (await this.host.aws.discoverTargetAccount(clientOptions)).accountId;
        const allowCrossAccount = options.allowCrossAccount ?? true;
        switch (await bucketInfo.bucketOwnership(s3, destination.bucketName, allowCrossAccount ? undefined : await account())) {
            case BucketOwnership.MINE:
                break;
            case BucketOwnership.DOES_NOT_EXIST:
                throw new Error(`No bucket named '${destination.bucketName}'. Is account ${await account()} bootstrapped?`);
            case BucketOwnership.NO_ACCESS:
                throw new Error(`Bucket named '${destination.bucketName}' exists, but we dont have access to it.`);
            case BucketOwnership.SOMEONE_ELSES_AND_HAVE_ACCESS:
                if (!allowCrossAccount) {
                    throw new Error(`❗❗ UNEXPECTED BUCKET OWNER DETECTED ❗❗

              We've detected that the S3 bucket ${destination.bucketName} was
              originally created in account ${await account()} as part of the CloudFormation stack CDKToolkit,
              but now resides in a different AWS account. To prevent cross-account asset bucket access of your
              deployments, CDK will stop now.

              If this situation is intentional and you own the AWS account that the bucket has moved to, remove the
              resource named StagingBucket from the template of CloudFormation stack CDKToolkit and try again.

              If this situation is not intentional, we strongly recommend auditing your account to make sure all
              resources are configured the way you expect them [1]. For questions or concerns, please contact
              AWS Support [2].

              [1] https://repost.aws/knowledge-center/potential-account-compromise

              [2] https://aws.amazon.com/support`);
                }
                break;
        }
        if (!options.force && await objectExists(s3, destination.bucketName, destination.objectKey)) {
            this.host.emitMessage(progress_1.EventType.FOUND, `Found ${s3Url}`);
            return;
        }
        // Identify the the bucket encryption type to set the header on upload
        // required for SCP rules denying uploads without encryption header
        let paramsEncryption = {};
        const encryption2 = await bucketInfo.bucketEncryption(s3, destination.bucketName);
        switch (encryption2.type) {
            case 'no_encryption':
                break;
            case 'aes256':
                paramsEncryption = { ServerSideEncryption: 'AES256' };
                break;
            case 'kms':
                // We must include the key ID otherwise S3 will encrypt with the default key
                paramsEncryption = {
                    ServerSideEncryption: 'aws:kms',
                    SSEKMSKeyId: encryption2.kmsKeyId,
                };
                break;
            case 'does_not_exist':
                this.host.emitMessage(progress_1.EventType.DEBUG, `No bucket named '${destination.bucketName}'. Is account ${await account()} bootstrapped?`);
                break;
            case 'access_denied':
                this.host.emitMessage(progress_1.EventType.DEBUG, `Could not read encryption settings of bucket '${destination.bucketName}': uploading with default settings ("cdk bootstrap" to version 9 if your organization's policies prevent a successful upload or to get rid of this message).`);
                break;
        }
        if (this.host.aborted) {
            return;
        }
        const publishFile = this.asset.source.executable
            ? await this.externalPackageFile(this.asset.source.executable)
            : await this.packageFile(this.asset.source);
        this.host.emitMessage(progress_1.EventType.UPLOAD, `Upload ${s3Url}`);
        const params = Object.assign({}, {
            Bucket: destination.bucketName,
            Key: destination.objectKey,
            Body: (0, fs_1.createReadStream)(publishFile.packagedPath),
            ContentType: publishFile.contentType,
            ChecksumAlgorithm: 'SHA256',
        }, paramsEncryption);
        await s3.upload(params);
    }
    async packageFile(source) {
        if (!source.path) {
            throw new Error(`'path' is expected in the File asset source, got: ${JSON.stringify(source)}`);
        }
        const fullPath = path.resolve(this.workDir, source.path);
        if (source.packaging === cloud_assembly_schema_1.FileAssetPackaging.ZIP_DIRECTORY) {
            const contentType = 'application/zip';
            await fs_1.promises.mkdir(this.fileCacheRoot, { recursive: true });
            const packagedPath = path.join(this.fileCacheRoot, `${this.asset.id.assetId}.zip`);
            if (await (0, fs_extra_1.pathExists)(packagedPath)) {
                this.host.emitMessage(progress_1.EventType.CACHED, `From cache ${packagedPath}`);
                return { packagedPath, contentType };
            }
            this.host.emitMessage(progress_1.EventType.BUILD, `Zip ${fullPath} -> ${packagedPath}`);
            await (0, archive_1.zipDirectory)(fullPath, packagedPath, (m) => this.host.emitMessage(progress_1.EventType.DEBUG, m));
            return { packagedPath, contentType };
        }
        else {
            const contentType = mime.getType(fullPath) ?? 'application/octet-stream';
            return { packagedPath: fullPath, contentType };
        }
    }
    async externalPackageFile(executable) {
        this.host.emitMessage(progress_1.EventType.BUILD, `Building asset source using command: '${executable}'`);
        const shellEventPublisher = (0, progress_1.shellEventPublisherFromEventEmitter)(this.host.emitMessage);
        return {
            packagedPath: (await (0, shell_1.shell)(executable, { subprocessOutputDestination: 'ignore', shellEventPublisher })).trim(),
            contentType: 'application/zip',
        };
    }
}
exports.FileAssetHandler = FileAssetHandler;
var BucketOwnership;
(function (BucketOwnership) {
    BucketOwnership[BucketOwnership["DOES_NOT_EXIST"] = 0] = "DOES_NOT_EXIST";
    BucketOwnership[BucketOwnership["MINE"] = 1] = "MINE";
    BucketOwnership[BucketOwnership["NO_ACCESS"] = 2] = "NO_ACCESS";
    BucketOwnership[BucketOwnership["SOMEONE_ELSES_AND_HAVE_ACCESS"] = 3] = "SOMEONE_ELSES_AND_HAVE_ACCESS";
})(BucketOwnership || (BucketOwnership = {}));
async function objectExists(s3, bucket, key) {
    /*
     * The object existence check here refrains from using the `headObject` operation because this
     * would create a negative cache entry, making GET-after-PUT eventually consistent. This has been
     * observed to result in CloudFormation issuing "ValidationError: S3 error: Access Denied", for
     * example in https://github.com/aws/aws-cdk/issues/6430.
     *
     * To prevent this, we are instead using the listObjectsV2 call, using the looked up key as the
     * prefix, and limiting results to 1. Since the list operation returns keys ordered by binary
     * UTF-8 representation, the key we are looking for is guaranteed to always be the first match
     * returned if it exists.
     *
     * If the file is too small, we discount it as a cache hit. There is an issue
     * somewhere that sometimes produces empty zip files, and we would otherwise
     * never retry building those assets without users having to manually clear
     * their bucket, which is a bad experience.
     */
    const response = await s3.listObjectsV2({
        Bucket: bucket,
        Prefix: key,
        MaxKeys: 1,
    });
    return (response.Contents != null &&
        response.Contents.some((object) => object.Key === key && (object.Size == null || object.Size > EMPTY_ZIP_FILE_SIZE)));
}
/**
 * Cache for bucket information, so we don't have to keep doing the same calls again and again
 *
 * We scope the lifetime of the cache to the lifetime of the host, so that we don't have to do
 * anything special for tests and yet the cache will live for the entire lifetime of the asset
 * upload session when used by the CLI.
 */
class BucketInformation {
    static for(host) {
        const existing = BucketInformation.caches.get(host);
        if (existing) {
            return existing;
        }
        const fresh = new BucketInformation();
        BucketInformation.caches.set(host, fresh);
        return fresh;
    }
    constructor() {
        this.ownerships = new Map();
        this.encryptions = new Map();
    }
    async bucketOwnership(s3, bucket, expectedAccount) {
        return cached(this.ownerships, bucket, async () => {
            const anyAccount = await this._bucketOwnership(s3, bucket);
            switch (anyAccount) {
                case BucketOwnership.MINE:
                    if (expectedAccount &&
                        (await this._bucketOwnership(s3, bucket, expectedAccount)) === BucketOwnership.NO_ACCESS) {
                        // if the only difference between MINE and NO_ACCESS is the expected account,
                        // then its definitely someone else's bucket.
                        return BucketOwnership.SOMEONE_ELSES_AND_HAVE_ACCESS;
                    }
                    return BucketOwnership.MINE;
                default:
                    return anyAccount;
            }
        });
    }
    async bucketEncryption(s3, bucket) {
        return cached(this.encryptions, bucket, () => this._bucketEncryption(s3, bucket));
    }
    async _bucketOwnership(s3, bucket, account) {
        try {
            await s3.getBucketLocation({ Bucket: bucket, ExpectedBucketOwner: account });
            return BucketOwnership.MINE;
        }
        catch (e) {
            if (e.name === 'NoSuchBucket') {
                return BucketOwnership.DOES_NOT_EXIST;
            }
            if (['AccessDenied', 'AllAccessDisabled'].includes(e.name)) {
                return BucketOwnership.NO_ACCESS;
            }
            throw e;
        }
    }
    async _bucketEncryption(s3, bucket) {
        try {
            const encryption = await s3.getBucketEncryption({ Bucket: bucket });
            const l = encryption?.ServerSideEncryptionConfiguration?.Rules?.length ?? 0;
            if (l > 0) {
                const apply = encryption?.ServerSideEncryptionConfiguration?.Rules?.at(0)?.ApplyServerSideEncryptionByDefault;
                let ssealgo = apply?.SSEAlgorithm;
                if (ssealgo === 'AES256')
                    return { type: 'aes256' };
                if (ssealgo === 'aws:kms')
                    return { type: 'kms', kmsKeyId: apply?.KMSMasterKeyID };
            }
            return { type: 'no_encryption' };
        }
        catch (e) {
            if (e.name === 'NoSuchBucket') {
                return { type: 'does_not_exist' };
            }
            if (e.name === 'ServerSideEncryptionConfigurationNotFoundError') {
                return { type: 'no_encryption' };
            }
            if (['AccessDenied', 'AllAccessDisabled'].includes(e.name)) {
                return { type: 'access_denied' };
            }
            return { type: 'no_encryption' };
        }
    }
}
BucketInformation.caches = new WeakMap();
async function cached(cache, key, factory) {
    if (cache.has(key)) {
        return cache.get(key);
    }
    const fresh = await factory(key);
    cache.set(key, fresh);
    return fresh;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJmaWxlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwyQkFBc0Q7QUFDdEQsNkJBQTZCO0FBRTdCLDBFQUFvRTtBQUNwRSw2QkFBNkI7QUFDN0IscURBQThEO0FBSTlELDZDQUFnRjtBQUNoRix3Q0FBMEM7QUFFMUMsMENBQXlDO0FBQ3pDLGtEQUF5RDtBQUN6RCxvQ0FBaUM7QUFFakM7Ozs7R0FJRztBQUNILE1BQU0sbUJBQW1CLEdBQUcsRUFBRSxDQUFDO0FBRS9CLE1BQWEsZ0JBQWdCO0lBRzNCLFlBQ21CLE9BQWUsRUFDZixLQUF3QixFQUN4QixJQUFrQjtRQUZsQixZQUFPLEdBQVAsT0FBTyxDQUFRO1FBQ2YsVUFBSyxHQUFMLEtBQUssQ0FBbUI7UUFDeEIsU0FBSSxHQUFKLElBQUksQ0FBYztRQUVuQyxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFTSxLQUFLLENBQUMsS0FBSztJQUNsQixDQUFDO0lBRU0sS0FBSyxDQUFDLFdBQVc7UUFDdEIsTUFBTSxXQUFXLEdBQUcsTUFBTSxJQUFBLHFDQUFzQixFQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDeEYsTUFBTSxLQUFLLEdBQUcsUUFBUSxXQUFXLENBQUMsVUFBVSxJQUFJLFdBQVcsQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUN4RSxJQUFJLENBQUM7WUFDSCxNQUFNLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQztnQkFDdEMsR0FBRyxJQUFBLDJDQUEwQixFQUFDLFdBQVcsQ0FBQztnQkFDMUMsS0FBSyxFQUFFLElBQUk7YUFDWixDQUFDLENBQUM7WUFDSCxJQUFJLENBQUMsSUFBSSxDQUFD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QU0sRUFBRSxPQUE2QjtJQUNqRixJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztRQUNuQixPQUFPLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFFLENBQUM7SUFDekIsQ0FBQztJQUVELE1BQU0sS0FBSyxHQUFHLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ3RCLE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVJlYWRTdHJlYW0sIHByb21pc2VzIGFzIGZzIH0gZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB0eXBlIHsgRmlsZVNvdXJjZSB9IGZyb20gJ0Bhd3MtY2RrL2Nsb3VkLWFzc2VtYmx5LXNjaGVtYSc7XG5pbXBvcnQgeyBGaWxlQXNzZXRQYWNrYWdpbmcgfSBmcm9tICdAYXdzLWNkay9jbG91ZC1hc3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0ICogYXMgbWltZSBmcm9tICdtaW1lJztcbmltcG9ydCB7IGRlc3RpbmF0aW9uVG9DbGllbnRPcHRpb25zIH0gZnJvbSAnLi9jbGllbnQtb3B0aW9ucyc7XG5pbXBvcnQgdHlwZSB7IEZpbGVNYW5pZmVzdEVudHJ5IH0gZnJvbSAnLi4vLi4vYXNzZXQtbWFuaWZlc3QnO1xuaW1wb3J0IHR5cGUgeyBJUzNDbGllbnQgfSBmcm9tICcuLi8uLi9hd3MnO1xuaW1wb3J0IHR5cGUgeyBQdXRPYmplY3RDb21tYW5kSW5wdXQgfSBmcm9tICcuLi8uLi9hd3MtdHlwZXMnO1xuaW1wb3J0IHsgRXZlbnRUeXBlLCBzaGVsbEV2ZW50UHVibGlzaGVyRnJvbUV2ZW50RW1pdHRlciB9IGZyb20gJy4uLy4uL3Byb2dyZXNzJztcbmltcG9ydCB7IHppcERpcmVjdG9yeSB9IGZyb20gJy4uL2FyY2hpdmUnO1xuaW1wb3J0IHR5cGUgeyBJQXNzZXRIYW5kbGVyLCBJSGFuZGxlckhvc3QsIFB1Ymxpc2hPcHRpb25zIH0gZnJvbSAnLi4vYXNzZXQtaGFuZGxlcic7XG5pbXBvcnQgeyBwYXRoRXhpc3RzIH0gZnJvbSAnLi4vZnMtZXh0cmEnO1xuaW1wb3J0IHsgcmVwbGFjZUF3c1BsYWNlaG9sZGVycyB9IGZyb20gJy4uL3BsYWNlaG9sZGVycyc7XG5pbXBvcnQgeyBzaGVsbCB9IGZyb20gJy4uL3NoZWxsJztcblxuLyoqXG4gKiBUaGUgc2l6ZSBvZiBhbiBlbXB0eSB6aXAgZmlsZSBpcyAyMiBieXRlc1xuICpcbiAqIFJlZjogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWklQXyhmaWxlX2Zvcm1hdClcbiAqL1xuY29uc3QgRU1QVFlfWklQX0ZJTEVfU0laRSA9IDIyO1xuXG5leHBvcnQgY2xhc3MgRmlsZUFzc2V0SGFuZGxlciBpbXBsZW1lbnRzIElBc3NldEhhbmRsZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IGZpbGVDYWNoZVJvb3Q6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHdvcmtEaXI6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGFzc2V0OiBGaWxlTWFuaWZlc3RFbnRyeSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGhvc3Q6IElIYW5kbGVySG9zdCxcbiAgKSB7XG4gICAgdGhpcy5maWxlQ2FjaGVSb290ID0gcGF0aC5qb2luKHdvcmtEaXIsICcuY2FjaGUnKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBidWlsZCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpc1B1Ymxpc2hlZCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBkZXN0aW5hdGlvbiA9IGF3YWl0IHJlcGxhY2VBd3NQbGFjZWhvbGRlcnModGhpcy5hc3NldC5kZXN0aW5hdGlvbiwgdGhpcy5ob3N0LmF3cyk7XG4gICAgY29uc3QgczNVcmwgPSBgczM6Ly8ke2Rlc3RpbmF0aW9uLmJ1Y2tldE5hbWV9LyR7ZGVzdGluYXRpb24ub2JqZWN0S2V5fWA7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHMzID0gYXdhaXQgdGhpcy5ob3N0LmF3cy5zM0NsaWVudCh7XG4gICAgICAgIC4uLmRlc3RpbmF0aW9uVG9DbGllbnRPcHRpb25zKGRlc3RpbmF0aW9uKSxcbiAgICAgICAgcXVpZXQ6IHRydWUsXG4gICAgICB9KTtcbiAgICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuQ0hFQ0ssIGBDaGVjayAke3MzVXJsfWApO1xuXG4gICAgICBpZiAoYXdhaXQgb2JqZWN0RXhpc3RzKHMzLCBkZXN0aW5hdGlvbi5idWNrZXROYW1lLCBkZXN0aW5hdGlvbi5vYmplY3RLZXkpKSB7XG4gICAgICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuRk9VTkQsIGBGb3VuZCAke3MzVXJsfWApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuREVCVUcsIGAke2UubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHB1Ymxpc2gob3B0aW9uczogUHVibGlzaE9wdGlvbnMgPSB7fSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gYXdhaXQgcmVwbGFjZUF3c1BsYWNlaG9sZGVycyh0aGlzLmFzc2V0LmRlc3RpbmF0aW9uLCB0aGlzLmhvc3QuYXdzKTtcbiAgICBjb25zdCBzM1VybCA9IGBzMzovLyR7ZGVzdGluYXRpb24uYnVja2V0TmFtZX0vJHtkZXN0aW5hdGlvbi5vYmplY3RLZXl9YDtcblxuICAgIGNvbnN0IGNsaWVudE9wdGlvbnMgPSBkZXN0aW5hdGlvblRvQ2xpZW50T3B0aW9ucyhkZXN0aW5hdGlvbik7XG4gICAgY29uc3QgczMgPSBhd2FpdCB0aGlzLmhvc3QuYXdzLnMzQ2xpZW50KGNsaWVudE9wdGlvbnMpO1xuICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuQ0hFQ0ssIGBDaGVjayAke3MzVXJsfWApO1xuXG4gICAgY29uc3QgYnVja2V0SW5mbyA9IEJ1Y2tldEluZm9ybWF0aW9uLmZvcih0aGlzLmhvc3QpO1xuXG4gICAgLy8gQSB0aHVuayBmb3IgZGVzY3JpYmluZyB0aGUgY3VycmVudCBhY2NvdW50LiBVc2VkIHdoZW4gd2UgbmVlZCB0byBmb3JtYXQgYW4gZXJyb3JcbiAgICAvLyBtZXNzYWdlLCBub3QgaW4gdGhlIHN1Y2Nlc3MgY2FzZS5cbiAgICBjb25zdCBhY2NvdW50ID0gYXN5bmMgKCkgPT5cbiAgICAgIChhd2FpdCB0aGlzLmhvc3QuYXdzLmRpc2NvdmVyVGFyZ2V0QWNjb3VudChjbGllbnRPcHRpb25zKSkuYWNjb3VudElkO1xuXG4gICAgY29uc3QgYWxsb3dDcm9zc0FjY291bnQgPSBvcHRpb25zLmFsbG93Q3Jvc3NBY2NvdW50ID8/IHRydWU7XG4gICAgc3dpdGNoIChcbiAgICAgIGF3YWl0IGJ1Y2tldEluZm8uYnVja2V0T3duZXJzaGlwKFxuICAgICAgICBzMyxcbiAgICAgICAgZGVzdGluYXRpb24uYnVja2V0TmFtZSxcbiAgICAgICAgYWxsb3dDcm9zc0FjY291bnQgPyB1bmRlZmluZWQgOiBhd2FpdCBhY2NvdW50KCksXG4gICAgICApXG4gICAgKSB7XG4gICAgICBjYXNlIEJ1Y2tldE93bmVyc2hpcC5NSU5FOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQnVja2V0T3duZXJzaGlwLkRPRVNfTk9UX0VYSVNUOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYE5vIGJ1Y2tldCBuYW1lZCAnJHtkZXN0aW5hdGlvbi5idWNrZXROYW1lfScuIElzIGFjY291bnQgJHthd2FpdCBhY2NvdW50KCl9IGJvb3RzdHJhcHBlZD9gLFxuICAgICAgICApO1xuICAgICAgY2FzZSBCdWNrZXRPd25lcnNoaXAuTk9fQUNDRVNTOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEJ1Y2tldCBuYW1lZCAnJHtkZXN0aW5hdGlvbi5idWNrZXROYW1lfScgZXhpc3RzLCBidXQgd2UgZG9udCBoYXZlIGFjY2VzcyB0byBpdC5gLFxuICAgICAgICApO1xuICAgICAgY2FzZSBCdWNrZXRPd25lcnNoaXAuU09NRU9ORV9FTFNFU19BTkRfSEFWRV9BQ0NFU1M6XG4gICAgICAgIGlmICghYWxsb3dDcm9zc0FjY291bnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBg4p2X4p2XIFVORVhQRUNURUQgQlVDS0VUIE9XTkVSIERFVEVDVEVEIOKdl+Kdl1xuXG4gICAgICAgICAgICAgIFdlJ3ZlIGRldGVjdGVkIHRoYXQgdGhlIFMzIGJ1Y2tldCAke2Rlc3RpbmF0aW9uLmJ1Y2tldE5hbWV9IHdhc1xuICAgICAgICAgICAgICBvcmlnaW5hbGx5IGNyZWF0ZWQgaW4gYWNjb3VudCAke2F3YWl0IGFjY291bnQoKX0gYXMgcGFydCBvZiB0aGUgQ2xvdWRGb3JtYXRpb24gc3RhY2sgQ0RLVG9vbGtpdCxcbiAgICAgICAgICAgICAgYnV0IG5vdyByZXNpZGVzIGluIGEgZGlmZmVyZW50IEFXUyBhY2NvdW50LiBUbyBwcmV2ZW50IGNyb3NzLWFjY291bnQgYXNzZXQgYnVja2V0IGFjY2VzcyBvZiB5b3VyXG4gICAgICAgICAgICAgIGRlcGxveW1lbnRzLCBDREsgd2lsbCBzdG9wIG5vdy5cblxuICAgICAgICAgICAgICBJZiB0aGlzIHNpdHVhdGlvbiBpcyBpbnRlbnRpb25hbCBhbmQgeW91IG93biB0aGUgQVdTIGFjY291bnQgdGhhdCB0aGUgYnVja2V0IGhhcyBtb3ZlZCB0bywgcmVtb3ZlIHRoZVxuICAgICAgICAgICAgICByZXNvdXJjZSBuYW1lZCBTdGFnaW5nQnVja2V0IGZyb20gdGhlIHRlbXBsYXRlIG9mIENsb3VkRm9ybWF0aW9uIHN0YWNrIENES1Rvb2xraXQgYW5kIHRyeSBhZ2Fpbi5cblxuICAgICAgICAgICAgICBJZiB0aGlzIHNpdHVhdGlvbiBpcyBub3QgaW50ZW50aW9uYWwsIHdlIHN0cm9uZ2x5IHJlY29tbWVuZCBhdWRpdGluZyB5b3VyIGFjY291bnQgdG8gbWFrZSBzdXJlIGFsbFxuICAgICAgICAgICAgICByZXNvdXJjZXMgYXJlIGNvbmZpZ3VyZWQgdGhlIHdheSB5b3UgZXhwZWN0IHRoZW0gWzFdLiBGb3IgcXVlc3Rpb25zIG9yIGNvbmNlcm5zLCBwbGVhc2UgY29udGFjdFxuICAgICAgICAgICAgICBBV1MgU3VwcG9ydCBbMl0uXG5cbiAgICAgICAgICAgICAgWzFdIGh0dHBzOi8vcmVwb3N0LmF3cy9rbm93bGVkZ2UtY2VudGVyL3BvdGVudGlhbC1hY2NvdW50LWNvbXByb21pc2VcblxuICAgICAgICAgICAgICBbMl0gaHR0cHM6Ly9hd3MuYW1hem9uLmNvbS9zdXBwb3J0YCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5mb3JjZSAmJiBhd2FpdCBvYmplY3RFeGlzdHMoczMsIGRlc3RpbmF0aW9uLmJ1Y2tldE5hbWUsIGRlc3RpbmF0aW9uLm9iamVjdEtleSkpIHtcbiAgICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuRk9VTkQsIGBGb3VuZCAke3MzVXJsfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElkZW50aWZ5IHRoZSB0aGUgYnVja2V0IGVuY3J5cHRpb24gdHlwZSB0byBzZXQgdGhlIGhlYWRlciBvbiB1cGxvYWRcbiAgICAvLyByZXF1aXJlZCBmb3IgU0NQIHJ1bGVzIGRlbnlpbmcgdXBsb2FkcyB3aXRob3V0IGVuY3J5cHRpb24gaGVhZGVyXG4gICAgbGV0IHBhcmFtc0VuY3J5cHRpb246IHsgW2luZGV4OiBzdHJpbmddOiBhbnkgfSA9IHt9O1xuICAgIGNvbnN0IGVuY3J5cHRpb24yID0gYXdhaXQgYnVja2V0SW5mby5idWNrZXRFbmNyeXB0aW9uKHMzLCBkZXN0aW5hdGlvbi5idWNrZXROYW1lKTtcbiAgICBzd2l0Y2ggKGVuY3J5cHRpb24yLnR5cGUpIHtcbiAgICAgIGNhc2UgJ25vX2VuY3J5cHRpb24nOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2FlczI1Nic6XG4gICAgICAgIHBhcmFtc0VuY3J5cHRpb24gPSB7IFNlcnZlclNpZGVFbmNyeXB0aW9uOiAnQUVTMjU2JyB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ttcyc6XG4gICAgICAgIC8vIFdlIG11c3QgaW5jbHVkZSB0aGUga2V5IElEIG90aGVyd2lzZSBTMyB3aWxsIGVuY3J5cHQgd2l0aCB0aGUgZGVmYXVsdCBrZXlcbiAgICAgICAgcGFyYW1zRW5jcnlwdGlvbiA9IHtcbiAgICAgICAgICBTZXJ2ZXJTaWRlRW5jcnlwdGlvbjogJ2F3czprbXMnLFxuICAgICAgICAgIFNTRUtNU0tleUlkOiBlbmNyeXB0aW9uMi5rbXNLZXlJZCxcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkb2VzX25vdF9leGlzdCc6XG4gICAgICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShcbiAgICAgICAgICBFdmVudFR5cGUuREVCVUcsXG4gICAgICAgICAgYE5vIGJ1Y2tldCBuYW1lZCAnJHtkZXN0aW5hdGlvbi5idWNrZXROYW1lfScuIElzIGFjY291bnQgJHthd2FpdCBhY2NvdW50KCl9IGJvb3RzdHJhcHBlZD9gLFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2FjY2Vzc19kZW5pZWQnOlxuICAgICAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoXG4gICAgICAgICAgRXZlbnRUeXBlLkRFQlVHLFxuICAgICAgICAgIGBDb3VsZCBub3QgcmVhZCBlbmNyeXB0aW9uIHNldHRpbmdzIG9mIGJ1Y2tldCAnJHtkZXN0aW5hdGlvbi5idWNrZXROYW1lfSc6IHVwbG9hZGluZyB3aXRoIGRlZmF1bHQgc2V0dGluZ3MgKFwiY2RrIGJvb3RzdHJhcFwiIHRvIHZlcnNpb24gOSBpZiB5b3VyIG9yZ2FuaXphdGlvbidzIHBvbGljaWVzIHByZXZlbnQgYSBzdWNjZXNzZnVsIHVwbG9hZCBvciB0byBnZXQgcmlkIG9mIHRoaXMgbWVzc2FnZSkuYCxcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHB1Ymxpc2hGaWxlID0gdGhpcy5hc3NldC5zb3VyY2UuZXhlY3V0YWJsZVxuICAgICAgPyBhd2FpdCB0aGlzLmV4dGVybmFsUGFja2FnZUZpbGUodGhpcy5hc3NldC5zb3VyY2UuZXhlY3V0YWJsZSlcbiAgICAgIDogYXdhaXQgdGhpcy5wYWNrYWdlRmlsZSh0aGlzLmFzc2V0LnNvdXJjZSk7XG5cbiAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLlVQTE9BRCwgYFVwbG9hZCAke3MzVXJsfWApO1xuXG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHt9LFxuICAgICAge1xuICAgICAgICBCdWNrZXQ6IGRlc3RpbmF0aW9uLmJ1Y2tldE5hbWUsXG4gICAgICAgIEtleTogZGVzdGluYXRpb24ub2JqZWN0S2V5LFxuICAgICAgICBCb2R5OiBjcmVhdGVSZWFkU3RyZWFtKHB1Ymxpc2hGaWxlLnBhY2thZ2VkUGF0aCksXG4gICAgICAgIENvbnRlbnRUeXBlOiBwdWJsaXNoRmlsZS5jb250ZW50VHlwZSxcbiAgICAgICAgQ2hlY2tzdW1BbGdvcml0aG06ICdTSEEyNTYnLFxuICAgICAgfSBzYXRpc2ZpZXMgUHV0T2JqZWN0Q29tbWFuZElucHV0LFxuICAgICAgcGFyYW1zRW5jcnlwdGlvbixcbiAgICApO1xuXG4gICAgYXdhaXQgczMudXBsb2FkKHBhcmFtcyk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHBhY2thZ2VGaWxlKHNvdXJjZTogRmlsZVNvdXJjZSk6IFByb21pc2U8UGFja2FnZWRGaWxlQXNzZXQ+IHtcbiAgICBpZiAoIXNvdXJjZS5wYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGAncGF0aCcgaXMgZXhwZWN0ZWQgaW4gdGhlIEZpbGUgYXNzZXQgc291cmNlLCBnb3Q6ICR7SlNPTi5zdHJpbmdpZnkoc291cmNlKX1gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGgucmVzb2x2ZSh0aGlzLndvcmtEaXIsIHNvdXJjZS5wYXRoKTtcblxuICAgIGlmIChzb3VyY2UucGFja2FnaW5nID09PSBGaWxlQXNzZXRQYWNrYWdpbmcuWklQX0RJUkVDVE9SWSkge1xuICAgICAgY29uc3QgY29udGVudFR5cGUgPSAnYXBwbGljYXRpb24vemlwJztcblxuICAgICAgYXdhaXQgZnMubWtkaXIodGhpcy5maWxlQ2FjaGVSb290LCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgIGNvbnN0IHBhY2thZ2VkUGF0aCA9IHBhdGguam9pbih0aGlzLmZpbGVDYWNoZVJvb3QsIGAke3RoaXMuYXNzZXQuaWQuYXNzZXRJZH0uemlwYCk7XG5cbiAgICAgIGlmIChhd2FpdCBwYXRoRXhpc3RzKHBhY2thZ2VkUGF0aCkpIHtcbiAgICAgICAgdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5DQUNIRUQsIGBGcm9tIGNhY2hlICR7cGFja2FnZWRQYXRofWApO1xuICAgICAgICByZXR1cm4geyBwYWNrYWdlZFBhdGgsIGNvbnRlbnRUeXBlIH07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuQlVJTEQsIGBaaXAgJHtmdWxsUGF0aH0gLT4gJHtwYWNrYWdlZFBhdGh9YCk7XG4gICAgICBhd2FpdCB6aXBEaXJlY3RvcnkoZnVsbFBhdGgsIHBhY2thZ2VkUGF0aCwgKG0pID0+IHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuREVCVUcsIG0pKTtcbiAgICAgIHJldHVybiB7IHBhY2thZ2VkUGF0aCwgY29udGVudFR5cGUgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29udGVudFR5cGUgPSBtaW1lLmdldFR5cGUoZnVsbFBhdGgpID8/ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgICAgcmV0dXJuIHsgcGFja2FnZWRQYXRoOiBmdWxsUGF0aCwgY29udGVudFR5cGUgfTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGV4dGVybmFsUGFja2FnZUZpbGUoZXhlY3V0YWJsZTogc3RyaW5nW10pOiBQcm9taXNlPFBhY2thZ2VkRmlsZUFzc2V0PiB7XG4gICAgdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5CVUlMRCwgYEJ1aWxkaW5nIGFzc2V0IHNvdXJjZSB1c2luZyBjb21tYW5kOiAnJHtleGVjdXRhYmxlfSdgKTtcblxuICAgIGNvbnN0IHNoZWxsRXZlbnRQdWJsaXNoZXIgPSBzaGVsbEV2ZW50UHVibGlzaGVyRnJvbUV2ZW50RW1pdHRlcih0aGlzLmhvc3QuZW1pdE1lc3NhZ2UpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhY2thZ2VkUGF0aDogKFxuICAgICAgICBhd2FpdCBzaGVsbChleGVjdXRhYmxlLCB7IHN1YnByb2Nlc3NPdXRwdXREZXN0aW5hdGlvbjogJ2lnbm9yZScsIHNoZWxsRXZlbnRQdWJsaXNoZXIgfSlcbiAgICAgICkudHJpbSgpLFxuICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi96aXAnLFxuICAgIH07XG4gIH1cbn1cblxuZW51bSBCdWNrZXRPd25lcnNoaXAge1xuICBET0VTX05PVF9FWElTVCxcbiAgTUlORSxcbiAgTk9fQUNDRVNTLFxuICBTT01FT05FX0VMU0VTX0FORF9IQVZFX0FDQ0VTUyxcbn1cblxudHlwZSBCdWNrZXRFbmNyeXB0aW9uID1cbiAgfCB7IHJlYWRvbmx5IHR5cGU6ICdub19lbmNyeXB0aW9uJyB9XG4gIHwgeyByZWFkb25seSB0eXBlOiAnYWVzMjU2JyB9XG4gIHwgeyByZWFkb25seSB0eXBlOiAna21zJzsgcmVhZG9ubHkga21zS2V5SWQ/OiBzdHJpbmcgfVxuICB8IHsgcmVhZG9ubHkgdHlwZTogJ2FjY2Vzc19kZW5pZWQnIH1cbiAgfCB7IHJlYWRvbmx5IHR5cGU6ICdkb2VzX25vdF9leGlzdCcgfTtcblxuYXN5bmMgZnVuY3Rpb24gb2JqZWN0RXhpc3RzKHMzOiBJUzNDbGllbnQsIGJ1Y2tldDogc3RyaW5nLCBrZXk6IHN0cmluZykge1xuICAvKlxuICAgKiBUaGUgb2JqZWN0IGV4aXN0ZW5jZSBjaGVjayBoZXJlIHJlZnJhaW5zIGZyb20gdXNpbmcgdGhlIGBoZWFkT2JqZWN0YCBvcGVyYXRpb24gYmVjYXVzZSB0aGlzXG4gICAqIHdvdWxkIGNyZWF0ZSBhIG5lZ2F0aXZlIGNhY2hlIGVudHJ5LCBtYWtpbmcgR0VULWFmdGVyLVBVVCBldmVudHVhbGx5IGNvbnNpc3RlbnQuIFRoaXMgaGFzIGJlZW5cbiAgICogb2JzZXJ2ZWQgdG8gcmVzdWx0IGluIENsb3VkRm9ybWF0aW9uIGlzc3VpbmcgXCJWYWxpZGF0aW9uRXJyb3I6IFMzIGVycm9yOiBBY2Nlc3MgRGVuaWVkXCIsIGZvclxuICAgKiBleGFtcGxlIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9pc3N1ZXMvNjQzMC5cbiAgICpcbiAgICogVG8gcHJldmVudCB0aGlzLCB3ZSBhcmUgaW5zdGVhZCB1c2luZyB0aGUgbGlzdE9iamVjdHNWMiBjYWxsLCB1c2luZyB0aGUgbG9va2VkIHVwIGtleSBhcyB0aGVcbiAgICogcHJlZml4LCBhbmQgbGltaXRpbmcgcmVzdWx0cyB0byAxLiBTaW5jZSB0aGUgbGlzdCBvcGVyYXRpb24gcmV0dXJucyBrZXlzIG9yZGVyZWQgYnkgYmluYXJ5XG4gICAqIFVURi04IHJlcHJlc2VudGF0aW9uLCB0aGUga2V5IHdlIGFyZSBsb29raW5nIGZvciBpcyBndWFyYW50ZWVkIHRvIGFsd2F5cyBiZSB0aGUgZmlyc3QgbWF0Y2hcbiAgICogcmV0dXJuZWQgaWYgaXQgZXhpc3RzLlxuICAgKlxuICAgKiBJZiB0aGUgZmlsZSBpcyB0b28gc21hbGwsIHdlIGRpc2NvdW50IGl0IGFzIGEgY2FjaGUgaGl0LiBUaGVyZSBpcyBhbiBpc3N1ZVxuICAgKiBzb21ld2hlcmUgdGhhdCBzb21ldGltZXMgcHJvZHVjZXMgZW1wdHkgemlwIGZpbGVzLCBhbmQgd2Ugd291bGQgb3RoZXJ3aXNlXG4gICAqIG5ldmVyIHJldHJ5IGJ1aWxkaW5nIHRob3NlIGFzc2V0cyB3aXRob3V0IHVzZXJzIGhhdmluZyB0byBtYW51YWxseSBjbGVhclxuICAgKiB0aGVpciBidWNrZXQsIHdoaWNoIGlzIGEgYmFkIGV4cGVyaWVuY2UuXG4gICAqL1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHMzLmxpc3RPYmplY3RzVjIoe1xuICAgIEJ1Y2tldDogYnVja2V0LFxuICAgIFByZWZpeDoga2V5LFxuICAgIE1heEtleXM6IDEsXG4gIH0pO1xuICByZXR1cm4gKFxuICAgIHJlc3BvbnNlLkNvbnRlbnRzICE9IG51bGwgJiZcbiAgICByZXNwb25zZS5Db250ZW50cy5zb21lKFxuICAgICAgKG9iamVjdCkgPT4gb2JqZWN0LktleSA9PT0ga2V5ICYmIChvYmplY3QuU2l6ZSA9PSBudWxsIHx8IG9iamVjdC5TaXplID4gRU1QVFlfWklQX0ZJTEVfU0laRSksXG4gICAgKVxuICApO1xufVxuXG4vKipcbiAqIEEgcGFja2FnZWQgYXNzZXQgd2hpY2ggY2FuIGJlIHVwbG9hZGVkIChlaXRoZXIgYSBzaW5nbGUgZmlsZSBvciBkaXJlY3RvcnkpXG4gKi9cbmludGVyZmFjZSBQYWNrYWdlZEZpbGVBc3NldCB7XG4gIC8qKlxuICAgKiBQYXRoIG9mIHRoZSBmaWxlIG9yIGRpcmVjdG9yeVxuICAgKi9cbiAgcmVhZG9ubHkgcGFja2FnZWRQYXRoOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIENvbnRlbnQgdHlwZSB0byBiZSBhZGRlZCBpbiB0aGUgUzMgdXBsb2FkIGFjdGlvblxuICAgKlxuICAgKiBAZGVmYXVsdCAtIE5vIGNvbnRlbnQgdHlwZVxuICAgKi9cbiAgcmVhZG9ubHkgY29udGVudFR5cGU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQ2FjaGUgZm9yIGJ1Y2tldCBpbmZvcm1hdGlvbiwgc28gd2UgZG9uJ3QgaGF2ZSB0byBrZWVwIGRvaW5nIHRoZSBzYW1lIGNhbGxzIGFnYWluIGFuZCBhZ2FpblxuICpcbiAqIFdlIHNjb3BlIHRoZSBsaWZldGltZSBvZiB0aGUgY2FjaGUgdG8gdGhlIGxpZmV0aW1lIG9mIHRoZSBob3N0LCBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gZG9cbiAqIGFueXRoaW5nIHNwZWNpYWwgZm9yIHRlc3RzIGFuZCB5ZXQgdGhlIGNhY2hlIHdpbGwgbGl2ZSBmb3IgdGhlIGVudGlyZSBsaWZldGltZSBvZiB0aGUgYXNzZXRcbiAqIHVwbG9hZCBzZXNzaW9uIHdoZW4gdXNlZCBieSB0aGUgQ0xJLlxuICovXG5jbGFzcyBCdWNrZXRJbmZvcm1hdGlvbiB7XG4gIHB1YmxpYyBzdGF0aWMgZm9yKGhvc3Q6IElIYW5kbGVySG9zdCkge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gQnVja2V0SW5mb3JtYXRpb24uY2FjaGVzLmdldChob3N0KTtcbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG5cbiAgICBjb25zdCBmcmVzaCA9IG5ldyBCdWNrZXRJbmZvcm1hdGlvbigpO1xuICAgIEJ1Y2tldEluZm9ybWF0aW9uLmNhY2hlcy5zZXQoaG9zdCwgZnJlc2gpO1xuICAgIHJldHVybiBmcmVzaDtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGNhY2hlcyA9IG5ldyBXZWFrTWFwPElIYW5kbGVySG9zdCwgQnVja2V0SW5mb3JtYXRpb24+KCk7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBvd25lcnNoaXBzID0gbmV3IE1hcDxzdHJpbmcsIEJ1Y2tldE93bmVyc2hpcD4oKTtcbiAgcHJpdmF0ZSByZWFkb25seSBlbmNyeXB0aW9ucyA9IG5ldyBNYXA8c3RyaW5nLCBCdWNrZXRFbmNyeXB0aW9uPigpO1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgYnVja2V0T3duZXJzaGlwKFxuICAgIHMzOiBJUzNDbGllbnQsXG4gICAgYnVja2V0OiBzdHJpbmcsXG4gICAgZXhwZWN0ZWRBY2NvdW50Pzogc3RyaW5nLFxuICApOiBQcm9taXNlPEJ1Y2tldE93bmVyc2hpcD4ge1xuICAgIHJldHVybiBjYWNoZWQodGhpcy5vd25lcnNoaXBzLCBidWNrZXQsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFueUFjY291bnQgPSBhd2FpdCB0aGlzLl9idWNrZXRPd25lcnNoaXAoczMsIGJ1Y2tldCk7XG5cbiAgICAgIHN3aXRjaCAoYW55QWNjb3VudCkge1xuICAgICAgICBjYXNlIEJ1Y2tldE93bmVyc2hpcC5NSU5FOlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGV4cGVjdGVkQWNjb3VudCAmJlxuICAgICAgICAgICAgKGF3YWl0IHRoaXMuX2J1Y2tldE93bmVyc2hpcChzMywgYnVja2V0LCBleHBlY3RlZEFjY291bnQpKSA9PT0gQnVja2V0T3duZXJzaGlwLk5PX0FDQ0VTU1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIG9ubHkgZGlmZmVyZW5jZSBiZXR3ZWVuIE1JTkUgYW5kIE5PX0FDQ0VTUyBpcyB0aGUgZXhwZWN0ZWQgYWNjb3VudCxcbiAgICAgICAgICAgIC8vIHRoZW4gaXRzIGRlZmluaXRlbHkgc29tZW9uZSBlbHNlJ3MgYnVja2V0LlxuICAgICAgICAgICAgcmV0dXJuIEJ1Y2tldE93bmVyc2hpcC5TT01FT05FX0VMU0VTX0FORF9IQVZFX0FDQ0VTUztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIEJ1Y2tldE93bmVyc2hpcC5NSU5FO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBhbnlBY2NvdW50O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGJ1Y2tldEVuY3J5cHRpb24oczM6IElTM0NsaWVudCwgYnVja2V0OiBzdHJpbmcpOiBQcm9taXNlPEJ1Y2tldEVuY3J5cHRpb24+IHtcbiAgICByZXR1cm4gY2FjaGVkKHRoaXMuZW5jcnlwdGlvbnMsIGJ1Y2tldCwgKCkgPT4gdGhpcy5fYnVja2V0RW5jcnlwdGlvbihzMywgYnVja2V0KSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9idWNrZXRPd25lcnNoaXAoXG4gICAgczM6IElTM0NsaWVudCxcbiAgICBidWNrZXQ6IHN0cmluZyxcbiAgICBhY2NvdW50Pzogc3RyaW5nLFxuICApOiBQcm9taXNlPEJ1Y2tldE93bmVyc2hpcC5NSU5FIHwgQnVja2V0T3duZXJzaGlwLkRPRVNfTk9UX0VYSVNUIHwgQnVja2V0T3duZXJzaGlwLk5PX0FDQ0VTUz4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBzMy5nZXRCdWNrZXRMb2NhdGlvbih7IEJ1Y2tldDogYnVja2V0LCBFeHBlY3RlZEJ1Y2tldE93bmVyOiBhY2NvdW50IH0pO1xuICAgICAgcmV0dXJuIEJ1Y2tldE93bmVyc2hpcC5NSU5FO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgaWYgKGUubmFtZSA9PT0gJ05vU3VjaEJ1Y2tldCcpIHtcbiAgICAgICAgcmV0dXJuIEJ1Y2tldE93bmVyc2hpcC5ET0VTX05PVF9FWElTVDtcbiAgICAgIH1cbiAgICAgIGlmIChbJ0FjY2Vzc0RlbmllZCcsICdBbGxBY2Nlc3NEaXNhYmxlZCddLmluY2x1ZGVzKGUubmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIEJ1Y2tldE93bmVyc2hpcC5OT19BQ0NFU1M7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2J1Y2tldEVuY3J5cHRpb24oczM6IElTM0NsaWVudCwgYnVja2V0OiBzdHJpbmcpOiBQcm9taXNlPEJ1Y2tldEVuY3J5cHRpb24+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZW5jcnlwdGlvbiA9IGF3YWl0IHMzLmdldEJ1Y2tldEVuY3J5cHRpb24oeyBCdWNrZXQ6IGJ1Y2tldCB9KTtcbiAgICAgIGNvbnN0IGwgPSBlbmNyeXB0aW9uPy5TZXJ2ZXJTaWRlRW5jcnlwdGlvbkNvbmZpZ3VyYXRpb24/LlJ1bGVzPy5sZW5ndGggPz8gMDtcbiAgICAgIGlmIChsID4gMCkge1xuICAgICAgICBjb25zdCBhcHBseSA9XG4gICAgICAgICAgZW5jcnlwdGlvbj8uU2VydmVyU2lkZUVuY3J5cHRpb25Db25maWd1cmF0aW9uPy5SdWxlcz8uYXQoXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICk/LkFwcGx5U2VydmVyU2lkZUVuY3J5cHRpb25CeURlZmF1bHQ7XG4gICAgICAgIGxldCBzc2VhbGdvID0gYXBwbHk/LlNTRUFsZ29yaXRobTtcbiAgICAgICAgaWYgKHNzZWFsZ28gPT09ICdBRVMyNTYnKSByZXR1cm4geyB0eXBlOiAnYWVzMjU2JyB9O1xuICAgICAgICBpZiAoc3NlYWxnbyA9PT0gJ2F3czprbXMnKSByZXR1cm4geyB0eXBlOiAna21zJywga21zS2V5SWQ6IGFwcGx5Py5LTVNNYXN0ZXJLZXlJRCB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdHlwZTogJ25vX2VuY3J5cHRpb24nIH07XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBpZiAoZS5uYW1lID09PSAnTm9TdWNoQnVja2V0Jykge1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnZG9lc19ub3RfZXhpc3QnIH07XG4gICAgICB9XG4gICAgICBpZiAoZS5uYW1lID09PSAnU2VydmVyU2lkZUVuY3J5cHRpb25Db25maWd1cmF0aW9uTm90Rm91bmRFcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ25vX2VuY3J5cHRpb24nIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChbJ0FjY2Vzc0RlbmllZCcsICdBbGxBY2Nlc3NEaXNhYmxlZCddLmluY2x1ZGVzKGUubmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2FjY2Vzc19kZW5pZWQnIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyB0eXBlOiAnbm9fZW5jcnlwdGlvbicgfTtcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gY2FjaGVkPEEsIEI+KGNhY2hlOiBNYXA8QSwgQj4sIGtleTogQSwgZmFjdG9yeTogKHg6IEEpID0+IFByb21pc2U8Qj4pOiBQcm9taXNlPEI+IHtcbiAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgcmV0dXJuIGNhY2hlLmdldChrZXkpITtcbiAgfVxuXG4gIGNvbnN0IGZyZXNoID0gYXdhaXQgZmFjdG9yeShrZXkpO1xuICBjYWNoZS5zZXQoa2V5LCBmcmVzaCk7XG4gIHJldHVybiBmcmVzaDtcbn1cbiJdfQ==