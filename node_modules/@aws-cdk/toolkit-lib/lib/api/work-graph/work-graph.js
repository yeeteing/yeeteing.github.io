"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkGraph = void 0;
const work_graph_types_1 = require("./work-graph-types");
const toolkit_error_1 = require("../../toolkit/toolkit-error");
const util_1 = require("../../util");
class WorkGraph {
    nodes;
    readyPool = [];
    lazyDependencies = new Map();
    ioHelper;
    error;
    constructor(nodes, ioHelper) {
        this.nodes = { ...nodes };
        this.ioHelper = ioHelper;
    }
    addNodes(...nodes) {
        for (const node of nodes) {
            if (this.nodes[node.id]) {
                throw new toolkit_error_1.ToolkitError(`Duplicate use of node id: ${node.id}`);
            }
            const ld = this.lazyDependencies.get(node.id);
            if (ld) {
                for (const x of ld) {
                    node.dependencies.add(x);
                }
                this.lazyDependencies.delete(node.id);
            }
            this.nodes[node.id] = node;
        }
    }
    removeNode(nodeId) {
        const id = typeof nodeId === 'string' ? nodeId : nodeId.id;
        const removedNode = this.nodes[id];
        this.lazyDependencies.delete(id);
        delete this.nodes[id];
        if (removedNode) {
            for (const node of Object.values(this.nodes)) {
                node.dependencies.delete(removedNode.id);
            }
        }
    }
    /**
     * Return all nodes of a given type
     */
    nodesOfType(type) {
        return Object.values(this.nodes).filter(n => n.type === type);
    }
    /**
     * Return all nodes that depend on a given node
     */
    dependees(nodeId) {
        const id = typeof nodeId === 'string' ? nodeId : nodeId.id;
        return Object.values(this.nodes).filter(n => n.dependencies.has(id));
    }
    /**
     * Add a dependency, that may come before or after the nodes involved
     */
    addDependency(fromId, toId) {
        const node = this.nodes[fromId];
        if (node) {
            node.dependencies.add(toId);
            return;
        }
        let lazyDeps = this.lazyDependencies.get(fromId);
        if (!lazyDeps) {
            lazyDeps = [];
            this.lazyDependencies.set(fromId, lazyDeps);
        }
        lazyDeps.push(toId);
    }
    tryGetNode(id) {
        return this.nodes[id];
    }
    node(id) {
        const ret = this.nodes[id];
        if (!ret) {
            throw new toolkit_error_1.ToolkitError(`No node with id ${id} among ${Object.keys(this.nodes)}`);
        }
        return ret;
    }
    absorb(graph) {
        this.addNodes(...Object.values(graph.nodes));
    }
    hasFailed() {
        return Object.values(this.nodes).some((n) => n.deploymentState === work_graph_types_1.DeploymentState.FAILED);
    }
    doParallel(concurrency, actions) {
        return this.forAllArtifacts(concurrency, async (x) => {
            switch (x.type) {
                case 'stack':
                    await actions.deployStack(x);
                    break;
                case 'asset-build':
                    await actions.buildAsset(x);
                    break;
                case 'asset-publish':
                    await actions.publishAsset(x);
                    break;
            }
        });
    }
    /**
     * Return the set of unblocked nodes
     */
    async ready() {
        await this.updateReadyPool();
        return this.readyPool;
    }
    forAllArtifacts(n, fn) {
        const graph = this;
        // If 'n' is a number, we limit all concurrency equally (effectively we will be using totalMax)
        // If 'n' is a record, we limit each job independently (effectively we will be using max)
        const max = typeof n === 'number' ?
            {
                'asset-build': n,
                'asset-publish': n,
                'stack': n,
            } : n;
        const totalMax = typeof n === 'number' ? n : sum(Object.values(n));
        return new Promise((ok, fail) => {
            let active = {
                'asset-build': 0,
                'asset-publish': 0,
                'stack': 0,
            };
            function totalActive() {
                return sum(Object.values(active));
            }
            start();
            function start() {
                graph.updateReadyPool().then(() => {
                    for (let i = 0; i < graph.readyPool.length;) {
                        const node = graph.readyPool[i];
                        if (active[node.type] < max[node.type] && totalActive() < totalMax) {
                            graph.readyPool.splice(i, 1);
                            startOne(node);
                        }
                        else {
                            i += 1;
                        }
                    }
                    if (totalActive() === 0) {
                        if (graph.done()) {
                            ok();
                        }
                        // wait for other active deploys to finish before failing
                        if (graph.hasFailed()) {
                            fail(graph.error);
                        }
                    }
                }).catch((e) => {
                    fail(e);
                });
            }
            function startOne(x) {
                x.deploymentState = work_graph_types_1.DeploymentState.DEPLOYING;
                active[x.type]++;
                void fn(x)
                    .finally(() => {
                    active[x.type]--;
                })
                    .then(() => {
                    graph.deployed(x);
                    start();
                }).catch((err) => {
                    // By recording the failure immediately as the queued task exits, we prevent the next
                    // queued task from starting.
                    graph.failed(x, err);
                    start();
                });
            }
        });
    }
    done() {
        return Object.values(this.nodes).every((n) => work_graph_types_1.DeploymentState.COMPLETED === n.deploymentState);
    }
    deployed(node) {
        node.deploymentState = work_graph_types_1.DeploymentState.COMPLETED;
    }
    failed(node, error) {
        this.error = error;
        node.deploymentState = work_graph_types_1.DeploymentState.FAILED;
        this.skipRest();
        this.readyPool.splice(0);
    }
    toString() {
        return [
            'digraph D {',
            ...Object.entries(this.nodes).flatMap(([id, node]) => renderNode(id, node)),
            '}',
        ].join('\n');
        function renderNode(id, node) {
            const ret = [];
            if (node.deploymentState === work_graph_types_1.DeploymentState.COMPLETED) {
                ret.push(`  ${gv(id, { style: 'filled', fillcolor: 'yellow', comment: node.note })};`);
            }
            else {
                ret.push(`  ${gv(id, { comment: node.note })};`);
            }
            for (const dep of node.dependencies) {
                ret.push(`  ${gv(id)} -> ${gv(dep)};`);
            }
            return ret;
        }
    }
    /**
     * Ensure all dependencies actually exist. This protects against scenarios such as the following:
     * StackA depends on StackB, but StackB is not selected to deploy. The dependency is redundant
     * and will be dropped.
     * This assumes the manifest comes uncorrupted so we will not fail if a dependency is not found.
     */
    removeUnavailableDependencies() {
        for (const node of Object.values(this.nodes)) {
            const removeDeps = Array.from(node.dependencies).filter((dep) => this.nodes[dep] === undefined);
            removeDeps.forEach((d) => {
                node.dependencies.delete(d);
            });
        }
    }
    /**
     * Remove all asset publishing steps for assets that are already published, and then build
     * that aren't used anymore.
     *
     * Do this in parallel, because there may be a lot of assets in an application (seen in practice: >100 assets)
     */
    async removeUnnecessaryAssets(isUnnecessary) {
        await this.ioHelper.defaults.debug('Checking for previously published assets');
        const publishes = this.nodesOfType('asset-publish');
        const classifiedNodes = await (0, util_1.parallelPromises)(8, publishes.map((assetNode) => async () => [assetNode, await isUnnecessary(assetNode)]));
        const alreadyPublished = classifiedNodes.filter(([_, unnecessary]) => unnecessary).map(([assetNode, _]) => assetNode);
        for (const assetNode of alreadyPublished) {
            this.removeNode(assetNode);
        }
        await this.ioHelper.defaults.debug(`${publishes.length} total assets, ${publishes.length - alreadyPublished.length} still need to be published`);
        // Now also remove any asset build steps that don't have any dependencies on them anymore
        const unusedBuilds = this.nodesOfType('asset-build').filter(build => this.dependees(build).length === 0);
        for (const unusedBuild of unusedBuilds) {
            this.removeNode(unusedBuild);
        }
    }
    async updateReadyPool() {
        const activeCount = Object.values(this.nodes).filter((x) => x.deploymentState === work_graph_types_1.DeploymentState.DEPLOYING).length;
        const pendingCount = Object.values(this.nodes).filter((x) => x.deploymentState === work_graph_types_1.DeploymentState.PENDING).length;
        const newlyReady = Object.values(this.nodes).filter((x) => x.deploymentState === work_graph_types_1.DeploymentState.PENDING &&
            Array.from(x.dependencies).every((id) => this.node(id).deploymentState === work_graph_types_1.DeploymentState.COMPLETED));
        // Add newly available nodes to the ready pool
        for (const node of newlyReady) {
            node.deploymentState = work_graph_types_1.DeploymentState.QUEUED;
            this.readyPool.push(node);
        }
        // Remove nodes from the ready pool that have already started deploying
        retainOnly(this.readyPool, (node) => node.deploymentState === work_graph_types_1.DeploymentState.QUEUED);
        // Sort by reverse priority
        this.readyPool.sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0));
        if (this.readyPool.length === 0 && activeCount === 0 && pendingCount > 0) {
            const cycle = this.findCycle() ?? ['No cycle found!'];
            await this.ioHelper.defaults.trace(`Cycle ${cycle.join(' -> ')} in graph ${this}`);
            throw new toolkit_error_1.ToolkitError(`Unable to make progress anymore, dependency cycle between remaining artifacts: ${cycle.join(' -> ')} (run with -vv for full graph)`);
        }
    }
    skipRest() {
        for (const node of Object.values(this.nodes)) {
            if ([work_graph_types_1.DeploymentState.QUEUED, work_graph_types_1.DeploymentState.PENDING].includes(node.deploymentState)) {
                node.deploymentState = work_graph_types_1.DeploymentState.SKIPPED;
            }
        }
    }
    /**
     * Find cycles in a graph
     *
     * Not the fastest, but effective and should be rare
     */
    findCycle() {
        const seen = new Set();
        const self = this;
        for (const nodeId of Object.keys(this.nodes)) {
            const cycle = recurse(nodeId, [nodeId]);
            if (cycle) {
                return cycle;
            }
        }
        return undefined;
        function recurse(nodeId, path) {
            if (seen.has(nodeId)) {
                return undefined;
            }
            try {
                for (const dep of self.nodes[nodeId].dependencies ?? []) {
                    const index = path.indexOf(dep);
                    if (index > -1) {
                        return [...path.slice(index), dep];
                    }
                    const cycle = recurse(dep, [...path, dep]);
                    if (cycle) {
                        return cycle;
                    }
                }
                return undefined;
            }
            finally {
                seen.add(nodeId);
            }
        }
    }
    /**
     * Whether the `end` node is reachable from the `start` node, following the dependency arrows
     */
    reachable(start, end) {
        const seen = new Set();
        const self = this;
        return recurse(start);
        function recurse(current) {
            if (seen.has(current)) {
                return false;
            }
            seen.add(current);
            if (current === end) {
                return true;
            }
            for (const dep of self.nodes[current].dependencies) {
                if (recurse(dep)) {
                    return true;
                }
            }
            return false;
        }
    }
}
exports.WorkGraph = WorkGraph;
function sum(xs) {
    let ret = 0;
    for (const x of xs) {
        ret += x;
    }
    return ret;
}
function retainOnly(xs, pred) {
    xs.splice(0, xs.length, ...xs.filter(pred));
}
function gv(id, attrs) {
    const attrString = Object.entries(attrs ?? {}).flatMap(([k, v]) => v !== undefined ? [`${k}="${v}"`] : []).join(',');
    return attrString ? `"${simplifyId(id)}" [${attrString}]` : `"${simplifyId(id)}"`;
}
function simplifyId(id) {
    return id.replace(/([0-9a-f]{6})[0-9a-f]{6,}/g, '$1');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid29yay1ncmFwaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIndvcmstZ3JhcGgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EseURBQXFEO0FBQ3JELCtEQUEyRDtBQUMzRCxxQ0FBOEM7QUFJOUMsTUFBYSxTQUFTO0lBQ0osS0FBSyxDQUEyQjtJQUMvQixTQUFTLEdBQW9CLEVBQUUsQ0FBQztJQUNoQyxnQkFBZ0IsR0FBRyxJQUFJLEdBQUcsRUFBb0IsQ0FBQztJQUMvQyxRQUFRLENBQVc7SUFFN0IsS0FBSyxDQUFTO0lBRXJCLFlBQW1CLEtBQStCLEVBQUUsUUFBa0I7UUFDcEUsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLEdBQUcsS0FBSyxFQUFFLENBQUM7UUFDMUIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7SUFDM0IsQ0FBQztJQUVNLFFBQVEsQ0FBQyxHQUFHLEtBQWlCO1FBQ2xDLEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxFQUFFLENBQUM7WUFDekIsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO2dCQUN4QixNQUFNLElBQUksNEJBQVksQ0FBQyw2QkFBNkIsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDakUsQ0FBQztZQUVELE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQzlDLElBQUksRUFBRSxFQUFFLENBQUM7Z0JBQ1AsS0FBSyxNQUFNLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQztvQkFDbkIsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzNCLENBQUM7Z0JBQ0QsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDeEMsQ0FBQztZQUVELElBQUksQ0FB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RUQsU0FBUyxFQUFFLENBQUMsRUFBVSxFQUFFLEtBQTBDO0lBQ2hFLE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUVySCxPQUFPLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxVQUFVLENBQUMsRUFBRSxDQUFDLE1BQU0sVUFBVSxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUM7QUFDcEYsQ0FBQztBQUVELFNBQVMsVUFBVSxDQUFDLEVBQVU7SUFDNUIsT0FBTyxFQUFFLENBQUMsT0FBTyxDQUFDLDRCQUE0QixFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3hELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFdvcmtOb2RlLCBTdGFja05vZGUsIEFzc2V0QnVpbGROb2RlLCBBc3NldFB1Ymxpc2hOb2RlIH0gZnJvbSAnLi93b3JrLWdyYXBoLXR5cGVzJztcbmltcG9ydCB7IERlcGxveW1lbnRTdGF0ZSB9IGZyb20gJy4vd29yay1ncmFwaC10eXBlcyc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuLi8uLi90b29sa2l0L3Rvb2xraXQtZXJyb3InO1xuaW1wb3J0IHsgcGFyYWxsZWxQcm9taXNlcyB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHR5cGUgeyBJb0hlbHBlciB9IGZyb20gJy4uL2lvL3ByaXZhdGUnO1xuZXhwb3J0IHR5cGUgQ29uY3VycmVuY3kgPSBudW1iZXIgfCBSZWNvcmQ8V29ya05vZGVbJ3R5cGUnXSwgbnVtYmVyPjtcblxuZXhwb3J0IGNsYXNzIFdvcmtHcmFwaCB7XG4gIHB1YmxpYyByZWFkb25seSBub2RlczogUmVjb3JkPHN0cmluZywgV29ya05vZGU+O1xuICBwcml2YXRlIHJlYWRvbmx5IHJlYWR5UG9vbDogQXJyYXk8V29ya05vZGU+ID0gW107XG4gIHByaXZhdGUgcmVhZG9ubHkgbGF6eURlcGVuZGVuY2llcyA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmdbXT4oKTtcbiAgcHJpdmF0ZSByZWFkb25seSBpb0hlbHBlcjogSW9IZWxwZXI7XG5cbiAgcHVibGljIGVycm9yPzogRXJyb3I7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKG5vZGVzOiBSZWNvcmQ8c3RyaW5nLCBXb3JrTm9kZT4sIGlvSGVscGVyOiBJb0hlbHBlcikge1xuICAgIHRoaXMubm9kZXMgPSB7IC4uLm5vZGVzIH07XG4gICAgdGhpcy5pb0hlbHBlciA9IGlvSGVscGVyO1xuICB9XG5cbiAgcHVibGljIGFkZE5vZGVzKC4uLm5vZGVzOiBXb3JrTm9kZVtdKSB7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICBpZiAodGhpcy5ub2Rlc1tub2RlLmlkXSkge1xuICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBEdXBsaWNhdGUgdXNlIG9mIG5vZGUgaWQ6ICR7bm9kZS5pZH1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGQgPSB0aGlzLmxhenlEZXBlbmRlbmNpZXMuZ2V0KG5vZGUuaWQpO1xuICAgICAgaWYgKGxkKSB7XG4gICAgICAgIGZvciAoY29uc3QgeCBvZiBsZCkge1xuICAgICAgICAgIG5vZGUuZGVwZW5kZW5jaWVzLmFkZCh4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhenlEZXBlbmRlbmNpZXMuZGVsZXRlKG5vZGUuaWQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5vZGVzW25vZGUuaWRdID0gbm9kZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlTm9kZShub2RlSWQ6IHN0cmluZyB8IFdvcmtOb2RlKSB7XG4gICAgY29uc3QgaWQgPSB0eXBlb2Ygbm9kZUlkID09PSAnc3RyaW5nJyA/IG5vZGVJZCA6IG5vZGVJZC5pZDtcbiAgICBjb25zdCByZW1vdmVkTm9kZSA9IHRoaXMubm9kZXNbaWRdO1xuXG4gICAgdGhpcy5sYXp5RGVwZW5kZW5jaWVzLmRlbGV0ZShpZCk7XG4gICAgZGVsZXRlIHRoaXMubm9kZXNbaWRdO1xuXG4gICAgaWYgKHJlbW92ZWROb2RlKSB7XG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLm5vZGVzKSkge1xuICAgICAgICBub2RlLmRlcGVuZGVuY2llcy5kZWxldGUocmVtb3ZlZE5vZGUuaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYWxsIG5vZGVzIG9mIGEgZ2l2ZW4gdHlwZVxuICAgKi9cbiAgcHVibGljIG5vZGVzT2ZUeXBlPFQgZXh0ZW5kcyBXb3JrTm9kZVsndHlwZSddPih0eXBlOiBUKTogRXh0cmFjdDxXb3JrTm9kZSwgeyB0eXBlOiBUIH0+W10ge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMubm9kZXMpLmZpbHRlcihuID0+IG4udHlwZSA9PT0gdHlwZSkgYXMgYW55O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgbm9kZXMgdGhhdCBkZXBlbmQgb24gYSBnaXZlbiBub2RlXG4gICAqL1xuICBwdWJsaWMgZGVwZW5kZWVzKG5vZGVJZDogc3RyaW5nIHwgV29ya05vZGUpIHtcbiAgICBjb25zdCBpZCA9IHR5cGVvZiBub2RlSWQgPT09ICdzdHJpbmcnID8gbm9kZUlkIDogbm9kZUlkLmlkO1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMubm9kZXMpLmZpbHRlcihuID0+IG4uZGVwZW5kZW5jaWVzLmhhcyhpZCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGRlcGVuZGVuY3ksIHRoYXQgbWF5IGNvbWUgYmVmb3JlIG9yIGFmdGVyIHRoZSBub2RlcyBpbnZvbHZlZFxuICAgKi9cbiAgcHVibGljIGFkZERlcGVuZGVuY3koZnJvbUlkOiBzdHJpbmcsIHRvSWQ6IHN0cmluZykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGVzW2Zyb21JZF07XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIG5vZGUuZGVwZW5kZW5jaWVzLmFkZCh0b0lkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGxhenlEZXBzID0gdGhpcy5sYXp5RGVwZW5kZW5jaWVzLmdldChmcm9tSWQpO1xuICAgIGlmICghbGF6eURlcHMpIHtcbiAgICAgIGxhenlEZXBzID0gW107XG4gICAgICB0aGlzLmxhenlEZXBlbmRlbmNpZXMuc2V0KGZyb21JZCwgbGF6eURlcHMpO1xuICAgIH1cbiAgICBsYXp5RGVwcy5wdXNoKHRvSWQpO1xuICB9XG5cbiAgcHVibGljIHRyeUdldE5vZGUoaWQ6IHN0cmluZyk6IFdvcmtOb2RlIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlc1tpZF07XG4gIH1cblxuICBwdWJsaWMgbm9kZShpZDogc3RyaW5nKSB7XG4gICAgY29uc3QgcmV0ID0gdGhpcy5ub2Rlc1tpZF07XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYE5vIG5vZGUgd2l0aCBpZCAke2lkfSBhbW9uZyAke09iamVjdC5rZXlzKHRoaXMubm9kZXMpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgcHVibGljIGFic29yYihncmFwaDogV29ya0dyYXBoKSB7XG4gICAgdGhpcy5hZGROb2RlcyguLi5PYmplY3QudmFsdWVzKGdyYXBoLm5vZGVzKSk7XG4gIH1cblxuICBwcml2YXRlIGhhc0ZhaWxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLm5vZGVzKS5zb21lKChuKSA9PiBuLmRlcGxveW1lbnRTdGF0ZSA9PT0gRGVwbG95bWVudFN0YXRlLkZBSUxFRCk7XG4gIH1cblxuICBwdWJsaWMgZG9QYXJhbGxlbChjb25jdXJyZW5jeTogQ29uY3VycmVuY3ksIGFjdGlvbnM6IFdvcmtHcmFwaEFjdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JBbGxBcnRpZmFjdHMoY29uY3VycmVuY3ksIGFzeW5jICh4OiBXb3JrTm9kZSkgPT4ge1xuICAgICAgc3dpdGNoICh4LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnc3RhY2snOlxuICAgICAgICAgIGF3YWl0IGFjdGlvbnMuZGVwbG95U3RhY2soeCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Fzc2V0LWJ1aWxkJzpcbiAgICAgICAgICBhd2FpdCBhY3Rpb25zLmJ1aWxkQXNzZXQoeCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Fzc2V0LXB1Ymxpc2gnOlxuICAgICAgICAgIGF3YWl0IGFjdGlvbnMucHVibGlzaEFzc2V0KHgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc2V0IG9mIHVuYmxvY2tlZCBub2Rlc1xuICAgKi9cbiAgcHVibGljIGFzeW5jIHJlYWR5KCk6IFByb21pc2U8UmVhZG9ubHlBcnJheTxXb3JrTm9kZT4+IHtcbiAgICBhd2FpdCB0aGlzLnVwZGF0ZVJlYWR5UG9vbCgpO1xuICAgIHJldHVybiB0aGlzLnJlYWR5UG9vbDtcbiAgfVxuXG4gIHByaXZhdGUgZm9yQWxsQXJ0aWZhY3RzKG46IENvbmN1cnJlbmN5LCBmbjogKHg6IFdvcmtOb2RlKSA9PiBQcm9taXNlPHZvaWQ+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZ3JhcGggPSB0aGlzO1xuXG4gICAgLy8gSWYgJ24nIGlzIGEgbnVtYmVyLCB3ZSBsaW1pdCBhbGwgY29uY3VycmVuY3kgZXF1YWxseSAoZWZmZWN0aXZlbHkgd2Ugd2lsbCBiZSB1c2luZyB0b3RhbE1heClcbiAgICAvLyBJZiAnbicgaXMgYSByZWNvcmQsIHdlIGxpbWl0IGVhY2ggam9iIGluZGVwZW5kZW50bHkgKGVmZmVjdGl2ZWx5IHdlIHdpbGwgYmUgdXNpbmcgbWF4KVxuICAgIGNvbnN0IG1heDogUmVjb3JkPFdvcmtOb2RlWyd0eXBlJ10sIG51bWJlcj4gPSB0eXBlb2YgbiA9PT0gJ251bWJlcicgP1xuICAgICAge1xuICAgICAgICAnYXNzZXQtYnVpbGQnOiBuLFxuICAgICAgICAnYXNzZXQtcHVibGlzaCc6IG4sXG4gICAgICAgICdzdGFjayc6IG4sXG4gICAgICB9IDogbjtcbiAgICBjb25zdCB0b3RhbE1heCA9IHR5cGVvZiBuID09PSAnbnVtYmVyJyA/IG4gOiBzdW0oT2JqZWN0LnZhbHVlcyhuKSk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKG9rLCBmYWlsKSA9PiB7XG4gICAgICBsZXQgYWN0aXZlOiBSZWNvcmQ8V29ya05vZGVbJ3R5cGUnXSwgbnVtYmVyPiA9IHtcbiAgICAgICAgJ2Fzc2V0LWJ1aWxkJzogMCxcbiAgICAgICAgJ2Fzc2V0LXB1Ymxpc2gnOiAwLFxuICAgICAgICAnc3RhY2snOiAwLFxuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIHRvdGFsQWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gc3VtKE9iamVjdC52YWx1ZXMoYWN0aXZlKSk7XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0KCk7XG5cbiAgICAgIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICBncmFwaC51cGRhdGVSZWFkeVBvb2woKS50aGVuKCgpID0+IHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyYXBoLnJlYWR5UG9vbC5sZW5ndGg7ICkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGdyYXBoLnJlYWR5UG9vbFtpXTtcblxuICAgICAgICAgICAgaWYgKGFjdGl2ZVtub2RlLnR5cGVdIDwgbWF4W25vZGUudHlwZV0gJiYgdG90YWxBY3RpdmUoKSA8IHRvdGFsTWF4KSB7XG4gICAgICAgICAgICAgIGdyYXBoLnJlYWR5UG9vbC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgIHN0YXJ0T25lKG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0b3RhbEFjdGl2ZSgpID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoZ3JhcGguZG9uZSgpKSB7XG4gICAgICAgICAgICAgIG9rKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3YWl0IGZvciBvdGhlciBhY3RpdmUgZGVwbG95cyB0byBmaW5pc2ggYmVmb3JlIGZhaWxpbmdcbiAgICAgICAgICAgIGlmIChncmFwaC5oYXNGYWlsZWQoKSkge1xuICAgICAgICAgICAgICBmYWlsKGdyYXBoLmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgZmFpbChlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHN0YXJ0T25lKHg6IFdvcmtOb2RlKSB7XG4gICAgICAgIHguZGVwbG95bWVudFN0YXRlID0gRGVwbG95bWVudFN0YXRlLkRFUExPWUlORztcbiAgICAgICAgYWN0aXZlW3gudHlwZV0rKztcbiAgICAgICAgdm9pZCBmbih4KVxuICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgIGFjdGl2ZVt4LnR5cGVdLS07XG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBncmFwaC5kZXBsb3llZCh4KTtcbiAgICAgICAgICAgIHN0YXJ0KCk7XG4gICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgLy8gQnkgcmVjb3JkaW5nIHRoZSBmYWlsdXJlIGltbWVkaWF0ZWx5IGFzIHRoZSBxdWV1ZWQgdGFzayBleGl0cywgd2UgcHJldmVudCB0aGUgbmV4dFxuICAgICAgICAgICAgLy8gcXVldWVkIHRhc2sgZnJvbSBzdGFydGluZy5cbiAgICAgICAgICAgIGdyYXBoLmZhaWxlZCh4LCBlcnIpO1xuICAgICAgICAgICAgc3RhcnQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgZG9uZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLm5vZGVzKS5ldmVyeSgobikgPT4gRGVwbG95bWVudFN0YXRlLkNPTVBMRVRFRCA9PT0gbi5kZXBsb3ltZW50U3RhdGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBkZXBsb3llZChub2RlOiBXb3JrTm9kZSkge1xuICAgIG5vZGUuZGVwbG95bWVudFN0YXRlID0gRGVwbG95bWVudFN0YXRlLkNPTVBMRVRFRDtcbiAgfVxuXG4gIHByaXZhdGUgZmFpbGVkKG5vZGU6IFdvcmtOb2RlLCBlcnJvcj86IEVycm9yKSB7XG4gICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIG5vZGUuZGVwbG95bWVudFN0YXRlID0gRGVwbG95bWVudFN0YXRlLkZBSUxFRDtcbiAgICB0aGlzLnNraXBSZXN0KCk7XG4gICAgdGhpcy5yZWFkeVBvb2wuc3BsaWNlKDApO1xuICB9XG5cbiAgcHVibGljIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBbXG4gICAgICAnZGlncmFwaCBEIHsnLFxuICAgICAgLi4uT2JqZWN0LmVudHJpZXModGhpcy5ub2RlcykuZmxhdE1hcCgoW2lkLCBub2RlXSkgPT4gcmVuZGVyTm9kZShpZCwgbm9kZSkpLFxuICAgICAgJ30nLFxuICAgIF0uam9pbignXFxuJyk7XG5cbiAgICBmdW5jdGlvbiByZW5kZXJOb2RlKGlkOiBzdHJpbmcsIG5vZGU6IFdvcmtOb2RlKTogc3RyaW5nW10ge1xuICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICBpZiAobm9kZS5kZXBsb3ltZW50U3RhdGUgPT09IERlcGxveW1lbnRTdGF0ZS5DT01QTEVURUQpIHtcbiAgICAgICAgcmV0LnB1c2goYCAgJHtndihpZCwgeyBzdHlsZTogJ2ZpbGxlZCcsIGZpbGxjb2xvcjogJ3llbGxvdycsIGNvbW1lbnQ6IG5vZGUubm90ZSB9KX07YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQucHVzaChgICAke2d2KGlkLCB7IGNvbW1lbnQ6IG5vZGUubm90ZSB9KX07YCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGRlcCBvZiBub2RlLmRlcGVuZGVuY2llcykge1xuICAgICAgICByZXQucHVzaChgICAke2d2KGlkKX0gLT4gJHtndihkZXApfTtgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZSBhbGwgZGVwZW5kZW5jaWVzIGFjdHVhbGx5IGV4aXN0LiBUaGlzIHByb3RlY3RzIGFnYWluc3Qgc2NlbmFyaW9zIHN1Y2ggYXMgdGhlIGZvbGxvd2luZzpcbiAgICogU3RhY2tBIGRlcGVuZHMgb24gU3RhY2tCLCBidXQgU3RhY2tCIGlzIG5vdCBzZWxlY3RlZCB0byBkZXBsb3kuIFRoZSBkZXBlbmRlbmN5IGlzIHJlZHVuZGFudFxuICAgKiBhbmQgd2lsbCBiZSBkcm9wcGVkLlxuICAgKiBUaGlzIGFzc3VtZXMgdGhlIG1hbmlmZXN0IGNvbWVzIHVuY29ycnVwdGVkIHNvIHdlIHdpbGwgbm90IGZhaWwgaWYgYSBkZXBlbmRlbmN5IGlzIG5vdCBmb3VuZC5cbiAgICovXG4gIHB1YmxpYyByZW1vdmVVbmF2YWlsYWJsZURlcGVuZGVuY2llcygpIHtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLm5vZGVzKSkge1xuICAgICAgY29uc3QgcmVtb3ZlRGVwcyA9IEFycmF5LmZyb20obm9kZS5kZXBlbmRlbmNpZXMpLmZpbHRlcigoZGVwKSA9PiB0aGlzLm5vZGVzW2RlcF0gPT09IHVuZGVmaW5lZCk7XG5cbiAgICAgIHJlbW92ZURlcHMuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICBub2RlLmRlcGVuZGVuY2llcy5kZWxldGUoZCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBhc3NldCBwdWJsaXNoaW5nIHN0ZXBzIGZvciBhc3NldHMgdGhhdCBhcmUgYWxyZWFkeSBwdWJsaXNoZWQsIGFuZCB0aGVuIGJ1aWxkXG4gICAqIHRoYXQgYXJlbid0IHVzZWQgYW55bW9yZS5cbiAgICpcbiAgICogRG8gdGhpcyBpbiBwYXJhbGxlbCwgYmVjYXVzZSB0aGVyZSBtYXkgYmUgYSBsb3Qgb2YgYXNzZXRzIGluIGFuIGFwcGxpY2F0aW9uIChzZWVuIGluIHByYWN0aWNlOiA+MTAwIGFzc2V0cylcbiAgICovXG4gIHB1YmxpYyBhc3luYyByZW1vdmVVbm5lY2Vzc2FyeUFzc2V0cyhpc1VubmVjZXNzYXJ5OiAoeDogQXNzZXRQdWJsaXNoTm9kZSkgPT4gUHJvbWlzZTxib29sZWFuPikge1xuICAgIGF3YWl0IHRoaXMuaW9IZWxwZXIuZGVmYXVsdHMuZGVidWcoJ0NoZWNraW5nIGZvciBwcmV2aW91c2x5IHB1Ymxpc2hlZCBhc3NldHMnKTtcblxuICAgIGNvbnN0IHB1Ymxpc2hlcyA9IHRoaXMubm9kZXNPZlR5cGUoJ2Fzc2V0LXB1Ymxpc2gnKTtcblxuICAgIGNvbnN0IGNsYXNzaWZpZWROb2RlcyA9IGF3YWl0IHBhcmFsbGVsUHJvbWlzZXMoXG4gICAgICA4LFxuICAgICAgcHVibGlzaGVzLm1hcCgoYXNzZXROb2RlKSA9PiBhc3luYygpID0+IFthc3NldE5vZGUsIGF3YWl0IGlzVW5uZWNlc3NhcnkoYXNzZXROb2RlKV0gYXMgY29uc3QpKTtcblxuICAgIGNvbnN0IGFscmVhZHlQdWJsaXNoZWQgPSBjbGFzc2lmaWVkTm9kZXMuZmlsdGVyKChbXywgdW5uZWNlc3NhcnldKSA9PiB1bm5lY2Vzc2FyeSkubWFwKChbYXNzZXROb2RlLCBfXSkgPT4gYXNzZXROb2RlKTtcbiAgICBmb3IgKGNvbnN0IGFzc2V0Tm9kZSBvZiBhbHJlYWR5UHVibGlzaGVkKSB7XG4gICAgICB0aGlzLnJlbW92ZU5vZGUoYXNzZXROb2RlKTtcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLmlvSGVscGVyLmRlZmF1bHRzLmRlYnVnKGAke3B1Ymxpc2hlcy5sZW5ndGh9IHRvdGFsIGFzc2V0cywgJHtwdWJsaXNoZXMubGVuZ3RoIC0gYWxyZWFkeVB1Ymxpc2hlZC5sZW5ndGh9IHN0aWxsIG5lZWQgdG8gYmUgcHVibGlzaGVkYCk7XG5cbiAgICAvLyBOb3cgYWxzbyByZW1vdmUgYW55IGFzc2V0IGJ1aWxkIHN0ZXBzIHRoYXQgZG9uJ3QgaGF2ZSBhbnkgZGVwZW5kZW5jaWVzIG9uIHRoZW0gYW55bW9yZVxuICAgIGNvbnN0IHVudXNlZEJ1aWxkcyA9IHRoaXMubm9kZXNPZlR5cGUoJ2Fzc2V0LWJ1aWxkJykuZmlsdGVyKGJ1aWxkID0+IHRoaXMuZGVwZW5kZWVzKGJ1aWxkKS5sZW5ndGggPT09IDApO1xuICAgIGZvciAoY29uc3QgdW51c2VkQnVpbGQgb2YgdW51c2VkQnVpbGRzKSB7XG4gICAgICB0aGlzLnJlbW92ZU5vZGUodW51c2VkQnVpbGQpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgdXBkYXRlUmVhZHlQb29sKCkge1xuICAgIGNvbnN0IGFjdGl2ZUNvdW50ID0gT2JqZWN0LnZhbHVlcyh0aGlzLm5vZGVzKS5maWx0ZXIoKHgpID0+IHguZGVwbG95bWVudFN0YXRlID09PSBEZXBsb3ltZW50U3RhdGUuREVQTE9ZSU5HKS5sZW5ndGg7XG4gICAgY29uc3QgcGVuZGluZ0NvdW50ID0gT2JqZWN0LnZhbHVlcyh0aGlzLm5vZGVzKS5maWx0ZXIoKHgpID0+IHguZGVwbG95bWVudFN0YXRlID09PSBEZXBsb3ltZW50U3RhdGUuUEVORElORykubGVuZ3RoO1xuXG4gICAgY29uc3QgbmV3bHlSZWFkeSA9IE9iamVjdC52YWx1ZXModGhpcy5ub2RlcykuZmlsdGVyKCh4KSA9PlxuICAgICAgeC5kZXBsb3ltZW50U3RhdGUgPT09IERlcGxveW1lbnRTdGF0ZS5QRU5ESU5HICYmXG4gICAgICBBcnJheS5mcm9tKHguZGVwZW5kZW5jaWVzKS5ldmVyeSgoaWQpID0+IHRoaXMubm9kZShpZCkuZGVwbG95bWVudFN0YXRlID09PSBEZXBsb3ltZW50U3RhdGUuQ09NUExFVEVEKSk7XG5cbiAgICAvLyBBZGQgbmV3bHkgYXZhaWxhYmxlIG5vZGVzIHRvIHRoZSByZWFkeSBwb29sXG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5ld2x5UmVhZHkpIHtcbiAgICAgIG5vZGUuZGVwbG95bWVudFN0YXRlID0gRGVwbG95bWVudFN0YXRlLlFVRVVFRDtcbiAgICAgIHRoaXMucmVhZHlQb29sLnB1c2gobm9kZSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIG5vZGVzIGZyb20gdGhlIHJlYWR5IHBvb2wgdGhhdCBoYXZlIGFscmVhZHkgc3RhcnRlZCBkZXBsb3lpbmdcbiAgICByZXRhaW5Pbmx5KHRoaXMucmVhZHlQb29sLCAobm9kZSkgPT4gbm9kZS5kZXBsb3ltZW50U3RhdGUgPT09IERlcGxveW1lbnRTdGF0ZS5RVUVVRUQpO1xuXG4gICAgLy8gU29ydCBieSByZXZlcnNlIHByaW9yaXR5XG4gICAgdGhpcy5yZWFkeVBvb2wuc29ydCgoYSwgYikgPT4gKGIucHJpb3JpdHkgPz8gMCkgLSAoYS5wcmlvcml0eSA/PyAwKSk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVBvb2wubGVuZ3RoID09PSAwICYmIGFjdGl2ZUNvdW50ID09PSAwICYmIHBlbmRpbmdDb3VudCA+IDApIHtcbiAgICAgIGNvbnN0IGN5Y2xlID0gdGhpcy5maW5kQ3ljbGUoKSA/PyBbJ05vIGN5Y2xlIGZvdW5kISddO1xuICAgICAgYXdhaXQgdGhpcy5pb0hlbHBlci5kZWZhdWx0cy50cmFjZShgQ3ljbGUgJHtjeWNsZS5qb2luKCcgLT4gJyl9IGluIGdyYXBoICR7dGhpc31gKTtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYFVuYWJsZSB0byBtYWtlIHByb2dyZXNzIGFueW1vcmUsIGRlcGVuZGVuY3kgY3ljbGUgYmV0d2VlbiByZW1haW5pbmcgYXJ0aWZhY3RzOiAke2N5Y2xlLmpvaW4oJyAtPiAnKX0gKHJ1biB3aXRoIC12diBmb3IgZnVsbCBncmFwaClgKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNraXBSZXN0KCkge1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBPYmplY3QudmFsdWVzKHRoaXMubm9kZXMpKSB7XG4gICAgICBpZiAoW0RlcGxveW1lbnRTdGF0ZS5RVUVVRUQsIERlcGxveW1lbnRTdGF0ZS5QRU5ESU5HXS5pbmNsdWRlcyhub2RlLmRlcGxveW1lbnRTdGF0ZSkpIHtcbiAgICAgICAgbm9kZS5kZXBsb3ltZW50U3RhdGUgPSBEZXBsb3ltZW50U3RhdGUuU0tJUFBFRDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmluZCBjeWNsZXMgaW4gYSBncmFwaFxuICAgKlxuICAgKiBOb3QgdGhlIGZhc3Rlc3QsIGJ1dCBlZmZlY3RpdmUgYW5kIHNob3VsZCBiZSByYXJlXG4gICAqL1xuICBwdWJsaWMgZmluZEN5Y2xlKCk6IHN0cmluZ1tdIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBzZWVuID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgZm9yIChjb25zdCBub2RlSWQgb2YgT2JqZWN0LmtleXModGhpcy5ub2RlcykpIHtcbiAgICAgIGNvbnN0IGN5Y2xlID0gcmVjdXJzZShub2RlSWQsIFtub2RlSWRdKTtcbiAgICAgIGlmIChjeWNsZSkge1xuICAgICAgICByZXR1cm4gY3ljbGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICBmdW5jdGlvbiByZWN1cnNlKG5vZGVJZDogc3RyaW5nLCBwYXRoOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHwgdW5kZWZpbmVkIHtcbiAgICAgIGlmIChzZWVuLmhhcyhub2RlSWQpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKGNvbnN0IGRlcCBvZiBzZWxmLm5vZGVzW25vZGVJZF0uZGVwZW5kZW5jaWVzID8/IFtdKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBwYXRoLmluZGV4T2YoZGVwKTtcbiAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5wYXRoLnNsaWNlKGluZGV4KSwgZGVwXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBjeWNsZSA9IHJlY3Vyc2UoZGVwLCBbLi4ucGF0aCwgZGVwXSk7XG4gICAgICAgICAgaWYgKGN5Y2xlKSB7XG4gICAgICAgICAgICByZXR1cm4gY3ljbGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNlZW4uYWRkKG5vZGVJZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGBlbmRgIG5vZGUgaXMgcmVhY2hhYmxlIGZyb20gdGhlIGBzdGFydGAgbm9kZSwgZm9sbG93aW5nIHRoZSBkZXBlbmRlbmN5IGFycm93c1xuICAgKi9cbiAgcHVibGljIHJlYWNoYWJsZShzdGFydDogc3RyaW5nLCBlbmQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gcmVjdXJzZShzdGFydCk7XG5cbiAgICBmdW5jdGlvbiByZWN1cnNlKGN1cnJlbnQ6IHN0cmluZykge1xuICAgICAgaWYgKHNlZW4uaGFzKGN1cnJlbnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHNlZW4uYWRkKGN1cnJlbnQpO1xuXG4gICAgICBpZiAoY3VycmVudCA9PT0gZW5kKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBkZXAgb2Ygc2VsZi5ub2Rlc1tjdXJyZW50XS5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgaWYgKHJlY3Vyc2UoZGVwKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV29ya0dyYXBoQWN0aW9ucyB7XG4gIGRlcGxveVN0YWNrOiAoc3RhY2tOb2RlOiBTdGFja05vZGUpID0+IFByb21pc2U8dm9pZD47XG4gIGJ1aWxkQXNzZXQ6IChhc3NldE5vZGU6IEFzc2V0QnVpbGROb2RlKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBwdWJsaXNoQXNzZXQ6IChhc3NldE5vZGU6IEFzc2V0UHVibGlzaE5vZGUpID0+IFByb21pc2U8dm9pZD47XG59XG5cbmZ1bmN0aW9uIHN1bSh4czogbnVtYmVyW10pIHtcbiAgbGV0IHJldCA9IDA7XG4gIGZvciAoY29uc3QgeCBvZiB4cykge1xuICAgIHJldCArPSB4O1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHJldGFpbk9ubHk8QT4oeHM6IEFbXSwgcHJlZDogKHg6IEEpID0+IGJvb2xlYW4pIHtcbiAgeHMuc3BsaWNlKDAsIHhzLmxlbmd0aCwgLi4ueHMuZmlsdGVyKHByZWQpKTtcbn1cblxuZnVuY3Rpb24gZ3YoaWQ6IHN0cmluZywgYXR0cnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+KSB7XG4gIGNvbnN0IGF0dHJTdHJpbmcgPSBPYmplY3QuZW50cmllcyhhdHRycyA/PyB7fSkuZmxhdE1hcCgoW2ssIHZdKSA9PiB2ICE9PSB1bmRlZmluZWQgPyBbYCR7a309XCIke3Z9XCJgXSA6IFtdKS5qb2luKCcsJyk7XG5cbiAgcmV0dXJuIGF0dHJTdHJpbmcgPyBgXCIke3NpbXBsaWZ5SWQoaWQpfVwiIFske2F0dHJTdHJpbmd9XWAgOiBgXCIke3NpbXBsaWZ5SWQoaWQpfVwiYDtcbn1cblxuZnVuY3Rpb24gc2ltcGxpZnlJZChpZDogc3RyaW5nKSB7XG4gIHJldHVybiBpZC5yZXBsYWNlKC8oWzAtOWEtZl17Nn0pWzAtOWEtZl17Nix9L2csICckMScpO1xufVxuIl19