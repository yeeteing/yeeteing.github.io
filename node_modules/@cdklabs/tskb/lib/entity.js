"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.optionalCmp = exports.numberCmp = exports.stringCmp = exports.ref = exports.isEntityCollection = exports.calculatedIndex = exports.fieldIndex = exports.entityCollection = void 0;
const sorted_map_1 = require("./sorted-map");
function entityCollection() {
    const entities = new Map();
    const _indexes = {};
    function add(x) {
        entities.set(x.$id, x);
        for (const index of Object.values(_indexes)) {
            // FIXME: why can't we type this?
            index.add(x);
        }
    }
    return {
        type: 'entities',
        entities,
        indexes: _indexes,
        add,
        dehydrate: () => ({
            type: 'entities',
            entities: Array.from(validatePlainObjects(entities).values()),
        }),
        hydrateFrom: (x) => {
            entities.clear();
            for (const e of Object.values(x.entities)) {
                add(e);
            }
        },
        index(indexes) {
            // This limitation exists purely because I couldn't type it otherwise.
            // Declaring a return type of `EntityCollection<A, I | II>` would make a lot
            // of our other type inspection code stop working (the union is hard to pick
            // apart). Since adding indexes in multiple goes is not really a use case,
            // the simpler solution is just to type it as if we replaced all indexes
            // and add a runtime check to make sure the types aren't lying.
            if (Object.keys(_indexes).length > 0) {
                throw new Error('You may only call .index() once on a new collection');
            }
            Object.assign(_indexes, indexes);
            return this;
        },
    };
}
exports.entityCollection = entityCollection;
/**
 * An index that uses the value of an entity's field
 */
function fieldIndex(propName, comparator) {
    return calculatedIndex((x) => x[propName], comparator);
}
exports.fieldIndex = fieldIndex;
/**
 * An index that is calculated based on a function applied to an entity
 */
function calculatedIndex(fn, comparator) {
    const index = [];
    return {
        add: (x) => sorted_map_1.sortedMap.add(index, comparator, fn(x), x.$id),
        lookups: {
            equals: (value) => sorted_map_1.sortedMap.findAll(index, comparator, value),
        },
        index,
    };
}
exports.calculatedIndex = calculatedIndex;
function isEntityCollection(x) {
    return typeof x === 'object' && !!x && x.type === 'entities';
}
exports.isEntityCollection = isEntityCollection;
function validatePlainObjects(xs) {
    for (const x of xs.values()) {
        if (x.constructor !== Object) {
            throw new Error(`Entities should be plain-text objects, got instance of ${x.constructor}`);
        }
    }
    return xs;
}
function ref(x) {
    return typeof x === 'string' ? { $ref: x } : { $ref: x.$id };
}
exports.ref = ref;
/**
 * Determines whether two strings are equivalent in the current or specified locale.
 */
function stringCmp(a, b) {
    return a.localeCompare(b);
}
exports.stringCmp = stringCmp;
/**
 * Determines whether two numbers are equivalent.
 */
function numberCmp(a, b) {
    return a - b;
}
exports.numberCmp = numberCmp;
/**
 * Creates a comparator to determine equivalent of two values, using a given comparator, but allows values to be optional.
 *
 * @param frontOrder If `true`, returns so that undefined values are ordered at the front. If `false`, undefined values are ordered at the back.
 */
function optionalCmp(cmp, frontOrder = true) {
    return (a, b) => {
        if (a == undefined && b != undefined) {
            return frontOrder ? -1 : 1;
        }
        if (a != undefined && b == undefined) {
            return frontOrder ? 1 : -1;
        }
        if (a == undefined && b == undefined) {
            return 0;
        }
        return cmp(a, b);
    };
}
exports.optionalCmp = optionalCmp;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW50aXR5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2VudGl0eS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSw2Q0FBeUQ7QUE0RXpELFNBQWdCLGdCQUFnQjtJQUM5QixNQUFNLFFBQVEsR0FBRyxJQUFJLEdBQUcsRUFBYSxDQUFDO0lBQ3RDLE1BQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQztJQUVwQixTQUFTLEdBQUcsQ0FBQyxDQUFJO1FBQ2YsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3ZCLEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUMzQyxpQ0FBaUM7WUFDaEMsS0FBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUN2QjtJQUNILENBQUM7SUFFRCxPQUFPO1FBQ0wsSUFBSSxFQUFFLFVBQVU7UUFDaEIsUUFBUTtRQUNSLE9BQU8sRUFBRSxRQUFlO1FBQ3hCLEdBQUc7UUFDSCxTQUFTLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztZQUNoQixJQUFJLEVBQUUsVUFBVTtZQUNoQixRQUFRLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztTQUM5RCxDQUFDO1FBQ0YsV0FBVyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDakIsUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ2pCLEtBQUssTUFBTSxDQUFDLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUU7Z0JBQ3pDLEdBQUcsQ0FBQyxDQUFRLENBQUMsQ0FBQzthQUNmO1FBQ0gsQ0FBQztRQUNELEtBQUssQ0FBQyxPQUFPO1lBQ1gsc0VBQXNFO1lBQ3RFLDRFQUE0RTtZQUM1RSw0RUFBNEU7WUFDNUUsMEVBQTBFO1lB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U0FBUyxFQUFFO1lBQ3BDLE9BQU8sVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQzVCO1FBQ0QsSUFBSSxDQUFDLElBQUksU0FBUyxJQUFJLENBQUMsSUFBSSxTQUFTLEVBQUU7WUFDcEMsT0FBTyxDQUFDLENBQUM7U0FDVjtRQUVELE9BQU8sR0FBRyxDQUFDLENBQUUsRUFBRSxDQUFFLENBQUMsQ0FBQztJQUNyQixDQUFDLENBQUM7QUFDSixDQUFDO0FBZEQsa0NBY0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzb3J0ZWRNYXAsIFNvcnRlZE11bHRpTWFwIH0gZnJvbSAnLi9zb3J0ZWQtbWFwJztcblxuZXhwb3J0IGludGVyZmFjZSBFbnRpdHkge1xuICByZWFkb25seSAkaWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgUGxhaW48RSBleHRlbmRzIEVudGl0eT4gPSBPbWl0PEUsICckaWQnPjtcblxudHlwZSBJbmRleGVzPEEgZXh0ZW5kcyBFbnRpdHk+ID0geyBbSyBpbiBQcm9wZXJ0eUtleV06IEVudGl0eUluZGV4PEEsIGFueT4gfTtcblxuZXhwb3J0IGludGVyZmFjZSBFbnRpdHlDb2xsZWN0aW9uPEEgZXh0ZW5kcyBFbnRpdHksIEkgZXh0ZW5kcyBJbmRleGVzPEVudGl0eT4gPSB7fT4ge1xuICByZWFkb25seSB0eXBlOiAnZW50aXRpZXMnO1xuICByZWFkb25seSBlbnRpdGllczogTWFwPHN0cmluZywgQT47XG4gIHJlYWRvbmx5IGluZGV4ZXM6IEk7XG5cbiAgYWRkKHg6IEEpOiB2b2lkO1xuICBkZWh5ZHJhdGUoKTogYW55O1xuICBoeWRyYXRlRnJvbSh4OiBhbnkpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBBZGQgaW5kZXhlcyB0byB0aGlzIGNvbGxlY3Rpb25cbiAgICpcbiAgICogQ3JlYXRpbmcgYW4gaW5kZXhlZCBjb2xsZWN0aW9uIGlzIGEgdHdvLXN0ZXAgb3BlcmF0aW9uIHNvIHRoYXQgd2UgY2FuIHNwZWNpZnkgdGhlXG4gICAqIEVudGl0eSB0eXBlLCBidXQgaW5mZXIgdGhlIGluZGV4IHR5cGVzIChUeXBlU2NyaXB0IGRvZXMgbm90IGFsbG93IGJvdGggc3BlY2lmeWluZyBBTkRcbiAgICogaW5mZXJyaW5nIGdlbmVyaWMgYXJndW1lbnRzIGluIGEgc2luZ2xlIGNhbGwpLlxuICAgKi9cbiAgaW5kZXg8SUkgZXh0ZW5kcyBJbmRleGVzPEE+PihpbmRleGVzOiBJSSk6IEVudGl0eUNvbGxlY3Rpb248QSwgSUk+O1xufVxuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgaW5kZXggb2JqZWN0c1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEVudGl0eUluZGV4PEEgZXh0ZW5kcyBFbnRpdHksIEluZGV4VHlwZT4ge1xuICAvKipcbiAgICogVGhlIGxvb2t1cHMgdGhhdCB0aGUgaW5kZXhlZCBmaWVsZCB0eXBlIGFmZm9yZHNcbiAgICpcbiAgICogRm9yIGV4YW1wbGUsICdlcXVhbHMnLCAnbGVzc1RoYW4nLCAncHJlZml4JywgZXRjLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9va3VwczogSW5kZXhMb29rdXBzPEluZGV4VHlwZT47XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBkYXRhIHN0b3JlXG4gICAqL1xuICByZWFkb25seSBpbmRleDogU29ydGVkTXVsdGlNYXA8SW5kZXhUeXBlLCBzdHJpbmc+O1xuXG4gIC8qKlxuICAgKiBBZGQgYW4gZW50aXR5IHRvIHRoZSBpbmRleFxuICAgKi9cbiAgYWRkKHg6IEEpOiB2b2lkO1xufVxuXG4vKipcbiAqIE1hcCBhIHR5cGUgdGhlIHR5cGVzIG9mIGxvb2t1cHMgd2UgY2FuIGRvIG9uIHRoYXQgdHlwZVxuICovXG5leHBvcnQgdHlwZSBJbmRleExvb2t1cHM8UD4gPSBbUF0gZXh0ZW5kcyBbc3RyaW5nXVxuICA/IFN0cmluZ0luZGV4TG9va3Vwc1xuICA6IFtQXSBleHRlbmRzIFtzdHJpbmcgfCB1bmRlZmluZWRdXG4gID8gT3B0aW9uYWxTdHJpbmdJbmRleExvb2t1cHNcbiAgOiB7fTtcblxuLyoqXG4gKiBBbGwgdGhlIGxvb2t1cHMgb24gJ3N0cmluZycgdHlwZXNcbiAqXG4gKiBXZSBjdXJyZW50bHkgb25seSBoYXZlICdlcXVhbHMnIGJ1dCB3ZSBjb3VsZCBoYXZlIG1vcmUgOilcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdHJpbmdJbmRleExvb2t1cHMge1xuICBlcXVhbHMoeDogc3RyaW5nKTogc3RyaW5nW107XG59XG5cbi8qKlxuICogQWxsIHRoZSBsb29rdXBzIG9uICdzdHJpbmcgfCB1bmRlZmluZWQnIHR5cGVzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uYWxTdHJpbmdJbmRleExvb2t1cHMge1xuICBlcXVhbHMoeDogc3RyaW5nIHwgdW5kZWZpbmVkKTogc3RyaW5nW107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnRpdHlDb2xsZWN0aW9uPEEgZXh0ZW5kcyBFbnRpdHk+KCk6IEVudGl0eUNvbGxlY3Rpb248QSwge30+IHtcbiAgY29uc3QgZW50aXRpZXMgPSBuZXcgTWFwPHN0cmluZywgQT4oKTtcbiAgY29uc3QgX2luZGV4ZXMgPSB7fTtcblxuICBmdW5jdGlvbiBhZGQoeDogQSkge1xuICAgIGVudGl0aWVzLnNldCh4LiRpZCwgeCk7XG4gICAgZm9yIChjb25zdCBpbmRleCBvZiBPYmplY3QudmFsdWVzKF9pbmRleGVzKSkge1xuICAgICAgLy8gRklYTUU6IHdoeSBjYW4ndCB3ZSB0eXBlIHRoaXM/XG4gICAgICAoaW5kZXggYXMgYW55KS5hZGQoeCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnZW50aXRpZXMnLFxuICAgIGVudGl0aWVzLFxuICAgIGluZGV4ZXM6IF9pbmRleGVzIGFzIGFueSxcbiAgICBhZGQsXG4gICAgZGVoeWRyYXRlOiAoKSA9PiAoe1xuICAgICAgdHlwZTogJ2VudGl0aWVzJyxcbiAgICAgIGVudGl0aWVzOiBBcnJheS5mcm9tKHZhbGlkYXRlUGxhaW5PYmplY3RzKGVudGl0aWVzKS52YWx1ZXMoKSksXG4gICAgfSksXG4gICAgaHlkcmF0ZUZyb206ICh4KSA9PiB7XG4gICAgICBlbnRpdGllcy5jbGVhcigpO1xuICAgICAgZm9yIChjb25zdCBlIG9mIE9iamVjdC52YWx1ZXMoeC5lbnRpdGllcykpIHtcbiAgICAgICAgYWRkKGUgYXMgYW55KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGluZGV4KGluZGV4ZXMpIHtcbiAgICAgIC8vIFRoaXMgbGltaXRhdGlvbiBleGlzdHMgcHVyZWx5IGJlY2F1c2UgSSBjb3VsZG4ndCB0eXBlIGl0IG90aGVyd2lzZS5cbiAgICAgIC8vIERlY2xhcmluZyBhIHJldHVybiB0eXBlIG9mIGBFbnRpdHlDb2xsZWN0aW9uPEEsIEkgfCBJST5gIHdvdWxkIG1ha2UgYSBsb3RcbiAgICAgIC8vIG9mIG91ciBvdGhlciB0eXBlIGluc3BlY3Rpb24gY29kZSBzdG9wIHdvcmtpbmcgKHRoZSB1bmlvbiBpcyBoYXJkIHRvIHBpY2tcbiAgICAgIC8vIGFwYXJ0KS4gU2luY2UgYWRkaW5nIGluZGV4ZXMgaW4gbXVsdGlwbGUgZ29lcyBpcyBub3QgcmVhbGx5IGEgdXNlIGNhc2UsXG4gICAgICAvLyB0aGUgc2ltcGxlciBzb2x1dGlvbiBpcyBqdXN0IHRvIHR5cGUgaXQgYXMgaWYgd2UgcmVwbGFjZWQgYWxsIGluZGV4ZXNcbiAgICAgIC8vIGFuZCBhZGQgYSBydW50aW1lIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGUgdHlwZXMgYXJlbid0IGx5aW5nLlxuICAgICAgaWYgKE9iamVjdC5rZXlzKF9pbmRleGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG1heSBvbmx5IGNhbGwgLmluZGV4KCkgb25jZSBvbiBhIG5ldyBjb2xsZWN0aW9uJyk7XG4gICAgICB9XG4gICAgICBPYmplY3QuYXNzaWduKF9pbmRleGVzLCBpbmRleGVzKTtcbiAgICAgIHJldHVybiB0aGlzIGFzIGFueTtcbiAgICB9LFxuICB9O1xufVxuXG4vKipcbiAqIEFuIGluZGV4IHRoYXQgdXNlcyB0aGUgdmFsdWUgb2YgYW4gZW50aXR5J3MgZmllbGRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpZWxkSW5kZXg8QSBleHRlbmRzIEVudGl0eSwgUCBleHRlbmRzIGtleW9mIEE+KFxuICBwcm9wTmFtZTogUCxcbiAgY29tcGFyYXRvcjogc29ydGVkTWFwLkNvbXBhcmF0b3I8QVtQXT4sXG4pOiBFbnRpdHlJbmRleDxBLCBBW1BdPiB7XG4gIHJldHVybiBjYWxjdWxhdGVkSW5kZXgoKHgpID0+IHhbcHJvcE5hbWVdLCBjb21wYXJhdG9yKTtcbn1cblxuLyoqXG4gKiBBbiBpbmRleCB0aGF0IGlzIGNhbGN1bGF0ZWQgYmFzZWQgb24gYSBmdW5jdGlvbiBhcHBsaWVkIHRvIGFuIGVudGl0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlZEluZGV4PEEgZXh0ZW5kcyBFbnRpdHksIEI+KGZuOiAoeDogQSkgPT4gQiwgY29tcGFyYXRvcjogc29ydGVkTWFwLkNvbXBhcmF0b3I8Qj4pIHtcbiAgY29uc3QgaW5kZXg6IFNvcnRlZE11bHRpTWFwPEIsIHN0cmluZz4gPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBhZGQ6ICh4OiBBKSA9PiBzb3J0ZWRNYXAuYWRkKGluZGV4LCBjb21wYXJhdG9yLCBmbih4KSwgeC4kaWQpLFxuICAgIGxvb2t1cHM6IHtcbiAgICAgIGVxdWFsczogKHZhbHVlOiBCKSA9PiBzb3J0ZWRNYXAuZmluZEFsbChpbmRleCwgY29tcGFyYXRvciwgdmFsdWUpLFxuICAgIH0gYXMgYW55LFxuICAgIGluZGV4LFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFbnRpdHlDb2xsZWN0aW9uKHg6IHVua25vd24pOiB4IGlzIEVudGl0eUNvbGxlY3Rpb248YW55PiB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgISF4ICYmICh4IGFzIGFueSkudHlwZSA9PT0gJ2VudGl0aWVzJztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQbGFpbk9iamVjdHM8QSBleHRlbmRzIG9iamVjdD4oeHM6IE1hcDxzdHJpbmcsIEE+KTogTWFwPHN0cmluZywgQT4ge1xuICBmb3IgKGNvbnN0IHggb2YgeHMudmFsdWVzKCkpIHtcbiAgICBpZiAoeC5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVudGl0aWVzIHNob3VsZCBiZSBwbGFpbi10ZXh0IG9iamVjdHMsIGdvdCBpbnN0YW5jZSBvZiAke3guY29uc3RydWN0b3J9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB4cztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWZlcmVuY2U8RSBleHRlbmRzIEVudGl0eT4ge1xuICByZWFkb25seSAkcmVmOiBFWyckaWQnXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZjxFIGV4dGVuZHMgRW50aXR5Pih4OiBFIHwgc3RyaW5nKTogUmVmZXJlbmNlPEU+IHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnc3RyaW5nJyA/IHsgJHJlZjogeCB9IDogeyAkcmVmOiB4LiRpZCB9O1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0d28gc3RyaW5ncyBhcmUgZXF1aXZhbGVudCBpbiB0aGUgY3VycmVudCBvciBzcGVjaWZpZWQgbG9jYWxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nQ21wKGE6IHN0cmluZywgYjogc3RyaW5nKTogbnVtYmVyIHtcbiAgcmV0dXJuIGEubG9jYWxlQ29tcGFyZShiKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdHdvIG51bWJlcnMgYXJlIGVxdWl2YWxlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJDbXAoYTogbnVtYmVyLCBiOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gYSAtIGI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbXBhcmF0b3IgdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnQgb2YgdHdvIHZhbHVlcywgdXNpbmcgYSBnaXZlbiBjb21wYXJhdG9yLCBidXQgYWxsb3dzIHZhbHVlcyB0byBiZSBvcHRpb25hbC5cbiAqXG4gKiBAcGFyYW0gZnJvbnRPcmRlciBJZiBgdHJ1ZWAsIHJldHVybnMgc28gdGhhdCB1bmRlZmluZWQgdmFsdWVzIGFyZSBvcmRlcmVkIGF0IHRoZSBmcm9udC4gSWYgYGZhbHNlYCwgdW5kZWZpbmVkIHZhbHVlcyBhcmUgb3JkZXJlZCBhdCB0aGUgYmFjay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9wdGlvbmFsQ21wPEE+KGNtcDogKGE6IEEsIGI6IEEpID0+IG51bWJlciwgZnJvbnRPcmRlciA9IHRydWUpIHtcbiAgcmV0dXJuIChhOiBBIHwgdW5kZWZpbmVkLCBiOiBBIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgaWYgKGEgPT0gdW5kZWZpbmVkICYmIGIgIT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJvbnRPcmRlciA/IC0xIDogMTtcbiAgICB9XG4gICAgaWYgKGEgIT0gdW5kZWZpbmVkICYmIGIgPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJvbnRPcmRlciA/IDEgOiAtMTtcbiAgICB9XG4gICAgaWYgKGEgPT0gdW5kZWZpbmVkICYmIGIgPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gY21wKGEhLCBiISk7XG4gIH07XG59XG4iXX0=