"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilteredNotice = exports.NoticesFilter = void 0;
const semver = require("semver");
const tree_1 = require("../tree");
/**
 * Normalizes the given components structure into DNF form
 */
function normalizeComponents(xs) {
    return xs.map(x => Array.isArray(x) ? x : [x]);
}
function renderConjunction(xs) {
    return xs.map(c => `${c.name}: ${c.version}`).join(' AND ');
}
class NoticesFilter {
    ioHelper;
    constructor(ioHelper) {
        this.ioHelper = ioHelper;
    }
    async filter(options) {
        const components = [
            ...(await this.constructTreeComponents(options.outDir)),
            ...(await this.otherComponents(options)),
        ];
        return this.findForNamedComponents(options.data, components);
    }
    /**
     * From a set of input options, return the notices components we are searching for
     */
    async otherComponents(options) {
        // Bootstrap environments
        let bootstrappedEnvironments = [];
        for (const env of options.bootstrappedEnvironments) {
            const semverBootstrapVersion = semver.coerce(env.bootstrapStackVersion);
            if (!semverBootstrapVersion) {
                // we don't throw because notices should never crash the cli.
                await this.ioHelper.defaults.warning(`While filtering notices, could not coerce bootstrap version '${env.bootstrapStackVersion}' into semver`);
                continue;
            }
            bootstrappedEnvironments.push({
                name: 'bootstrap',
                version: `${semverBootstrapVersion}`,
                dynamicName: 'ENVIRONMENTS',
                dynamicValue: env.environment.name,
            });
        }
        return [
            // CLI
            {
                name: 'cli',
                version: options.cliVersion,
            },
            // Node version
            {
                name: 'node',
                version: process.version.replace(/^v/, ''), // remove the 'v' prefix.
                dynamicName: 'node',
            },
            // Bootstrap environments
            ...bootstrappedEnvironments,
        ];
    }
    /**
     * Based on a set of component names, find all notices that match one of the given components
     */
    findForNamedComponents(data, actualComponents) {
        return data.flatMap(notice => {
            const ors = this.resolveAliases(normalizeComponents(notice.components));
            // Find the first set of the disjunctions of which all components match against the actual components.
            // Return the actual components we found so that we can inject their dynamic values. A single filter
            // component can match more than one actual component
            for (const ands of ors) {
                const matched = ands.map(affected => actualComponents.filter(actual => this.componentNameMatches(affected, actual) && semver.satisfies(actual.version, affected.version, { includePrerelease: true })));
                // For every clause in the filter we matched one or more components
                if (matched.every(xs => xs.length > 0)) {
                    const ret = new FilteredNotice(notice);
                    this.addDynamicValues(matched.flatMap(x => x), ret);
                    return [ret];
                }
            }
            return [];
        });
    }
    /**
     * Whether the given "affected component" name applies to the given actual component name.
     *
     * The name matches if the name is exactly the same, or the name in the notice
     * is a prefix of the node name when the query ends in '.'.
     */
    componentNameMatches(pattern, actual) {
        return pattern.name.endsWith('.') ? actual.name.startsWith(pattern.name) : pattern.name === actual.name;
    }
    /**
     * Adds dynamic values from the given ActualComponents
     *
     * If there are multiple components with the same dynamic name, they are joined
     * by a comma.
     */
    addDynamicValues(comps, notice) {
        const dynamicValues = {};
        for (const comp of comps) {
            if (comp.dynamicName) {
                dynamicValues[comp.dynamicName] = dynamicValues[comp.dynamicName] ?? [];
                dynamicValues[comp.dynamicName].push(comp.dynamicValue ?? comp.version);
            }
        }
        for (const [key, values] of Object.entries(dynamicValues)) {
            notice.addDynamicValue(key, values.join(','));
        }
    }
    /**
     * Treat 'framework' as an alias for either `aws-cdk-lib.` or `@aws-cdk/core.`.
     *
     * Because it's EITHER `aws-cdk-lib` or `@aws-cdk/core`, we need to add multiple
     * arrays at the top level.
     */
    resolveAliases(ors) {
        return ors.flatMap(ands => {
            const hasFramework = ands.find(c => c.name === 'framework');
            if (!hasFramework) {
                return [ands];
            }
            return [
                ands.map(c => c.name === 'framework' ? { ...c, name: '@aws-cdk/core.' } : c),
                ands.map(c => c.name === 'framework' ? { ...c, name: 'aws-cdk-lib.' } : c),
            ];
        });
    }
    /**
     * Load the construct tree from the given directory and return its components
     */
    async constructTreeComponents(manifestDir) {
        const tree = await (0, tree_1.loadTreeFromDir)(manifestDir, (msg) => this.ioHelper.defaults.trace(msg));
        if (!tree) {
            return [];
        }
        const ret = [];
        recurse(tree);
        return ret;
        function recurse(x) {
            if (x.constructInfo?.fqn && x.constructInfo?.version) {
                ret.push({
                    name: x.constructInfo?.fqn,
                    version: x.constructInfo?.version,
                });
            }
            for (const child of Object.values(x.children ?? {})) {
                recurse(child);
            }
        }
    }
}
exports.NoticesFilter = NoticesFilter;
/**
 * Notice after passing the filter. A filter can augment a notice with
 * dynamic values as it has access to the dynamic matching data.
 */
class FilteredNotice {
    notice;
    dynamicValues = {};
    constructor(notice) {
        this.notice = notice;
    }
    addDynamicValue(key, value) {
        this.dynamicValues[`{resolve:${key}}`] = value;
    }
    format() {
        const componentsValue = normalizeComponents(this.notice.components).map(renderConjunction).join(', ');
        return this.resolveDynamicValues([
            `${this.notice.issueNumber}\t${this.notice.title}`,
            this.formatOverview(),
            `\tAffected versions: ${componentsValue}`,
            `\tMore information at: https://github.com/aws/aws-cdk/issues/${this.notice.issueNumber}`,
        ].join('\n\n') + '\n');
    }
    formatOverview() {
        const wrap = (s) => s.replace(/(?![^\n]{1,60}$)([^\n]{1,60})\s/g, '$1\n');
        const heading = 'Overview: ';
        const separator = `\n\t${' '.repeat(heading.length)}`;
        const content = wrap(this.notice.overview)
            .split('\n')
            .join(separator);
        return '\t' + heading + content;
    }
    resolveDynamicValues(input) {
        const pattern = new RegExp(Object.keys(this.dynamicValues).join('|'), 'g');
        return input.replace(pattern, (matched) => this.dynamicValues[matched] ?? matched);
    }
}
exports.FilteredNotice = FilteredNotice;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsdGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZmlsdGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLGlDQUFpQztBQUdqQyxrQ0FBMEM7QUFHMUM7O0dBRUc7QUFDSCxTQUFTLG1CQUFtQixDQUFDLEVBQWtDO0lBQzdELE9BQU8sRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2pELENBQUM7QUFFRCxTQUFTLGlCQUFpQixDQUFDLEVBQWU7SUFDeEMsT0FBTyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUM5RCxDQUFDO0FBNENELE1BQWEsYUFBYTtJQUNQLFFBQVEsQ0FBVztJQUVwQyxZQUFZLFFBQWtCO1FBQzVCLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0lBQzNCLENBQUM7SUFFTSxLQUFLLENBQUMsTUFBTSxDQUFDLE9BQW1DO1FBQ3JELE1BQU0sVUFBVSxHQUFHO1lBQ2pCLEdBQUcsQ0FBQyxNQUFNLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDdkQsR0FBRyxDQUFDLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUN6QyxDQUFDO1FBRUYsT0FBTyxJQUFJLENBQUMsc0JBQXNCLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQztJQUMvRCxDQUFDO0lBRUQ7O09BRUc7SUFDSyxLQUFLLENBQUMsZUFBZSxDQUFDLE9BQW1DO1FBQy9ELHlCQUF5QjtR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QUcsT0FBTyxHQUFHLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO1FBQ3RELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQzthQUN2QyxLQUFLLENBQUMsSUFBSSxDQUFDO2FBQ1gsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRW5CLE9BQU8sSUFBSSxHQUFHLE9BQU8sR0FBRyxPQUFPLENBQUM7SUFDbEMsQ0FBQztJQUVPLG9CQUFvQixDQUFDLEtBQWE7UUFDeEMsTUFBTSxPQUFPLEdBQUcsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQzNFLE9BQU8sS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLElBQUksT0FBTyxDQUFDLENBQUM7SUFDckYsQ0FBQztDQUNGO0FBcENELHdDQW9DQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHNlbXZlciBmcm9tICdzZW12ZXInO1xuaW1wb3J0IHR5cGUgeyBJb0hlbHBlciB9IGZyb20gJy4uL2lvL3ByaXZhdGUnO1xuaW1wb3J0IHR5cGUgeyBDb25zdHJ1Y3RUcmVlTm9kZSB9IGZyb20gJy4uL3RyZWUnO1xuaW1wb3J0IHsgbG9hZFRyZWVGcm9tRGlyIH0gZnJvbSAnLi4vdHJlZSc7XG5pbXBvcnQgdHlwZSB7IEJvb3RzdHJhcHBlZEVudmlyb25tZW50LCBDb21wb25lbnQsIE5vdGljZSB9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIE5vcm1hbGl6ZXMgdGhlIGdpdmVuIGNvbXBvbmVudHMgc3RydWN0dXJlIGludG8gRE5GIGZvcm1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50cyh4czogQXJyYXk8Q29tcG9uZW50IHwgQ29tcG9uZW50W10+KTogQ29tcG9uZW50W11bXSB7XG4gIHJldHVybiB4cy5tYXAoeCA9PiBBcnJheS5pc0FycmF5KHgpID8geCA6IFt4XSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNvbmp1bmN0aW9uKHhzOiBDb21wb25lbnRbXSk6IHN0cmluZyB7XG4gIHJldHVybiB4cy5tYXAoYyA9PiBgJHtjLm5hbWV9OiAke2MudmVyc2lvbn1gKS5qb2luKCcgQU5EICcpO1xufVxuXG5pbnRlcmZhY2UgQWN0dWFsQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBWZXJzaW9uIG9mIHRoZSBjb21wb25lbnRcbiAgICovXG4gIHJlYWRvbmx5IHZlcnNpb246IHN0cmluZztcblxuICAvKipcbiAgICogSWYgbWF0Y2hlZCwgdW5kZXIgd2hhdCBuYW1lIHNob3VsZCBpdCBiZSBhZGRlZCB0byB0aGUgc2V0IG9mIGR5bmFtaWMgdmFsdWVzXG4gICAqXG4gICAqIFRoZXNlIHdpbGwgYmUgdXNlZCB0byBzdWJzdGl0dXRlIHBsYWNlaG9sZGVycyBpbiB0aGUgbWVzc2FnZSBzdHJpbmcsIHdoZXJlXG4gICAqIHBsYWNlaG9sZGVycyBsb29rIGxpa2UgYHtyZXNvbHZlOlhZWn1gLlxuICAgKlxuICAgKiBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIGNvbXBvbmVudCB3aXRoIHRoZSBzYW1lIGR5bmFtaWMgbmFtZSwgdGhleSBhcmVcbiAgICogam9pbmVkIGJ5ICcsJy5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBEb24ndCBhZGQgdG8gdGhlIHNldCBvZiBkeW5hbWljIHZhbHVlc1xuICAgKi9cbiAgcmVhZG9ubHkgZHluYW1pY05hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIElmIG1hdGNoZWQsIHdoYXQgd2Ugc2hvdWxkIHB1dCBpbiB0aGUgc2V0IG9mIGR5bmFtaWMgdmFsdWVzIGluc3N0ZWFkIG9mIHRoZSB2ZXJzaW9uLlxuICAgKlxuICAgKiBPbmx5IHVzZWQgaWYgYGR5bmFtaWNOYW1lYCBpcyBzZXQ7IGJ5IGRlZmF1bHQgd2Ugd2lsbCBhZGQgdGhlIGFjdHVhbCB2ZXJzaW9uXG4gICAqIG9mIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gVGhlIHZlcnNpb25cbiAgICovXG4gIHJlYWRvbmx5IGR5bmFtaWNWYWx1ZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb3RpY2VzRmlsdGVyRmlsdGVyT3B0aW9ucyB7XG4gIHJlYWRvbmx5IGRhdGE6IE5vdGljZVtdO1xuICByZWFkb25seSBjbGlWZXJzaW9uOiBzdHJpbmc7XG4gIHJlYWRvbmx5IG91dERpcjogc3RyaW5nO1xuICByZWFkb25seSBib290c3RyYXBwZWRFbnZpcm9ubWVudHM6IEJvb3RzdHJhcHBlZEVudmlyb25tZW50W107XG59XG5cbmV4cG9ydCBjbGFzcyBOb3RpY2VzRmlsdGVyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBpb0hlbHBlcjogSW9IZWxwZXI7XG5cbiAgY29uc3RydWN0b3IoaW9IZWxwZXI6IElvSGVscGVyKSB7XG4gICAgdGhpcy5pb0hlbHBlciA9IGlvSGVscGVyO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGZpbHRlcihvcHRpb25zOiBOb3RpY2VzRmlsdGVyRmlsdGVyT3B0aW9ucyk6IFByb21pc2U8RmlsdGVyZWROb3RpY2VbXT4ge1xuICAgIGNvbnN0IGNvbXBvbmVudHMgPSBbXG4gICAgICAuLi4oYXdhaXQgdGhpcy5jb25zdHJ1Y3RUcmVlQ29tcG9uZW50cyhvcHRpb25zLm91dERpcikpLFxuICAgICAgLi4uKGF3YWl0IHRoaXMub3RoZXJDb21wb25lbnRzKG9wdGlvbnMpKSxcbiAgICBdO1xuXG4gICAgcmV0dXJuIHRoaXMuZmluZEZvck5hbWVkQ29tcG9uZW50cyhvcHRpb25zLmRhdGEsIGNvbXBvbmVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZyb20gYSBzZXQgb2YgaW5wdXQgb3B0aW9ucywgcmV0dXJuIHRoZSBub3RpY2VzIGNvbXBvbmVudHMgd2UgYXJlIHNlYXJjaGluZyBmb3JcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgb3RoZXJDb21wb25lbnRzKG9wdGlvbnM6IE5vdGljZXNGaWx0ZXJGaWx0ZXJPcHRpb25zKTogUHJvbWlzZTxBY3R1YWxDb21wb25lbnRbXT4ge1xuICAgIC8vIEJvb3RzdHJhcCBlbnZpcm9ubWVudHNcbiAgICBsZXQgYm9vdHN0cmFwcGVkRW52aXJvbm1lbnRzID0gW107XG4gICAgZm9yIChjb25zdCBlbnYgb2Ygb3B0aW9ucy5ib290c3RyYXBwZWRFbnZpcm9ubWVudHMpIHtcbiAgICAgIGNvbnN0IHNlbXZlckJvb3RzdHJhcFZlcnNpb24gPSBzZW12ZXIuY29lcmNlKGVudi5ib290c3RyYXBTdGFja1ZlcnNpb24pO1xuICAgICAgaWYgKCFzZW12ZXJCb290c3RyYXBWZXJzaW9uKSB7XG4gICAgICAgIC8vIHdlIGRvbid0IHRocm93IGJlY2F1c2Ugbm90aWNlcyBzaG91bGQgbmV2ZXIgY3Jhc2ggdGhlIGNsaS5cbiAgICAgICAgYXdhaXQgdGhpcy5pb0hlbHBlci5kZWZhdWx0cy53YXJuaW5nKGBXaGlsZSBmaWx0ZXJpbmcgbm90aWNlcywgY291bGQgbm90IGNvZXJjZSBib290c3RyYXAgdmVyc2lvbiAnJHtlbnYuYm9vdHN0cmFwU3RhY2tWZXJzaW9ufScgaW50byBzZW12ZXJgKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGJvb3RzdHJhcHBlZEVudmlyb25tZW50cy5wdXNoKHtcbiAgICAgICAgbmFtZTogJ2Jvb3RzdHJhcCcsXG4gICAgICAgIHZlcnNpb246IGAke3NlbXZlckJvb3RzdHJhcFZlcnNpb259YCxcbiAgICAgICAgZHluYW1pY05hbWU6ICdFTlZJUk9OTUVOVFMnLFxuICAgICAgICBkeW5hbWljVmFsdWU6IGVudi5lbnZpcm9ubWVudC5uYW1lLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgIC8vIENMSVxuICAgICAge1xuICAgICAgICBuYW1lOiAnY2xpJyxcbiAgICAgICAgdmVyc2lvbjogb3B0aW9ucy5jbGlWZXJzaW9uLFxuICAgICAgfSxcblxuICAgICAgLy8gTm9kZSB2ZXJzaW9uXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdub2RlJyxcbiAgICAgICAgdmVyc2lvbjogcHJvY2Vzcy52ZXJzaW9uLnJlcGxhY2UoL152LywgJycpLCAvLyByZW1vdmUgdGhlICd2JyBwcmVmaXguXG4gICAgICAgIGR5bmFtaWNOYW1lOiAnbm9kZScsXG4gICAgICB9LFxuXG4gICAgICAvLyBCb290c3RyYXAgZW52aXJvbm1lbnRzXG4gICAgICAuLi5ib290c3RyYXBwZWRFbnZpcm9ubWVudHMsXG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYXNlZCBvbiBhIHNldCBvZiBjb21wb25lbnQgbmFtZXMsIGZpbmQgYWxsIG5vdGljZXMgdGhhdCBtYXRjaCBvbmUgb2YgdGhlIGdpdmVuIGNvbXBvbmVudHNcbiAgICovXG4gIHByaXZhdGUgZmluZEZvck5hbWVkQ29tcG9uZW50cyhkYXRhOiBOb3RpY2VbXSwgYWN0dWFsQ29tcG9uZW50czogQWN0dWFsQ29tcG9uZW50W10pOiBGaWx0ZXJlZE5vdGljZVtdIHtcbiAgICByZXR1cm4gZGF0YS5mbGF0TWFwKG5vdGljZSA9PiB7XG4gICAgICBjb25zdCBvcnMgPSB0aGlzLnJlc29sdmVBbGlhc2VzKG5vcm1hbGl6ZUNvbXBvbmVudHMobm90aWNlLmNvbXBvbmVudHMpKTtcblxuICAgICAgLy8gRmluZCB0aGUgZmlyc3Qgc2V0IG9mIHRoZSBkaXNqdW5jdGlvbnMgb2Ygd2hpY2ggYWxsIGNvbXBvbmVudHMgbWF0Y2ggYWdhaW5zdCB0aGUgYWN0dWFsIGNvbXBvbmVudHMuXG4gICAgICAvLyBSZXR1cm4gdGhlIGFjdHVhbCBjb21wb25lbnRzIHdlIGZvdW5kIHNvIHRoYXQgd2UgY2FuIGluamVjdCB0aGVpciBkeW5hbWljIHZhbHVlcy4gQSBzaW5nbGUgZmlsdGVyXG4gICAgICAvLyBjb21wb25lbnQgY2FuIG1hdGNoIG1vcmUgdGhhbiBvbmUgYWN0dWFsIGNvbXBvbmVudFxuICAgICAgZm9yIChjb25zdCBhbmRzIG9mIG9ycykge1xuICAgICAgICBjb25zdCBtYXRjaGVkID0gYW5kcy5tYXAoYWZmZWN0ZWQgPT4gYWN0dWFsQ29tcG9uZW50cy5maWx0ZXIoYWN0dWFsID0+XG4gICAgICAgICAgdGhpcy5jb21wb25lbnROYW1lTWF0Y2hlcyhhZmZlY3RlZCwgYWN0dWFsKSAmJiBzZW12ZXIuc2F0aXNmaWVzKGFjdHVhbC52ZXJzaW9uLCBhZmZlY3RlZC52ZXJzaW9uLCB7IGluY2x1ZGVQcmVyZWxlYXNlOiB0cnVlIH0pKSk7XG5cbiAgICAgICAgLy8gRm9yIGV2ZXJ5IGNsYXVzZSBpbiB0aGUgZmlsdGVyIHdlIG1hdGNoZWQgb25lIG9yIG1vcmUgY29tcG9uZW50c1xuICAgICAgICBpZiAobWF0Y2hlZC5ldmVyeSh4cyA9PiB4cy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgIGNvbnN0IHJldCA9IG5ldyBGaWx0ZXJlZE5vdGljZShub3RpY2UpO1xuICAgICAgICAgIHRoaXMuYWRkRHluYW1pY1ZhbHVlcyhtYXRjaGVkLmZsYXRNYXAoeCA9PiB4KSwgcmV0KTtcbiAgICAgICAgICByZXR1cm4gW3JldF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGdpdmVuIFwiYWZmZWN0ZWQgY29tcG9uZW50XCIgbmFtZSBhcHBsaWVzIHRvIHRoZSBnaXZlbiBhY3R1YWwgY29tcG9uZW50IG5hbWUuXG4gICAqXG4gICAqIFRoZSBuYW1lIG1hdGNoZXMgaWYgdGhlIG5hbWUgaXMgZXhhY3RseSB0aGUgc2FtZSwgb3IgdGhlIG5hbWUgaW4gdGhlIG5vdGljZVxuICAgKiBpcyBhIHByZWZpeCBvZiB0aGUgbm9kZSBuYW1lIHdoZW4gdGhlIHF1ZXJ5IGVuZHMgaW4gJy4nLlxuICAgKi9cbiAgcHJpdmF0ZSBjb21wb25lbnROYW1lTWF0Y2hlcyhwYXR0ZXJuOiBDb21wb25lbnQsIGFjdHVhbDogQWN0dWFsQ29tcG9uZW50KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHBhdHRlcm4ubmFtZS5lbmRzV2l0aCgnLicpID8gYWN0dWFsLm5hbWUuc3RhcnRzV2l0aChwYXR0ZXJuLm5hbWUpIDogcGF0dGVybi5uYW1lID09PSBhY3R1YWwubmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGR5bmFtaWMgdmFsdWVzIGZyb20gdGhlIGdpdmVuIEFjdHVhbENvbXBvbmVudHNcbiAgICpcbiAgICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNvbXBvbmVudHMgd2l0aCB0aGUgc2FtZSBkeW5hbWljIG5hbWUsIHRoZXkgYXJlIGpvaW5lZFxuICAgKiBieSBhIGNvbW1hLlxuICAgKi9cbiAgcHJpdmF0ZSBhZGREeW5hbWljVmFsdWVzKGNvbXBzOiBBY3R1YWxDb21wb25lbnRbXSwgbm90aWNlOiBGaWx0ZXJlZE5vdGljZSkge1xuICAgIGNvbnN0IGR5bmFtaWNWYWx1ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiA9IHt9O1xuICAgIGZvciAoY29uc3QgY29tcCBvZiBjb21wcykge1xuICAgICAgaWYgKGNvbXAuZHluYW1pY05hbWUpIHtcbiAgICAgICAgZHluYW1pY1ZhbHVlc1tjb21wLmR5bmFtaWNOYW1lXSA9IGR5bmFtaWNWYWx1ZXNbY29tcC5keW5hbWljTmFtZV0gPz8gW107XG4gICAgICAgIGR5bmFtaWNWYWx1ZXNbY29tcC5keW5hbWljTmFtZV0ucHVzaChjb21wLmR5bmFtaWNWYWx1ZSA/PyBjb21wLnZlcnNpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2YgT2JqZWN0LmVudHJpZXMoZHluYW1pY1ZhbHVlcykpIHtcbiAgICAgIG5vdGljZS5hZGREeW5hbWljVmFsdWUoa2V5LCB2YWx1ZXMuam9pbignLCcpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJlYXQgJ2ZyYW1ld29yaycgYXMgYW4gYWxpYXMgZm9yIGVpdGhlciBgYXdzLWNkay1saWIuYCBvciBgQGF3cy1jZGsvY29yZS5gLlxuICAgKlxuICAgKiBCZWNhdXNlIGl0J3MgRUlUSEVSIGBhd3MtY2RrLWxpYmAgb3IgYEBhd3MtY2RrL2NvcmVgLCB3ZSBuZWVkIHRvIGFkZCBtdWx0aXBsZVxuICAgKiBhcnJheXMgYXQgdGhlIHRvcCBsZXZlbC5cbiAgICovXG4gIHByaXZhdGUgcmVzb2x2ZUFsaWFzZXMob3JzOiBDb21wb25lbnRbXVtdKTogQ29tcG9uZW50W11bXSB7XG4gICAgcmV0dXJuIG9ycy5mbGF0TWFwKGFuZHMgPT4ge1xuICAgICAgY29uc3QgaGFzRnJhbWV3b3JrID0gYW5kcy5maW5kKGMgPT4gYy5uYW1lID09PSAnZnJhbWV3b3JrJyk7XG4gICAgICBpZiAoIWhhc0ZyYW1ld29yaykge1xuICAgICAgICByZXR1cm4gW2FuZHNdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBhbmRzLm1hcChjID0+IGMubmFtZSA9PT0gJ2ZyYW1ld29yaycgPyB7IC4uLmMsIG5hbWU6ICdAYXdzLWNkay9jb3JlLicgfSA6IGMpLFxuICAgICAgICBhbmRzLm1hcChjID0+IGMubmFtZSA9PT0gJ2ZyYW1ld29yaycgPyB7IC4uLmMsIG5hbWU6ICdhd3MtY2RrLWxpYi4nIH0gOiBjKSxcbiAgICAgIF07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCB0aGUgY29uc3RydWN0IHRyZWUgZnJvbSB0aGUgZ2l2ZW4gZGlyZWN0b3J5IGFuZCByZXR1cm4gaXRzIGNvbXBvbmVudHNcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY29uc3RydWN0VHJlZUNvbXBvbmVudHMobWFuaWZlc3REaXI6IHN0cmluZyk6IFByb21pc2U8QWN0dWFsQ29tcG9uZW50W10+IHtcbiAgICBjb25zdCB0cmVlID0gYXdhaXQgbG9hZFRyZWVGcm9tRGlyKG1hbmlmZXN0RGlyLCAobXNnOiBzdHJpbmcpID0+IHRoaXMuaW9IZWxwZXIuZGVmYXVsdHMudHJhY2UobXNnKSk7XG4gICAgaWYgKCF0cmVlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgcmV0OiBBY3R1YWxDb21wb25lbnRbXSA9IFtdO1xuICAgIHJlY3Vyc2UodHJlZSk7XG4gICAgcmV0dXJuIHJldDtcblxuICAgIGZ1bmN0aW9uIHJlY3Vyc2UoeDogQ29uc3RydWN0VHJlZU5vZGUpIHtcbiAgICAgIGlmICh4LmNvbnN0cnVjdEluZm8/LmZxbiAmJiB4LmNvbnN0cnVjdEluZm8/LnZlcnNpb24pIHtcbiAgICAgICAgcmV0LnB1c2goe1xuICAgICAgICAgIG5hbWU6IHguY29uc3RydWN0SW5mbz8uZnFuLFxuICAgICAgICAgIHZlcnNpb246IHguY29uc3RydWN0SW5mbz8udmVyc2lvbixcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgT2JqZWN0LnZhbHVlcyh4LmNoaWxkcmVuID8/IHt9KSkge1xuICAgICAgICByZWN1cnNlKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBOb3RpY2UgYWZ0ZXIgcGFzc2luZyB0aGUgZmlsdGVyLiBBIGZpbHRlciBjYW4gYXVnbWVudCBhIG5vdGljZSB3aXRoXG4gKiBkeW5hbWljIHZhbHVlcyBhcyBpdCBoYXMgYWNjZXNzIHRvIHRoZSBkeW5hbWljIG1hdGNoaW5nIGRhdGEuXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWx0ZXJlZE5vdGljZSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgZHluYW1pY1ZhbHVlczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgbm90aWNlOiBOb3RpY2UpIHtcbiAgfVxuXG4gIHB1YmxpYyBhZGREeW5hbWljVmFsdWUoa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLmR5bmFtaWNWYWx1ZXNbYHtyZXNvbHZlOiR7a2V5fX1gXSA9IHZhbHVlO1xuICB9XG5cbiAgcHVibGljIGZvcm1hdCgpOiBzdHJpbmcge1xuICAgIGNvbnN0IGNvbXBvbmVudHNWYWx1ZSA9IG5vcm1hbGl6ZUNvbXBvbmVudHModGhpcy5ub3RpY2UuY29tcG9uZW50cykubWFwKHJlbmRlckNvbmp1bmN0aW9uKS5qb2luKCcsICcpO1xuICAgIHJldHVybiB0aGlzLnJlc29sdmVEeW5hbWljVmFsdWVzKFtcbiAgICAgIGAke3RoaXMubm90aWNlLmlzc3VlTnVtYmVyfVxcdCR7dGhpcy5ub3RpY2UudGl0bGV9YCxcbiAgICAgIHRoaXMuZm9ybWF0T3ZlcnZpZXcoKSxcbiAgICAgIGBcXHRBZmZlY3RlZCB2ZXJzaW9uczogJHtjb21wb25lbnRzVmFsdWV9YCxcbiAgICAgIGBcXHRNb3JlIGluZm9ybWF0aW9uIGF0OiBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1jZGsvaXNzdWVzLyR7dGhpcy5ub3RpY2UuaXNzdWVOdW1iZXJ9YCxcbiAgICBdLmpvaW4oJ1xcblxcbicpICsgJ1xcbicpO1xuICB9XG5cbiAgcHJpdmF0ZSBmb3JtYXRPdmVydmlldygpIHtcbiAgICBjb25zdCB3cmFwID0gKHM6IHN0cmluZykgPT4gcy5yZXBsYWNlKC8oPyFbXlxcbl17MSw2MH0kKShbXlxcbl17MSw2MH0pXFxzL2csICckMVxcbicpO1xuXG4gICAgY29uc3QgaGVhZGluZyA9ICdPdmVydmlldzogJztcbiAgICBjb25zdCBzZXBhcmF0b3IgPSBgXFxuXFx0JHsnICcucmVwZWF0KGhlYWRpbmcubGVuZ3RoKX1gO1xuICAgIGNvbnN0IGNvbnRlbnQgPSB3cmFwKHRoaXMubm90aWNlLm92ZXJ2aWV3KVxuICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgLmpvaW4oc2VwYXJhdG9yKTtcblxuICAgIHJldHVybiAnXFx0JyArIGhlYWRpbmcgKyBjb250ZW50O1xuICB9XG5cbiAgcHJpdmF0ZSByZXNvbHZlRHluYW1pY1ZhbHVlcyhpbnB1dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBwYXR0ZXJuID0gbmV3IFJlZ0V4cChPYmplY3Qua2V5cyh0aGlzLmR5bmFtaWNWYWx1ZXMpLmpvaW4oJ3wnKSwgJ2cnKTtcbiAgICByZXR1cm4gaW5wdXQucmVwbGFjZShwYXR0ZXJuLCAobWF0Y2hlZCkgPT4gdGhpcy5keW5hbWljVmFsdWVzW21hdGNoZWRdID8/IG1hdGNoZWQpO1xuICB9XG59XG4iXX0=