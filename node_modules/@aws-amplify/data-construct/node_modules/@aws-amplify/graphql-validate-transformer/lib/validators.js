"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validate = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const graphql_directives_1 = require("@aws-amplify/graphql-directives");
const types_1 = require("./types");
const validate = (parentNode, fieldNode, directive, config) => {
    validateModelType(parentNode);
    validateNoListFieldValidation(fieldNode);
    validateOrderingWithDefaultDirective(fieldNode, directive);
    validateNoDuplicateTypes(fieldNode, directive, config.validationType);
    validateTypeCompatibility(fieldNode, config.validationType);
    if (isLengthValidation(config.validationType)) {
        validateLengthValue(config);
    }
    if (isNumericValidation(config.validationType)) {
        validateNumericValue(config);
    }
};
exports.validate = validate;
const validateModelType = (parentNode) => {
    if (!parentNode.directives.find((d) => d.name.value === 'model')) {
        throw new graphql_transformer_core_1.InvalidDirectiveError('@validate directive can only be used on fields within @model types.');
    }
};
const validateNoListFieldValidation = (fieldNode) => {
    if ((0, graphql_transformer_common_1.isListType)(fieldNode.type)) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@validate directive cannot be used on list field '${fieldNode.name.value}'`);
    }
};
const validateOrderingWithDefaultDirective = (fieldNode, currentDirective) => {
    const directives = fieldNode.directives;
    const validateDirectiveIndex = directives.indexOf(currentDirective);
    const defaultDirectiveIndex = directives.findIndex((d) => d.name.value === graphql_directives_1.DefaultDirective.name);
    if (defaultDirectiveIndex !== -1 && validateDirectiveIndex < defaultDirectiveIndex) {
        throw new graphql_transformer_core_1.InvalidDirectiveError('@validate directive must be specified after @default directive');
    }
};
const validateNoDuplicateTypes = (fieldNode, currentDirective, currentType) => {
    for (const peerDirective of fieldNode.directives) {
        if (peerDirective === currentDirective) {
            continue;
        }
        if (peerDirective.name.value === 'validate') {
            const peerType = peerDirective.arguments.find((arg) => arg.name.value === 'type').value.value;
            if (peerType === currentType) {
                throw new graphql_transformer_core_1.InvalidDirectiveError(`Duplicate @validate directive with type '${currentType}' on field '${fieldNode.name.value}'. Each validation type can only be used once per field.`);
            }
        }
    }
};
const validateTypeCompatibility = (fieldNode, validationType) => {
    const baseType = (0, graphql_transformer_common_1.getBaseType)(fieldNode.type);
    if (isNumericValidation(validationType) && baseType !== 'Int' && baseType !== 'Float') {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`Validation type '${validationType}' can only be used with numeric fields (Int, Float). Field '${fieldNode.name.value}' is of type '${baseType}'`);
    }
    if (isStringValidation(validationType) && baseType !== 'String') {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`Validation type '${validationType}' can only be used with 'String' fields. Field '${fieldNode.name.value}' is of type '${baseType}'`);
    }
};
const validateLengthValue = (config) => {
    const value = parseInt(config.validationValue);
    if (isNaN(value) || value < 0) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`${config.validationType} value must be a non-negative integer. Received '${config.validationValue}' for field '${config.fieldNode.name.value}'`);
    }
};
const validateNumericValue = (config) => {
    const value = parseFloat(config.validationValue);
    if (isNaN(value)) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`${config.validationType} value must be a number. Received '${config.validationValue}' for field '${config.fieldNode.name.value}'`);
    }
};
const isNumericValidation = (type) => {
    return types_1.NUMERIC_VALIDATION_TYPES.includes(type);
};
const isStringValidation = (type) => {
    return types_1.STRING_VALIDATION_TYPES.includes(type);
};
const isLengthValidation = (type) => {
    return ['minLength', 'maxLength'].includes(type);
};
//# sourceMappingURL=validators.js.map