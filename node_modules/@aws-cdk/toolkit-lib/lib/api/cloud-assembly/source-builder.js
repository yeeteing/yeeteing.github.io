"use strict";
var __addDisposableResource = (this && this.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (this && this.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while (r = env.stack.pop()) {
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                    }
                    else s |= 1;
                }
                catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloudAssemblySourceBuilder = void 0;
const path = require("path");
const util_1 = require("util");
const cxapi = require("@aws-cdk/cx-api");
const fs = require("fs-extra");
const context_store_1 = require("./context-store");
const rwlock_1 = require("../rwlock");
const context_aware_source_1 = require("./private/context-aware-source");
const exec_1 = require("./private/exec");
const prepare_source_1 = require("./private/prepare-source");
const readable_assembly_1 = require("./private/readable-assembly");
const toolkit_error_1 = require("../../toolkit/toolkit-error");
const util_2 = require("../../util");
const private_1 = require("../io/private");
const helpers_1 = require("./private/helpers");
class CloudAssemblySourceBuilder {
    /**
     * Create a Cloud Assembly from a Cloud Assembly builder function.
     *
     * ## Outdir
     *
     * If no output directory is given, it will synthesize into a temporary system
     * directory. The temporary directory will be cleaned up, unless
     * `disposeOutdir: false`.
     *
     * A write lock will be acquired on the output directory for the duration of
     * the CDK app synthesis (which means that no two apps can synthesize at the
     * same time), and after synthesis a read lock will be acquired on the
     * directory. This means that while the CloudAssembly is being used, no CDK
     * app synthesis can take place into that directory.
     *
     * ## Context
     *
     * If no `contextStore` is given, a `MemoryContext` will be used. This means
     * no provider lookups will be persisted anywhere by default. Use a different
     * type of context store if you want persistence between synth operations.
     *
     * @param builder - the builder function
     * @param props - additional configuration properties
     * @returns the CloudAssembly source
     */
    async fromAssemblyBuilder(builder, props = {}) {
        const services = await this.sourceBuilderServices();
        const contextStore = props.contextStore ?? new context_store_1.MemoryContext();
        const contextAssemblyProps = {
            services,
            contextStore,
            lookups: props.lookups,
        };
        const outdir = props.outdir ? path.resolve(props.outdir) : undefined;
        return new context_aware_source_1.ContextAwareCloudAssemblySource({
            produce: async () => {
                const env_1 = { stack: [], error: void 0, hasError: false };
                try {
                    const execution = __addDisposableResource(env_1, await prepare_source_1.ExecutionEnvironment.create(services, { outdir }), true);
                    const synthParams = (0, prepare_source_1.parametersFromSynthOptions)(props.synthOptions);
                    const fullContext = {
                        ...await contextStore.read(),
                        ...synthParams.context,
                    };
                    await services.ioHelper.defaults.debug((0, util_1.format)('context:', fullContext));
                    const env = (0, util_2.noUndefined)({
                        // Versioning, outdir, default account and region
                        ...await execution.defaultEnvVars(),
                        // Environment variables derived from settings
                        ...synthParams.env,
                    });
                    const cleanupContextTemp = (0, prepare_source_1.writeContextToEnv)(env, fullContext);
                    const _cleanupEnv = __addDisposableResource(env_1, (props.clobberEnv ?? true) ? (0, helpers_1.temporarilyWriteEnv)(env) : undefined, false);
                    let assembly;
                    try {
                        assembly = await builder({
                            outdir: execution.outdir,
                            context: fullContext,
                            env,
                        });
                    }
                    catch (error) {
                        // re-throw toolkit errors unchanged
                        if (toolkit_error_1.ToolkitError.isToolkitError(error)) {
                            throw error;
                        }
                        // otherwise, wrap into an assembly error
                        throw toolkit_error_1.AssemblyError.withCause('Assembly builder failed', error);
                    }
                    finally {
                        await cleanupContextTemp();
                    }
                    // Convert what we got to the definitely correct type we're expecting, a cxapi.CloudAssembly
                    const asm = cxapi.CloudAssembly.isCloudAssembly(assembly)
                        ? assembly
                        : await (0, prepare_source_1.assemblyFromDirectory)(assembly.directory, services.ioHelper, props.loadAssemblyOptions);
                    const success = await execution.markSuccessful();
                    const deleteOnDispose = props.disposeOutdir ?? execution.outDirIsTemporary;
                    return new readable_assembly_1.ReadableCloudAssembly(asm, success.readLock, { deleteOnDispose });
                }
                catch (e_1) {
                    env_1.error = e_1;
                    env_1.hasError = true;
                }
                finally {
                    const result_1 = __disposeResources(env_1);
                    if (result_1)
                        await result_1;
                }
            },
        }, contextAssemblyProps);
    }
    /**
     * Creates a Cloud Assembly from an existing assembly directory.
     *
     * A read lock will be acquired for the directory. This means that while
     * the CloudAssembly is being used, no CDK app synthesis can take place into
     * that directory.
     *
     * @param directory - directory the directory of a already produced Cloud Assembly.
     * @returns the CloudAssembly source
     */
    async fromAssemblyDirectory(directory, props = {}) {
        const services = await this.sourceBuilderServices();
        const contextAssemblyProps = {
            services,
            contextStore: new context_store_1.MemoryContext(), // @todo We shouldn't be using a `ContextAwareCloudAssemblySource` at all.
            lookups: false,
        };
        return new context_aware_source_1.ContextAwareCloudAssemblySource({
            produce: async () => {
                // @todo build
                await services.ioHelper.notify(private_1.IO.CDK_ASSEMBLY_I0150.msg('--app points to a cloud assembly, so we bypass synth'));
                const readLock = await new rwlock_1.RWLock(directory).acquireRead();
                try {
                    const asm = await (0, prepare_source_1.assemblyFromDirectory)(directory, services.ioHelper, props.loadAssemblyOptions);
                    return new readable_assembly_1.ReadableCloudAssembly(asm, readLock, { deleteOnDispose: false });
                }
                catch (e) {
                    await readLock.release();
                    throw e;
                }
            },
        }, contextAssemblyProps);
    }
    /**
     * Use a directory containing an AWS CDK app as source.
     *
     * The subprocess will execute in `workingDirectory`, which defaults to
     * the current process' working directory if not given.
     *
     * ## Outdir
     *
     * If an output directory is supplied, relative paths are evaluated with
     * respect to the current process' working directory. If an output directory
     * is not supplied, the default is a `cdk.out` directory underneath
     * `workingDirectory`. The output directory will not be cleaned up unless
     * `disposeOutdir: true`.
     *
     * A write lock will be acquired on the output directory for the duration of
     * the CDK app synthesis (which means that no two apps can synthesize at the
     * same time), and after synthesis a read lock will be acquired on the
     * directory.  This means that while the CloudAssembly is being used, no CDK
     * app synthesis can take place into that directory.
     *
     * ## Context
     *
     * If no `contextStore` is given, a `CdkAppMultiContext` will be used, initialized
     * to the app's `workingDirectory`. This means that context will be loaded from
     * all the CDK's default context sources, and updates will be written to
     * `cdk.context.json`.
     *
     * @param props - additional configuration properties
     * @returns the CloudAssembly source
     */
    async fromCdkApp(app, props = {}) {
        const services = await this.sourceBuilderServices();
        const workingDirectory = props.workingDirectory ?? process.cwd();
        const outdir = props.outdir ? path.resolve(props.outdir) : path.resolve(workingDirectory, 'cdk.out');
        const contextStore = props.contextStore ?? new context_store_1.CdkAppMultiContext(workingDirectory);
        const contextAssemblyProps = {
            services,
            contextStore,
            lookups: props.lookups,
        };
        return new context_aware_source_1.ContextAwareCloudAssemblySource({
            produce: async () => {
                const env_2 = { stack: [], error: void 0, hasError: false };
                try {
                    // @todo build
                    // const build = this.props.configuration.settings.get(['build']);
                    // if (build) {
                    //   await execInChildProcess(build, { cwd: props.workingDirectory });
                    // }
                    try {
                        fs.mkdirpSync(outdir);
                    }
                    catch (e) {
                        throw new toolkit_error_1.ToolkitError(`Could not create output directory at '${outdir}' (${e.message}).`);
                    }
                    const execution = __addDisposableResource(env_2, await prepare_source_1.ExecutionEnvironment.create(services, { outdir }), true);
                    const commandLine = await execution.guessExecutable(app);
                    const synthParams = (0, prepare_source_1.parametersFromSynthOptions)(props.synthOptions);
                    const fullContext = {
                        ...await contextStore.read(),
                        ...synthParams.context,
                    };
                    await services.ioHelper.defaults.debug((0, util_1.format)('context:', fullContext));
                    const env = (0, util_2.noUndefined)({
                        // Need to start with full env of `writeContextToEnv` will not be able to do the size
                        // calculation correctly.
                        ...process.env,
                        // User gave us something
                        ...props.env,
                        // Versioning, outdir, default account and region
                        ...await execution.defaultEnvVars(),
                        // Environment variables derived from settings
                        ...synthParams.env,
                    });
                    const cleanupTemp = (0, prepare_source_1.writeContextToEnv)(env, fullContext);
                    try {
                        await (0, exec_1.execInChildProcess)(commandLine.join(' '), {
                            eventPublisher: async (type, line) => {
                                switch (type) {
                                    case 'data_stdout':
                                        await services.ioHelper.notify(private_1.IO.CDK_ASSEMBLY_I1001.msg(line));
                                        break;
                                    case 'data_stderr':
                                        await services.ioHelper.notify(private_1.IO.CDK_ASSEMBLY_E1002.msg(line));
                                        break;
                                }
                            },
                            env,
                            cwd: workingDirectory,
                        });
                    }
                    finally {
                        await cleanupTemp();
                    }
                    const asm = await (0, prepare_source_1.assemblyFromDirectory)(outdir, services.ioHelper, props.loadAssemblyOptions);
                    const success = await execution.markSuccessful();
                    const deleteOnDispose = props.disposeOutdir ?? execution.outDirIsTemporary;
                    return new readable_assembly_1.ReadableCloudAssembly(asm, success.readLock, { deleteOnDispose });
                }
                catch (e_2) {
                    env_2.error = e_2;
                    env_2.hasError = true;
                }
                finally {
                    const result_2 = __disposeResources(env_2);
                    if (result_2)
                        await result_2;
                }
            },
        }, contextAssemblyProps);
    }
}
exports.CloudAssemblySourceBuilder = CloudAssemblySourceBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic291cmNlLWJ1aWxkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzb3VyY2UtYnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNkJBQTZCO0FBQzdCLCtCQUE4QjtBQUU5Qix5Q0FBeUM7QUFDekMsK0JBQStCO0FBQy9CLG1EQUF3RjtBQUN4RixzQ0FBbUM7QUFFbkMseUVBQWlGO0FBQ2pGLHlDQUFvRDtBQUNwRCw2REFBc0k7QUFDdEksbUVBQW9FO0FBR3BFLCtEQUEwRTtBQUMxRSxxQ0FBeUM7QUFDekMsMkNBQW1DO0FBQ25DLCtDQUF3RDtBQTJQeEQsTUFBc0IsMEJBQTBCO0lBTzlDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F3Qkc7SUFDSSxLQUFLLENBQUMsbUJBQW1CLENBQzlCLE9BQXdCLEVBQ3hCLFFBQW9DLEVBQUU7UUFFdEMsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQztRQUNwRCxNQUFNLFlBQVksR0FBRyxLQUFLLENBQUMsWUFBWSxJQUFJLElBQUksNkJBQWEsRUFBRSxDQUFDO1FBQy9ELE1BQU0sb0JBQW9CLEdBQW1DO1lBQzNELFFBQVE7WUFDUixZQUFZO1lBQ1osT0FBTyxFQUFFLEtBQUssQ0FBQyxPQUFPO1NBQ3ZCLENBQUM7UUFFRixNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO1FBRXJFLE9BQU8sSUFBSSxzREFBK0IsQ0FDeEM7WUFDRSxPQUFPLEVBQUUsS0FBSyxJQUFJLEVBQUU7OztvQkFDbEIsTUFBWSxTQUFTLGtDQUFHLE1BQU0scUNBQW9CLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxFQUFFLE1BQU0s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QkFFOUYsTUFBTSxPQUFPLEdBQUcsTUFBTSxTQUFTLENBQUMsY0FBYyxFQUFFLENBQUM7b0JBQ2pELE1BQU0sZUFBZSxHQUFHLEtBQUssQ0FBQyxhQUFhLElBQUksU0FBUyxDQUFDLGlCQUFpQixDQUFDO29CQUMzRSxPQUFPLElBQUkseUNBQXFCLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxRQUFRLEVBQUUsRUFBRSxlQUFlLEVBQUUsQ0FBQyxDQUFDOzs7Ozs7Ozs7OzthQUM5RTtTQUNGLEVBQ0Qsb0JBQW9CLENBQ3JCLENBQUM7SUFDSixDQUFDO0NBQ0Y7QUExUEQsZ0VBMFBDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IGZvcm1hdCB9IGZyb20gJ3V0aWwnO1xuaW1wb3J0IHR5cGUgKiBhcyBjeHNjaGVtYSBmcm9tICdAYXdzLWNkay9jbG91ZC1hc3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCB7IENka0FwcE11bHRpQ29udGV4dCwgTWVtb3J5Q29udGV4dCwgdHlwZSBJQ29udGV4dFN0b3JlIH0gZnJvbSAnLi9jb250ZXh0LXN0b3JlJztcbmltcG9ydCB7IFJXTG9jayB9IGZyb20gJy4uL3J3bG9jayc7XG5pbXBvcnQgdHlwZSB7IENvbnRleHRBd2FyZUNsb3VkQXNzZW1ibHlQcm9wcyB9IGZyb20gJy4vcHJpdmF0ZS9jb250ZXh0LWF3YXJlLXNvdXJjZSc7XG5pbXBvcnQgeyBDb250ZXh0QXdhcmVDbG91ZEFzc2VtYmx5U291cmNlIH0gZnJvbSAnLi9wcml2YXRlL2NvbnRleHQtYXdhcmUtc291cmNlJztcbmltcG9ydCB7IGV4ZWNJbkNoaWxkUHJvY2VzcyB9IGZyb20gJy4vcHJpdmF0ZS9leGVjJztcbmltcG9ydCB7IEV4ZWN1dGlvbkVudmlyb25tZW50LCBhc3NlbWJseUZyb21EaXJlY3RvcnksIHBhcmFtZXRlcnNGcm9tU3ludGhPcHRpb25zLCB3cml0ZUNvbnRleHRUb0VudiB9IGZyb20gJy4vcHJpdmF0ZS9wcmVwYXJlLXNvdXJjZSc7XG5pbXBvcnQgeyBSZWFkYWJsZUNsb3VkQXNzZW1ibHkgfSBmcm9tICcuL3ByaXZhdGUvcmVhZGFibGUtYXNzZW1ibHknO1xuaW1wb3J0IHR5cGUgeyBJQ2xvdWRBc3NlbWJseVNvdXJjZSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHR5cGUgeyBUb29sa2l0U2VydmljZXMgfSBmcm9tICcuLi8uLi90b29sa2l0L3ByaXZhdGUnO1xuaW1wb3J0IHsgVG9vbGtpdEVycm9yLCBBc3NlbWJseUVycm9yIH0gZnJvbSAnLi4vLi4vdG9vbGtpdC90b29sa2l0LWVycm9yJztcbmltcG9ydCB7IG5vVW5kZWZpbmVkIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBJTyB9IGZyb20gJy4uL2lvL3ByaXZhdGUnO1xuaW1wb3J0IHsgdGVtcG9yYXJpbHlXcml0ZUVudiB9IGZyb20gJy4vcHJpdmF0ZS9oZWxwZXJzJztcblxuLyoqXG4gKiBQcm9wZXJ0aWVzIHRoZSBidWlsZGVyIGZ1bmN0aW9uIHJlY2VpdmVzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFzc2VtYmx5QnVpbGRlclByb3BzIHtcbiAgLyoqXG4gICAqIFRoZSBvdXRwdXQgZGlyZWN0b3J5IGludG8gd2hpY2ggdG8gdGhlIGJ1aWxkZXIgYXBwIHdpbGwgZW1pdCBzeW50aGVzaXplZCBhcnRpZmFjdHMuXG4gICAqL1xuICByZWFkb25seSBvdXRkaXI/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZXh0IHByb3ZpZGVkIHRwIHRoZSBidWlsZGVyIGFwcCB0byBzeW50aGVzaXplIHRoZSBDbG91ZCBBc3NlbWJseSwgaW5jbHVkaW5nIGxvb2tlZC11cCBjb250ZXh0LlxuICAgKi9cbiAgcmVhZG9ubHkgY29udGV4dD86IHsgW2tleTogc3RyaW5nXTogYW55IH07XG5cbiAgLyoqXG4gICAqIEFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiB0aGF0IHdvdWxkIG5vcm1hbGx5IGJlIHBhc3NlZCB0byBhIENESyBhcHAgdXNpbmcgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAqXG4gICAqIFRoaXMgY29udGFpbnMgdmFyaWFibGVzIGludGVuZGVkIGZvciB0aGUgdXNlciBwb3J0aW9uIG9mIGEgQ0RLIGFwcCAobm90YWJseVxuICAgKiBgQ0RLX0RFRkFVTFRfQUNDT1VOVGAgYW5kIGBDREtfREVGQVVMVF9SRUdJT05gKSwgd2hpY2ggeW91IGNhbiBmcmVlbHkgcmVhZC5cbiAgICpcbiAgICogSXQgYWxzbyBjb250YWlucyB2YXJpYWJsZXMgaW50ZW5kZWQgZm9yIHRoZSBDREsgVG9vbGtpdCB0byBjb21tdW5pY2F0ZSB3aXRoXG4gICAqIHRoZSBpbnRlcm5hbHMgb2YgdGhlIGNvbnN0cnVjdCBsaWJyYXJ5LCBsaWtlIGBDREtfREVCVUdgIGFuZFxuICAgKiBgQ0RLX0NMSV9BU01fVkVSU0lPTmAuIFJlYWRpbmcgdGhlc2UgbGF0dGVyIHZhcmlhYmxlcyBpcyBwb3NzaWJsZSBidXQgbm90XG4gICAqIHJlY29tbWVuZGVkLCBhcyB0aGVpciBtZWFuaW5nIG1heSBjaGFuZ2Ugd2l0aG91dCBub3RpY2UuXG4gICAqL1xuICByZWFkb25seSBlbnY6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG59XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIHN5bnRoZXNpcyBwYXJhbWV0ZXJzIGFuZCBwcm9kdWNlcyBhIENsb3VkIEFzc2VtYmx5XG4gKlxuICogTW9zdCB0eXBpY2FsbHksIHRoZSBwcm9wZXJ0aWVzIHBhc3NlZCBoZXJlIHdpbGwgYmUgdXNlZCB0byBjb25zdHJ1Y3QgYVxuICogYGNkay5BcHBgLCBhbmQgdGhlIHJldHVybiB2YWx1ZSBpcyB0aGUgcmV0dXJuIHZhbHVlIG9mIGBhcHAuc3ludGgoKWAuXG4gKi9cbmV4cG9ydCB0eXBlIEFzc2VtYmx5QnVpbGRlciA9IChwcm9wczogQXNzZW1ibHlCdWlsZGVyUHJvcHMpID0+IFByb21pc2U8Y3hzY2hlbWEuSUNsb3VkQXNzZW1ibHk+O1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIGNyZWF0aW5nIGEgQ0xJIGZyb20gYW4gQVdTIENESyBBcHAgZGlyZWN0b3J5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXNzZW1ibHlEaXJlY3RvcnlQcm9wcyB7XG4gIC8qKlxuICAgKiBPcHRpb25zIHRvIGNvbmZpZ3VyZSBsb2FkaW5nIG9mIHRoZSBhc3NlbWJseSBhZnRlciBpdCBoYXMgYmVlbiBzeW50aGVzaXplZFxuICAgKi9cbiAgcmVhZG9ubHkgbG9hZEFzc2VtYmx5T3B0aW9ucz86IExvYWRBc3NlbWJseU9wdGlvbnM7XG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBDTEkgZnJvbSBhbiBBV1MgQ0RLIEFwcCBkaXJlY3RvcnlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBc3NlbWJseVNvdXJjZVByb3BzIHtcbiAgLyoqXG4gICAqIEVtaXRzIHRoZSBzeW50aGVzaXplZCBjbG91ZCBhc3NlbWJseSBpbnRvIHRoZSBnaXZlbiBkaXJlY3RvcnlcbiAgICpcbiAgICogQGRlZmF1bHQgXCJjZGsub3V0XCJcbiAgICovXG4gIHJlYWRvbmx5IG91dGRpcj86IHN0cmluZztcblxuICAvKipcbiAgICogUGVyZm9ybSBjb250ZXh0IGxvb2t1cHMuXG4gICAqXG4gICAqIFN5bnRoZXNpcyBmYWlscyBpZiB0aGlzIGlzIGRpc2FibGVkIGFuZCBjb250ZXh0IGxvb2t1cHMgbmVlZCB0byBiZSBwZXJmb3JtZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IGxvb2t1cHM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBIGNvbnRleHQgc3RvcmUgZm9yIHRoaXMgb3BlcmF0aW9uXG4gICAqXG4gICAqIFRoZSBjb250ZXh0IHN0b3JlIHdpbGwgYmUgdXNlZCB0byBzb3VyY2UgaW5pdGlhbCBjb250ZXh0IHZhbHVlcyxcbiAgICogYW5kIHVwZGF0ZWQgdmFsdWVzIHdpbGwgYmUgc3RvcmVkIGhlcmUuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gRGVwZW5kcyBvbiB0aGUgb3BlcmF0aW9uXG4gICAqL1xuICByZWFkb25seSBjb250ZXh0U3RvcmU/OiBJQ29udGV4dFN0b3JlO1xuXG4gIC8qKlxuICAgKiBPcHRpb25zIHRoYXQgYXJlIHBhc3NlZCB0aHJvdWdoIHRoZSBjb250ZXh0IHRvIGEgQ0RLIGFwcCBvbiBzeW50aFxuICAgKi9cbiAgcmVhZG9ubHkgc3ludGhPcHRpb25zPzogQXBwU3ludGhPcHRpb25zO1xuXG4gIC8qKlxuICAgKiBPcHRpb25zIHRvIGNvbmZpZ3VyZSBsb2FkaW5nIG9mIHRoZSBhc3NlbWJseSBhZnRlciBpdCBoYXMgYmVlbiBzeW50aGVzaXplZFxuICAgKi9cbiAgcmVhZG9ubHkgbG9hZEFzc2VtYmx5T3B0aW9ucz86IExvYWRBc3NlbWJseU9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIERlbGV0ZSB0aGUgYG91dGRpcmAgd2hlbiB0aGUgYXNzZW1ibHkgaXMgZGlzcG9zZWRcbiAgICpcbiAgICogQGRlZmF1bHQgLSBgdHJ1ZWAgaWYgYG91dGRpcmAgaXMgbm90IGdpdmVuLCBgZmFsc2VgIG90aGVyd2lzZVxuICAgKi9cbiAgcmVhZG9ubHkgZGlzcG9zZU91dGRpcj86IGJvb2xlYW47XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgdGhlIGBmcm9tQXNzZW1ibHlCdWlsZGVyYCBBc3NlbWJseSBTb3VyY2UgY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGcm9tQXNzZW1ibHlCdWlsZGVyT3B0aW9ucyBleHRlbmRzIEFzc2VtYmx5U291cmNlUHJvcHMge1xuICAvKipcbiAgICogTXV0YXRlIGN1cnJlbnQgcHJvY2VzcycgZW52aXJvbm1lbnQgdmFyaWFibGVzIHRvIGNvbW11bmljYXRlIHdpdGggQ0RLIGFwcFxuICAgKlxuICAgKiBUaGVyZSBhcmUgYSBudW1iZXIgb2YgZW52aXJvbm1lbnQgdmFyaWFibGVzIHRoZSBUb29sa2l0IHVzZXMgdG8gcGFzc1xuICAgKiBpbmZvcm1hdGlvbiB0byB0aGUgQ0RLIGFwcC5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhlc2UgZW52aXJvbm1lbnQgdmFyaWFibGVzIHdpbGwgYmUgd3JpdHRlbiB0byB0aGUgY3VycmVudFxuICAgKiBwcm9jZXNzJyBnbG9iYWwgc2hhcmVkIGVudmlyb25tZW50IHZhcmlhYmxlcyBiZWZvcmUgdGhlIGJ1aWxkZXIgaXMgaW52b2tlZCxcbiAgICogYW5kIHlvdSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nIGVsc2UuIEhvd2V2ZXIsIGJlY2F1c2UgdGhpcyBtdXRhdGVzXG4gICAqIHNoYXJlZCBzdGF0ZSBpdCBpcyBub3Qgc2FmZSB0byBydW4gbXVsdGlwbGUgYnVpbGRlcnMgY29uY3VycmVudGx5LlxuICAgKlxuICAgKiBTZXQgdGhpcyB0byBgZmFsc2VgIHRvIGF2b2lkIG11dGF0aW5nIHRoZSBzaGFyZWQgZW52aXJvbm1lbnQuIEluc3RlYWQsXG4gICAqIHlvdSB3aWxsIG5lZWQgdG8gcGFzcyB0aGUgYG91dGRpcmAgYW5kIGBjb250ZXh0YCB0byB0aGUgYEFwcGAgY29uc3RydWN0b3JcbiAgICogZGlyZWN0bHkgaW4geW91ciBidWlsZGVyLCBhbmQgaW5zcGVjdCB0aGUgYGVudmAgbWFwIGRpcmVjdGx5XG4gICAqIGZvciBpbmZvcm1hdGlvbiBsaWtlIHRoZSBgQ0RLX0RFRkFVTFRfQUNDT1VOVGAgYW5kIGBDREtfREVGQVVMVF9SRUdJT05gLlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBjeCA9IGF3YWl0IHRvb2xraXQuZnJvbUFzc2VtYmx5QnVpbGRlcihhc3luYyAocHJvcHMpID0+IHtcbiAgICogICAvLyBJbXBvcnRhbnQ6IHBhc3Mgb24gc3ludGhlc2lzIHBhcmFtZXRlcnNcbiAgICogICBjb25zdCBhcHAgPSBuZXcgY29yZS5BcHAoe1xuICAgKiAgICAgb3V0ZGlyOiBwcm9wcy5vdXRkaXIsXG4gICAqICAgICBjb250ZXh0OiBwcm9wcy5jb250ZXh0LFxuICAgKiAgIH0pO1xuICAgKlxuICAgKiAgIG5ldyBNeVN0YWNrKGFwcCwgJ015U3RhY2snLCB7XG4gICAqICAgICBlbnY6IHtcbiAgICogICAgICAgYWNjb3VudDogcHJvcHMuZW52LkNES19ERUZBVUxUX0FDQ09VTlQsXG4gICAqICAgICAgIHJlZ2lvbjogcHJvcHMuZW52LkNES19ERUZBVUxUX1JFR0lPTixcbiAgICogICAgIH0sXG4gICAqICAgfSk7XG4gICAqXG4gICAqICAgLy8gLi4uXG4gICAqIH0sIHtcbiAgICogICBjbG9iYmVyRW52OiBmYWxzZSxcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBjbG9iYmVyRW52PzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciB0aGUgYGZyb21DZGtBcHBgIEFzc2VtYmx5IFNvdXJjZSBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZyb21DZGtBcHBPcHRpb25zIGV4dGVuZHMgQXNzZW1ibHlTb3VyY2VQcm9wcyB7XG4gIC8qKlxuICAgKiBFeGVjdXRlIHRoZSBhcHBsaWNhdGlvbiBpbiB0aGlzIHdvcmtpbmcgZGlyZWN0b3J5LlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIEN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnlcbiAgICovXG4gIHJlYWRvbmx5IHdvcmtpbmdEaXJlY3Rvcnk/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFkZGl0aW9uYWwgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAqXG4gICAqIFRoZXNlIGVudmlyb25tZW50IHZhcmlhYmxlcyB3aWxsIGJlIHNldCBpbiBhZGRpdGlvbiB0byB0aGUgZW52aXJvbm1lbnRcbiAgICogdmFyaWFibGVzIGN1cnJlbnRseSBzZXQgaW4gdGhlIHByb2Nlc3MuIEEgdmFsdWUgb2YgYHVuZGVmaW5lZGAgd2lsbFxuICAgKiB1bnNldCBhIHBhcnRpY3VsYXIgZW52aXJvbm1lbnQgdmFyaWFibGUuXG4gICAqL1xuICByZWFkb25seSBlbnY/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+O1xufVxuXG4vKipcbiAqIFNldHRpbmdzIHRoYXQgYXJlIHBhc3NlZCB0byBhIENESyBhcHAgdmlhIHRoZSBjb250ZXh0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXBwU3ludGhPcHRpb25zIHtcbiAgLyoqXG4gICAqIERlYnVnIHRoZSBDREsgYXBwLlxuICAgKiBMb2dzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gZHVyaW5nIHN5bnRoZXNpcywgc3VjaCBhcyBjcmVhdGlvbiBzdGFjayB0cmFjZXMgb2YgdG9rZW5zLlxuICAgKiBUaGlzIGFsc28gc2V0cyB0aGUgYENES19ERUJVR2AgZW52IHZhcmlhYmxlIGFuZCB3aWxsIHNsb3cgZG93biBzeW50aGVzaXMuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBkZWJ1Zz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEVuYWJsZXMgdGhlIGVtYmVkZGluZyBvZiB0aGUgXCJhd3M6Y2RrOnBhdGhcIiBpbiBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZSBtZXRhZGF0YS5cbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgcGF0aE1ldGFkYXRhPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogRW5hYmxlIHRoZSBjb2xsZWN0aW9uIGFuZCByZXBvcnRpbmcgb2YgdmVyc2lvbiBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgdmVyc2lvblJlcG9ydGluZz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZSBlbmFibGVkLCBgYXdzOmFzc2V0Onh4eGAgbWV0YWRhdGEgZW50cmllcyBhcmUgYWRkZWQgdG8gdGhlIHRlbXBsYXRlLlxuICAgKlxuICAgKiBEaXNhYmxpbmcgdGhpcyBjYW4gYmUgdXNlZnVsIGluIGNlcnRhaW4gY2FzZXMgbGlrZSBpbnRlZ3JhdGlvbiB0ZXN0cy5cbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgYXNzZXRNZXRhZGF0YT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBhc3NldCBzdGFnaW5nLlxuICAgKlxuICAgKiBEaXNhYmxpbmcgYXNzZXQgc3RhZ2luZyBtZWFucyB0aGF0IGNvcHlhYmxlIGFzc2V0cyB3aWxsIG5vdCBiZSBjb3BpZWQgdG8gdGhlXG4gICAqIG91dHB1dCBkaXJlY3RvcnkgYW5kIHdpbGwgYmUgcmVmZXJlbmNlZCB3aXRoIGFic29sdXRlIHBhdGhzLlxuICAgKlxuICAgKiBOb3QgY29waWVkIHRvIHRoZSBvdXRwdXQgZGlyZWN0b3J5OiB0aGlzIGlzIHNvIHVzZXJzIGNhbiBpdGVyYXRlIG9uIHRoZVxuICAgKiBMYW1iZGEgc291cmNlIGFuZCBydW4gU0FNIENMSSB3aXRob3V0IGhhdmluZyB0byByZS1ydW4gQ0RLIChub3RlOiB3ZVxuICAgKiBjYW5ub3QgYWNoaWV2ZSB0aGlzIGZvciBidW5kbGVkIGFzc2V0cywgaWYgYXNzZXRzIGFyZSBidW5kbGVkIHRoZXlcbiAgICogd2lsbCBoYXZlIHRvIHJlLXJ1biBDREsgQ0xJIHRvIHJlLWJ1bmRsZSB1cGRhdGVkIHZlcnNpb25zKS5cbiAgICpcbiAgICogQWJzb2x1dGUgcGF0aDogU0FNIENMSSBleHBlY3RzIGBjd2RgLXJlbGF0aXZlIHBhdGhzIGluIGEgcmVzb3VyY2Unc1xuICAgKiBgYXdzOmFzc2V0OnBhdGhgIG1ldGFkYXRhLiBJbiBvcmRlciB0byBiZSBwcmVkaWN0YWJsZSwgd2Ugd2lsbCBhbHdheXMgb3V0cHV0XG4gICAqIGFic29sdXRlIHBhdGhzLlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBhc3NldFN0YWdpbmc/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBTZWxlY3Qgd2hpY2ggc3RhY2tzIHNob3VsZCBoYXZlIGFzc2V0IGJ1bmRsaW5nIGVuYWJsZWRcbiAgICpcbiAgICogQGRlZmF1bHQgW1wiKipcIl0gLSBhbGwgc3RhY2tzXG4gICAqL1xuICByZWFkb25seSBidW5kbGluZ0ZvclN0YWNrcz86IHN0cmluZztcbn1cblxuLyoqXG4gKiBPcHRpb25zIHRvIGNvbmZpZ3VyZSBsb2FkaW5nIG9mIHRoZSBhc3NlbWJseSBhZnRlciBpdCBoYXMgYmVlbiBzeW50aGVzaXplZFxuICovXG5leHBvcnQgaW50ZXJmYWNlIExvYWRBc3NlbWJseU9wdGlvbnMge1xuICAvKipcbiAgICogQ2hlY2sgdGhlIFRvb2xraXQgc3VwcG9ydHMgdGhlIENsb3VkIEFzc2VtYmx5IFNjaGVtYSB2ZXJzaW9uXG4gICAqXG4gICAqIFdoZW4gZGlzYWJsZWQsIGFsbG93cyB0byBUb29sa2l0IHRvIHJlYWQgYSBuZXdlciBjbG91ZCBhc3NlbWJseSB0aGFuIHRoZSBDWCBBUEkgaXMgZGVzaWduZWRcbiAgICogdG8gc3VwcG9ydC4gWW91ciBhcHBsaWNhdGlvbiBtYXkgbm90IGJlIGF3YXJlIG9mIGFsbCBmZWF0dXJlcyB0aGF0IGluIHVzZSBpbiB0aGUgQ2xvdWQgQXNzZW1ibHkuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IGNoZWNrVmVyc2lvbj86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGVudW1zIHRvIG9ubHkgaGF2ZSBrbm93biB2YWx1ZXNcbiAgICpcbiAgICogV2hlbiBkaXNhYmxlZCwgdGhlIFRvb2xraXQgbWF5IHJlYWQgZW51bSB2YWx1ZXMgaXQgZG9lc24ndCBrbm93IGFib3V0IHlldC5cbiAgICogWW91IHdpbGwgaGF2ZSB0byBtYWtlIHN1cmUgdG8gYWx3YXlzIGNoZWNrIHRoZSB2YWx1ZXMgb2YgZW51bXMgeW91IGVuY291bnRlciBpbiB0aGUgbWFuaWZlc3QuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IGNoZWNrRW51bXM/OiBib29sZWFuO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ2xvdWRBc3NlbWJseVNvdXJjZUJ1aWxkZXIge1xuICAvKipcbiAgICogSGVscGVyIHRvIHByb3ZpZGUgdGhlIENsb3VkQXNzZW1ibHlTb3VyY2VCdWlsZGVyIHdpdGggcmVxdWlyZWQgdG9vbGtpdCBzZXJ2aWNlc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBzb3VyY2VCdWlsZGVyU2VydmljZXMoKTogUHJvbWlzZTxUb29sa2l0U2VydmljZXM+O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBDbG91ZCBBc3NlbWJseSBmcm9tIGEgQ2xvdWQgQXNzZW1ibHkgYnVpbGRlciBmdW5jdGlvbi5cbiAgICpcbiAgICogIyMgT3V0ZGlyXG4gICAqXG4gICAqIElmIG5vIG91dHB1dCBkaXJlY3RvcnkgaXMgZ2l2ZW4sIGl0IHdpbGwgc3ludGhlc2l6ZSBpbnRvIGEgdGVtcG9yYXJ5IHN5c3RlbVxuICAgKiBkaXJlY3RvcnkuIFRoZSB0ZW1wb3JhcnkgZGlyZWN0b3J5IHdpbGwgYmUgY2xlYW5lZCB1cCwgdW5sZXNzXG4gICAqIGBkaXNwb3NlT3V0ZGlyOiBmYWxzZWAuXG4gICAqXG4gICAqIEEgd3JpdGUgbG9jayB3aWxsIGJlIGFjcXVpcmVkIG9uIHRoZSBvdXRwdXQgZGlyZWN0b3J5IGZvciB0aGUgZHVyYXRpb24gb2ZcbiAgICogdGhlIENESyBhcHAgc3ludGhlc2lzICh3aGljaCBtZWFucyB0aGF0IG5vIHR3byBhcHBzIGNhbiBzeW50aGVzaXplIGF0IHRoZVxuICAgKiBzYW1lIHRpbWUpLCBhbmQgYWZ0ZXIgc3ludGhlc2lzIGEgcmVhZCBsb2NrIHdpbGwgYmUgYWNxdWlyZWQgb24gdGhlXG4gICAqIGRpcmVjdG9yeS4gVGhpcyBtZWFucyB0aGF0IHdoaWxlIHRoZSBDbG91ZEFzc2VtYmx5IGlzIGJlaW5nIHVzZWQsIG5vIENES1xuICAgKiBhcHAgc3ludGhlc2lzIGNhbiB0YWtlIHBsYWNlIGludG8gdGhhdCBkaXJlY3RvcnkuXG4gICAqXG4gICAqICMjIENvbnRleHRcbiAgICpcbiAgICogSWYgbm8gYGNvbnRleHRTdG9yZWAgaXMgZ2l2ZW4sIGEgYE1lbW9yeUNvbnRleHRgIHdpbGwgYmUgdXNlZC4gVGhpcyBtZWFuc1xuICAgKiBubyBwcm92aWRlciBsb29rdXBzIHdpbGwgYmUgcGVyc2lzdGVkIGFueXdoZXJlIGJ5IGRlZmF1bHQuIFVzZSBhIGRpZmZlcmVudFxuICAgKiB0eXBlIG9mIGNvbnRleHQgc3RvcmUgaWYgeW91IHdhbnQgcGVyc2lzdGVuY2UgYmV0d2VlbiBzeW50aCBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gYnVpbGRlciAtIHRoZSBidWlsZGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSBwcm9wcyAtIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzXG4gICAqIEByZXR1cm5zIHRoZSBDbG91ZEFzc2VtYmx5IHNvdXJjZVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGZyb21Bc3NlbWJseUJ1aWxkZXIoXG4gICAgYnVpbGRlcjogQXNzZW1ibHlCdWlsZGVyLFxuICAgIHByb3BzOiBGcm9tQXNzZW1ibHlCdWlsZGVyT3B0aW9ucyA9IHt9LFxuICApOiBQcm9taXNlPElDbG91ZEFzc2VtYmx5U291cmNlPiB7XG4gICAgY29uc3Qgc2VydmljZXMgPSBhd2FpdCB0aGlzLnNvdXJjZUJ1aWxkZXJTZXJ2aWNlcygpO1xuICAgIGNvbnN0IGNvbnRleHRTdG9yZSA9IHByb3BzLmNvbnRleHRTdG9yZSA/PyBuZXcgTWVtb3J5Q29udGV4dCgpO1xuICAgIGNvbnN0IGNvbnRleHRBc3NlbWJseVByb3BzOiBDb250ZXh0QXdhcmVDbG91ZEFzc2VtYmx5UHJvcHMgPSB7XG4gICAgICBzZXJ2aWNlcyxcbiAgICAgIGNvbnRleHRTdG9yZSxcbiAgICAgIGxvb2t1cHM6IHByb3BzLmxvb2t1cHMsXG4gICAgfTtcblxuICAgIGNvbnN0IG91dGRpciA9IHByb3BzLm91dGRpciA/IHBhdGgucmVzb2x2ZShwcm9wcy5vdXRkaXIpIDogdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIG5ldyBDb250ZXh0QXdhcmVDbG91ZEFzc2VtYmx5U291cmNlKFxuICAgICAge1xuICAgICAgICBwcm9kdWNlOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgdXNpbmcgZXhlY3V0aW9uID0gYXdhaXQgRXhlY3V0aW9uRW52aXJvbm1lbnQuY3JlYXRlKHNlcnZpY2VzLCB7IG91dGRpciB9KTtcblxuICAgICAgICAgIGNvbnN0IHN5bnRoUGFyYW1zID0gcGFyYW1ldGVyc0Zyb21TeW50aE9wdGlvbnMocHJvcHMuc3ludGhPcHRpb25zKTtcblxuICAgICAgICAgIGNvbnN0IGZ1bGxDb250ZXh0ID0ge1xuICAgICAgICAgICAgLi4uYXdhaXQgY29udGV4dFN0b3JlLnJlYWQoKSxcbiAgICAgICAgICAgIC4uLnN5bnRoUGFyYW1zLmNvbnRleHQsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGF3YWl0IHNlcnZpY2VzLmlvSGVscGVyLmRlZmF1bHRzLmRlYnVnKGZvcm1hdCgnY29udGV4dDonLCBmdWxsQ29udGV4dCkpO1xuXG4gICAgICAgICAgY29uc3QgZW52ID0gbm9VbmRlZmluZWQoe1xuICAgICAgICAgICAgLy8gVmVyc2lvbmluZywgb3V0ZGlyLCBkZWZhdWx0IGFjY291bnQgYW5kIHJlZ2lvblxuICAgICAgICAgICAgLi4uYXdhaXQgZXhlY3V0aW9uLmRlZmF1bHRFbnZWYXJzKCksXG4gICAgICAgICAgICAvLyBFbnZpcm9ubWVudCB2YXJpYWJsZXMgZGVyaXZlZCBmcm9tIHNldHRpbmdzXG4gICAgICAgICAgICAuLi5zeW50aFBhcmFtcy5lbnYsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjb25zdCBjbGVhbnVwQ29udGV4dFRlbXAgPSB3cml0ZUNvbnRleHRUb0VudihlbnYsIGZ1bGxDb250ZXh0KTtcbiAgICAgICAgICB1c2luZyBfY2xlYW51cEVudiA9IChwcm9wcy5jbG9iYmVyRW52ID8/IHRydWUpID8gdGVtcG9yYXJpbHlXcml0ZUVudihlbnYpIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGxldCBhc3NlbWJseTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXNzZW1ibHkgPSBhd2FpdCBidWlsZGVyKHtcbiAgICAgICAgICAgICAgb3V0ZGlyOiBleGVjdXRpb24ub3V0ZGlyLFxuICAgICAgICAgICAgICBjb250ZXh0OiBmdWxsQ29udGV4dCxcbiAgICAgICAgICAgICAgZW52LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcbiAgICAgICAgICAgIC8vIHJlLXRocm93IHRvb2xraXQgZXJyb3JzIHVuY2hhbmdlZFxuICAgICAgICAgICAgaWYgKFRvb2xraXRFcnJvci5pc1Rvb2xraXRFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIHdyYXAgaW50byBhbiBhc3NlbWJseSBlcnJvclxuICAgICAgICAgICAgdGhyb3cgQXNzZW1ibHlFcnJvci53aXRoQ2F1c2UoJ0Fzc2VtYmx5IGJ1aWxkZXIgZmFpbGVkJywgZXJyb3IpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBhd2FpdCBjbGVhbnVwQ29udGV4dFRlbXAoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDb252ZXJ0IHdoYXQgd2UgZ290IHRvIHRoZSBkZWZpbml0ZWx5IGNvcnJlY3QgdHlwZSB3ZSdyZSBleHBlY3RpbmcsIGEgY3hhcGkuQ2xvdWRBc3NlbWJseVxuICAgICAgICAgIGNvbnN0IGFzbSA9IGN4YXBpLkNsb3VkQXNzZW1ibHkuaXNDbG91ZEFzc2VtYmx5KGFzc2VtYmx5KVxuICAgICAgICAgICAgPyBhc3NlbWJseVxuICAgICAgICAgICAgOiBhd2FpdCBhc3NlbWJseUZyb21EaXJlY3RvcnkoYXNzZW1ibHkuZGlyZWN0b3J5LCBzZXJ2aWNlcy5pb0hlbHBlciwgcHJvcHMubG9hZEFzc2VtYmx5T3B0aW9ucyk7XG5cbiAgICAgICAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgZXhlY3V0aW9uLm1hcmtTdWNjZXNzZnVsKCk7XG4gICAgICAgICAgY29uc3QgZGVsZXRlT25EaXNwb3NlID0gcHJvcHMuZGlzcG9zZU91dGRpciA/PyBleGVjdXRpb24ub3V0RGlySXNUZW1wb3Jhcnk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZUNsb3VkQXNzZW1ibHkoYXNtLCBzdWNjZXNzLnJlYWRMb2NrLCB7IGRlbGV0ZU9uRGlzcG9zZSB9KTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBjb250ZXh0QXNzZW1ibHlQcm9wcyxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBDbG91ZCBBc3NlbWJseSBmcm9tIGFuIGV4aXN0aW5nIGFzc2VtYmx5IGRpcmVjdG9yeS5cbiAgICpcbiAgICogQSByZWFkIGxvY2sgd2lsbCBiZSBhY3F1aXJlZCBmb3IgdGhlIGRpcmVjdG9yeS4gVGhpcyBtZWFucyB0aGF0IHdoaWxlXG4gICAqIHRoZSBDbG91ZEFzc2VtYmx5IGlzIGJlaW5nIHVzZWQsIG5vIENESyBhcHAgc3ludGhlc2lzIGNhbiB0YWtlIHBsYWNlIGludG9cbiAgICogdGhhdCBkaXJlY3RvcnkuXG4gICAqXG4gICAqIEBwYXJhbSBkaXJlY3RvcnkgLSBkaXJlY3RvcnkgdGhlIGRpcmVjdG9yeSBvZiBhIGFscmVhZHkgcHJvZHVjZWQgQ2xvdWQgQXNzZW1ibHkuXG4gICAqIEByZXR1cm5zIHRoZSBDbG91ZEFzc2VtYmx5IHNvdXJjZVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGZyb21Bc3NlbWJseURpcmVjdG9yeShkaXJlY3Rvcnk6IHN0cmluZywgcHJvcHM6IEFzc2VtYmx5RGlyZWN0b3J5UHJvcHMgPSB7fSk6IFByb21pc2U8SUNsb3VkQXNzZW1ibHlTb3VyY2U+IHtcbiAgICBjb25zdCBzZXJ2aWNlczogVG9vbGtpdFNlcnZpY2VzID0gYXdhaXQgdGhpcy5zb3VyY2VCdWlsZGVyU2VydmljZXMoKTtcbiAgICBjb25zdCBjb250ZXh0QXNzZW1ibHlQcm9wczogQ29udGV4dEF3YXJlQ2xvdWRBc3NlbWJseVByb3BzID0ge1xuICAgICAgc2VydmljZXMsXG4gICAgICBjb250ZXh0U3RvcmU6IG5ldyBNZW1vcnlDb250ZXh0KCksIC8vIEB0b2RvIFdlIHNob3VsZG4ndCBiZSB1c2luZyBhIGBDb250ZXh0QXdhcmVDbG91ZEFzc2VtYmx5U291cmNlYCBhdCBhbGwuXG4gICAgICBsb29rdXBzOiBmYWxzZSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIG5ldyBDb250ZXh0QXdhcmVDbG91ZEFzc2VtYmx5U291cmNlKFxuICAgICAge1xuICAgICAgICBwcm9kdWNlOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgLy8gQHRvZG8gYnVpbGRcbiAgICAgICAgICBhd2FpdCBzZXJ2aWNlcy5pb0hlbHBlci5ub3RpZnkoSU8uQ0RLX0FTU0VNQkxZX0kwMTUwLm1zZygnLS1hcHAgcG9pbnRzIHRvIGEgY2xvdWQgYXNzZW1ibHksIHNvIHdlIGJ5cGFzcyBzeW50aCcpKTtcblxuICAgICAgICAgIGNvbnN0IHJlYWRMb2NrID0gYXdhaXQgbmV3IFJXTG9jayhkaXJlY3RvcnkpLmFjcXVpcmVSZWFkKCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFzbSA9IGF3YWl0IGFzc2VtYmx5RnJvbURpcmVjdG9yeShkaXJlY3RvcnksIHNlcnZpY2VzLmlvSGVscGVyLCBwcm9wcy5sb2FkQXNzZW1ibHlPcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVhZGFibGVDbG91ZEFzc2VtYmx5KGFzbSwgcmVhZExvY2ssIHsgZGVsZXRlT25EaXNwb3NlOiBmYWxzZSB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCByZWFkTG9jay5yZWxlYXNlKCk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBjb250ZXh0QXNzZW1ibHlQcm9wcyxcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBVc2UgYSBkaXJlY3RvcnkgY29udGFpbmluZyBhbiBBV1MgQ0RLIGFwcCBhcyBzb3VyY2UuXG4gICAqXG4gICAqIFRoZSBzdWJwcm9jZXNzIHdpbGwgZXhlY3V0ZSBpbiBgd29ya2luZ0RpcmVjdG9yeWAsIHdoaWNoIGRlZmF1bHRzIHRvXG4gICAqIHRoZSBjdXJyZW50IHByb2Nlc3MnIHdvcmtpbmcgZGlyZWN0b3J5IGlmIG5vdCBnaXZlbi5cbiAgICpcbiAgICogIyMgT3V0ZGlyXG4gICAqXG4gICAqIElmIGFuIG91dHB1dCBkaXJlY3RvcnkgaXMgc3VwcGxpZWQsIHJlbGF0aXZlIHBhdGhzIGFyZSBldmFsdWF0ZWQgd2l0aFxuICAgKiByZXNwZWN0IHRvIHRoZSBjdXJyZW50IHByb2Nlc3MnIHdvcmtpbmcgZGlyZWN0b3J5LiBJZiBhbiBvdXRwdXQgZGlyZWN0b3J5XG4gICAqIGlzIG5vdCBzdXBwbGllZCwgdGhlIGRlZmF1bHQgaXMgYSBgY2RrLm91dGAgZGlyZWN0b3J5IHVuZGVybmVhdGhcbiAgICogYHdvcmtpbmdEaXJlY3RvcnlgLiBUaGUgb3V0cHV0IGRpcmVjdG9yeSB3aWxsIG5vdCBiZSBjbGVhbmVkIHVwIHVubGVzc1xuICAgKiBgZGlzcG9zZU91dGRpcjogdHJ1ZWAuXG4gICAqXG4gICAqIEEgd3JpdGUgbG9jayB3aWxsIGJlIGFjcXVpcmVkIG9uIHRoZSBvdXRwdXQgZGlyZWN0b3J5IGZvciB0aGUgZHVyYXRpb24gb2ZcbiAgICogdGhlIENESyBhcHAgc3ludGhlc2lzICh3aGljaCBtZWFucyB0aGF0IG5vIHR3byBhcHBzIGNhbiBzeW50aGVzaXplIGF0IHRoZVxuICAgKiBzYW1lIHRpbWUpLCBhbmQgYWZ0ZXIgc3ludGhlc2lzIGEgcmVhZCBsb2NrIHdpbGwgYmUgYWNxdWlyZWQgb24gdGhlXG4gICAqIGRpcmVjdG9yeS4gIFRoaXMgbWVhbnMgdGhhdCB3aGlsZSB0aGUgQ2xvdWRBc3NlbWJseSBpcyBiZWluZyB1c2VkLCBubyBDREtcbiAgICogYXBwIHN5bnRoZXNpcyBjYW4gdGFrZSBwbGFjZSBpbnRvIHRoYXQgZGlyZWN0b3J5LlxuICAgKlxuICAgKiAjIyBDb250ZXh0XG4gICAqXG4gICAqIElmIG5vIGBjb250ZXh0U3RvcmVgIGlzIGdpdmVuLCBhIGBDZGtBcHBNdWx0aUNvbnRleHRgIHdpbGwgYmUgdXNlZCwgaW5pdGlhbGl6ZWRcbiAgICogdG8gdGhlIGFwcCdzIGB3b3JraW5nRGlyZWN0b3J5YC4gVGhpcyBtZWFucyB0aGF0IGNvbnRleHQgd2lsbCBiZSBsb2FkZWQgZnJvbVxuICAgKiBhbGwgdGhlIENESydzIGRlZmF1bHQgY29udGV4dCBzb3VyY2VzLCBhbmQgdXBkYXRlcyB3aWxsIGJlIHdyaXR0ZW4gdG9cbiAgICogYGNkay5jb250ZXh0Lmpzb25gLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcHMgLSBhZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllc1xuICAgKiBAcmV0dXJucyB0aGUgQ2xvdWRBc3NlbWJseSBzb3VyY2VcbiAgICovXG4gIHB1YmxpYyBhc3luYyBmcm9tQ2RrQXBwKGFwcDogc3RyaW5nLCBwcm9wczogRnJvbUNka0FwcE9wdGlvbnMgPSB7fSk6IFByb21pc2U8SUNsb3VkQXNzZW1ibHlTb3VyY2U+IHtcbiAgICBjb25zdCBzZXJ2aWNlczogVG9vbGtpdFNlcnZpY2VzID0gYXdhaXQgdGhpcy5zb3VyY2VCdWlsZGVyU2VydmljZXMoKTtcbiAgICBjb25zdCB3b3JraW5nRGlyZWN0b3J5ID0gcHJvcHMud29ya2luZ0RpcmVjdG9yeSA/PyBwcm9jZXNzLmN3ZCgpO1xuICAgIGNvbnN0IG91dGRpciA9IHByb3BzLm91dGRpciA/IHBhdGgucmVzb2x2ZShwcm9wcy5vdXRkaXIpIDogcGF0aC5yZXNvbHZlKHdvcmtpbmdEaXJlY3RvcnksICdjZGsub3V0Jyk7XG5cbiAgICBjb25zdCBjb250ZXh0U3RvcmUgPSBwcm9wcy5jb250ZXh0U3RvcmUgPz8gbmV3IENka0FwcE11bHRpQ29udGV4dCh3b3JraW5nRGlyZWN0b3J5KTtcblxuICAgIGNvbnN0IGNvbnRleHRBc3NlbWJseVByb3BzOiBDb250ZXh0QXdhcmVDbG91ZEFzc2VtYmx5UHJvcHMgPSB7XG4gICAgICBzZXJ2aWNlcyxcbiAgICAgIGNvbnRleHRTdG9yZSxcbiAgICAgIGxvb2t1cHM6IHByb3BzLmxvb2t1cHMsXG4gICAgfTtcblxuICAgIHJldHVybiBuZXcgQ29udGV4dEF3YXJlQ2xvdWRBc3NlbWJseVNvdXJjZShcbiAgICAgIHtcbiAgICAgICAgcHJvZHVjZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIC8vIEB0b2RvIGJ1aWxkXG4gICAgICAgICAgLy8gY29uc3QgYnVpbGQgPSB0aGlzLnByb3BzLmNvbmZpZ3VyYXRpb24uc2V0dGluZ3MuZ2V0KFsnYnVpbGQnXSk7XG4gICAgICAgICAgLy8gaWYgKGJ1aWxkKSB7XG4gICAgICAgICAgLy8gICBhd2FpdCBleGVjSW5DaGlsZFByb2Nlc3MoYnVpbGQsIHsgY3dkOiBwcm9wcy53b3JraW5nRGlyZWN0b3J5IH0pO1xuICAgICAgICAgIC8vIH1cblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmcy5ta2RpcnBTeW5jKG91dGRpcik7XG4gICAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBDb3VsZCBub3QgY3JlYXRlIG91dHB1dCBkaXJlY3RvcnkgYXQgJyR7b3V0ZGlyfScgKCR7ZS5tZXNzYWdlfSkuYCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXdhaXQgdXNpbmcgZXhlY3V0aW9uID0gYXdhaXQgRXhlY3V0aW9uRW52aXJvbm1lbnQuY3JlYXRlKHNlcnZpY2VzLCB7IG91dGRpciB9KTtcblxuICAgICAgICAgIGNvbnN0IGNvbW1hbmRMaW5lID0gYXdhaXQgZXhlY3V0aW9uLmd1ZXNzRXhlY3V0YWJsZShhcHApO1xuXG4gICAgICAgICAgY29uc3Qgc3ludGhQYXJhbXMgPSBwYXJhbWV0ZXJzRnJvbVN5bnRoT3B0aW9ucyhwcm9wcy5zeW50aE9wdGlvbnMpO1xuXG4gICAgICAgICAgY29uc3QgZnVsbENvbnRleHQgPSB7XG4gICAgICAgICAgICAuLi5hd2FpdCBjb250ZXh0U3RvcmUucmVhZCgpLFxuICAgICAgICAgICAgLi4uc3ludGhQYXJhbXMuY29udGV4dCxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgYXdhaXQgc2VydmljZXMuaW9IZWxwZXIuZGVmYXVsdHMuZGVidWcoZm9ybWF0KCdjb250ZXh0OicsIGZ1bGxDb250ZXh0KSk7XG5cbiAgICAgICAgICBjb25zdCBlbnYgPSBub1VuZGVmaW5lZCh7XG4gICAgICAgICAgICAvLyBOZWVkIHRvIHN0YXJ0IHdpdGggZnVsbCBlbnYgb2YgYHdyaXRlQ29udGV4dFRvRW52YCB3aWxsIG5vdCBiZSBhYmxlIHRvIGRvIHRoZSBzaXplXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGlvbiBjb3JyZWN0bHkuXG4gICAgICAgICAgICAuLi5wcm9jZXNzLmVudixcbiAgICAgICAgICAgIC8vIFVzZXIgZ2F2ZSB1cyBzb21ldGhpbmdcbiAgICAgICAgICAgIC4uLnByb3BzLmVudixcbiAgICAgICAgICAgIC8vIFZlcnNpb25pbmcsIG91dGRpciwgZGVmYXVsdCBhY2NvdW50IGFuZCByZWdpb25cbiAgICAgICAgICAgIC4uLmF3YWl0IGV4ZWN1dGlvbi5kZWZhdWx0RW52VmFycygpLFxuICAgICAgICAgICAgLy8gRW52aXJvbm1lbnQgdmFyaWFibGVzIGRlcml2ZWQgZnJvbSBzZXR0aW5nc1xuICAgICAgICAgICAgLi4uc3ludGhQYXJhbXMuZW52LFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGNsZWFudXBUZW1wID0gd3JpdGVDb250ZXh0VG9FbnYoZW52LCBmdWxsQ29udGV4dCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGV4ZWNJbkNoaWxkUHJvY2Vzcyhjb21tYW5kTGluZS5qb2luKCcgJyksIHtcbiAgICAgICAgICAgICAgZXZlbnRQdWJsaXNoZXI6IGFzeW5jICh0eXBlLCBsaW5lKSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICdkYXRhX3N0ZG91dCc6XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHNlcnZpY2VzLmlvSGVscGVyLm5vdGlmeShJTy5DREtfQVNTRU1CTFlfSTEwMDEubXNnKGxpbmUpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICdkYXRhX3N0ZGVycic6XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHNlcnZpY2VzLmlvSGVscGVyLm5vdGlmeShJTy5DREtfQVNTRU1CTFlfRTEwMDIubXNnKGxpbmUpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBlbnYsXG4gICAgICAgICAgICAgIGN3ZDogd29ya2luZ0RpcmVjdG9yeSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBhd2FpdCBjbGVhbnVwVGVtcCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGFzbSA9IGF3YWl0IGFzc2VtYmx5RnJvbURpcmVjdG9yeShvdXRkaXIsIHNlcnZpY2VzLmlvSGVscGVyLCBwcm9wcy5sb2FkQXNzZW1ibHlPcHRpb25zKTtcblxuICAgICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCBleGVjdXRpb24ubWFya1N1Y2Nlc3NmdWwoKTtcbiAgICAgICAgICBjb25zdCBkZWxldGVPbkRpc3Bvc2UgPSBwcm9wcy5kaXNwb3NlT3V0ZGlyID8/IGV4ZWN1dGlvbi5vdXREaXJJc1RlbXBvcmFyeTtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlYWRhYmxlQ2xvdWRBc3NlbWJseShhc20sIHN1Y2Nlc3MucmVhZExvY2ssIHsgZGVsZXRlT25EaXNwb3NlIH0pO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGNvbnRleHRBc3NlbWJseVByb3BzLFxuICAgICk7XG4gIH1cbn1cblxuIl19