import { AsyncLocalStorage } from 'node:async_hooks';
import { generateCommandFailureHandler } from '../error_handler.js';
import { extractSubCommands } from '../extract_sub_commands.js';
class OutputInterceptor {
    output = '';
    append = (chunk) => {
        this.output += chunk;
    };
    getOutput = () => this.output;
}
const asyncLocalStorage = new AsyncLocalStorage();
// Casting original write to Function to disable compiler safety intentionally.
// The process.stdout.write has many overloads and it's impossible to get right types here.
// We're passing unchanged argument list to original method, therefore this is safe.
// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
const createInterceptedWrite = (originalWrite) => {
    return (...args) => {
        const interceptor = asyncLocalStorage.getStore();
        if (interceptor && args.length > 0 && typeof args[0] === 'string') {
            interceptor.append(args[0]);
        }
        return originalWrite(...args);
    };
};
const originalStdoutWrite = process.stdout.write.bind(process.stdout);
process.stdout.write = createInterceptedWrite(originalStdoutWrite);
const originalStderrWrite = process.stderr.write.bind(process.stderr);
process.stderr.write = createInterceptedWrite(originalStderrWrite);
/**
 * An error that has both output and error that occurred during command execution.
 */
export class TestCommandError extends Error {
    error;
    output;
    /**
     * Creates new test command error.
     */
    constructor(error, output) {
        super();
        this.error = error;
        this.output = output;
    }
}
/**
 * Runs commands given preconfigured yargs parser.
 */
export class TestCommandRunner {
    parser;
    usageDataEmitter;
    /**
     * Creates new command runner.
     */
    constructor(parser, usageDataEmitter = {
        emitFailure: () => Promise.resolve(),
        emitSuccess: () => Promise.resolve(),
    }) {
        this.parser = parser;
        this.usageDataEmitter = usageDataEmitter;
        this.parser = parser
            // Pin locale
            .locale('en')
            // Override script name to avoid long test file names
            .scriptName('ampx')
            // Make sure we don't exit process on error or --help
            .exitProcess(false)
            // attach the failure handler
            // this is necessary because we may be testing a subcommand that doesn't have the top-level failure handler attached
            // eventually we may want to have a separate "testFailureHandler" if we need additional tooling here
            .fail(generateCommandFailureHandler(parser, this.usageDataEmitter));
    }
    /**
     * Runs a command. Returns command output or throws an error if command failed.
     */
    runCommand = async (args) => {
        const interceptor = new OutputInterceptor();
        try {
            // We are using AsyncLocalStorage and OutputInterceptor to capture stdout and stdin streams into memory
            // instead of using parse/parseAsync with callback.
            // The reasons are:
            // - parse/parseAsync with callback leaves orphan promises that trigger unhandledRejection handler in tests
            // - parse/parseAsync with callback have edge cases if command builder and handler methods are sync or async
            //   see https://github.com/yargs/yargs/issues/1069
            //   and https://github.com/yargs/yargs/blob/main/docs/api.md#parseargs-context-parsecallback
            // - callback can only capture yargs logger outputs. it can't capture messages emitted from our code
            //
            // AsyncLocalStorage is used to make sure that we're capturing outputs only from the same asynchronous context
            // in potentially concurrent environment.
            await asyncLocalStorage.run(interceptor, async () => {
                await this.parser.parseAsync(args);
                const metricDimension = {};
                const subCommands = extractSubCommands(this.parser);
                if (subCommands) {
                    metricDimension.command = subCommands;
                }
                await this.usageDataEmitter.emitSuccess({}, metricDimension);
            });
            return interceptor.getOutput();
        }
        catch (err) {
            throw new TestCommandError(err, interceptor.getOutput());
        }
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tbWFuZF9ydW5uZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdGVzdC11dGlscy9jb21tYW5kX3J1bm5lci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUVyRCxPQUFPLEVBQUUsNkJBQTZCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNwRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUVoRSxNQUFNLGlCQUFpQjtJQUNiLE1BQU0sR0FBRyxFQUFFLENBQUM7SUFDcEIsTUFBTSxHQUFHLENBQUMsS0FBYSxFQUFFLEVBQUU7UUFDekIsSUFBSSxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUM7SUFDdkIsQ0FBQyxDQUFDO0lBQ0YsU0FBUyxHQUFHLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7Q0FDL0I7QUFFRCxNQUFNLGlCQUFpQixHQUFHLElBQUksaUJBQWlCLEVBQXFCLENBQUM7QUFFckUsK0VBQStFO0FBQy9FLDJGQUEyRjtBQUMzRixvRkFBb0Y7QUFDcEYsc0VBQXNFO0FBQ3RFLE1BQU0sc0JBQXNCLEdBQUcsQ0FBQyxhQUF1QixFQUFFLEVBQUU7SUFDekQsT0FBTyxDQUFDLEdBQUcsSUFBYSxFQUFFLEVBQUU7UUFDMUIsTUFBTSxXQUFXLEdBQ2YsaUJBQWlCLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDL0IsSUFBSSxXQUFXLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssUUFBUSxFQUFFLENBQUM7WUFDbEUsV0FBVyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM5QixDQUFDO1FBRUQsT0FBTyxhQUFhLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztJQUNoQyxDQUFDLENBQUM7QUFD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dXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFyZ3YgfSBmcm9tICd5YXJncyc7XG5pbXBvcnQgeyBBc3luY0xvY2FsU3RvcmFnZSB9IGZyb20gJ25vZGU6YXN5bmNfaG9va3MnO1xuaW1wb3J0IHsgVXNhZ2VEYXRhRW1pdHRlciB9IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbGF0Zm9ybS1jb3JlJztcbmltcG9ydCB7IGdlbmVyYXRlQ29tbWFuZEZhaWx1cmVIYW5kbGVyIH0gZnJvbSAnLi4vZXJyb3JfaGFuZGxlci5qcyc7XG5pbXBvcnQgeyBleHRyYWN0U3ViQ29tbWFuZHMgfSBmcm9tICcuLi9leHRyYWN0X3N1Yl9jb21tYW5kcy5qcyc7XG5cbmNsYXNzIE91dHB1dEludGVyY2VwdG9yIHtcbiAgcHJpdmF0ZSBvdXRwdXQgPSAnJztcbiAgYXBwZW5kID0gKGNodW5rOiBzdHJpbmcpID0+IHtcbiAgICB0aGlzLm91dHB1dCArPSBjaHVuaztcbiAgfTtcbiAgZ2V0T3V0cHV0ID0gKCkgPT4gdGhpcy5vdXRwdXQ7XG59XG5cbmNvbnN0IGFzeW5jTG9jYWxTdG9yYWdlID0gbmV3IEFzeW5jTG9jYWxTdG9yYWdlPE91dHB1dEludGVyY2VwdG9yPigpO1xuXG4vLyBDYXN0aW5nIG9yaWdpbmFsIHdyaXRlIHRvIEZ1bmN0aW9uIHRvIGRpc2FibGUgY29tcGlsZXIgc2FmZXR5IGludGVudGlvbmFsbHkuXG4vLyBUaGUgcHJvY2Vzcy5zdGRvdXQud3JpdGUgaGFzIG1hbnkgb3ZlcmxvYWRzIGFuZCBpdCdzIGltcG9zc2libGUgdG8gZ2V0IHJpZ2h0IHR5cGVzIGhlcmUuXG4vLyBXZSdyZSBwYXNzaW5nIHVuY2hhbmdlZCBhcmd1bWVudCBsaXN0IHRvIG9yaWdpbmFsIG1ldGhvZCwgdGhlcmVmb3JlIHRoaXMgaXMgc2FmZS5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWZ1bmN0aW9uLXR5cGVcbmNvbnN0IGNyZWF0ZUludGVyY2VwdGVkV3JpdGUgPSAob3JpZ2luYWxXcml0ZTogRnVuY3Rpb24pID0+IHtcbiAgcmV0dXJuICguLi5hcmdzOiBuZXZlcltdKSA9PiB7XG4gICAgY29uc3QgaW50ZXJjZXB0b3I6IE91dHB1dEludGVyY2VwdG9yIHwgdW5kZWZpbmVkID1cbiAgICAgIGFzeW5jTG9jYWxTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgaWYgKGludGVyY2VwdG9yICYmIGFyZ3MubGVuZ3RoID4gMCAmJiB0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGludGVyY2VwdG9yLmFwcGVuZChhcmdzWzBdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3JpZ2luYWxXcml0ZSguLi5hcmdzKTtcbiAgfTtcbn07XG5jb25zdCBvcmlnaW5hbFN0ZG91dFdyaXRlID0gcHJvY2Vzcy5zdGRvdXQud3JpdGUuYmluZChwcm9jZXNzLnN0ZG91dCk7XG5wcm9jZXNzLnN0ZG91dC53cml0ZSA9IGNyZWF0ZUludGVyY2VwdGVkV3JpdGUob3JpZ2luYWxTdGRvdXRXcml0ZSk7XG5cbmNvbnN0IG9yaWdpbmFsU3RkZXJyV3JpdGUgPSBwcm9jZXNzLnN0ZGVyci53cml0ZS5iaW5kKHByb2Nlc3Muc3RkZXJyKTtcbnByb2Nlc3Muc3RkZXJyLndyaXRlID0gY3JlYXRlSW50ZXJjZXB0ZWRXcml0ZShvcmlnaW5hbFN0ZGVycldyaXRlKTtcblxuLyoqXG4gKiBBbiBlcnJvciB0aGF0IGhhcyBib3RoIG91dHB1dCBhbmQgZXJyb3IgdGhhdCBvY2N1cnJlZCBkdXJpbmcgY29tbWFuZCBleGVjdXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBUZXN0Q29tbWFuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogQ3JlYXRlcyBuZXcgdGVzdCBjb21tYW5kIGVycm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcmVhZG9ubHkgZXJyb3I6IEVycm9yLFxuICAgIHJlYWRvbmx5IG91dHB1dDogc3RyaW5nLFxuICApIHtcbiAgICBzdXBlcigpO1xuICB9XG59XG5cbi8qKlxuICogUnVucyBjb21tYW5kcyBnaXZlbiBwcmVjb25maWd1cmVkIHlhcmdzIHBhcnNlci5cbiAqL1xuZXhwb3J0IGNsYXNzIFRlc3RDb21tYW5kUnVubmVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgbmV3IGNvbW1hbmQgcnVubmVyLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBwYXJzZXI6IEFyZ3YsXG4gICAgcHJpdmF0ZSB1c2FnZURhdGFFbWl0dGVyOiBVc2FnZURhdGFFbWl0dGVyID0ge1xuICAgICAgZW1pdEZhaWx1cmU6ICgpID0+IFByb21pc2UucmVzb2x2ZSgpLFxuICAgICAgZW1pdFN1Y2Nlc3M6ICgpID0+IFByb21pc2UucmVzb2x2ZSgpLFxuICAgIH0sXG4gICkge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyXG4gICAgICAvLyBQaW4gbG9jYWxlXG4gICAgICAubG9jYWxlKCdlbicpXG4gICAgICAvLyBPdmVycmlkZSBzY3JpcHQgbmFtZSB0byBhdm9pZCBsb25nIHRlc3QgZmlsZSBuYW1lc1xuICAgICAgLnNjcmlwdE5hbWUoJ2FtcHgnKVxuICAgICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IGV4aXQgcHJvY2VzcyBvbiBlcnJvciBvciAtLWhlbHBcbiAgICAgIC5leGl0UHJvY2VzcyhmYWxzZSlcbiAgICAgIC8vIGF0dGFjaCB0aGUgZmFpbHVyZSBoYW5kbGVyXG4gICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHdlIG1heSBiZSB0ZXN0aW5nIGEgc3ViY29tbWFuZCB0aGF0IGRvZXNuJ3QgaGF2ZSB0aGUgdG9wLWxldmVsIGZhaWx1cmUgaGFuZGxlciBhdHRhY2hlZFxuICAgICAgLy8gZXZlbnR1YWxseSB3ZSBtYXkgd2FudCB0byBoYXZlIGEgc2VwYXJhdGUgXCJ0ZXN0RmFpbHVyZUhhbmRsZXJcIiBpZiB3ZSBuZWVkIGFkZGl0aW9uYWwgdG9vbGluZyBoZXJlXG4gICAgICAuZmFpbChnZW5lcmF0ZUNvbW1hbmRGYWlsdXJlSGFuZGxlcihwYXJzZXIsIHRoaXMudXNhZ2VEYXRhRW1pdHRlcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgYSBjb21tYW5kLiBSZXR1cm5zIGNvbW1hbmQgb3V0cHV0IG9yIHRocm93cyBhbiBlcnJvciBpZiBjb21tYW5kIGZhaWxlZC5cbiAgICovXG4gIHJ1bkNvbW1hbmQgPSBhc3luYyAoYXJnczogc3RyaW5nIHwgQXJyYXk8c3RyaW5nPik6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgY29uc3QgaW50ZXJjZXB0b3IgPSBuZXcgT3V0cHV0SW50ZXJjZXB0b3IoKTtcbiAgICB0cnkge1xuICAgICAgLy8gV2UgYXJlIHVzaW5nIEFzeW5jTG9jYWxTdG9yYWdlIGFuZCBPdXRwdXRJbnRlcmNlcHRvciB0byBjYXB0dXJlIHN0ZG91dCBhbmQgc3RkaW4gc3RyZWFtcyBpbnRvIG1lbW9yeVxuICAgICAgLy8gaW5zdGVhZCBvZiB1c2luZyBwYXJzZS9wYXJzZUFzeW5jIHdpdGggY2FsbGJhY2suXG4gICAgICAvLyBUaGUgcmVhc29ucyBhcmU6XG4gICAgICAvLyAtIHBhcnNlL3BhcnNlQXN5bmMgd2l0aCBjYWxsYmFjayBsZWF2ZXMgb3JwaGFuIHByb21pc2VzIHRoYXQgdHJpZ2dlciB1bmhhbmRsZWRSZWplY3Rpb24gaGFuZGxlciBpbiB0ZXN0c1xuICAgICAgLy8gLSBwYXJzZS9wYXJzZUFzeW5jIHdpdGggY2FsbGJhY2sgaGF2ZSBlZGdlIGNhc2VzIGlmIGNvbW1hbmQgYnVpbGRlciBhbmQgaGFuZGxlciBtZXRob2RzIGFyZSBzeW5jIG9yIGFzeW5jXG4gICAgICAvLyAgIHNlZSBodHRwczovL2dpdGh1Yi5jb20veWFyZ3MveWFyZ3MvaXNzdWVzLzEwNjlcbiAgICAgIC8vICAgYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS95YXJncy95YXJncy9ibG9iL21haW4vZG9jcy9hcGkubWQjcGFyc2VhcmdzLWNvbnRleHQtcGFyc2VjYWxsYmFja1xuICAgICAgLy8gLSBjYWxsYmFjayBjYW4gb25seSBjYXB0dXJlIHlhcmdzIGxvZ2dlciBvdXRwdXRzLiBpdCBjYW4ndCBjYXB0dXJlIG1lc3NhZ2VzIGVtaXR0ZWQgZnJvbSBvdXIgY29kZVxuICAgICAgLy9cbiAgICAgIC8vIEFzeW5jTG9jYWxTdG9yYWdlIGlzIHVzZWQgdG8gbWFrZSBzdXJlIHRoYXQgd2UncmUgY2FwdHVyaW5nIG91dHB1dHMgb25seSBmcm9tIHRoZSBzYW1lIGFzeW5jaHJvbm91cyBjb250ZXh0XG4gICAgICAvLyBpbiBwb3RlbnRpYWxseSBjb25jdXJyZW50IGVudmlyb25tZW50LlxuICAgICAgYXdhaXQgYXN5bmNMb2NhbFN0b3JhZ2UucnVuKGludGVyY2VwdG9yLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHRoaXMucGFyc2VyLnBhcnNlQXN5bmMoYXJncyk7XG4gICAgICAgIGNvbnN0IG1ldHJpY0RpbWVuc2lvbjogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICAgICAgICBjb25zdCBzdWJDb21tYW5kcyA9IGV4dHJhY3RTdWJDb21tYW5kcyh0aGlzLnBhcnNlcik7XG5cbiAgICAgICAgaWYgKHN1YkNvbW1hbmRzKSB7XG4gICAgICAgICAgbWV0cmljRGltZW5zaW9uLmNvbW1hbmQgPSBzdWJDb21tYW5kcztcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnVzYWdlRGF0YUVtaXR0ZXIuZW1pdFN1Y2Nlc3Moe30sIG1ldHJpY0RpbWVuc2lvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpbnRlcmNlcHRvci5nZXRPdXRwdXQoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBUZXN0Q29tbWFuZEVycm9yKGVyciBhcyBFcnJvciwgaW50ZXJjZXB0b3IuZ2V0T3V0cHV0KCkpO1xuICAgIH1cbiAgfTtcbn1cbiJdfQ==