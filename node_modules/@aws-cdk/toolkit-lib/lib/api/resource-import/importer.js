"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourceImporter = void 0;
exports.removeNonImportResources = removeNonImportResources;
const util_1 = require("util");
const cfnDiff = require("@aws-cdk/cloudformation-diff");
const chalk = require("chalk");
const fs = require("fs-extra");
const toolkit_error_1 = require("../../toolkit/toolkit-error");
const deployments_1 = require("../deployments");
const private_1 = require("../io/private");
/**
 * Resource importing utility class
 *
 * - Determines the resources added to a template (compared to the deployed version)
 * - Look up the identification information
 *   - Load them from a file, or
 *   - Ask the user, based on information supplied to us by CloudFormation's GetTemplateSummary
 * - Translate the input to a structure expected by CloudFormation, update the template to add the
 *   importable resources, then run an IMPORT changeset.
 */
class ResourceImporter {
    _currentTemplate;
    stack;
    cfn;
    ioHelper;
    constructor(stack, props) {
        this.stack = stack;
        this.cfn = props.deployments;
        this.ioHelper = props.ioHelper;
    }
    /**
     * Ask the user for resources to import
     */
    async askForResourceIdentifiers(available) {
        const ret = { importResources: [], resourceMap: {} };
        const resourceIdentifiers = await this.resourceIdentifiers();
        for (const resource of available) {
            const identifier = await this.askForResourceIdentifier(resourceIdentifiers, resource);
            if (!identifier) {
                continue;
            }
            ret.importResources.push(resource);
            ret.resourceMap[resource.logicalId] = identifier;
        }
        return ret;
    }
    /**
     * Load the resources to import from a file
     */
    async loadResourceIdentifiers(available, filename) {
        const contents = await fs.readJson(filename);
        const ret = { importResources: [], resourceMap: {} };
        for (const resource of available) {
            const descr = this.describeResource(resource.logicalId);
            const idProps = contents[resource.logicalId];
            if (idProps) {
                await this.ioHelper.defaults.info((0, util_1.format)('%s: importing using %s', chalk.blue(descr), chalk.blue(fmtdict(idProps))));
                ret.importResources.push(resource);
                ret.resourceMap[resource.logicalId] = idProps;
                delete contents[resource.logicalId];
            }
            else {
                await this.ioHelper.defaults.info((0, util_1.format)('%s: skipping', chalk.blue(descr)));
            }
        }
        const unknown = Object.keys(contents);
        if (unknown.length > 0) {
            await this.ioHelper.defaults.warn(`Unrecognized resource identifiers in mapping file: ${unknown.join(', ')}`);
        }
        return ret;
    }
    /**
     * Based on the provided resource mapping, prepare CFN structures for import (template,
     * ResourcesToImport structure) and perform the import operation (CloudFormation deployment)
     *
     * @param importMap - Mapping from CDK construct tree path to physical resource import identifiers
     * @param options - Options to pass to CloudFormation deploy operation
     */
    async importResourcesFromMap(importMap, options = {}) {
        const resourcesToImport = await this.makeResourcesToImport(importMap);
        const updatedTemplate = await this.currentTemplateWithAdditions(importMap.importResources);
        await this.importResources(updatedTemplate, resourcesToImport, options);
    }
    /**
     * Based on the app and resources file generated by cdk migrate. Removes all items from the template that
     * cannot be included in an import change-set for new stacks and performs the import operation,
     * creating the new stack.
     *
     * @param resourcesToImport - The mapping created by cdk migrate
     * @param options - Options to pass to CloudFormation deploy operation
     */
    async importResourcesFromMigrate(resourcesToImport, options = {}) {
        const updatedTemplate = this.removeNonImportResources();
        await this.importResources(updatedTemplate, resourcesToImport, options);
    }
    async importResources(overrideTemplate, resourcesToImport, options) {
        try {
            const result = await this.cfn.deployStack({
                stack: this.stack,
                deployName: this.stack.stackName,
                ...options,
                overrideTemplate,
                resourcesToImport,
            });
            (0, deployments_1.assertIsSuccessfulDeployStackResult)(result);
            const message = result.noOp
                ? ' ✅  %s (no changes)'
                : ' ✅  %s';
            await this.ioHelper.defaults.info('\n' + chalk.green((0, util_1.format)(message, this.stack.displayName)));
        }
        catch (e) {
            await this.ioHelper.notify(private_1.IO.CDK_TOOLKIT_E3900.msg((0, util_1.format)('\n ❌  %s failed: %s', chalk.bold(this.stack.displayName), e), { error: e }));
            throw e;
        }
    }
    /**
     * Perform a diff between the currently running and the new template, ensure that it is valid
     * for importing and return a list of resources that are being added in the new version
     *
     * @return mapping logicalResourceId -> resourceDifference
     */
    async discoverImportableResources(allowNonAdditions = false) {
        const currentTemplate = await this.currentTemplate();
        const diff = cfnDiff.fullDiff(currentTemplate, this.stack.template);
        // Ignore changes to CDKMetadata
        const resourceChanges = Object.entries(diff.resources.changes)
            .filter(([logicalId, _]) => logicalId !== 'CDKMetadata');
        // Split the changes into additions and non-additions. Imports only make sense
        // for newly-added resources.
        const nonAdditions = resourceChanges.filter(([_, dif]) => !dif.isAddition);
        const additions = resourceChanges.filter(([_, dif]) => dif.isAddition);
        if (nonAdditions.length) {
            const offendingResources = nonAdditions.map(([logId, _]) => this.describeResource(logId));
            if (allowNonAdditions) {
                await this.ioHelper.defaults.warn(`Ignoring updated/deleted resources (--force): ${offendingResources.join(', ')}`);
            }
            else {
                throw new toolkit_error_1.ToolkitError('No resource updates or deletes are allowed on import operation. Make sure to resolve pending changes ' +
                    `to existing resources, before attempting an import. Updated/deleted resources: ${offendingResources.join(', ')} (--force to override)`);
            }
        }
        // Resources in the new template, that are not present in the current template, are a potential import candidates
        return {
            additions: additions.map(([logicalId, resourceDiff]) => ({
                logicalId,
                resourceDiff,
                resourceDefinition: addDefaultDeletionPolicy(this.stack.template?.Resources?.[logicalId] ?? {}),
            })),
            hasNonAdditions: nonAdditions.length > 0,
        };
    }
    /**
     * Resolves the environment of a stack.
     */
    async resolveEnvironment() {
        return this.cfn.resolveEnvironment(this.stack);
    }
    /**
     * Get currently deployed template of the given stack (SINGLETON)
     *
     * @returns Currently deployed CloudFormation template
     */
    async currentTemplate() {
        if (!this._currentTemplate) {
            this._currentTemplate = await this.cfn.readCurrentTemplate(this.stack);
        }
        return this._currentTemplate;
    }
    /**
     * Return the current template, with the given resources added to it
     */
    async currentTemplateWithAdditions(additions) {
        const template = await this.currentTemplate();
        if (!template.Resources) {
            template.Resources = {};
        }
        for (const add of additions) {
            template.Resources[add.logicalId] = add.resourceDefinition;
        }
        return template;
    }
    /**
     * Get a list of import identifiers for all resource types used in the given
     * template that do support the import operation (SINGLETON)
     *
     * @returns a mapping from a resource type to a list of property names that together identify the resource for import
     */
    async resourceIdentifiers() {
        const ret = {};
        const resourceIdentifierSummaries = await this.cfn.resourceIdentifierSummaries(this.stack);
        for (const summary of resourceIdentifierSummaries) {
            if ('ResourceType' in summary && summary.ResourceType && 'ResourceIdentifiers' in summary && summary.ResourceIdentifiers) {
                ret[summary.ResourceType] = (summary.ResourceIdentifiers ?? [])?.map(x => x.split(','));
            }
        }
        return ret;
    }
    /**
     * Ask for the importable identifier for the given resource
     *
     * There may be more than one identifier under which a resource can be imported. The `import`
     * operation needs exactly one of them.
     *
     * - If we can get one from the template, we will use one.
     * - Otherwise, we will ask the user for one of them.
     */
    async askForResourceIdentifier(resourceIdentifiers, chg) {
        const resourceName = this.describeResource(chg.logicalId);
        // Skip resources that do not support importing
        const resourceType = chg.resourceDiff.newResourceType;
        if (resourceType === undefined || !(resourceType in resourceIdentifiers)) {
            await this.ioHelper.defaults.warn(`${resourceName}: unsupported resource type ${resourceType}, skipping import.`);
            return undefined;
        }
        const idPropSets = resourceIdentifiers[resourceType];
        // Retain only literal strings: strip potential CFN intrinsics
        const resourceProps = Object.fromEntries(Object.entries(chg.resourceDefinition.Properties ?? {})
            .filter(([_, v]) => typeof v === 'string'));
        // Find property sets that are fully satisfied in the template, ask the user to confirm them
        const satisfiedPropSets = idPropSets.filter(ps => ps.every(p => resourceProps[p]));
        for (const satisfiedPropSet of satisfiedPropSets) {
            const candidateProps = Object.fromEntries(satisfiedPropSet.map(p => [p, resourceProps[p]]));
            const displayCandidateProps = fmtdict(candidateProps);
            const importTheResource = await this.ioHelper.requestResponse(private_1.IO.CDK_TOOLKIT_I3100.req(`${chalk.blue(resourceName)} (${resourceType}): import with ${chalk.yellow(displayCandidateProps)}`, {
                resource: {
                    type: resourceType,
                    props: candidateProps,
                    stringifiedProps: displayCandidateProps,
                },
            }));
            if (importTheResource) {
                return candidateProps;
            }
        }
        // If we got here and the user rejected any available identifiers, then apparently they don't want the resource at all
        if (satisfiedPropSets.length > 0) {
            await this.ioHelper.defaults.info(chalk.grey(`Skipping import of ${resourceName}`));
            return undefined;
        }
        // We cannot auto-import this, ask the user for one of the props
        // The only difference between these cases is what we print: for multiple properties, we print a preamble
        const prefix = `${chalk.blue(resourceName)} (${resourceType})`;
        const promptPattern = `${prefix}: enter %s`;
        if (idPropSets.length > 1) {
            const preamble = `${prefix}: enter one of ${idPropSets.map(x => chalk.blue(x.join('+'))).join(', ')} to import (leave all empty to skip)`;
            await this.ioHelper.defaults.info(preamble);
        }
        // Do the input loop here
        for (const idProps of idPropSets) {
            const input = {};
            for (const idProp of idProps) {
                // If we have a value from the template, use it as default. This will only be a partial
                // identifier if present, otherwise we would have done the import already above.
                const defaultValue = resourceProps[idProp] ?? '';
                const response = await this.ioHelper.requestResponse(private_1.IO.CDK_TOOLKIT_I3110.req((0, util_1.format)(promptPattern, chalk.blue(idProp)), {
                    resource: {
                        name: resourceName,
                        type: resourceType,
                        idProp,
                    },
                    responseDescription: defaultValue ? undefined : 'empty to skip',
                }, defaultValue));
                if (!response) {
                    break;
                }
                input[idProp] = response;
                // Also stick this property into 'resourceProps', so that it may be reused by a subsequent question
                // (for a different compound identifier that involves the same property). Just a small UX enhancement.
                resourceProps[idProp] = response;
            }
            // If the user gave inputs for all values, we are complete
            if (Object.keys(input).length === idProps.length) {
                return input;
            }
        }
        await this.ioHelper.defaults.info(chalk.grey(`Skipping import of ${resourceName}`));
        return undefined;
    }
    /**
     * Convert the internal "resource mapping" structure to CloudFormation accepted "ResourcesToImport" structure
     */
    async makeResourcesToImport(resourceMap) {
        return resourceMap.importResources.map(res => ({
            LogicalResourceId: res.logicalId,
            ResourceType: res.resourceDiff.newResourceType,
            ResourceIdentifier: resourceMap.resourceMap[res.logicalId],
        }));
    }
    /**
     * Convert CloudFormation logical resource ID to CDK construct tree path
     *
     * @param logicalId - CloudFormation logical ID of the resource (the key in the template's Resources section)
     * @returns Forward-slash separated path of the resource in CDK construct tree, e.g. MyStack/MyBucket/Resource
     */
    describeResource(logicalId) {
        return this.stack.template?.Resources?.[logicalId]?.Metadata?.['aws:cdk:path'] ?? logicalId;
    }
    /**
     * Removes CDKMetadata and Outputs in the template so that only resources for importing are left.
     * @returns template with import resources only
     */
    removeNonImportResources() {
        return removeNonImportResources(this.stack);
    }
}
exports.ResourceImporter = ResourceImporter;
function fmtdict(xs) {
    return Object.entries(xs).map(([k, v]) => `${k}=${v}`).join(', ');
}
/**
 * Add a default `DeletionPolicy` policy.
 * The default value is set to 'Retain', to lower risk of unintentionally
 * deleting stateful resources in the process of importing to CDK.
 */
function addDefaultDeletionPolicy(resource) {
    if (resource.DeletionPolicy) {
        return resource;
    }
    return {
        ...resource,
        DeletionPolicy: 'Retain',
    };
}
function removeNonImportResources(stack) {
    const template = stack.template;
    delete template.Resources.CDKMetadata;
    delete template.Outputs;
    return template;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW1wb3J0ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbXBvcnRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUE2ZkEsNERBS0M7QUFsZ0JELCtCQUE4QjtBQUM5Qix3REFBd0Q7QUFJeEQsK0JBQStCO0FBQy9CLCtCQUErQjtBQUUvQiwrREFBMkQ7QUFFM0QsZ0RBQXFFO0FBQ3JFLDJDQUFrRDtBQW1GbEQ7Ozs7Ozs7OztHQVNHO0FBQ0gsTUFBYSxnQkFBZ0I7SUFDbkIsZ0JBQWdCLENBQU07SUFFYixLQUFLLENBQW9DO0lBQ3pDLEdBQUcsQ0FBYztJQUNqQixRQUFRLENBQVc7SUFFcEMsWUFDRSxLQUF3QyxFQUN4QyxLQUE0QjtRQUU1QixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUM7UUFDN0IsSUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDO0lBQ2pDLENBQUM7SUFFRDs7T0FFRztJQUNJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxTQUErQjtRQUNwRSxNQUFNLEdBQUcsR0FBYyxFQUFFLGVBQWUsRUFBRSxFQUFFLEVBQUUsV0FBVyxFQUFFLEVBQUUsRUFBRSxDQUFDO1FBQ2hFLE1BQU0sbUJBQW1CLEdBQUcsTUFBTSxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztRQUU3RCxLQUFLLE1BQU0sUUFBUSxJQUFJLFNBQVMsRUFBRSxDQUFDO1lBQ2pDLE1BQU0sVUFBVSxHQUFHLE1BQU0sSUFBSSxDQUFDLHdCQUF3QixDQUFDLG1CQUFtQixFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQ3RGLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztnQkFDaEIsU0FBUztZQUNYLENBQUM7WUFFRCxHQUFHLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUNuQyxHQUFHLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FB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LENBQUMsUUFBUSxDQUFDO0lBQ2hDLE9BQU8sUUFBUSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUM7SUFDdEMsT0FBTyxRQUFRLENBQUMsT0FBTyxDQUFDO0lBQ3hCLE9BQU8sUUFBUSxDQUFDO0FBQ2xCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmb3JtYXQgfSBmcm9tICd1dGlsJztcbmltcG9ydCAqIGFzIGNmbkRpZmYgZnJvbSAnQGF3cy1jZGsvY2xvdWRmb3JtYXRpb24tZGlmZic7XG5pbXBvcnQgdHlwZSB7IFJlc291cmNlRGlmZmVyZW5jZSB9IGZyb20gJ0Bhd3MtY2RrL2Nsb3VkZm9ybWF0aW9uLWRpZmYnO1xuaW1wb3J0IHR5cGUgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHR5cGUgeyBSZXNvdXJjZUlkZW50aWZpZXJTdW1tYXJ5LCBSZXNvdXJjZVRvSW1wb3J0IH0gZnJvbSAnQGF3cy1zZGsvY2xpZW50LWNsb3VkZm9ybWF0aW9uJztcbmltcG9ydCAqIGFzIGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCB0eXBlIHsgRGVwbG95bWVudE1ldGhvZCB9IGZyb20gJy4uLy4uL2FjdGlvbnMvZGVwbG95JztcbmltcG9ydCB7IFRvb2xraXRFcnJvciB9IGZyb20gJy4uLy4uL3Rvb2xraXQvdG9vbGtpdC1lcnJvcic7XG5pbXBvcnQgdHlwZSB7IERlcGxveW1lbnRzIH0gZnJvbSAnLi4vZGVwbG95bWVudHMnO1xuaW1wb3J0IHsgYXNzZXJ0SXNTdWNjZXNzZnVsRGVwbG95U3RhY2tSZXN1bHQgfSBmcm9tICcuLi9kZXBsb3ltZW50cyc7XG5pbXBvcnQgeyBJTywgdHlwZSBJb0hlbHBlciB9IGZyb20gJy4uL2lvL3ByaXZhdGUnO1xuaW1wb3J0IHR5cGUgeyBUYWcgfSBmcm9tICcuLi90YWdzJztcblxuZXhwb3J0IHR5cGUgUmVzb3VyY2VzVG9JbXBvcnQgPSBSZXNvdXJjZVRvSW1wb3J0W107XG5leHBvcnQgdHlwZSBSZXNvdXJjZUlkZW50aWZpZXJTdW1tYXJpZXMgPSBSZXNvdXJjZUlkZW50aWZpZXJTdW1tYXJ5W107XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb3VyY2VJbXBvcnRlclByb3BzIHtcbiAgZGVwbG95bWVudHM6IERlcGxveW1lbnRzO1xuICBpb0hlbHBlcjogSW9IZWxwZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1wb3J0RGVwbG95bWVudE9wdGlvbnMge1xuICAvKipcbiAgICogUm9sZSB0byBwYXNzIHRvIENsb3VkRm9ybWF0aW9uIGZvciBkZXBsb3ltZW50XG4gICAqXG4gICAqIEBkZWZhdWx0IC0gRGVmYXVsdCBzdGFjayByb2xlXG4gICAqL1xuICByZWFkb25seSByb2xlQXJuPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBEZXBsb3ltZW50IG1ldGhvZFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIENoYW5nZSBzZXQgd2l0aCBkZWZhdWx0IG9wdGlvbnNcbiAgICovXG4gIHJlYWRvbmx5IGRlcGxveW1lbnRNZXRob2Q/OiBEZXBsb3ltZW50TWV0aG9kO1xuXG4gIC8qKlxuICAgKiBTdGFjayB0YWdzIChwYXNzIHRocm91Z2ggdG8gQ2xvdWRGb3JtYXRpb24pXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gdGFnc1xuICAgKi9cbiAgcmVhZG9ubHkgdGFncz86IFRhZ1tdO1xuXG4gIC8qKlxuICAgKiBVc2UgcHJldmlvdXMgdmFsdWVzIGZvciB1bnNwZWNpZmllZCBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIElmIG5vdCBzZXQsIGFsbCBwYXJhbWV0ZXJzIG11c3QgYmUgc3BlY2lmaWVkIGZvciBldmVyeSBkZXBsb3ltZW50LlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSB1c2VQcmV2aW91c1BhcmFtZXRlcnM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBSb2xsYmFjayBmYWlsZWQgZGVwbG95bWVudHNcbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgcm9sbGJhY2s/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFNldCBvZiBwYXJhbWV0ZXJzIHRoYXQgdW5pcXVlbHkgaWRlbnRpZnkgYSBwaHlzaWNhbCByZXNvdXJjZSBvZiBhIGdpdmVuIHR5cGVcbiAqIGZvciB0aGUgaW1wb3J0IG9wZXJhdGlvbiwgZXhhbXBsZTpcbiAqXG4gKiBgYGBcbiAqIHtcbiAqICAgXCJBV1M6OlMzOjpCdWNrZXRcIjogW1tcIkJ1Y2tldE5hbWVcIl1dLFxuICogICBcIkFXUzo6RHluYW1vREI6Okdsb2JhbFRhYmxlXCI6IFtbXCJUYWJsZU5hbWVcIl0sIFtcIlRhYmxlQXJuXCJdLCBbXCJUYWJsZVN0cmVhbUFyblwiXV0sXG4gKiAgIFwiQVdTOjpSb3V0ZTUzOjpLZXlTaWduaW5nS2V5XCI6IFtbXCJIb3N0ZWRab25lSWRcIiwgXCJOYW1lXCJdXSxcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgdHlwZSBSZXNvdXJjZUlkZW50aWZpZXJzID0geyBbcmVzb3VyY2VUeXBlOiBzdHJpbmddOiBzdHJpbmdbXVtdIH07XG5cbnR5cGUgUmVzb3VyY2VJZGVudGlmaWVyUHJvcGVydGllcyA9IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG5cbi8qKlxuICogTWFwcGluZyBvZiBDREsgcmVzb3VyY2VzIChMMSBjb25zdHJ1Y3RzKSB0byBwaHlzaWNhbCByZXNvdXJjZXMgdG8gYmUgaW1wb3J0ZWRcbiAqIGluIHRoZWlyIHBsYWNlLCBleGFtcGxlOlxuICpcbiAqIGBgYFxuICoge1xuICogICBcIk15U3RhY2svTXlTM0J1Y2tldC9SZXNvdXJjZVwiOiB7XG4gKiAgICAgXCJCdWNrZXROYW1lXCI6IFwibXktbWFudWFsbHktY3JlYXRlZC1zMy1idWNrZXRcIlxuICogICB9LFxuICogICBcIk15U3RhY2svTXlWcGMvUmVzb3VyY2VcIjoge1xuICogICAgIFwiVnBjSWRcIjogXCJ2cGMtMTIzNDU2Nzg5XCJcbiAqICAgfVxuICogfVxuICogYGBgXG4gKi9cbnR5cGUgUmVzb3VyY2VNYXAgPSB7IFtsb2dpY2FsUmVzb3VyY2U6IHN0cmluZ106IFJlc291cmNlSWRlbnRpZmllclByb3BlcnRpZXMgfTtcblxuLyoqXG4gKiBSZXNvdXJjZSBpbXBvcnRpbmcgdXRpbGl0eSBjbGFzc1xuICpcbiAqIC0gRGV0ZXJtaW5lcyB0aGUgcmVzb3VyY2VzIGFkZGVkIHRvIGEgdGVtcGxhdGUgKGNvbXBhcmVkIHRvIHRoZSBkZXBsb3llZCB2ZXJzaW9uKVxuICogLSBMb29rIHVwIHRoZSBpZGVudGlmaWNhdGlvbiBpbmZvcm1hdGlvblxuICogICAtIExvYWQgdGhlbSBmcm9tIGEgZmlsZSwgb3JcbiAqICAgLSBBc2sgdGhlIHVzZXIsIGJhc2VkIG9uIGluZm9ybWF0aW9uIHN1cHBsaWVkIHRvIHVzIGJ5IENsb3VkRm9ybWF0aW9uJ3MgR2V0VGVtcGxhdGVTdW1tYXJ5XG4gKiAtIFRyYW5zbGF0ZSB0aGUgaW5wdXQgdG8gYSBzdHJ1Y3R1cmUgZXhwZWN0ZWQgYnkgQ2xvdWRGb3JtYXRpb24sIHVwZGF0ZSB0aGUgdGVtcGxhdGUgdG8gYWRkIHRoZVxuICogICBpbXBvcnRhYmxlIHJlc291cmNlcywgdGhlbiBydW4gYW4gSU1QT1JUIGNoYW5nZXNldC5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlc291cmNlSW1wb3J0ZXIge1xuICBwcml2YXRlIF9jdXJyZW50VGVtcGxhdGU6IGFueTtcblxuICBwcml2YXRlIHJlYWRvbmx5IHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q7XG4gIHByaXZhdGUgcmVhZG9ubHkgY2ZuOiBEZXBsb3ltZW50cztcbiAgcHJpdmF0ZSByZWFkb25seSBpb0hlbHBlcjogSW9IZWxwZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgc3RhY2s6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCxcbiAgICBwcm9wczogUmVzb3VyY2VJbXBvcnRlclByb3BzLFxuICApIHtcbiAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgdGhpcy5jZm4gPSBwcm9wcy5kZXBsb3ltZW50cztcbiAgICB0aGlzLmlvSGVscGVyID0gcHJvcHMuaW9IZWxwZXI7XG4gIH1cblxuICAvKipcbiAgICogQXNrIHRoZSB1c2VyIGZvciByZXNvdXJjZXMgdG8gaW1wb3J0XG4gICAqL1xuICBwdWJsaWMgYXN5bmMgYXNrRm9yUmVzb3VyY2VJZGVudGlmaWVycyhhdmFpbGFibGU6IEltcG9ydGFibGVSZXNvdXJjZVtdKTogUHJvbWlzZTxJbXBvcnRNYXA+IHtcbiAgICBjb25zdCByZXQ6IEltcG9ydE1hcCA9IHsgaW1wb3J0UmVzb3VyY2VzOiBbXSwgcmVzb3VyY2VNYXA6IHt9IH07XG4gICAgY29uc3QgcmVzb3VyY2VJZGVudGlmaWVycyA9IGF3YWl0IHRoaXMucmVzb3VyY2VJZGVudGlmaWVycygpO1xuXG4gICAgZm9yIChjb25zdCByZXNvdXJjZSBvZiBhdmFpbGFibGUpIHtcbiAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBhd2FpdCB0aGlzLmFza0ZvclJlc291cmNlSWRlbnRpZmllcihyZXNvdXJjZUlkZW50aWZpZXJzLCByZXNvdXJjZSk7XG4gICAgICBpZiAoIWlkZW50aWZpZXIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJldC5pbXBvcnRSZXNvdXJjZXMucHVzaChyZXNvdXJjZSk7XG4gICAgICByZXQucmVzb3VyY2VNYXBbcmVzb3VyY2UubG9naWNhbElkXSA9IGlkZW50aWZpZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIHRoZSByZXNvdXJjZXMgdG8gaW1wb3J0IGZyb20gYSBmaWxlXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbG9hZFJlc291cmNlSWRlbnRpZmllcnMoYXZhaWxhYmxlOiBJbXBvcnRhYmxlUmVzb3VyY2VbXSwgZmlsZW5hbWU6IHN0cmluZyk6IFByb21pc2U8SW1wb3J0TWFwPiB7XG4gICAgY29uc3QgY29udGVudHMgPSBhd2FpdCBmcy5yZWFkSnNvbihmaWxlbmFtZSk7XG5cbiAgICBjb25zdCByZXQ6IEltcG9ydE1hcCA9IHsgaW1wb3J0UmVzb3VyY2VzOiBbXSwgcmVzb3VyY2VNYXA6IHt9IH07XG4gICAgZm9yIChjb25zdCByZXNvdXJjZSBvZiBhdmFpbGFibGUpIHtcbiAgICAgIGNvbnN0IGRlc2NyID0gdGhpcy5kZXNjcmliZVJlc291cmNlKHJlc291cmNlLmxvZ2ljYWxJZCk7XG4gICAgICBjb25zdCBpZFByb3BzID0gY29udGVudHNbcmVzb3VyY2UubG9naWNhbElkXTtcbiAgICAgIGlmIChpZFByb3BzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW9IZWxwZXIuZGVmYXVsdHMuaW5mbyhmb3JtYXQoJyVzOiBpbXBvcnRpbmcgdXNpbmcgJXMnLCBjaGFsay5ibHVlKGRlc2NyKSwgY2hhbGsuYmx1ZShmbXRkaWN0KGlkUHJvcHMpKSkpO1xuXG4gICAgICAgIHJldC5pbXBvcnRSZXNvdXJjZXMucHVzaChyZXNvdXJjZSk7XG4gICAgICAgIHJldC5yZXNvdXJjZU1hcFtyZXNvdXJjZS5sb2dpY2FsSWRdID0gaWRQcm9wcztcbiAgICAgICAgZGVsZXRlIGNvbnRlbnRzW3Jlc291cmNlLmxvZ2ljYWxJZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCB0aGlzLmlvSGVscGVyLmRlZmF1bHRzLmluZm8oZm9ybWF0KCclczogc2tpcHBpbmcnLCBjaGFsay5ibHVlKGRlc2NyKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHVua25vd24gPSBPYmplY3Qua2V5cyhjb250ZW50cyk7XG4gICAgaWYgKHVua25vd24ubGVuZ3RoID4gMCkge1xuICAgICAgYXdhaXQgdGhpcy5pb0hlbHBlci5kZWZhdWx0cy53YXJuKGBVbnJlY29nbml6ZWQgcmVzb3VyY2UgaWRlbnRpZmllcnMgaW4gbWFwcGluZyBmaWxlOiAke3Vua25vd24uam9pbignLCAnKX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIEJhc2VkIG9uIHRoZSBwcm92aWRlZCByZXNvdXJjZSBtYXBwaW5nLCBwcmVwYXJlIENGTiBzdHJ1Y3R1cmVzIGZvciBpbXBvcnQgKHRlbXBsYXRlLFxuICAgKiBSZXNvdXJjZXNUb0ltcG9ydCBzdHJ1Y3R1cmUpIGFuZCBwZXJmb3JtIHRoZSBpbXBvcnQgb3BlcmF0aW9uIChDbG91ZEZvcm1hdGlvbiBkZXBsb3ltZW50KVxuICAgKlxuICAgKiBAcGFyYW0gaW1wb3J0TWFwIC0gTWFwcGluZyBmcm9tIENESyBjb25zdHJ1Y3QgdHJlZSBwYXRoIHRvIHBoeXNpY2FsIHJlc291cmNlIGltcG9ydCBpZGVudGlmaWVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gcGFzcyB0byBDbG91ZEZvcm1hdGlvbiBkZXBsb3kgb3BlcmF0aW9uXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaW1wb3J0UmVzb3VyY2VzRnJvbU1hcChpbXBvcnRNYXA6IEltcG9ydE1hcCwgb3B0aW9uczogSW1wb3J0RGVwbG95bWVudE9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlc291cmNlc1RvSW1wb3J0OiBSZXNvdXJjZXNUb0ltcG9ydCA9IGF3YWl0IHRoaXMubWFrZVJlc291cmNlc1RvSW1wb3J0KGltcG9ydE1hcCk7XG4gICAgY29uc3QgdXBkYXRlZFRlbXBsYXRlID0gYXdhaXQgdGhpcy5jdXJyZW50VGVtcGxhdGVXaXRoQWRkaXRpb25zKGltcG9ydE1hcC5pbXBvcnRSZXNvdXJjZXMpO1xuXG4gICAgYXdhaXQgdGhpcy5pbXBvcnRSZXNvdXJjZXModXBkYXRlZFRlbXBsYXRlLCByZXNvdXJjZXNUb0ltcG9ydCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQmFzZWQgb24gdGhlIGFwcCBhbmQgcmVzb3VyY2VzIGZpbGUgZ2VuZXJhdGVkIGJ5IGNkayBtaWdyYXRlLiBSZW1vdmVzIGFsbCBpdGVtcyBmcm9tIHRoZSB0ZW1wbGF0ZSB0aGF0XG4gICAqIGNhbm5vdCBiZSBpbmNsdWRlZCBpbiBhbiBpbXBvcnQgY2hhbmdlLXNldCBmb3IgbmV3IHN0YWNrcyBhbmQgcGVyZm9ybXMgdGhlIGltcG9ydCBvcGVyYXRpb24sXG4gICAqIGNyZWF0aW5nIHRoZSBuZXcgc3RhY2suXG4gICAqXG4gICAqIEBwYXJhbSByZXNvdXJjZXNUb0ltcG9ydCAtIFRoZSBtYXBwaW5nIGNyZWF0ZWQgYnkgY2RrIG1pZ3JhdGVcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIHBhc3MgdG8gQ2xvdWRGb3JtYXRpb24gZGVwbG95IG9wZXJhdGlvblxuICAgKi9cbiAgcHVibGljIGFzeW5jIGltcG9ydFJlc291cmNlc0Zyb21NaWdyYXRlKHJlc291cmNlc1RvSW1wb3J0OiBSZXNvdXJjZXNUb0ltcG9ydCwgb3B0aW9uczogSW1wb3J0RGVwbG95bWVudE9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHVwZGF0ZWRUZW1wbGF0ZSA9IHRoaXMucmVtb3ZlTm9uSW1wb3J0UmVzb3VyY2VzKCk7XG5cbiAgICBhd2FpdCB0aGlzLmltcG9ydFJlc291cmNlcyh1cGRhdGVkVGVtcGxhdGUsIHJlc291cmNlc1RvSW1wb3J0LCBvcHRpb25zKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaW1wb3J0UmVzb3VyY2VzKG92ZXJyaWRlVGVtcGxhdGU6IGFueSwgcmVzb3VyY2VzVG9JbXBvcnQ6IFJlc291cmNlc1RvSW1wb3J0LCBvcHRpb25zOiBJbXBvcnREZXBsb3ltZW50T3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNmbi5kZXBsb3lTdGFjayh7XG4gICAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgICBkZXBsb3lOYW1lOiB0aGlzLnN0YWNrLnN0YWNrTmFtZSxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgb3ZlcnJpZGVUZW1wbGF0ZSxcbiAgICAgICAgcmVzb3VyY2VzVG9JbXBvcnQsXG4gICAgICB9KTtcblxuICAgICAgYXNzZXJ0SXNTdWNjZXNzZnVsRGVwbG95U3RhY2tSZXN1bHQocmVzdWx0KTtcblxuICAgICAgY29uc3QgbWVzc2FnZSA9IHJlc3VsdC5ub09wXG4gICAgICAgID8gJyDinIUgICVzIChubyBjaGFuZ2VzKSdcbiAgICAgICAgOiAnIOKchSAgJXMnO1xuXG4gICAgICBhd2FpdCB0aGlzLmlvSGVscGVyLmRlZmF1bHRzLmluZm8oJ1xcbicgKyBjaGFsay5ncmVlbihmb3JtYXQobWVzc2FnZSwgdGhpcy5zdGFjay5kaXNwbGF5TmFtZSkpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBhd2FpdCB0aGlzLmlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9FMzkwMC5tc2coZm9ybWF0KCdcXG4g4p2MICAlcyBmYWlsZWQ6ICVzJywgY2hhbGsuYm9sZCh0aGlzLnN0YWNrLmRpc3BsYXlOYW1lKSwgZSksIHsgZXJyb3I6IGUgYXMgYW55IH0pKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYSBkaWZmIGJldHdlZW4gdGhlIGN1cnJlbnRseSBydW5uaW5nIGFuZCB0aGUgbmV3IHRlbXBsYXRlLCBlbnN1cmUgdGhhdCBpdCBpcyB2YWxpZFxuICAgKiBmb3IgaW1wb3J0aW5nIGFuZCByZXR1cm4gYSBsaXN0IG9mIHJlc291cmNlcyB0aGF0IGFyZSBiZWluZyBhZGRlZCBpbiB0aGUgbmV3IHZlcnNpb25cbiAgICpcbiAgICogQHJldHVybiBtYXBwaW5nIGxvZ2ljYWxSZXNvdXJjZUlkIC0+IHJlc291cmNlRGlmZmVyZW5jZVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRpc2NvdmVySW1wb3J0YWJsZVJlc291cmNlcyhhbGxvd05vbkFkZGl0aW9ucyA9IGZhbHNlKTogUHJvbWlzZTxEaXNjb3ZlckltcG9ydGFibGVSZXNvdXJjZXNSZXN1bHQ+IHtcbiAgICBjb25zdCBjdXJyZW50VGVtcGxhdGUgPSBhd2FpdCB0aGlzLmN1cnJlbnRUZW1wbGF0ZSgpO1xuXG4gICAgY29uc3QgZGlmZiA9IGNmbkRpZmYuZnVsbERpZmYoY3VycmVudFRlbXBsYXRlLCB0aGlzLnN0YWNrLnRlbXBsYXRlKTtcblxuICAgIC8vIElnbm9yZSBjaGFuZ2VzIHRvIENES01ldGFkYXRhXG4gICAgY29uc3QgcmVzb3VyY2VDaGFuZ2VzID0gT2JqZWN0LmVudHJpZXMoZGlmZi5yZXNvdXJjZXMuY2hhbmdlcylcbiAgICAgIC5maWx0ZXIoKFtsb2dpY2FsSWQsIF9dKSA9PiBsb2dpY2FsSWQgIT09ICdDREtNZXRhZGF0YScpO1xuXG4gICAgLy8gU3BsaXQgdGhlIGNoYW5nZXMgaW50byBhZGRpdGlvbnMgYW5kIG5vbi1hZGRpdGlvbnMuIEltcG9ydHMgb25seSBtYWtlIHNlbnNlXG4gICAgLy8gZm9yIG5ld2x5LWFkZGVkIHJlc291cmNlcy5cbiAgICBjb25zdCBub25BZGRpdGlvbnMgPSByZXNvdXJjZUNoYW5nZXMuZmlsdGVyKChbXywgZGlmXSkgPT4gIWRpZi5pc0FkZGl0aW9uKTtcbiAgICBjb25zdCBhZGRpdGlvbnMgPSByZXNvdXJjZUNoYW5nZXMuZmlsdGVyKChbXywgZGlmXSkgPT4gZGlmLmlzQWRkaXRpb24pO1xuXG4gICAgaWYgKG5vbkFkZGl0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG9mZmVuZGluZ1Jlc291cmNlcyA9IG5vbkFkZGl0aW9ucy5tYXAoKFtsb2dJZCwgX10pID0+IHRoaXMuZGVzY3JpYmVSZXNvdXJjZShsb2dJZCkpO1xuXG4gICAgICBpZiAoYWxsb3dOb25BZGRpdGlvbnMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pb0hlbHBlci5kZWZhdWx0cy53YXJuKGBJZ25vcmluZyB1cGRhdGVkL2RlbGV0ZWQgcmVzb3VyY2VzICgtLWZvcmNlKTogJHtvZmZlbmRpbmdSZXNvdXJjZXMuam9pbignLCAnKX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ05vIHJlc291cmNlIHVwZGF0ZXMgb3IgZGVsZXRlcyBhcmUgYWxsb3dlZCBvbiBpbXBvcnQgb3BlcmF0aW9uLiBNYWtlIHN1cmUgdG8gcmVzb2x2ZSBwZW5kaW5nIGNoYW5nZXMgJyArXG4gICAgICAgICAgYHRvIGV4aXN0aW5nIHJlc291cmNlcywgYmVmb3JlIGF0dGVtcHRpbmcgYW4gaW1wb3J0LiBVcGRhdGVkL2RlbGV0ZWQgcmVzb3VyY2VzOiAke29mZmVuZGluZ1Jlc291cmNlcy5qb2luKCcsICcpfSAoLS1mb3JjZSB0byBvdmVycmlkZSlgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXNvdXJjZXMgaW4gdGhlIG5ldyB0ZW1wbGF0ZSwgdGhhdCBhcmUgbm90IHByZXNlbnQgaW4gdGhlIGN1cnJlbnQgdGVtcGxhdGUsIGFyZSBhIHBvdGVudGlhbCBpbXBvcnQgY2FuZGlkYXRlc1xuICAgIHJldHVybiB7XG4gICAgICBhZGRpdGlvbnM6IGFkZGl0aW9ucy5tYXAoKFtsb2dpY2FsSWQsIHJlc291cmNlRGlmZl0pID0+ICh7XG4gICAgICAgIGxvZ2ljYWxJZCxcbiAgICAgICAgcmVzb3VyY2VEaWZmLFxuICAgICAgICByZXNvdXJjZURlZmluaXRpb246IGFkZERlZmF1bHREZWxldGlvblBvbGljeSh0aGlzLnN0YWNrLnRlbXBsYXRlPy5SZXNvdXJjZXM/Lltsb2dpY2FsSWRdID8/IHt9KSxcbiAgICAgIH0pKSxcbiAgICAgIGhhc05vbkFkZGl0aW9uczogbm9uQWRkaXRpb25zLmxlbmd0aCA+IDAsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0aGUgZW52aXJvbm1lbnQgb2YgYSBzdGFjay5cbiAgICovXG4gIHB1YmxpYyBhc3luYyByZXNvbHZlRW52aXJvbm1lbnQoKTogUHJvbWlzZTxjeGFwaS5FbnZpcm9ubWVudD4ge1xuICAgIHJldHVybiB0aGlzLmNmbi5yZXNvbHZlRW52aXJvbm1lbnQodGhpcy5zdGFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnRseSBkZXBsb3llZCB0ZW1wbGF0ZSBvZiB0aGUgZ2l2ZW4gc3RhY2sgKFNJTkdMRVRPTilcbiAgICpcbiAgICogQHJldHVybnMgQ3VycmVudGx5IGRlcGxveWVkIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGN1cnJlbnRUZW1wbGF0ZSgpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghdGhpcy5fY3VycmVudFRlbXBsYXRlKSB7XG4gICAgICB0aGlzLl9jdXJyZW50VGVtcGxhdGUgPSBhd2FpdCB0aGlzLmNmbi5yZWFkQ3VycmVudFRlbXBsYXRlKHRoaXMuc3RhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFRlbXBsYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY3VycmVudCB0ZW1wbGF0ZSwgd2l0aCB0aGUgZ2l2ZW4gcmVzb3VyY2VzIGFkZGVkIHRvIGl0XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGN1cnJlbnRUZW1wbGF0ZVdpdGhBZGRpdGlvbnMoYWRkaXRpb25zOiBJbXBvcnRhYmxlUmVzb3VyY2VbXSk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBhd2FpdCB0aGlzLmN1cnJlbnRUZW1wbGF0ZSgpO1xuICAgIGlmICghdGVtcGxhdGUuUmVzb3VyY2VzKSB7XG4gICAgICB0ZW1wbGF0ZS5SZXNvdXJjZXMgPSB7fTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGFkZCBvZiBhZGRpdGlvbnMpIHtcbiAgICAgIHRlbXBsYXRlLlJlc291cmNlc1thZGQubG9naWNhbElkXSA9IGFkZC5yZXNvdXJjZURlZmluaXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2YgaW1wb3J0IGlkZW50aWZpZXJzIGZvciBhbGwgcmVzb3VyY2UgdHlwZXMgdXNlZCBpbiB0aGUgZ2l2ZW5cbiAgICogdGVtcGxhdGUgdGhhdCBkbyBzdXBwb3J0IHRoZSBpbXBvcnQgb3BlcmF0aW9uIChTSU5HTEVUT04pXG4gICAqXG4gICAqIEByZXR1cm5zIGEgbWFwcGluZyBmcm9tIGEgcmVzb3VyY2UgdHlwZSB0byBhIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMgdGhhdCB0b2dldGhlciBpZGVudGlmeSB0aGUgcmVzb3VyY2UgZm9yIGltcG9ydFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyByZXNvdXJjZUlkZW50aWZpZXJzKCk6IFByb21pc2U8UmVzb3VyY2VJZGVudGlmaWVycz4ge1xuICAgIGNvbnN0IHJldDogUmVzb3VyY2VJZGVudGlmaWVycyA9IHt9O1xuICAgIGNvbnN0IHJlc291cmNlSWRlbnRpZmllclN1bW1hcmllcyA9IGF3YWl0IHRoaXMuY2ZuLnJlc291cmNlSWRlbnRpZmllclN1bW1hcmllcyh0aGlzLnN0YWNrKTtcbiAgICBmb3IgKGNvbnN0IHN1bW1hcnkgb2YgcmVzb3VyY2VJZGVudGlmaWVyU3VtbWFyaWVzKSB7XG4gICAgICBpZiAoJ1Jlc291cmNlVHlwZScgaW4gc3VtbWFyeSAmJiBzdW1tYXJ5LlJlc291cmNlVHlwZSAmJiAnUmVzb3VyY2VJZGVudGlmaWVycycgaW4gc3VtbWFyeSAmJiBzdW1tYXJ5LlJlc291cmNlSWRlbnRpZmllcnMpIHtcbiAgICAgICAgcmV0W3N1bW1hcnkuUmVzb3VyY2VUeXBlXSA9IChzdW1tYXJ5LlJlc291cmNlSWRlbnRpZmllcnMgPz8gW10pPy5tYXAoeCA9PiB4LnNwbGl0KCcsJykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFzayBmb3IgdGhlIGltcG9ydGFibGUgaWRlbnRpZmllciBmb3IgdGhlIGdpdmVuIHJlc291cmNlXG4gICAqXG4gICAqIFRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIGlkZW50aWZpZXIgdW5kZXIgd2hpY2ggYSByZXNvdXJjZSBjYW4gYmUgaW1wb3J0ZWQuIFRoZSBgaW1wb3J0YFxuICAgKiBvcGVyYXRpb24gbmVlZHMgZXhhY3RseSBvbmUgb2YgdGhlbS5cbiAgICpcbiAgICogLSBJZiB3ZSBjYW4gZ2V0IG9uZSBmcm9tIHRoZSB0ZW1wbGF0ZSwgd2Ugd2lsbCB1c2Ugb25lLlxuICAgKiAtIE90aGVyd2lzZSwgd2Ugd2lsbCBhc2sgdGhlIHVzZXIgZm9yIG9uZSBvZiB0aGVtLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBhc2tGb3JSZXNvdXJjZUlkZW50aWZpZXIoXG4gICAgcmVzb3VyY2VJZGVudGlmaWVyczogUmVzb3VyY2VJZGVudGlmaWVycyxcbiAgICBjaGc6IEltcG9ydGFibGVSZXNvdXJjZSxcbiAgKTogUHJvbWlzZTxSZXNvdXJjZUlkZW50aWZpZXJQcm9wZXJ0aWVzIHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3QgcmVzb3VyY2VOYW1lID0gdGhpcy5kZXNjcmliZVJlc291cmNlKGNoZy5sb2dpY2FsSWQpO1xuXG4gICAgLy8gU2tpcCByZXNvdXJjZXMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpbXBvcnRpbmdcbiAgICBjb25zdCByZXNvdXJjZVR5cGUgPSBjaGcucmVzb3VyY2VEaWZmLm5ld1Jlc291cmNlVHlwZTtcbiAgICBpZiAocmVzb3VyY2VUeXBlID09PSB1bmRlZmluZWQgfHwgIShyZXNvdXJjZVR5cGUgaW4gcmVzb3VyY2VJZGVudGlmaWVycykpIHtcbiAgICAgIGF3YWl0IHRoaXMuaW9IZWxwZXIuZGVmYXVsdHMud2FybihgJHtyZXNvdXJjZU5hbWV9OiB1bnN1cHBvcnRlZCByZXNvdXJjZSB0eXBlICR7cmVzb3VyY2VUeXBlfSwgc2tpcHBpbmcgaW1wb3J0LmApO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBpZFByb3BTZXRzID0gcmVzb3VyY2VJZGVudGlmaWVyc1tyZXNvdXJjZVR5cGVdO1xuXG4gICAgLy8gUmV0YWluIG9ubHkgbGl0ZXJhbCBzdHJpbmdzOiBzdHJpcCBwb3RlbnRpYWwgQ0ZOIGludHJpbnNpY3NcbiAgICBjb25zdCByZXNvdXJjZVByb3BzID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGNoZy5yZXNvdXJjZURlZmluaXRpb24uUHJvcGVydGllcyA/PyB7fSlcbiAgICAgIC5maWx0ZXIoKFtfLCB2XSkgPT4gdHlwZW9mIHYgPT09ICdzdHJpbmcnKSkgYXMgUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcblxuICAgIC8vIEZpbmQgcHJvcGVydHkgc2V0cyB0aGF0IGFyZSBmdWxseSBzYXRpc2ZpZWQgaW4gdGhlIHRlbXBsYXRlLCBhc2sgdGhlIHVzZXIgdG8gY29uZmlybSB0aGVtXG4gICAgY29uc3Qgc2F0aXNmaWVkUHJvcFNldHMgPSBpZFByb3BTZXRzLmZpbHRlcihwcyA9PiBwcy5ldmVyeShwID0+IHJlc291cmNlUHJvcHNbcF0pKTtcbiAgICBmb3IgKGNvbnN0IHNhdGlzZmllZFByb3BTZXQgb2Ygc2F0aXNmaWVkUHJvcFNldHMpIHtcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZVByb3BzID0gT2JqZWN0LmZyb21FbnRyaWVzKHNhdGlzZmllZFByb3BTZXQubWFwKHAgPT4gW3AsIHJlc291cmNlUHJvcHNbcF1dKSk7XG4gICAgICBjb25zdCBkaXNwbGF5Q2FuZGlkYXRlUHJvcHMgPSBmbXRkaWN0KGNhbmRpZGF0ZVByb3BzKTtcblxuICAgICAgY29uc3QgaW1wb3J0VGhlUmVzb3VyY2UgPSBhd2FpdCB0aGlzLmlvSGVscGVyLnJlcXVlc3RSZXNwb25zZShJTy5DREtfVE9PTEtJVF9JMzEwMC5yZXEoYCR7Y2hhbGsuYmx1ZShyZXNvdXJjZU5hbWUpfSAoJHtyZXNvdXJjZVR5cGV9KTogaW1wb3J0IHdpdGggJHtjaGFsay55ZWxsb3coZGlzcGxheUNhbmRpZGF0ZVByb3BzKX1gLCB7XG4gICAgICAgIHJlc291cmNlOiB7XG4gICAgICAgICAgdHlwZTogcmVzb3VyY2VUeXBlLFxuICAgICAgICAgIHByb3BzOiBjYW5kaWRhdGVQcm9wcyxcbiAgICAgICAgICBzdHJpbmdpZmllZFByb3BzOiBkaXNwbGF5Q2FuZGlkYXRlUHJvcHMsXG4gICAgICAgIH0sXG4gICAgICB9KSk7XG4gICAgICBpZiAoaW1wb3J0VGhlUmVzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZVByb3BzO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIGdvdCBoZXJlIGFuZCB0aGUgdXNlciByZWplY3RlZCBhbnkgYXZhaWxhYmxlIGlkZW50aWZpZXJzLCB0aGVuIGFwcGFyZW50bHkgdGhleSBkb24ndCB3YW50IHRoZSByZXNvdXJjZSBhdCBhbGxcbiAgICBpZiAoc2F0aXNmaWVkUHJvcFNldHMubGVuZ3RoID4gMCkge1xuICAgICAgYXdhaXQgdGhpcy5pb0hlbHBlci5kZWZhdWx0cy5pbmZvKGNoYWxrLmdyZXkoYFNraXBwaW5nIGltcG9ydCBvZiAke3Jlc291cmNlTmFtZX1gKSk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIFdlIGNhbm5vdCBhdXRvLWltcG9ydCB0aGlzLCBhc2sgdGhlIHVzZXIgZm9yIG9uZSBvZiB0aGUgcHJvcHNcbiAgICAvLyBUaGUgb25seSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlc2UgY2FzZXMgaXMgd2hhdCB3ZSBwcmludDogZm9yIG11bHRpcGxlIHByb3BlcnRpZXMsIHdlIHByaW50IGEgcHJlYW1ibGVcbiAgICBjb25zdCBwcmVmaXggPSBgJHtjaGFsay5ibHVlKHJlc291cmNlTmFtZSl9ICgke3Jlc291cmNlVHlwZX0pYDtcbiAgICBjb25zdCBwcm9tcHRQYXR0ZXJuID0gYCR7cHJlZml4fTogZW50ZXIgJXNgO1xuICAgIGlmIChpZFByb3BTZXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IHByZWFtYmxlID0gYCR7cHJlZml4fTogZW50ZXIgb25lIG9mICR7aWRQcm9wU2V0cy5tYXAoeCA9PiBjaGFsay5ibHVlKHguam9pbignKycpKSkuam9pbignLCAnKX0gdG8gaW1wb3J0IChsZWF2ZSBhbGwgZW1wdHkgdG8gc2tpcClgO1xuICAgICAgYXdhaXQgdGhpcy5pb0hlbHBlci5kZWZhdWx0cy5pbmZvKHByZWFtYmxlKTtcbiAgICB9XG5cbiAgICAvLyBEbyB0aGUgaW5wdXQgbG9vcCBoZXJlXG4gICAgZm9yIChjb25zdCBpZFByb3BzIG9mIGlkUHJvcFNldHMpIHtcbiAgICAgIGNvbnN0IGlucHV0OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gICAgICBmb3IgKGNvbnN0IGlkUHJvcCBvZiBpZFByb3BzKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSB2YWx1ZSBmcm9tIHRoZSB0ZW1wbGF0ZSwgdXNlIGl0IGFzIGRlZmF1bHQuIFRoaXMgd2lsbCBvbmx5IGJlIGEgcGFydGlhbFxuICAgICAgICAvLyBpZGVudGlmaWVyIGlmIHByZXNlbnQsIG90aGVyd2lzZSB3ZSB3b3VsZCBoYXZlIGRvbmUgdGhlIGltcG9ydCBhbHJlYWR5IGFib3ZlLlxuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSByZXNvdXJjZVByb3BzW2lkUHJvcF0gPz8gJyc7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmlvSGVscGVyLnJlcXVlc3RSZXNwb25zZShJTy5DREtfVE9PTEtJVF9JMzExMC5yZXEoXG4gICAgICAgICAgZm9ybWF0KHByb21wdFBhdHRlcm4sIGNoYWxrLmJsdWUoaWRQcm9wKSksXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmVzb3VyY2U6IHtcbiAgICAgICAgICAgICAgbmFtZTogcmVzb3VyY2VOYW1lLFxuICAgICAgICAgICAgICB0eXBlOiByZXNvdXJjZVR5cGUsXG4gICAgICAgICAgICAgIGlkUHJvcCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNwb25zZURlc2NyaXB0aW9uOiBkZWZhdWx0VmFsdWUgPyB1bmRlZmluZWQgOiAnZW1wdHkgdG8gc2tpcCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0VmFsdWUsXG4gICAgICAgICkpO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0W2lkUHJvcF0gPSByZXNwb25zZTtcbiAgICAgICAgLy8gQWxzbyBzdGljayB0aGlzIHByb3BlcnR5IGludG8gJ3Jlc291cmNlUHJvcHMnLCBzbyB0aGF0IGl0IG1heSBiZSByZXVzZWQgYnkgYSBzdWJzZXF1ZW50IHF1ZXN0aW9uXG4gICAgICAgIC8vIChmb3IgYSBkaWZmZXJlbnQgY29tcG91bmQgaWRlbnRpZmllciB0aGF0IGludm9sdmVzIHRoZSBzYW1lIHByb3BlcnR5KS4gSnVzdCBhIHNtYWxsIFVYIGVuaGFuY2VtZW50LlxuICAgICAgICByZXNvdXJjZVByb3BzW2lkUHJvcF0gPSByZXNwb25zZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHVzZXIgZ2F2ZSBpbnB1dHMgZm9yIGFsbCB2YWx1ZXMsIHdlIGFyZSBjb21wbGV0ZVxuICAgICAgaWYgKE9iamVjdC5rZXlzKGlucHV0KS5sZW5ndGggPT09IGlkUHJvcHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLmlvSGVscGVyLmRlZmF1bHRzLmluZm8oY2hhbGsuZ3JleShgU2tpcHBpbmcgaW1wb3J0IG9mICR7cmVzb3VyY2VOYW1lfWApKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIGludGVybmFsIFwicmVzb3VyY2UgbWFwcGluZ1wiIHN0cnVjdHVyZSB0byBDbG91ZEZvcm1hdGlvbiBhY2NlcHRlZCBcIlJlc291cmNlc1RvSW1wb3J0XCIgc3RydWN0dXJlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIG1ha2VSZXNvdXJjZXNUb0ltcG9ydChyZXNvdXJjZU1hcDogSW1wb3J0TWFwKTogUHJvbWlzZTxSZXNvdXJjZXNUb0ltcG9ydD4ge1xuICAgIHJldHVybiByZXNvdXJjZU1hcC5pbXBvcnRSZXNvdXJjZXMubWFwKHJlcyA9PiAoe1xuICAgICAgTG9naWNhbFJlc291cmNlSWQ6IHJlcy5sb2dpY2FsSWQsXG4gICAgICBSZXNvdXJjZVR5cGU6IHJlcy5yZXNvdXJjZURpZmYubmV3UmVzb3VyY2VUeXBlISxcbiAgICAgIFJlc291cmNlSWRlbnRpZmllcjogcmVzb3VyY2VNYXAucmVzb3VyY2VNYXBbcmVzLmxvZ2ljYWxJZF0sXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgQ2xvdWRGb3JtYXRpb24gbG9naWNhbCByZXNvdXJjZSBJRCB0byBDREsgY29uc3RydWN0IHRyZWUgcGF0aFxuICAgKlxuICAgKiBAcGFyYW0gbG9naWNhbElkIC0gQ2xvdWRGb3JtYXRpb24gbG9naWNhbCBJRCBvZiB0aGUgcmVzb3VyY2UgKHRoZSBrZXkgaW4gdGhlIHRlbXBsYXRlJ3MgUmVzb3VyY2VzIHNlY3Rpb24pXG4gICAqIEByZXR1cm5zIEZvcndhcmQtc2xhc2ggc2VwYXJhdGVkIHBhdGggb2YgdGhlIHJlc291cmNlIGluIENESyBjb25zdHJ1Y3QgdHJlZSwgZS5nLiBNeVN0YWNrL015QnVja2V0L1Jlc291cmNlXG4gICAqL1xuICBwcml2YXRlIGRlc2NyaWJlUmVzb3VyY2UobG9naWNhbElkOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnN0YWNrLnRlbXBsYXRlPy5SZXNvdXJjZXM/Lltsb2dpY2FsSWRdPy5NZXRhZGF0YT8uWydhd3M6Y2RrOnBhdGgnXSA/PyBsb2dpY2FsSWQ7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBDREtNZXRhZGF0YSBhbmQgT3V0cHV0cyBpbiB0aGUgdGVtcGxhdGUgc28gdGhhdCBvbmx5IHJlc291cmNlcyBmb3IgaW1wb3J0aW5nIGFyZSBsZWZ0LlxuICAgKiBAcmV0dXJucyB0ZW1wbGF0ZSB3aXRoIGltcG9ydCByZXNvdXJjZXMgb25seVxuICAgKi9cbiAgcHJpdmF0ZSByZW1vdmVOb25JbXBvcnRSZXNvdXJjZXMoKSB7XG4gICAgcmV0dXJuIHJlbW92ZU5vbkltcG9ydFJlc291cmNlcyh0aGlzLnN0YWNrKTtcbiAgfVxufVxuXG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IGEgcmVzb3VyY2UgaW4gdGhlIHRlbXBsYXRlIHRoYXQgaXMgaW1wb3J0YWJsZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEltcG9ydGFibGVSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBUaGUgbG9naWNhbCBJRCBvZiB0aGUgcmVzb3VyY2VcbiAgICovXG4gIHJlYWRvbmx5IGxvZ2ljYWxJZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVzb3VyY2UgZGVmaW5pdGlvbiBpbiB0aGUgbmV3IHRlbXBsYXRlXG4gICAqL1xuICByZWFkb25seSByZXNvdXJjZURlZmluaXRpb246IGFueTtcblxuICAvKipcbiAgICogVGhlIGRpZmYgYXMgcmVwb3J0ZWQgYnkgYGNsb3VkZm9ybWF0aW9uLWRpZmZgLlxuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2VEaWZmOiBSZXNvdXJjZURpZmZlcmVuY2U7XG59XG5cbi8qKlxuICogVGhlIGluZm9ybWF0aW9uIG5lY2Vzc2FyeSB0byBleGVjdXRlIGFuIGltcG9ydCBvcGVyYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbXBvcnRNYXAge1xuICAvKipcbiAgICogTWFwcGluZyBsb2dpY2FsIElEcyB0byBwaHlzaWNhbCBuYW1lc1xuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2VNYXA6IFJlc291cmNlTWFwO1xuXG4gIC8qKlxuICAgKiBUaGUgc2VsZWN0aW9uIG9mIHJlc291cmNlcyB3ZSBhcmUgYWN0dWFsbHkgaW1wb3J0aW5nXG4gICAqXG4gICAqIEZvciBlYWNoIG9mIHRoZSByZXNvdXJjZXMgaW4gdGhpcyBsaXN0LCB0aGVyZSBpcyBhIGNvcnJlc3BvbmRpbmcgZW50cnkgaW5cbiAgICogdGhlIGByZXNvdXJjZU1hcGAgbWFwLlxuICAgKi9cbiAgcmVhZG9ubHkgaW1wb3J0UmVzb3VyY2VzOiBJbXBvcnRhYmxlUmVzb3VyY2VbXTtcbn1cblxuZnVuY3Rpb24gZm10ZGljdDxBPih4czogUmVjb3JkPHN0cmluZywgQT4pIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHhzKS5tYXAoKFtrLCB2XSkgPT4gYCR7a309JHt2fWApLmpvaW4oJywgJyk7XG59XG5cbi8qKlxuICogQWRkIGEgZGVmYXVsdCBgRGVsZXRpb25Qb2xpY3lgIHBvbGljeS5cbiAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHNldCB0byAnUmV0YWluJywgdG8gbG93ZXIgcmlzayBvZiB1bmludGVudGlvbmFsbHlcbiAqIGRlbGV0aW5nIHN0YXRlZnVsIHJlc291cmNlcyBpbiB0aGUgcHJvY2VzcyBvZiBpbXBvcnRpbmcgdG8gQ0RLLlxuICovXG5mdW5jdGlvbiBhZGREZWZhdWx0RGVsZXRpb25Qb2xpY3kocmVzb3VyY2U6IGFueSk6IGFueSB7XG4gIGlmIChyZXNvdXJjZS5EZWxldGlvblBvbGljeSkge1xuICAgIHJldHVybiByZXNvdXJjZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4ucmVzb3VyY2UsXG4gICAgRGVsZXRpb25Qb2xpY3k6ICdSZXRhaW4nLFxuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERpc2NvdmVySW1wb3J0YWJsZVJlc291cmNlc1Jlc3VsdCB7XG4gIHJlYWRvbmx5IGFkZGl0aW9uczogSW1wb3J0YWJsZVJlc291cmNlW107XG4gIHJlYWRvbmx5IGhhc05vbkFkZGl0aW9uczogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU5vbkltcG9ydFJlc291cmNlcyhzdGFjazpjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QpIHtcbiAgY29uc3QgdGVtcGxhdGUgPSBzdGFjay50ZW1wbGF0ZTtcbiAgZGVsZXRlIHRlbXBsYXRlLlJlc291cmNlcy5DREtNZXRhZGF0YTtcbiAgZGVsZXRlIHRlbXBsYXRlLk91dHB1dHM7XG4gIHJldHVybiB0ZW1wbGF0ZTtcbn1cbiJdfQ==