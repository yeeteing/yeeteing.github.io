import '../../../private/dispose-polyfill';
import * as cxapi from '@aws-cdk/cx-api';
import type { ToolkitServices } from '../../../toolkit/private';
import type { IoHelper } from '../../io/private';
import type { IReadLock } from '../../rwlock';
import { Settings } from '../../settings';
import type { Context, Env } from '../environment';
import type { AppSynthOptions, LoadAssemblyOptions } from '../source-builder';
export declare class ExecutionEnvironment implements AsyncDisposable {
    readonly outdir: string;
    readonly outDirIsTemporary: boolean;
    /**
     * Create an ExecutionEnvironment
     *
     * An ExecutionEnvironment holds a writer lock on the given directory which will
     * be cleaned up when the object is disposed.
     *
     * A temporary directory will be created if none is supplied, which will be cleaned
     * up when this object is disposed.
     *
     * If `markSuccessful()` is called, the writer lock is converted to a reader lock
     * and temporary directories will not be cleaned up anymore.
     */
    static create(services: ToolkitServices, props?: {
        outdir?: string;
    }): Promise<ExecutionEnvironment>;
    private readonly ioHelper;
    private readonly sdkProvider;
    private readonly debugFn;
    private lock;
    private shouldClean;
    private constructor();
    [Symbol.asyncDispose](): Promise<void>;
    /**
     * Mark the execution as successful, which stops the writer lock from being released upon disposal
     */
    markSuccessful(): Promise<{
        readLock: IReadLock;
    }>;
    /**
     * Begin an execution in this environment
     *
     * This will acquire a write lock on the given environment. The write lock
     * will be released automatically when the return object is disposed, unless it
     * is converted to a reader lock.
     */
    beginExecution(): Promise<{
        writeToReadLock(): Promise<IReadLock>;
    } & AsyncDisposable>;
    /**
     * Guess the executable from the command-line argument
     *
     * Only do this if the file is NOT marked as executable. If it is,
     * we'll defer to the shebang inside the file itself.
     *
     * If we're on Windows, we ALWAYS take the handler, since it's hard to
     * verify if registry associations have or have not been set up for this
     * file type, so we'll assume the worst and take control.
     */
    guessExecutable(app: string): Promise<any>;
    /**
     * If we don't have region/account defined in context, we fall back to the default SDK behavior
     * where region is retrieved from ~/.aws/config and account is based on default credentials provider
     * chain and then STS is queried.
     *
     * This is done opportunistically: for example, if we can't access STS for some reason or the region
     * is not configured, the context value will be 'null' and there could failures down the line. In
     * some cases, synthesis does not require region/account information at all, so that might be perfectly
     * fine in certain scenarios.
     */
    defaultEnvVars(): Promise<Env>;
    /**
     * Run code from a different working directory
     */
    changeDir<T>(block: () => Promise<T>, workingDir?: string): Promise<T>;
}
/**
 * Serializes the given context to a set if environment variables environment variables
 *
 * Needs to know the size of the rest of the env because that's necessary to do
 * an overflow computation on Windows. This function will mutate the given
 * environment in-place. It should be called as the very last operation on the
 * environment, because afterwards is might be at the maximum size.
 *
 * This *would* have returned an `IAsyncDisposable` but that requires messing
 * with TypeScript type definitions to use it in aws-cdk, so returning an
 * explicit cleanup function is easier.
 */
export declare function writeContextToEnv(env: Env, context: Context): () => Promise<void>;
/**
 * Safely create an assembly from a cloud assembly directory
 */
export declare function assemblyFromDirectory(assemblyDir: string, ioHelper: IoHelper, loadOptions?: LoadAssemblyOptions): Promise<cxapi.CloudAssembly>;
export declare function settingsFromSynthOptions(synthOpts?: AppSynthOptions): Settings;
/**
 * Turn synthesis options into context/environment variables that will go to the CDK app
 *
 * These are parameters that control the synthesis operation, configurable by the user
 * from the outside of the app.
 */
export declare function parametersFromSynthOptions(synthOptions?: AppSynthOptions): {
    context: Context;
    env: Env;
};
