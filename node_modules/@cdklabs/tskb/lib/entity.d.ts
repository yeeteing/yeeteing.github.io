import { sortedMap, SortedMultiMap } from './sorted-map';
export interface Entity {
    readonly $id: string;
}
export type Plain<E extends Entity> = Omit<E, '$id'>;
type Indexes<A extends Entity> = {
    [K in PropertyKey]: EntityIndex<A, any>;
};
export interface EntityCollection<A extends Entity, I extends Indexes<Entity> = {}> {
    readonly type: 'entities';
    readonly entities: Map<string, A>;
    readonly indexes: I;
    add(x: A): void;
    dehydrate(): any;
    hydrateFrom(x: any): void;
    /**
     * Add indexes to this collection
     *
     * Creating an indexed collection is a two-step operation so that we can specify the
     * Entity type, but infer the index types (TypeScript does not allow both specifying AND
     * inferring generic arguments in a single call).
     */
    index<II extends Indexes<A>>(indexes: II): EntityCollection<A, II>;
}
/**
 * Interface for index objects
 */
export interface EntityIndex<A extends Entity, IndexType> {
    /**
     * The lookups that the indexed field type affords
     *
     * For example, 'equals', 'lessThan', 'prefix', etc.
     */
    readonly lookups: IndexLookups<IndexType>;
    /**
     * The index data store
     */
    readonly index: SortedMultiMap<IndexType, string>;
    /**
     * Add an entity to the index
     */
    add(x: A): void;
}
/**
 * Map a type the types of lookups we can do on that type
 */
export type IndexLookups<P> = [P] extends [string] ? StringIndexLookups : [P] extends [string | undefined] ? OptionalStringIndexLookups : {};
/**
 * All the lookups on 'string' types
 *
 * We currently only have 'equals' but we could have more :)
 */
export interface StringIndexLookups {
    equals(x: string): string[];
}
/**
 * All the lookups on 'string | undefined' types
 */
export interface OptionalStringIndexLookups {
    equals(x: string | undefined): string[];
}
export declare function entityCollection<A extends Entity>(): EntityCollection<A, {}>;
/**
 * An index that uses the value of an entity's field
 */
export declare function fieldIndex<A extends Entity, P extends keyof A>(propName: P, comparator: sortedMap.Comparator<A[P]>): EntityIndex<A, A[P]>;
/**
 * An index that is calculated based on a function applied to an entity
 */
export declare function calculatedIndex<A extends Entity, B>(fn: (x: A) => B, comparator: sortedMap.Comparator<B>): {
    add: (x: A) => void;
    lookups: any;
    index: SortedMultiMap<B, string>;
};
export declare function isEntityCollection(x: unknown): x is EntityCollection<any>;
export interface Reference<E extends Entity> {
    readonly $ref: E['$id'];
}
export declare function ref<E extends Entity>(x: E | string): Reference<E>;
/**
 * Determines whether two strings are equivalent in the current or specified locale.
 */
export declare function stringCmp(a: string, b: string): number;
/**
 * Determines whether two numbers are equivalent.
 */
export declare function numberCmp(a: number, b: number): number;
/**
 * Creates a comparator to determine equivalent of two values, using a given comparator, but allows values to be optional.
 *
 * @param frontOrder If `true`, returns so that undefined values are ordered at the front. If `false`, undefined values are ordered at the back.
 */
export declare function optionalCmp<A>(cmp: (a: A, b: A) => number, frontOrder?: boolean): (a: A | undefined, b: A | undefined) => number;
export {};
